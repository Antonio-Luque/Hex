
; File #0: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   org     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         defs    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 defb                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 defb    0                           ; board potential
6198 00          1 51 defb    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               defb    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                defb    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             defb    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             defb    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              defb    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             defb    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            defb    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 defb    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 defb    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 defb    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 defb    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 defb    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 defb    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 defb    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 defm    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;org     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 AA 73       1 85 defw    PathFinder_CYAN_Edge_0
6202 CA 73       1 86 defw    PathFinder_CYAN_Edge_1
6204 E5 73       1 87 defw    PathFinder_CYAN_Edge_2
6206 03 74       1 88 defw    PathFinder_CYAN_Edge_3
6208 22 74       1 89 defw    PathFinder_CYAN_Edge_4
620A 40 74       1 90 defw    PathFinder_CYAN_Edge_5
620C 5B 74       1 91 defw    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E 00          1 96 CHAR_COUNT              defb    0                           ; number of current characters in input player move
620F 00          1 97 THREE_ROW               defb    0                           ; three-in-a-row counter
6210 0F 0E 0C 0B 1 98 ROW_COLOR_MAP           defb    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6214 0D 0A       1 98 
6216 00 2D 30 00 1 99 STR_MOVE                defb    0, '-', '0', 0, '\0'        ; formatted move string
621A 00          1 99 
621B 53 70 65 63 1 100 STR_SPECCY              defm    "Speccy\0"
621F 63 79 00    1 100 
6222 50 6C 61 79 1 101 STR_PLAYER              defm    "Player\0"
6226 65 72 00    1 101 
6229 4C 65 76 65 1 102 STR_LEVELTEXT           defm    "Level\0"
622D 6C 00       1 102 
622F 46 49 4C 4C 1 103 STR_FILLED              defm    "FILLED\0"
6233 45 44 00    1 103 
6236 57 41 49 54 1 104 STR_WAIT                defm    "WAIT\0"
623A 00          1 104 
623B 20 57 49 4E 1 105 STR_WINNER              defm    " WINS \0"
623F 53 20 00    1 105 
6242 20 20 20 20 1 106 STR_EMPTY4              defm    "    \0"
6246 00          1 106 
6247 20 20 20 20 1 107 STR_EMPTY6              defm    "      \0"
624B 20 20 00    1 107 
624E             1 109 ; ----------------------------------------------------------------------------------------------------------------------
624E             1 110 ; Conversion table: from position to XY board indexes
624E             1 111 ; ----------------------------------------------------------------------------------------------------------------------
624E             1 112 BOARD_COORDINATES:
624E 00 00 00 00 1 113 defb    $00, $00, $00, $00, $00, $00, $00, $00
6252 00 00 00 00 1 113 
6256 00 09 0A 0B 1 114 defb    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
625A 0C 0D 0E 0F 1 114 
625E 00 12 13 14 1 115 defb    $00, $12, $13, $14, $15, $16, $17, $18
6262 15 16 17 18 1 115 
6266 00 1B 1C 1D 1 116 defb    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
626A 1E 1F 20 21 1 116 
626E 00 24 25 26 1 117 defb    $00, $24, $25, $26, $27, $28, $29, $2A
6272 27 28 29 2A 1 117 
6276 00 2D 2E 2F 1 118 defb    $00, $2D, $2E, $2F, $30, $31, $32, $33
627A 30 31 32 33 1 118 
627E 00 36 37 38 1 119 defb    $00, $36, $37, $38, $39, $3A, $3B, $3C
6282 39 3A 3B 3C 1 119 
6286 00 3F 40 41 1 120 defb    $00, $3F, $40, $41, $42, $43, $44, $45
628A 42 43 44 45 1 120 
628E             1 122 ; ----------------------------------------------------------------------------------------------------------------------
628E             1 123 ; Graphics map indexes for the frame tiles
628E             1 124 ; ----------------------------------------------------------------------------------------------------------------------
628E             1 125 FRAME_MAP:
628E 00 01 01 01 1 126 defb      0,   1,   1,   1,   1,   1,   2,   3
6292 01 01 02 03 1 126 
6296 04 FF FF FF 1 127 defb      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
629A FF FF FF FF 1 127 
629E 05 06 07 01 1 128 defb      5,   6,   7,   1,   1,   1,   1,   1
62A2 01 01 01 01 1 128 
62A6 01 01 01 01 1 129 defb      1,   1,   1,   1,   1,   1,   1,   8
62AA 01 01 01 08 1 129 
62AE 09 01 01 01 1 130 defb      9,   1,   1,   1,   1,   1,   1,   1
62B2 01 01 01 01 1 130 
62B6 01 01 01 01 1 131 defb      1,   1,   1,   1,   1,   1,   1,   1
62BA 01 01 01 01 1 131 
62BE 0A 06 0D 0D 1 132 defb     10,   6,  13,  13,  13,   3,  11,   1
62C2 0D 03 0B 01 1 132 
62C6 01 01 01 01 1 133 defb      1,   1,   1,   1,   1,   1,   1,  12
62CA 01 01 01 0C 1 133 
62CE             1 135 ; ----------------------------------------------------------------------------------------------------------------------
62CE             1 136 ; Definition of a small "Opening Book" for speccy first move
62CE             1 137 ; ----------------------------------------------------------------------------------------------------------------------
62CE             1 138 OPENINGS:
62CE 0F 14 16 17 1 139 defb    $0F, $14, $16, $17, $18, $1C, $1D
62D2 18 1C 1D    1 139 
62D5 1E 1F 20 24 1 140 defb    $1E, $1F, $20, $24, $25, $26, $27
62D9 25 26 27    1 140 
62DC 28 29 2A 2E 1 141 defb    $28, $29, $2A, $2E, $2F, $30, $31
62E0 2F 30 31    1 141 
62E3 32 36 37 38 1 142 defb    $32, $36, $37, $38, $3A, $3F
62E7 3A 3F       1 142 
62E9             1 144 ; ----------------------------------------------------------------------------------------------------------------------
62E9             1 145 ; Timer variables
62E9             1 146 ; ----------------------------------------------------------------------------------------------------------------------
62E9 00          1 147 TIMER_FLAG              defb    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62EA             1 148 ; for each timer:
62EA             1 149 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62EA             1 150 ;   2nd byte = seconds counter
62EA             1 151 ;   3th byte = minutes counter
62EA 32 00 00    1 152 CYAN_TIMER              defb    50, 0, 0
62ED 32 00 00    1 153 RED_TIMER               defb    50, 0, 0
62F0             1 155 ; ----------------------------------------------------------------------------------------------------------------------
62F0             1 156 ; Screen addresses look-up array for board numbers
62F0             1 157 ; ----------------------------------------------------------------------------------------------------------------------
62F0             1 158 NUMBER_SCREEN:
62F0 A5 43 E6 43 1 159 defw    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F4 27 4B 68 4B 1 159 
62F8 A9 4B EA 4B 1 159 
62FC 2B 53       1 159 
62FE FF FF       1 161 FILLER_1                defb    $FF, $FF                    ; filler to align next block (not used)
6300             1 163 ;org     $6300
6300             1 164 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 165 ; Circular queue
6300             1 166 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 167 RED_QUEUE_AREA          defs    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 167 
6308 00 00 00 00 1 167 
630C 00 00 00 00 1 167 
6310 00 00 00 00 1 167 
6314 00 00 00 00 1 167 
6318 00 00 00 00 1 167 
631C 00 00 00 00 1 167 
6320 00 00 00 00 1 167 
6324 00 00 00 00 1 167 
6328 00 00 00 00 1 167 
632C 00 00 00 00 1 167 
6330 00 00 00 00 1 167 
6334 00 00 00 00 1 167 
6338 00 00 00 00 1 167 
633C 00 00 00 00 1 167 
6340 00 00 00 00 1 167 
6344 00 00 00 00 1 167 
6348 00 00 00 00 1 167 
634C 00 00 00 00 1 167 
6350 00 00 00 00 1 167 
6354 00 00 00 00 1 167 
6358 00 00 00 00 1 167 
635C 00 00 00 00 1 167 
6360 00 00 00 00 1 167 
6364 00 00 00 00 1 167 
6368 00 00 00 00 1 167 
636C 00 00 00 00 1 167 
6370 00 00 00 00 1 167 
6374 00 00 00 00 1 167 
6378 00 00 00 00 1 167 
637C 00 00 00 00 1 167 
6380 00 00 00 00 1 167 
6384 00 00 00 00 1 167 
6388 00 00 00 00 1 167 
638C 00 00 00 00 1 167 
6390 00 00 00 00 1 167 
6394 00 00 00 00 1 167 
6398 00 00 00 00 1 167 
639C 00 00 00 00 1 167 
63A0 00 00 00 00 1 167 
63A4 00 00 00 00 1 167 
63A8 00 00 00 00 1 167 
63AC 00 00 00 00 1 167 
63B0 00 00 00 00 1 167 
63B4 00 00 00 00 1 167 
63B8 00 00 00 00 1 167 
63BC 00 00 00 00 1 167 
63C0 00 00 00 00 1 167 
63C4 00 00 00 00 1 167 
63C8 00 00 00 00 1 167 
63CC 00 00 00 00 1 167 
63D0 00 00 00 00 1 167 
63D4 00 00 00 00 1 167 
63D8 00 00 00 00 1 167 
63DC 00 00 00 00 1 167 
63E0 00 00 00 00 1 167 
63E4 00 00 00 00 1 167 
63E8 00 00 00 00 1 167 
63EC 00 00 00 00 1 167 
63F0 00 00 00 00 1 167 
63F4 00 00 00 00 1 167 
63F8 00 00 00 00 1 167 
63FC 00 00 00 00 1 167 
6400             1 169 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 170 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 171 ; 
6400             1 172 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 173 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 174 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 175 ; 
6400             1 176 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 177 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 178 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 179 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 180 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 181 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 181 
6408 7F 00 00 00 1 182 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 182 
6410 80          1 182 
6411 7F 00 00 00 1 183 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 183 
6419 81          1 183 
641A 7F 00 00 00 1 184 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 184 
6422 82          1 184 
6423 7F 00 00 00 1 185 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 185 
642B 83          1 185 
642C 7F 00 00 00 1 186 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 186 
6434 84          1 186 
6435 7F 00 00 00 1 187 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 187 
643D 85          1 187 
643E 7F 00 00 00 1 188 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 188 
6446 86          1 188 
6447 7F 7F 7F 7F 1 189 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 189 
644F 7F          1 189 
6450             1 190 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 191 defb    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 191 
6458 7F          1 191 
6459 81 00 00 00 1 192 defb       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 192 
6461 7F          1 192 
6462 82 00 00 00 1 193 defb          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 193 
646A 7F          1 193 
646B 83 00 00 00 1 194 defb             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 194 
6473 7F          1 194 
6474 84 00 00 00 1 195 defb                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 195 
647C 7F          1 195 
647D 85 00 00 00 1 196 defb                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 196 
6485 7F          1 196 
6486 86 00 00 00 1 197 defb                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 197 
648E 7F          1 197 
648F 7F 7F 7F 7F 1 198 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 198 
6497             1 200 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 201 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 202 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 203 TIMER_DIGITS:
6497 00 0F 0B 0B 1 204 defb    $00, $0F, $0B, $0B, $0B, $0F, $00, $00
649B 0B 0F 00 00 1 204 
649F 00 06 0E 06 1 205 defb    $00, $06, $0E, $06, $06, $06, $00, $00
64A3 06 06 00 00 1 205 
64A7 00 0F 03 0F 1 206 defb    $00, $0F, $03, $0F, $08, $0F, $00, $00
64AB 08 0F 00 00 1 206 
64AF 00 0F 03 07 1 207 defb    $00, $0F, $03, $07, $03, $0F, $00, $00
64B3 03 0F 00 00 1 207 
64B7 00 0B 0B 0F 1 208 defb    $00, $0B, $0B, $0F, $03, $03, $00, $00
64BB 03 03 00 00 1 208 
64BF 00 0F 08 0F 1 209 defb    $00, $0F, $08, $0F, $03, $0F, $00, $00
64C3 03 0F 00 00 1 209 
64C7 00 0F 0C 0F 1 210 defb    $00, $0F, $0C, $0F, $0D, $0F, $00, $00
64CB 0D 0F 00 00 1 210 
64CF 00 0F 03 03 1 211 defb    $00, $0F, $03, $03, $03, $03, $00, $00
64D3 03 03 00 00 1 211 
64D7 00 0F 0B 0F 1 212 defb    $00, $0F, $0B, $0F, $0B, $0F, $00, $00
64DB 0B 0F 00 00 1 212 
64DF 00 0F 0B 0F 1 213 defb    $00, $0F, $0B, $0F, $03, $0F, $00, $00
64E3 03 0F 00 00 1 213 
64E7             1 215 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 216 ; Tone parameters for sound effects
64E7             1 217 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 218 ; for each tone (from left to right):
64E7             1 219 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 220 ;   - length of a frame (1..65536)
64E7             1 221 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 222 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 223 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 224 TOKEN_FX                defw       1, 1000, 1400,   0
64EB 78 05 00 00 1 224 
64EF 05 00 88 13 1 225 WINNER_FX               defw       5, 5000,  200, 100
64F3 C8 00 64 00 1 225 
64F7 E8 03 0A 00 1 226 FILLED_FX               defw    1000,   10,  100,   0
64FB 64 00 00 00 1 226 
64FF FF          1 228 FILLER_2                defb    $FF                         ; filler to align next block (not used)
6500             1 230 ;org     $6500
6500             1 231 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 232 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 233 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 234 RED_VECTOR_TABLE:
6500 90 72       1 235 defw    PathFinder_RED_Edge_0
6502 BE 72       1 236 defw    PathFinder_RED_Edge_1
6504 E4 72       1 237 defw    PathFinder_RED_Edge_2
6506 0A 73       1 238 defw    PathFinder_RED_Edge_3
6508 30 73       1 239 defw    PathFinder_RED_Edge_4
650A 56 73       1 240 defw    PathFinder_RED_Edge_5
650C 7C 73       1 241 defw    PathFinder_RED_Edge_6
650E             1 243 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 244 ; Graphics for the screen frame
650E             1 245 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 246 FRAME_TILES:
650E 00 00 1F 3F 1 247 defb    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C
6512 3F 3F 3C 3C 1 247 
6516 00 00 FF FF 1 248 defb    $00, $00, $FF, $FF, $FF, $FF, $00, $00
651A FF FF 00 00 1 248 
651E 00 00 FF FE 1 249 defb    $00, $00, $FF, $FE, $FE, $FF, $00, $00
6522 FE FF 00 00 1 249 
6526 03 07 0F 0F 1 250 defb    $03, $07, $0F, $0F, $0F, $0F, $07, $03
652A 0F 0F 07 03 1 250 
652E FF FE FC FC 1 251 defb    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF
6532 FC FC FE FF 1 251 
6536 FF 7F 3F 3F 1 252 defb    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF
653A 3F 3F 7F FF 1 252 
653E C0 E0 F0 F0 1 253 defb    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0
6542 F0 F0 E0 C0 1 253 
6546 00 00 FF 7F 1 254 defb    $00, $00, $FF, $7F, $7F, $FF, $00, $00
654A 7F FF 00 00 1 254 
654E 00 00 F8 FC 1 255 defb    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C
6552 FC FC 3C 3C 1 255 
6556 3C 3C 3F 3F 1 256 defb    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00
655A 3F 1F 00 00 1 256 
655E 00 00 FE FF 1 257 defb    $00, $00, $FE, $FF, $FF, $FE, $00, $00
6562 FF FE 00 00 1 257 
6566 00 00 7F FF 1 258 defb    $00, $00, $7F, $FF, $FF, $7F, $00, $00
656A FF 7F 00 00 1 258 
656E 3C 3C FC FC 1 259 defb    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00
6572 FC F8 00 00 1 259 
6576 00 00 38 7C 1 260 defb    $00, $00, $38, $7C, $7C, $38, $00, $00
657A 7C 38 00 00 1 260 
657E             1 262 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 263 ; Hexagon sprites
657E             1 264 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 265 HEXAGON_EMPTY:
657E 07 E0 18 18 1 266 defb    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 266 
6586 48 02 48 02 1 267 defb    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 267 
658E 40 02 40 02 1 268 defb    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 268 
6596 20 24 20 04 1 269 defb    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 269 
659E             1 270 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 271 defb    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 271 
65A6 24 04 24 04 1 272 defb    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 272 
65AE 20 04 20 04 1 273 defb    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 273 
65B6 10 48 10 08 1 274 defb    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 274 
65BE 01 80 02 40 1 276 defb    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 276 
65C6 0A 10 0A 10 1 277 defb    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 277 
65CE 08 10 08 10 1 278 defb    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 278 
65D6 08 90 04 20 1 279 defb    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 279 
65DE 00 80 00 80 1 281 defb    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 281 
65E6 00 80 00 80 1 282 defb    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 282 
65EE 00 80 00 80 1 283 defb    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 283 
65F6 00 80 00 80 1 284 defb    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 284 
65FE 01 80 02 40 1 286 defb    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 286 
6606 0B D0 0B D0 1 287 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 287 
660E 0B D0 0B D0 1 288 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 288 
6616 0B D0 05 A0 1 289 defb    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 289 
661E 03 C0 0C 30 1 291 defb    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 291 
6626 2F F4 2F F4 1 292 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 292 
662E 2F F4 2F F4 1 293 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 293 
6636 17 E8 13 C8 1 294 defb    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 294 
663E             1 295 HEXAGON_TOKEN:
663E 07 E0 18 18 1 296 defb    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 296 
6646 5F FA 5F FA 1 297 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 297 
664E 5F FA 5F FA 1 298 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 298 
6656 2F F4 27 E4 1 299 defb    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 299 
665E             1 301 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 302 ; Board letter sprites
665E             1 303 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 304 LETTER_SPRITES:
665E 3C 7E FF C3 1 305 defb    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C
6662 F3 C3 D3 C3 1 305 
6666 7E 3C       1 305 
6668 3C 7E CF CF 1 306 defb    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C
666C C3 CB CB C3 1 306 
6670 7E 3C       1 306 
6672 3C 7E FF E3 1 307 defb    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C
6676 CF CF CF E3 1 307 
667A 7E 3C       1 307 
667C 3C 7E F3 F3 1 308 defb    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C
6680 C3 D3 D3 C3 1 308 
6684 7E 3C       1 308 
6686 3C 7E FF E3 1 309 defb    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C
668A CB C3 CF E3 1 309 
668E 7E 3C       1 309 
6690 3C 7E E3 CF 1 310 defb    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C
6694 C7 CF CF CF 1 310 
6698 7E 3C       1 310 
669A 3C 7E FF E3 1 311 defb    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C
669E D3 D3 E3 F3 1 311 
66A2 46 3C       1 311 
66A4             1 313 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 314 ; Board number sprites
66A4             1 315 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 316 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 317 defb    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C
66A8 E7 E7 E7 E7 1 317 
66AC 7E 3C       1 317 
66AE 3C 7E E7 D3 1 318 defb    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C
66B2 F3 E7 CF C3 1 318 
66B6 7E 3C       1 318 
66B8 3C 7E C7 F3 1 319 defb    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C
66BC E3 F3 F3 C7 1 319 
66C0 7E 3C       1 319 
66C2 3C 7E D3 D3 1 320 defb    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C
66C6 C3 F3 F3 F3 1 320 
66CA 7E 3C       1 320 
66CC 3C 7E C3 CF 1 321 defb    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C
66D0 C7 F3 F3 C7 1 321 
66D4 7E 3C       1 321 
66D6 3C 7E E3 CF 1 322 defb    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C
66DA C3 CB CB C3 1 322 
66DE 7E 3C       1 322 
66E0 3C 7E C3 F3 1 323 defb    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C
66E4 F3 E7 E7 E7 1 323 
66E8 7E 3C       1 323 
66EA             1 325 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 326 ; Screen addresses for menu hexagons
66EA             1 327 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 328 MENU_HEXAGONS:
66EA 01 40 05 40 1 329 defw    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 329 
66F2 0F 40 13 40 1 329 
66F6 1A 40       1 329 
66F8 45 40 48 40 1 330 defw    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 330 
6700 81 40 83 40 1 330 
6704 85 40       1 330 
6706 88 40 8A 40 1 331 defw    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 331 
670E C1 40 D0 40 1 331 
6712 D9 40       1 331 
6714 05 48 08 48 1 332 defw    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 332 
671C 19 48 1B 48 1 332 
6720 1D 48       1 332 
6722 0A 40 59 40 1 333 defw    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 333 
672A D2 40 0C 48 1 333 
672E 1C 40       1 333 
6730 41 40 50 40 1 334 defw    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 334 
6738 0F 48       1 334 
673A             1 335 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 336 defw    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 336 
6742 EF 40 F1 40 1 336 
6746 B2 40       1 336 
6748 E9 40 6F 48 1 337 defw    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 337 
6750 AA 48 AC 40 1 337 
6754 EF 48       1 337 
6756 2A 48 6D 48 1 338 defw    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 338 
675E             1 339 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 340 defw    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 340 
6766 AE 48 EF 48 1 340 
676A 2E 50       1 340 
676C AC 48 B4 48 1 341 defw    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 341 
6774 2E 48 F1 40 1 341 
6778 F3 40       1 341 
677A 73 48 B2 48 1 342 defw    $4873, $48B2, $5030
677E 30 50       1 342 
6780             1 344 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 345 ; Strings
6780             1 346 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 347 STR_OPTIONS:
6780 53 74 61 72 1 348 defm    "Start new game\0"
6784 74 20 6E 65 1 348 
6788 77 20 67 61 1 348 
678C 6D 65 00    1 348 
678F 48 6F 77 20 1 349 defm    "How to play\0"
6793 74 6F 20 70 1 349 
6797 6C 61 79 00 1 349 
679B 43 72 65 64 1 350 defm    "Credits\0"
679F 69 74 73 00 1 350 
67A3             1 351 STR_CREDITS:
67A3 44 65 73 69 1 352 defm    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 352 
67AB 20 20 20 20 1 352 
67AF 41 6E 74 6F 1 352 
67B3 6E 69 6F 20 1 352 
67B7 4C 75 71 75 1 352 
67BB 65 00       1 352 
67BD 43 6F 64 65 1 353 defm    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 353 
67C5 20 20 20 20 1 353 
67C9 41 6E 74 6F 1 353 
67CD 6E 69 6F 20 1 353 
67D1 4C 75 71 75 1 353 
67D5 65 00       1 353 
67D7 20 20 20 20 1 354 defm    "            Einar Saukas\0"
67DB 20 20 20 20 1 354 
67DF 20 20 20 20 1 354 
67E3 45 69 6E 61 1 354 
67E7 72 20 53 61 1 354 
67EB 75 6B 61 73 1 354 
67EF 00          1 354 
67F0 46 6F 6E 74 1 355 defm    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 355 
67F8 20 20 20 20 1 355 
67FC 45 69 6E 61 1 355 
6800 72 20 53 61 1 355 
6804 75 6B 61 73 1 355 
6808 00          1 355 
6809 47 72 61 70 1 356 defm    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 356 
6811 3A 20 20 20 1 356 
6815 45 69 6E 61 1 356 
6819 72 20 53 61 1 356 
681D 75 6B 61 73 1 356 
6821 00          1 356 
6822 20 20 20 20 1 357 defm    "            Antonio Luque\0"
6826 20 20 20 20 1 357 
682A 20 20 20 20 1 357 
682E 41 6E 74 6F 1 357 
6832 6E 69 6F 20 1 357 
6836 4C 75 71 75 1 357 
683A 65 00       1 357 
683C 50 72 65 73 1 358 STR_PRESSKEY            defm    "Press any key\0"
6840 73 20 61 6E 1 358 
6844 79 20 6B 65 1 358 
6848 79 00       1 358 
684A             1 359 STR_BUTTONS:
684A 4E 65 78 74 1 360 defm    "Next\0"
684E 00          1 360 
684F 42 61 63 6B 1 361 defm    "Back\0"
6853 00          1 361 
6854 52 45 44 00 1 362 STR_RED                 defm    "RED\0"
6858 43 59 41 4E 1 363 STR_CYAN                defm    "CYAN\0"
685C 00          1 363 
685D 43 6F 6E 6E 1 364 STR_HELP1               defm    "Connect\0"
6861 65 63 74 00 1 364 
6865 6C 65 66 74 1 365 STR_HELP2_RED           defm    "left and\0"
6869 20 61 6E 64 1 365 
686D 00          1 365 
686E 75 70 20 61 1 366 STR_HELP2_CYAN          defm    "up and\0"
6872 6E 64 00    1 366 
6875 72 69 67 68 1 367 STR_HELP3_RED           defm    "right\0"
6879 74 00       1 367 
687B 64 6F 77 6E 1 368 STR_HELP3_CYAN          defm    "down\0"
687F 00          1 368 
6880 62 6F 72 64 1 369 STR_HELP4               defm    "borders\0"
6884 65 72 73 00 1 369 
6888 74 6F 20 77 1 370 STR_HELP5               defm    "to win\0"
688C 69 6E 00    1 370 
688F             1 371 STR_HELP:
688F 57 69 6E 20 1 372 defm    "Win three\0"
6893 74 68 72 65 1 372 
6897 65 00       1 372 
6899 74 69 6D 65 1 373 defm    "times in\0"
689D 73 20 69 6E 1 373 
68A1 00          1 373 
68A2 61 20 72 6F 1 374 defm    "a row to\0"
68A6 77 20 74 6F 1 374 
68AA 00          1 374 
68AB 6C 65 76 65 1 375 defm    "level up\0"
68AF 6C 20 75 70 1 375 
68B3 00          1 375 
68B4 20 43 4F 4E 1 376 STR_CONGRATS            defm    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 376 
68BC 55 4C 41 54 1 376 
68C0 49 4F 4E 53 1 376 
68C4 20 00       1 376 
68C6             1 377 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 378 defm    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 378 
68CE 65 21 20 4C 1 378 
68D2 61 73 74 20 1 378 
68D6 6C 65 76 65 1 378 
68DA 6C 20 70 61 1 378 
68DE 73 73 65 64 1 378 
68E2 00          1 378 
68E3 43 68 6F 6F 1 379 defm    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 379 
68EB 65 76 65 6C 1 379 
68EF 20 74 6F 20 1 379 
68F3 72 65 73 74 1 379 
68F7 61 72 74 2C 1 379 
68FB 20 31 2D 34 1 379 
68FF 00          1 379 
6900             1 381 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 382 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 383 ; this font was designed by Einar Saukas for Hex game
6900             1 384 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 385 FONT:
6900 00 00 00 00 1 386 includebin "King+.bin"
6904 00 00 00 00 1 386 
6908 00 18 18 18 1 386 
690C 00 18 18 00 1 386 
6910 00 24 24 00 1 386 
6914 00 00 00 00 1 386 
6918 00 24 7E 24 1 386 
691C 24 7E 24 00 1 386 
6920 00 08 3E 28 1 386 
6924 3E 0A 3E 08 1 386 
6928 00 62 64 08 1 386 
692C 10 26 46 00 1 386 
6930 00 10 28 10 1 386 
6934 2A 44 3A 00 1 386 
6938 00 18 30 00 1 386 
693C 00 00 00 00 1 386 
6940 06 0C 08 08 1 386 
6944 08 0C 06 00 1 386 
6948 60 30 10 10 1 386 
694C 10 30 60 00 1 386 
6950 00 00 14 08 1 386 
6954 3E 08 14 00 1 386 
6958 00 00 08 08 1 386 
695C 3E 08 08 00 1 386 
6960 00 00 00 00 1 386 
6964 00 0C 18 30 1 386 
6968 00 00 00 7E 1 386 
696C 7E 00 00 00 1 386 
6970 00 00 00 00 1 386 
6974 30 70 70 00 1 386 
6978 02 06 0C 18 1 386 
697C 30 60 40 00 1 386 
6980 00 7E 62 62 1 386 
6984 62 62 7E 00 1 386 
6988 00 18 38 18 1 386 
698C 18 18 3C 00 1 386 
6990 00 38 4C 4C 1 386 
6994 18 30 7C 00 1 386 
6998 00 3C 62 0C 1 386 
699C 06 66 3C 00 1 386 
69A0 00 30 30 30 1 386 
69A4 30 34 3E 04 1 386 
69A8 00 7E 60 7E 1 386 
69AC 06 66 3C 00 1 386 
69B0 00 30 60 7C 1 386 
69B4 66 66 3C 00 1 386 
69B8 00 7E 46 0C 1 386 
69BC 18 30 60 00 1 386 
69C0 00 3C 66 3C 1 386 
69C4 66 66 3C 00 1 386 
69C8 00 3C 66 66 1 386 
69CC 3E 06 3C 00 1 386 
69D0 00 00 08 18 1 386 
69D4 00 08 18 00 1 386 
69D8 00 00 04 0C 1 386 
69DC 00 0C 18 30 1 386 
69E0 00 00 04 08 1 386 
69E4 10 08 04 00 1 386 
69E8 00 00 00 3E 1 386 
69EC 00 3E 00 00 1 386 
69F0 00 00 10 08 1 386 
69F4 04 08 10 00 1 386 
69F8 00 3C 42 04 1 386 
69FC 08 00 08 00 1 386 
6A00 00 3C 4A 56 1 386 
6A04 5E 40 3C 00 1 386 
6A08 00 7E 46 46 1 386 
6A0C 7E 46 46 00 1 386 
6A10 00 7C 62 7C 1 386 
6A14 62 62 7C 00 1 386 
6A18 00 7E 66 60 1 386 
6A1C 60 66 7E 00 1 386 
6A20 00 7C 46 46 1 386 
6A24 46 46 7C 00 1 386 
6A28 00 7E 60 7C 1 386 
6A2C 60 60 7E 00 1 386 
6A30 00 7E 60 7C 1 386 
6A34 60 60 60 00 1 386 
6A38 00 3E 62 60 1 386 
6A3C 66 66 3E 00 1 386 
6A40 00 62 62 7E 1 386 
6A44 62 62 62 00 1 386 
6A48 00 18 18 18 1 386 
6A4C 18 18 18 00 1 386 
6A50 00 0C 0C 0C 1 386 
6A54 0C 4C 38 00 1 386 
6A58 00 66 64 68 1 386 
6A5C 7E 46 66 00 1 386 
6A60 00 60 60 60 1 386 
6A64 60 60 7E 00 1 386 
6A68 00 7E 56 56 1 386 
6A6C 56 56 56 00 1 386 
6A70 00 7E 46 46 1 386 
6A74 46 46 46 00 1 386 
6A78 00 7E 62 62 1 386 
6A7C 62 62 7E 00 1 386 
6A80 00 7E 62 62 1 386 
6A84 7E 60 60 00 1 386 
6A88 00 7C 64 64 1 386 
6A8C 64 64 7E 00 1 386 
6A90 00 7C 62 64 1 386 
6A94 7C 46 46 00 1 386 
6A98 00 7E 60 7E 1 386 
6A9C 06 06 7E 00 1 386 
6AA0 00 7E 18 18 1 386 
6AA4 18 18 18 00 1 386 
6AA8 00 62 62 62 1 386 
6AAC 62 62 7E 00 1 386 
6AB0 00 62 62 62 1 386 
6AB4 62 34 18 00 1 386 
6AB8 00 6A 6A 6A 1 386 
6ABC 6A 6A 7E 00 1 386 
6AC0 00 62 62 34 1 386 
6AC4 4E 46 46 00 1 386 
6AC8 00 62 62 7E 1 386 
6ACC 18 18 18 00 1 386 
6AD0 00 7E 06 1C 1 386 
6AD4 38 60 7E 00 1 386 
6AD8 00 0E 08 08 1 386 
6ADC 08 08 0E 00 1 386 
6AE0 00 00 40 20 1 386 
6AE4 10 08 04 00 1 386 
6AE8 00 70 10 10 1 386 
6AEC 10 10 70 00 1 386 
6AF0 00 08 1C 2A 1 386 
6AF4 08 08 08 08 1 386 
6AF8 00 00 00 00 1 386 
6AFC 00 00 00 FF 1 386 
6B00 0C 12 10 38 1 386 
6B04 10 10 3E 00 1 386 
6B08 00 00 3C 06 1 386 
6B0C 7E 46 7E 00 1 386 
6B10 00 60 60 7E 1 386 
6B14 62 62 7E 00 1 386 
6B18 00 00 7E 62 1 386 
6B1C 60 62 7E 00 1 386 
6B20 00 06 06 7E 1 386 
6B24 46 46 7E 00 1 386 
6B28 00 00 7E 46 1 386 
6B2C 7E 60 7E 00 1 386 
6B30 00 1E 30 3C 1 386 
6B34 30 30 30 00 1 386 
6B38 00 00 7E 46 1 386 
6B3C 46 3E 06 3E 1 386 
6B40 00 60 60 7C 1 386 
6B44 66 66 66 00 1 386 
6B48 00 18 00 38 1 386 
6B4C 18 18 3C 00 1 386 
6B50 00 0C 00 0C 1 386 
6B54 0C 0C 4C 38 1 386 
6B58 00 20 2C 38 1 386 
6B5C 38 2C 26 00 1 386 
6B60 00 18 18 18 1 386 
6B64 18 18 0E 00 1 386 
6B68 00 00 6C 56 1 386 
6B6C 56 56 46 00 1 386 
6B70 00 00 7C 46 1 386 
6B74 46 46 46 00 1 386 
6B78 00 00 3C 46 1 386 
6B7C 46 46 3C 00 1 386 
6B80 00 00 7C 66 1 386 
6B84 66 7C 60 60 1 386 
6B88 00 00 3E 46 1 386 
6B8C 46 3E 06 06 1 386 
6B90 00 00 3C 62 1 386 
6B94 60 60 60 00 1 386 
6B98 00 00 3C 60 1 386 
6B9C 3C 06 3C 00 1 386 
6BA0 00 30 78 30 1 386 
6BA4 30 30 1C 00 1 386 
6BA8 00 00 46 46 1 386 
6BAC 46 46 3C 00 1 386 
6BB0 00 00 46 46 1 386 
6BB4 2C 3C 18 00 1 386 
6BB8 00 00 46 56 1 386 
6BBC 56 56 2C 00 1 386 
6BC0 00 00 46 2C 1 386 
6BC4 18 2C 46 00 1 386 
6BC8 00 00 46 46 1 386 
6BCC 46 3E 06 3C 1 386 
6BD0 00 00 7E 0C 1 386 
6BD4 18 30 7E 00 1 386 
6BD8 00 0E 08 30 1 386 
6BDC 08 08 0E 00 1 386 
6BE0 00 08 08 08 1 386 
6BE4 08 2A 1C 08 1 386 
6BE8 00 70 10 0C 1 386 
6BEC 10 10 70 00 1 386 
6BF0 00 14 28 00 1 386 
6BF4 00 00 00 00 1 386 
6BF8 FF 81 81 81 1 386 
6BFC 81 81 81 FF 1 386 

; File #2: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Main.z80asm

6C00             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 2 ; Main.z80asm
6C00             2 3 ; Coded by Antonio Luque
6C00             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 6 CYAN_COLOR              equ     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6C00             2 7 RED_COLOR               equ     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6C00             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 10 ; Entry point of the program - Initialization
6C00             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 12 Main                    ent     $
6C00 F3          2 14 di                                  ; disable interrupts
6C01             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6C01 21 1D 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6C04 FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C08 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C0B FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C0E 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C10 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C12 ED 5E       2 24 im      2                           ; set interrupt mode 2
6C14             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C14             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C14             2 28 ; resultant vector address is formed as follows:
6C14             2 29 ;
6C14             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C14             2 31 ; Source: 
6C14             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
6C14             2 33 ;
6C14             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C14             2 35 ; memory area and it is used by some ROM routines, but none of them are called by HEX2 program.
6C14 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C17 AF          2 39 xor     a                           ; A = 0
6C18 D3 FE       2 40 out     ($FE), a                    ; set border color (black)
6C1A CD 74 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C1D             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 44 ; Start new game
6C1D             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 46 Main_Start
6C1D CD 09 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C20 CD 16 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C23 CD 42 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C26 CD 81 77    2 50 call    Screen_Frame                ; draw the screen frame
6C29 CD D9 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C2C CD F8 77    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C2F CD 3B 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C32 FB          2 55 ei                                  ; enable interrupts
6C33             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 58 ; New level
6C33             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 60 Main_New_Level
6C33 3E 04       2 61 ld      a, 4                        ; maximum level
6C35 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C38 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C39 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C3B CD 75 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C3E 18 DD       2 66 jr      Main_Start                  ; start a new game
6C40             2 67 Main_Increment_Level
6C40 34          2 68 inc     (hl)                        ; increment game level
6C41 CD 18 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C44 CD 07 79    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C47 AF          2 71 xor     a                           ; A = 0
6C48 32 0F 62    2 72 ld      (THREE_ROW), a              ; initialize three-in-a-row counter
6C4B             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 75 ; Start new match
6C4B             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 77 Main_Start_Match
6C4B             2 78 ; set up timers and clear last messages
6C4B CD B2 76    2 80 call    Timer_Reset                 ; reset timers
6C4E CD 9D 76    2 81 call    Timer_Display_All           ; display timers
6C51 CD 0E 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C54 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C56 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C59 CD 35 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C5C             2 87 ; swap players' colors
6C5C 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C5F EE 07       2 90 xor     %00000111                   ; swap color
6C61 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C64 CD F1 6E    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C67             2 94 ; initialize positions and draw empty board
6C67 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C6A 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C6D 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C6F 01 FF 01    2 99 ld      bc, 256*2-1                 ; length of cyan + red positions areas (-1 already set)
6C72 ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C74 CD A1 6D    2 101 call    Draw_Board                  ; draw an empty hexagons board
6C77             2 103 ; initialize draw token delay, move number and token color
6C77 3E 0A       2 105 ld      a, 10                       ; set delay duration for animate hexagons
6C79 32 D0 6D    2 106 ld      (Draw_Token_Delay+1), a
6C7C 3E 01       2 107 ld      a, 1                        ; initialize move number
6C7E 32 9B 61    2 108 ld      (MOVE_NUMBER), a
6C81 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C83             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 112 ; Process players moves - Match loop
6C83             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 114 Main_Match_Loop
6C83             2 115 ; check player turn
6C83 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C86 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C89 BE          2 119 cp      (hl)                        ; is player color = current token color?
6C8A 28 05       2 120 jr      z, Main_Player_Move         ; yes, process player move
6C8C CD EC 6C    2 122 call    Main_GetSpeccy_Move         ; get the speccy move
6C8F 18 03       2 123 jr      Main_Update_Board           ; update board position
6C91             2 124 Main_Player_Move
6C91 CD 36 6D    2 125 call    Main_GetPlayer_Move         ; get a legal (empty position) player move 
6C94             2 126 Main_Update_Board
6C94             2 127 ; update positions with player/speccy move
6C94 CD ED 70    2 129 call    PathFinder_Friend           ; get player/speccy side
6C97 CD F7 70    2 130 call    PathFinder_PutToken         ; put token on cyan and red positions
6C9A             2 132 ; draw token on the board
6C9A AF          2 134 xor     a                           ; stop timers
6C9B 32 E9 62    2 135 ld      (TIMER_FLAG), a
6C9E CD BC 6D    2 136 call    Draw_Token                  ; animate hexagon sprite on the screen
6CA1 DD 21 E7 64 2 137 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6CA5 CD C7 76    2 138 call    Sound_FX                    ; play sound effect
6CA8             2 140 ; check for a winner
6CA8 CD A0 75    2 142 call    PathFinder_VictoryPath      ; check current player victory path
6CAB 3C          2 143 inc     a                           ; is there a victory path?
6CAC 20 0B       2 144 jr      nz, Main_Match_End          ; yes, match ends
6CAE 21 9B 61    2 146 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CB1 34          2 147 inc     (hl)                        ; increment move number
6CB2             2 149 ; swap players' token color
6CB2 3A 9E 61    2 151 ld      a, (TOKEN_COLOR)            ; get current token color
6CB5 EE 07       2 152 xor     %00000111                   ; swap token color
6CB7 18 CA       2 153 jr      Main_Match_Loop             ; repeat match loop
6CB9             2 155 ; ----------------------------------------------------------------------------------------------------------------------
6CB9             2 156 ; Current player wins the match
6CB9             2 157 ; ----------------------------------------------------------------------------------------------------------------------
6CB9             2 158 Main_Match_End
6CB9 47          2 159 ld      b, a                        ; set start position of victory path in B
6CBA 3E 04       2 160 ld      a, 4                        ; set delay duration for animate hexagons
6CBC 32 D0 6D    2 161 ld      (Draw_Token_Delay+1), a
6CBF CD D5 75    2 163 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CC2 11 3B 62    2 165 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CC5 CD 15 6F    2 166 call    Print_Alert                 ; print string
6CC8 3A 9E 61    2 168 ld      a, (TOKEN_COLOR)            ; get current token color
6CCB 21 9F 61    2 169 ld      hl, PLAYER_COLOR            ; get player color
6CCE BE          2 170 cp      (hl)                        ; is player color = current token color?
6CCF 21 0F 62    2 171 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CD2 28 04       2 172 jr      z, Main_ThreeRow_Increment  ; yes, go to increment three-in-a-row counter
6CD4 35          2 173 dec     (hl)                        ; decrement three-in-a-row counter
6CD5 F2 D9 6C    2 174 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CD8             2 175 Main_ThreeRow_Increment
6CD8 34          2 176 inc     (hl)                        ; increment three-in-a-row counter
6CD9             2 177 Main_ThreeRow_Show
6CD9 CD EB 78    2 178 call    Screen_ThreeRow             ; show three-in-a-row marks
6CDC 3E FF       2 179 ld      a, 255                      ; set delay duration
6CDE CD 92 6D    2 180 call    Main_Delay                  ; execute delay
6CE1 3A 0F 62    2 181 ld      a, (THREE_ROW)              ; check three row counter
6CE4 FE 03       2 182 cp      3                           ; is it 3?
6CE6 CA 33 6C    2 183 jp      z, Main_New_Level           ; yes, start a new level
6CE9 C3 4B 6C    2 184 jp      Main_Start_Match            ; start a new match
6CEC             2 186 ; ----------------------------------------------------------------------------------------------------------------------
6CEC             2 187 ; Main_GetSpeccy_Move: get the speccy move
6CEC             2 188 ;
6CEC             2 189 ; Input:     A = current token color
6CEC             2 190 ;
6CEC             2 191 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CEC             2 192 ;           HL = CYAN_POSITIONS move address
6CEC             2 193 ;
6CEC             2 194 ; Uses:     MOVE_NUMBER (current move number)
6CEC             2 195 ;           GAME_LEVEL (current game level)
6CEC             2 196 ;           AI_DEPTH (recursion depth level)
6CEC             2 197 ;           STR_MOVE (formatted move string)
6CEC             2 198 ;
6CEC             2 199 ; Destroys: A, DE, IX, IY
6CEC             2 200 ; ----------------------------------------------------------------------------------------------------------------------
6CEC             2 201 Main_GetSpeccy_Move:
6CEC E6 03       2 202 and     %00000011                   ; calculate speccy's timer flag based on current token color
6CEE 32 E9 62    2 203 ld      (TIMER_FLAG), a             ; (re)start speccy timer
6CF1 CD 2E 6F    2 205 call    Print_Wait                  ; print "WAIT" message
6CF4 3A 9B 61    2 206 ld      a, (MOVE_NUMBER)            ; get move number
6CF7 3D          2 207 dec     a                           ; is it cyan first move?
6CF8 28 2A       2 208 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CFA DD 21 00 7F 2 210 ld      ix, CANDIDATES              ; IX points to candidates list address
6CFE 3A 9D 61    2 211 ld      a, (GAME_LEVEL)             ; get game level
6D01 32 9A 61    2 212 ld      (AI_DEPTH), a               ; save recursion depth level
6D04 CD ED 70    2 214 call    PathFinder_Friend           ; get speccy side
6D07 CD 7F 6F    2 215 call    BRAINIAC_best_move          ; get speccy best move
6D0A 6B          2 216 ld      l, e                        ; set node index in L
6D0B             2 217 Main_GetSpeccy_Positions
6D0B 26 7D       2 218 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D0D E5          2 219 push    hl                          ; store CYAN_POSITIONS move address
6D0E CD 81 6D    2 220 call    Main_Board2Indexes          ; convert board position to indexes
6D11 78          2 221 ld      a, b                        ; get 1..7 column
6D12 C6 60       2 222 add     a, $60                      ; adjust to charset ('a'..'g')
6D14 32 16 62    2 223 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D17 79          2 224 ld      a, c                        ; get 1..7 row
6D18 C6 30       2 225 add     a, $30                      ; adjust to charset ('1'..'7')
6D1A 32 19 62    2 226 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D1D C5          2 227 push    bc                          ; store hexagon board indexes
6D1E CD 3C 6F    2 228 call    Print_Move                  ; print Speccy move
6D21 C1          2 229 pop     bc                          ; restore hexagon board indexes
6D22 E1          2 230 pop     hl                          ; restore CYAN_POSITIONS move address
6D23 C9          2 231 ret
6D24             2 232 Main_GetSpeccy_Book
6D24 ED 5F       2 233 ld      a, r                        ; get a pseudo-random number (0..127)
6D26 E6 1F       2 234 and     %00011111                   ; number is in range (0..31)
6D28 FE 1B       2 235 cp      27                          ; is it >= 27?
6D2A 30 F8       2 236 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D2C 21 CE 62    2 237 ld      hl, OPENINGS                ; HL points to opening book address
6D2F 16 00       2 238 ld      d, 0                        ; set index in DE
6D31 5F          2 239 ld      e, a
6D32 19          2 240 add     hl, de                      ; HL points to move index address
6D33 6E          2 241 ld      l, (hl)                     ; get move from opening book
6D34 18 D5       2 242 jr      Main_GetSpeccy_Positions    ; get speccy move positions
6D36             2 244 ; ----------------------------------------------------------------------------------------------------------------------
6D36             2 245 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D36             2 246 ;
6D36             2 247 ; Input:     A = current token color
6D36             2 248 ;
6D36             2 249 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D36             2 250 ;           HL = CYAN_POSITIONS move address
6D36             2 251 ;
6D36             2 252 ; Uses:     STR_MOVE (formatted move string)
6D36             2 253 ;
6D36             2 254 ; Destroys: A, DE, IX
6D36             2 255 ; ----------------------------------------------------------------------------------------------------------------------
6D36             2 256 Main_GetPlayer_Move:
6D36 E6 03       2 257 and     %00000011                   ; calculate player's timer flag based on current token color
6D38 32 E9 62    2 258 ld      (TIMER_FLAG), a             ; (re)start player timer
6D3B             2 259 Main_GetPlayer_Input
6D3B CD 35 6F    2 260 call    Print_Clear_Move            ; clear player last move
6D3E CD 2B 6E    2 261 call    Input_Move                  ; wait for input player move
6D41 CD 3C 6F    2 262 call    Print_Move                  ; print player move
6D44 3A 16 62    2 264 ld      a, (STR_MOVE+0)             ; get column ('a'..'g')
6D47 D6 60       2 265 sub     $60                         ; convert to number (1..7)
6D49 47          2 266 ld      b, a                        ; set column index in B
6D4A 3A 19 62    2 267 ld      a, (STR_MOVE+3)             ; get row ('1'..'7')
6D4D D6 30       2 268 sub     $30                         ; convert to number (1..7)
6D4F 4F          2 269 ld      c, a                        ; set row index in C
6D50 11 4E 62    2 270 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D53 CD 74 6D    2 271 call    Main_Search_Table           ; search board position in board coordinates
6D56 6E          2 272 ld      l, (hl)                     ; set board position of player move
6D57 26 7D       2 273 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D59 3E 00       2 274 ld      a, EMPTY                    ; check position
6D5B BE          2 275 cp      (hl)                        ; is position empty?
6D5C C8          2 276 ret     z                           ; yes, return
6D5D             2 278 ; illegal player move (position not empty)
6D5D 11 2F 62    2 280 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D60 CD 15 6F    2 281 call    Print_Alert                 ; print string
6D63 DD 21 F7 64 2 282 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D67 CD C7 76    2 283 call    Sound_FX                    ; play sound fx
6D6A 3E 50       2 284 ld      a, 80                       ; set delay counter
6D6C CD 92 6D    2 285 call    Main_Delay                  ; execute delay
6D6F CD 0E 6F    2 286 call    Print_Clear_Alert           ; clear alert message
6D72 18 C7       2 287 jr      Main_GetPlayer_Input        ; repeat player input until move is legal
6D74             2 289 ; ----------------------------------------------------------------------------------------------------------------------
6D74             2 290 ; Main_Search_Table: search an element in a 8x8 bytes table
6D74             2 291 ;
6D74             2 292 ; Input:    BC = element indexes (B = column, C = row)
6D74             2 293 ;           DE = table address in which to search for the element
6D74             2 294 ;
6D74             2 295 ; Output:   DE = address of first element in the C row of the table
6D74             2 296 ;           HL = address of the element in the BC indexes of the table
6D74             2 297 ;
6D74             2 298 ; Destroys: -
6D74             2 299 ; ----------------------------------------------------------------------------------------------------------------------
6D74             2 300 Main_Search_Table:
6D74 26 00       2 301 ld      h, 0                        ; first, get the C row in table
6D76 69          2 302 ld      l, c                        ; set index in HL
6D77 29          2 303 add     hl, hl                      ; a row is 8 bytes long
6D78 29          2 304 add     hl, hl
6D79 29          2 305 add     hl, hl
6D7A 19          2 306 add     hl, de                      ; HL points to the address of C row 
6D7B EB          2 307 ex      de, hl                      ; DE points to the address of C row
6D7C 26 00       2 308 ld      h, 0                        ; go for to the B column
6D7E 68          2 309 ld      l, b                        ; set index in HL
6D7F 19          2 310 add     hl, de                      ; HL points to the address of BC indexes
6D80 C9          2 311 ret
6D81             2 313 ; ----------------------------------------------------------------------------------------------------------------------
6D81             2 314 ; Main_Board2Indexes: convert a board position into a board indexes
6D81             2 315 ;
6D81             2 316 ; Input:    L  = board position
6D81             2 317 ;
6D81             2 318 ; Output:   BC = board indexes (B = column, C = row)
6D81             2 319 ;
6D81             2 320 ; Destroys: HL
6D81             2 321 ; ----------------------------------------------------------------------------------------------------------------------
6D81             2 322 Main_Board2Indexes:
6D81 7D          2 323 ld      a, l                        ; set board position in A to compare later
6D82 21 8E 62    2 325 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D85 0E 07       2 326 ld      c, 7                        ; 7 rows
6D87             2 327 Main_Board2Indexes_Row
6D87 06 07       2 328 ld      b, 7                        ; 7 columns
6D89             2 329 Main_Board2Indexes_Col
6D89 2B          2 330 dec     hl                          ; move HL to next board position address
6D8A BE          2 331 cp      (hl)                        ; is A the position?
6D8B C8          2 332 ret     z                           ; yes, return board indexes
6D8C 10 FB       2 333 djnz    Main_Board2Indexes_Col      ; repeat for each column
6D8E 2B          2 334 dec     hl                          ; skip borders
6D8F 0D          2 335 dec     c                           ; decrement row
6D90 18 F5       2 336 jr      Main_Board2Indexes_Row      ; loop until find position
6D92             2 338 ; ----------------------------------------------------------------------------------------------------------------------
6D92             2 339 ; Main_Delay: execute a delay
6D92             2 340 ;
6D92             2 341 ; Input:    A = delay counter
6D92             2 342 ;
6D92             2 343 ; Output:   -
6D92             2 344 ;
6D92             2 345 ; Destroys: A
6D92             2 346 ; ----------------------------------------------------------------------------------------------------------------------
6D92             2 347 Main_Delay:
6D92 C5          2 348 push    bc                          ; store register
6D93             2 349 Main_Delay_Loop
6D93 0E 0A       2 350 ld      c, 10                       ; set outer loop counter
6D95             2 351 Main_Delay_Loop1
6D95 06 00       2 352 ld      b, 0                        ; set inner loop counter (256)
6D97             2 353 Main_Delay_Loop2
6D97 10 FE       2 354 djnz    Main_Delay_Loop2            ; repeat until B=0
6D99 0D          2 355 dec     c                           ; decrement outer loop counter
6D9A 20 F9       2 356 jr      nz, Main_Delay_Loop1        ; repeat until C=0
6D9C 3D          2 357 dec     a                           ; decrement delay counter
6D9D 20 F4       2 358 jr      nz, Main_Delay_Loop         ; repeat until A=0
6D9F C1          2 359 pop     bc                          ; restore register
6DA0 C9          2 360 ret

; File #3: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Draw.z80asm

6DA1             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6DA1             3 2 ; Draw.z80asm
6DA1             3 3 ; Coded by Antonio Luque
6DA1             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6DA1             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6DA1             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6DA1             3 8 ;
6DA1             3 9 ; Input:    -
6DA1             3 10 ;
6DA1             3 11 ; Output:   -
6DA1             3 12 ;
6DA1             3 13 ; Uses:     TOKEN_COLOR (current token color)
6DA1             3 14 ;
6DA1             3 15 ; Destroys: A, BC, DE, HL, IXL
6DA1             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6DA1             3 17 Draw_Board:
6DA1 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6DA3 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6DA6 0E 07       3 20 ld      c, 7                        ; 7 rows
6DA8             3 21 Draw_Board_Row
6DA8 06 07       3 22 ld      b, 7                        ; 7 columns
6DAA             3 23 Draw_Board_Column
6DAA CD D7 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DAD CD 0F 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DB0 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DB3 CD E1 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DB6 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DB8 0D          3 29 dec     c                           ; decrement row
6DB9 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DBB C9          3 31 ret
6DBC             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DBC             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DBC             3 35 ;
6DBC             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DBC             3 37 ;
6DBC             3 38 ; Output:   -
6DBC             3 39 ;
6DBC             3 40 ; Destroys: A, BC, DE, HL, IXL
6DBC             3 41 ; ----------------------------------------------------------------------------------------------------------------------
6DBC             3 42 Draw_Token:
6DBC CD D7 6D    3 43 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DBF 01 04 06    3 44 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DC2 11 9E 65    3 45 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DC5             3 46 Draw_Token_Loop
6DC5 E5          3 47 push    hl                          ; store hexagon screen address
6DC6 CD E1 6D    3 48 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DC9 E1          3 49 pop     hl                          ; restore hexagon screen address
6DCA 78          3 50 ld      a, b                        ; check loop counter
6DCB B9          3 51 cp      c                           ; is it 4?
6DCC CC 0F 6E    3 52 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DCF             3 53 Draw_Token_Delay
6DCF 3E 00       3 54 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DD1 CD 92 6D    3 55 call    Main_Delay                  ; execute delay
6DD4 10 EF       3 56 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DD6 C9          3 57 ret
6DD7             3 59 ; ----------------------------------------------------------------------------------------------------------------------
6DD7             3 60 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DD7             3 61 ;
6DD7             3 62 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DD7             3 63 ;
6DD7             3 64 ; Output:   HL = hexagon screen address 
6DD7             3 65 ;
6DD7             3 66 ; Destroys: A, DE
6DD7             3 67 ; ----------------------------------------------------------------------------------------------------------------------
6DD7             3 68 Draw_GetHEX_Screen:
6DD7 11 98 61    3 69 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DDA CD 74 6D    3 70 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DDD 6E          3 71 ld      l, (hl)                     ; set the low byte of the screen address in L
6DDE 1A          3 72 ld      a, (de)                     ; set the high byte of the screen address in H
6DDF 67          3 73 ld      h, a
6DE0 C9          3 74 ret
6DE1             3 76 ; ----------------------------------------------------------------------------------------------------------------------
6DE1             3 77 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DE1             3 78 ;
6DE1             3 79 ; Input:    DE = hexagon sprite address
6DE1             3 80 ;           HL = hexagon screen address
6DE1             3 81 ;
6DE1             3 82 ; Output:   DE = next hexagon sprite address
6DE1             3 83 ;
6DE1             3 84 ; Destroys: A, HL, IXL
6DE1             3 85 ; ----------------------------------------------------------------------------------------------------------------------
6DE1             3 86 Draw_Sprite_Hexagon:
6DE1 DD 2E 10    3 87 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DE4             3 88 Draw_Sprite_HexLoop
6DE4 1A          3 89 ld      a, (de)                     ; get sprite byte
6DE5 77          3 90 ld      (hl), a                     ; put sprite byte on screen
6DE6 13          3 91 inc     de                          ; move DE to next sprite byte address
6DE7 2C          3 92 inc     l                           ; move HL to next screen column
6DE8 1A          3 93 ld      a, (de)                     ; get sprite byte
6DE9 77          3 94 ld      (hl), a                     ; put sprite byte on screen
6DEA 13          3 95 inc     de                          ; move DE to next sprite byte
6DEB 2D          3 96 dec     l                           ; move HL to previous screen column
6DEC CD 00 6E    3 97 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DEF DD 2D       3 98 dec     ixl                         ; decrement sprite height
6DF1 20 F1       3 99 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6DF3 C9          3 100 ret
6DF4             3 102 ; ----------------------------------------------------------------------------------------------------------------------
6DF4             3 103 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6DF4             3 104 ;
6DF4             3 105 ; Input:    DE = letter/number sprite address
6DF4             3 106 ;           HL = letter/number screen address
6DF4             3 107 ;
6DF4             3 108 ; Output:   DE = next letter/number sprite address
6DF4             3 109 ;
6DF4             3 110 ; Destroys: A, C, HL
6DF4             3 111 ; ----------------------------------------------------------------------------------------------------------------------
6DF4             3 112 Draw_Sprite_LetterNum:
6DF4 0E 0A       3 113 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6DF6             3 114 Draw_Sprite_Loop
6DF6 1A          3 115 ld      a, (de)                     ; get sprite byte
6DF7 77          3 116 ld      (hl), a                     ; put sprite byte on screen
6DF8 13          3 117 inc     de                          ; move DE to next sprite byte address
6DF9 CD 00 6E    3 118 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DFC 0D          3 119 dec     c                           ; decrement sprite height
6DFD 20 F7       3 120 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6DFF C9          3 121 ret
6E00             3 123 ; ----------------------------------------------------------------------------------------------------------------------
6E00             3 124 ; Draw_Down_PixelLine: move HL down one pixel-line
6E00             3 125 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6E00             3 126 ;
6E00             3 127 ; The screen address of a pixel-line is encoded as follows:
6E00             3 128 ;
6E00             3 129 ;             H           |           L
6E00             3 130 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E00             3 131 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E00             3 132 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E00             3 133 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6E00             3 134 ;
6E00             3 135 ; where:
6E00             3 136 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E00             3 137 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E00             3 138 ;
6E00             3 139 ; Input:    HL = pixel-line address
6E00             3 140 ;
6E00             3 141 ; Output:   HL = next (down) pixel-line address
6E00             3 142 ;
6E00             3 143 ; Destroys: A
6E00             3 144 ; ----------------------------------------------------------------------------------------------------------------------
6E00             3 145 Draw_Down_PixelLine:
6E00 24          3 146 inc     h                           ; move HL down one pixel-line
6E01 7C          3 147 ld      a, h                        ; get high byte of pixel-line address
6E02 E6 07       3 148 and     %00000111                   ; is pixel-line address inside a character line?
6E04 C0          3 149 ret     nz                          ; yes, return
6E05 7D          3 150 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6E06 C6 20       3 151 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E08 6F          3 152 ld      l, a                        ; move HL down one character line
6E09 D8          3 153 ret     c                           ; a third was crossed? yes, return
6E0A 7C          3 154 ld      a, h                        ; get high byte of pixel-line address
6E0B D6 08       3 155 sub     8                           ; clean up the bit from Y6
6E0D 67          3 156 ld      h, a                        ; HL points to next (down) pixel-line address
6E0E C9          3 157 ret
6E0F             3 159 ; ----------------------------------------------------------------------------------------------------------------------
6E0F             3 160 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E0F             3 161 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E0F             3 162 ;
6E0F             3 163 ; This routine converts a screen address (HL) into an attribute address (IX):
6E0F             3 164 ;
6E0F             3 165 ;             H           |           L
6E0F             3 166 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0F             3 167 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E0F             3 168 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0F             3 169 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E0F             3 170 ;
6E0F             3 171 ;            IXH          |          IXL
6E0F             3 172 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0F             3 173 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E0F             3 174 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0F             3 175 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E0F             3 176 ;
6E0F             3 177 ; where:
6E0F             3 178 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E0F             3 179 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E0F             3 180 ;
6E0F             3 181 ; Input:    HL = screen address of the hexagon
6E0F             3 182 ;
6E0F             3 183 ; Output:   IX = attribute address of the hexagon
6E0F             3 184 ;
6E0F             3 185 ; Uses:     TOKEN_COLOR (current token color)
6E0F             3 186 ;
6E0F             3 187 ; Destroys: A
6E0F             3 188 ; ----------------------------------------------------------------------------------------------------------------------
6E0F             3 189 Draw_Hexagon_Color:
6E0F 7C          3 190 ld      a, h                        ; get high byte of screen address
6E10 F6 87       3 191 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E12 1F          3 192 rra                                 ; shift Y7-Y6 two positions
6E13 1F          3 193 rra
6E14 CB 3F       3 194 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E16 DD 67       3 195 ld      ixh, a                      ; set high byte of attribute address in IXH
6E18 7D          3 196 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E19 DD 6F       3 197 ld      ixl, a                      ; set low byte of attribute address in IXL
6E1B 3A 9E 61    3 198 ld      a, (TOKEN_COLOR)            ; get current token color
6E1E DD 77 00    3 199 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E21 DD 77 01    3 200 ld      (ix+1), a
6E24 DD 77 20    3 201 ld      (ix+32), a
6E27 DD 77 21    3 202 ld      (ix+33), a
6E2A C9          3 203 ret

; File #4: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Input.z80asm

6E2B             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E2B             4 2 ; Input.z80asm
6E2B             4 3 ; Coded by Antonio Luque
6E2B             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E2B             4 6 MAX_CHARS               equ     2                           ; maximum of input chars
6E2B             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E2B             4 9 ; Input_Move: wait for input a move from keyboard
6E2B             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E2B             4 11 ;
6E2B             4 12 ; Input:    -
6E2B             4 13 ;
6E2B             4 14 ; Output:   -
6E2B             4 15 ;
6E2B             4 16 ; Uses:     TOKEN_COLOR (current token color)
6E2B             4 17 ;           STR_MOVE (formatted move string)
6E2B             4 18 ;
6E2B             4 19 ; Destroys: A, A', BC, DE, HL, IX
6E2B             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E2B             4 21 Input_Move:
6E2B 01 00 02    4 22 ld      bc, MAX_CHARS*256           ; B = maximum of input chars, C = chars counter
6E2E DD 21 83 5A 4 24 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E32 21 83 50    4 25 ld      hl, $5083                   ; HL points to screen address of RED input text
6E35 3A 9E 61    4 26 ld      a, (TOKEN_COLOR)            ; check current player color
6E38 FE 02       4 27 cp      RED_COLOR                   ; is RED the current token color?
6E3A 28 07       4 28 jr      z, Input_Start              ; yes, start input
6E3C DD 21 19 59 4 29 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E40 21 19 48    4 30 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E43             4 31 Input_Start
6E43 DD 36 00 C7 4 32 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E47 3E 5F       4 33 ld      a, '_'                      ; text input cursor
6E49 CD 65 6F    4 34 call    Print_Char                  ; print cursor
6E4C             4 35 Input_Loop
6E4C CD C5 6E    4 36 call    Input_Key_Scan              ; scan for a key pressed
6E4F FE 0D       4 38 cp      $0D                         ; is it ENTER?
6E51 28 64       4 39 jr      z, Input_Enter              ; yes, perform enter pressed
6E53 FE 30       4 40 cp      '0'                         ; is it "delete"? (char '0' acts as delete, without Shift)
6E55 28 42       4 41 jr      z, Input_Delete             ; yes, perform delete char
6E57 08          4 42 ex      af, af'                     ; store char in A'
6E58 79          4 43 ld      a, c                        ; check number of chars inserted
6E59 B8          4 44 cp      b                           ; chars limit reached?
6E5A 28 F0       4 45 jr      z, Input_Loop               ; yes, repeat input loop
6E5C B7          4 47 or      a                           ; is it the first char?
6E5D 20 21       4 48 jr      nz, Input_Numbers           ; no, perform input of 2nd char
6E5F             4 50 ; restrict first char to 'a'-'g'
6E5F 08          4 52 ex      af, af'                     ; restore char
6E60 FE 61       4 53 cp      'a'                         ; is it < 'a'?
6E62 38 E8       4 54 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E64 FE 68       4 55 cp      'h'                         ; is it >= 'g'?
6E66 30 E4       4 56 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E68             4 58 ; char is valid as column
6E68 32 16 62    4 60 ld      (STR_MOVE+0), a             ; save char in player move
6E6B DD 36 00 47 4 61 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E6F CD 65 6F    4 62 call    Print_Char                  ; print key pressed
6E72 0C          4 63 inc     c                           ; increment chars counter
6E73 2C          4 64 inc     l                           ; increment X position of current input screen location
6E74 DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E76 3E 2D       4 66 ld      a, '-'                      ; set dash char
6E78 CD 65 6F    4 67 call    Print_Char                  ; print key pressed
6E7B 2C          4 68 inc     l                           ; increment X position of current input screen location
6E7C DD 2C       4 69 inc     ixl                         ; increment X position of current input attr location
6E7E 18 C3       4 70 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E80             4 71 Input_Numbers
6E80             4 72 ; restrict second char to '1'-'7'
6E80 08          4 74 ex      af, af'                     ; restore char
6E81 FE 31       4 75 cp      '1'                         ; is it < '1'?
6E83 38 C7       4 76 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E85 FE 38       4 77 cp      '8'                         ; is it >= '8'?
6E87 30 C3       4 78 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E89             4 80 ; char is valid as row
6E89 32 19 62    4 82 ld      (STR_MOVE+3), a             ; save char in player move
6E8C DD 36 00 47 4 83 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E90 CD 65 6F    4 84 call    Print_Char                  ; print key pressed
6E93 0C          4 85 inc     c                           ; increment chars counter
6E94 2C          4 86 inc     l                           ; increment X position of current input screen location
6E95 DD 2C       4 87 inc     ixl                         ; increment X position of current input attr location
6E97 18 AA       4 88 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E99             4 90 ; player pressed "delete" (char '0')
6E99             4 91 Input_Delete
6E99 79          4 92 ld      a, c                        ; get char counter
6E9A B7          4 93 or      a                           ; is it 0?
6E9B 28 AF       4 94 jr      z, Input_Loop               ; repeat input loop (no chars to delete)
6E9D DD 36 00 47 4 96 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EA1 B8          4 97 cp      b                           ; is it the first char?
6EA2 28 08       4 98 jr      z, Input_Delete_Char        ; yes, continue delete
6EA4 3E 20       4 99 ld      a, ' '                      ; empty char
6EA6 CD 65 6F    4 100 call    Print_Char                  ; delete cursor and last char
6EA9 2D          4 101 dec     l                           ; decrement X position of input screen location
6EAA DD 2D       4 102 dec     ixl                         ; decrement X position of input attr location
6EAC             4 103 Input_Delete_Char
6EAC 0D          4 104 dec     c                           ; decrement char counter
6EAD 3E 20       4 105 ld      a, ' '                      ; empty char
6EAF CD 65 6F    4 106 call    Print_Char                  ; delete cursor and last char
6EB2 2D          4 107 dec     l                           ; decrement X position of player input screen location
6EB3 DD 2D       4 108 dec     ixl                         ; decrement X position of player input attr location
6EB5 18 8C       4 109 jr      Input_Start                 ; get next char
6EB7             4 111 ; player pressed ENTER
6EB7             4 112 Input_Enter
6EB7 79          4 113 ld      a, c                        ; check char counter  
6EB8 B8          4 114 cp      b                           ; is it < MAX_CHARS?
6EB9 38 91       4 115 jr      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EBB DD 36 00 47 4 117 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EBF 3E 20       4 118 ld      a, ' '                      ; empty char
6EC1 CD 65 6F    4 119 call    Print_Char                  ; delete cursor
6EC4 C9          4 120 ret
6EC5             4 122 ; ----------------------------------------------------------------------------------------------------------------------
6EC5             4 123 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EC5             4 124 ;
6EC5             4 125 ;                           Bit
6EC5             4 126 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EC5             4 127 ;  ------+-------+-------+-------+-------+-------+
6EC5             4 128 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EC5             4 129 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EC5             4 130 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EC5             4 131 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EC5             4 132 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EC5             4 133 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EC5             4 134 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EC5             4 135 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EC5             4 136 ;
6EC5             4 137 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EC5             4 138 ;
6EC5             4 139 ; Input:    -
6EC5             4 140 ;
6EC5             4 141 ; Output:   A = ASCII code of key pressed
6EC5             4 142 ;
6EC5             4 143 ; Destroys: DE
6EC5             4 144 ; ----------------------------------------------------------------------------------------------------------------------
6EC5             4 145 Input_Key_Scan:
6EC5 C5          4 146 push    bc                          ; store registers
6EC6 E5          4 147 push    hl
6EC7             4 148 Input_Key_Released
6EC7 01 FE FE    4 149 ld      bc, $FEFE                   ; set keyboard port (see above)
6ECA             4 150 Input_Key_Released_Line
6ECA ED 78       4 151 in      a, (c)                      ; read port
6ECC 2F          4 152 cpl                                 ; invert bits
6ECD E6 1F       4 153 and     %00011111                   ; check 0 to 4 bits
6ECF 20 F6       4 154 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6ED1 CB 00       4 155 rlc     b                           ; move BC to the next port
6ED3 38 F5       4 156 jr      c, Input_Key_Released_Line  ; repeat for each port
6ED5 11 05 00    4 157 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6ED8             4 158 Input_Key_Pressed_Begin
6ED8 21 D8 61    4 159 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6EDB             4 160 Input_Key_Pressed_Line
6EDB ED 78       4 161 in      a, (c)                      ; read port
6EDD 2F          4 162 cpl                                 ; invert bits
6EDE E6 1F       4 163 and     %00011111                   ; check 0 to 4 bits
6EE0 20 08       4 164 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6EE2 19          4 165 add     hl, de                      ; HL points to the next KEY_MAP block
6EE3 CB 00       4 166 rlc     b                           ; move BC to the next port
6EE5 38 F4       4 167 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6EE7 18 EF       4 168 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6EE9             4 169 Input_Key_Next
6EE9 23          4 170 inc     hl                          ; move HL to the next character
6EEA             4 171 Input_Key_Pressed
6EEA 1F          4 172 rra                                 ; rotate bits of port readed
6EEB 30 FC       4 173 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6EED 7E          4 174 ld      a, (hl)                     ; return key pressed (ASCII) in A
6EEE E1          4 175 pop     hl                          ; restore registers
6EEF C1          4 176 pop     bc
6EF0 C9          4 177 ret

; File #5: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Print.z80asm

6EF1             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6EF1             5 2 ; Print.z80asm
6EF1             5 3 ; Coded by Antonio Luque
6EF1             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6EF1             5 6 CHAR_SET                equ     FONT-256                    ; address of character set data, adjusted for ASCII codes
6EF1             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6EF1             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6EF1             5 10 ;
6EF1             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6EF1             5 12 ;
6EF1             5 13 ; Output:   -
6EF1             5 14 ;
6EF1             5 15 ; Destroys: A, BC, DE, HL
6EF1             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6EF1             5 17 Print_Players:
6EF1 11 22 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6EF4 01 1B 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6EF7 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6EFA FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6EFC 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6EFE 11 1B 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6F01 01 22 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6F04             5 25 Print_Players_Strings
6F04 CD 59 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6F07 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F08 59          5 28 ld      e, c
6F09 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F0C 18 4B       5 30 jr      Print_String                ; print "Player" or "Speccy"
6F0E             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F0E             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F0E             5 34 ;
6F0E             5 35 ; Input:    -
6F0E             5 36 ; Output:   -
6F0E             5 37 ; Destroys: A, BC, DE, HL, IX
6F0E             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F0E             5 39 Print_Clear_Alert:
6F0E 11 47 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F11 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F13 18 02       5 42 jr      Print_Alert_XY              ; print (clear) alert string
6F15             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F15             5 45 ; Print_Alert: print an alert message below the current player input move
6F15             5 46 ;
6F15             5 47 ; Input:    DE = alert message string address
6F15             5 48 ;
6F15             5 49 ; Output:   -
6F15             5 50 ;
6F15             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F15             5 52 ;
6F15             5 53 ; Destroys: A, BC, DE, HL, IX
6F15             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F15             5 55 Print_Alert:
6F15 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F17             5 57 Print_Alert_XY
6F17 DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F1B 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F1E 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F21 FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F23 28 31       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F25 DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F29 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F2C 18 28       5 65 jr      Print_String_Color          ; print alert string with color
6F2E             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F2E             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F2E             5 69 ;
6F2E             5 70 ; Input:    -
6F2E             5 71 ;
6F2E             5 72 ; Output:   -
6F2E             5 73 ;
6F2E             5 74 ; Destroys: A, BC, DE, HL, IX
6F2E             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F2E             5 76 Print_Wait:
6F2E 11 36 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F31 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F33 18 0C       5 79 jr      Print_Move_XY               ; print wait string
6F35             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F35             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F35             5 83 ;
6F35             5 84 ; Input:    -
6F35             5 85 ;
6F35             5 86 ; Output:   -
6F35             5 87 ;
6F35             5 88 ; Destroys: A, BC, DE, HL, IX
6F35             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F35             5 90 Print_Clear_Move:
6F35 11 42 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F38 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F3A 18 05       5 93 jr      Print_Move_XY               ; print (clear) move string
6F3C             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F3C             5 96 ; Print_Move: print a formatted move at current player input move location 
6F3C             5 97 ;
6F3C             5 98 ; Input:    -
6F3C             5 99 ;
6F3C             5 100 ; Output:   -
6F3C             5 101 ;
6F3C             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F3C             5 103 ;
6F3C             5 104 ; Destroys: A, BC, DE, HL, IX
6F3C             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F3C             5 106 Print_Move:
6F3C 11 16 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F3F 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F41             5 109 Print_Move_XY
6F41 DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F45 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F48 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F4B FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F4D 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F4F DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F53 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F56             5 117 Print_String_Color
6F56 CD 6B 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F59             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F59             5 120 ; Print_String: print a string on the screen
6F59             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F59             5 122 ;
6F59             5 123 ; Input:    DE = string address (ending with 0)
6F59             5 124 ;           HL = string screen address
6F59             5 125 ;
6F59             5 126 ; Output:   -
6F59             5 127 ;
6F59             5 128 ; Destroys: A, DE, HL
6F59             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F59             5 130 Print_String:
6F59 1A          5 131 ld      a, (de)                     ; get string character
6F5A B7          5 132 or      a                           ; is it 0? (end of string)
6F5B C8          5 133 ret     z                           ; yes, return
6F5C D5          5 134 push    de                          ; store pointer to string address
6F5D CD 65 6F    5 135 call    Print_Char                  ; print character
6F60 D1          5 136 pop     de                          ; restore pointer to string address
6F61 13          5 137 inc     de                          ; move DE to next string character
6F62 2C          5 138 inc     l                           ; move HL to next screen column
6F63 18 F4       5 139 jr      Print_String                ; repeat until end of string
6F65             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F65             5 142 ; Print_Char: print a character on the screen
6F65             5 143 ;
6F65             5 144 ; Input:    A  = character to print (ASCII)
6F65             5 145 ;           HL = character screen address
6F65             5 146 ;
6F65             5 147 ; Output:   -
6F65             5 148 ;
6F65             5 149 ; Destroys: A, DE
6F65             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F65             5 151 Print_Char:
6F65 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F68             5 153 Print_Tile:
6F68 E5          5 154 push    hl                          ; store pointer to character/tile screen address
6F69 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F6B 6F          5 156 ld      l, a
6F6C 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6F6D 29          5 158 add     hl, hl
6F6E 29          5 159 add     hl, hl
6F6F 19          5 160 add     hl, de                      ; move HL to character/tile address
6F70 EB          5 161 ex      de, hl                      ; DE points to character/tile address
6F71 E1          5 162 pop     hl                          ; restore pointer to character/tile screen address
6F72 C5          5 163 push    bc                          ; store BC register
6F73 4C          5 164 ld      c, h                        ; save high byte of character/tile screen address
6F74 06 08       5 165 ld      b, 8                        ; number of character/tile bytes (loop counter)
6F76             5 166 Print_Tile_Pixels
6F76 1A          5 167 ld      a, (de)                     ; get character/tile byte
6F77 77          5 168 ld      (hl), a                     ; put character/tile byte on screen
6F78 13          5 169 inc     de                          ; move DE to next character/tile byte
6F79 24          5 170 inc     h                           ; move HL down one pixel-line
6F7A 10 FA       5 171 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6F7C 61          5 172 ld      h, c                        ; restore high byte of character/tile screen address
6F7D C1          5 173 pop     bc                          ; restore BC register
6F7E C9          5 174 ret

; File #6: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Brainiac.z80asm

6F7F             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6F7F             6 2 ; Brainiac.z80asm
6F7F             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F7F             6 4 ;
6F7F             6 5 ; Adapted for Hex game by Einar Saukas
6F7F             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6F7F             6 8 MIN_VALUE               equ     0                           ; alphaBeta pruning minimum value
6F7F             6 9 MAX_VALUE               equ     255                         ; alphaBeta pruning maximum value
6F7F             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6F7F             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6F7F             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6F7F             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6F7F             6 15 ; depth.
6F7F             6 16 ;
6F7F             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F7F             6 18 ;
6F7F             6 19 ; Input:    A  = speccy side (FRIEND or ENEMY)
6F7F             6 20 ;           IX = candidates vector address
6F7F             6 21 ;
6F7F             6 22 ; Output:   E  = selected position (speccy move)
6F7F             6 23 ;
6F7F             6 24 ; Uses:     AI_PLAYER (speccy side)
6F7F             6 25 ;           AI_DEPTH (recursion depth level)
6F7F             6 26 ;
6F7F             6 27 ; Destroys: A, A', BC, D, HL, IX, IY
6F7F             6 28 ; ----------------------------------------------------------------------------------------------------------------------
6F7F             6 29 BRAINIAC_best_move:
6F7F 32 99 61    6 30 ld      (AI_PLAYER), a              ; save speccy side
6F82 CD 7B 74    6 32 call    PathFinder_Score            ; get board score
6F85 CD 24 75    6 33 call    PathFinder_Candidates       ; get candidates from board potentials
6F88             6 35 ; BRAINIAC start
6F88             6 36 AI_First_Candidate
6F88 DD 7E 00    6 37 ld      a, (ix+0)                   ; A is our first candidate
6F8B 5F          6 39 ld      e, a                        ; E = best speccy move (initialization)
6F8C 16 00       6 40 ld      d, MIN_VALUE                ; D = alphaMax
6F8E             6 42 AI_Main_Loop                                                ; for each candidate {
6F8E D5          6 43 push    de                          ;       store alphaMax and best speccy move
6F8F 26 7D       6 45 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F91 6F          6 46 ld      l, a
6F92 E5          6 47 push    hl
6F93 3A 99 61    6 49 ld      a, (AI_PLAYER)              ;       get speccy side
6F96 CD F7 70    6 50 call    PathFinder_PutToken         ;       BRAINIAC_play
6F99 1E FF       6 51 ld      e, MAX_VALUE                ;       E = betaMin
6F9B CD B4 6F    6 52 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6F9E E1          6 54 pop     hl                          ;       restore candidate position
6F9F CD FD 70    6 55 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FA2 D1          6 57 pop     de                          ;       restore alphaMax and best player node
6FA3 BA          6 59 cp      d
6FA4 38 04       6 60 jr      c, AI_Main_Next
6FA6 28 02       6 61 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FA8 57          6 63 ld      d, a                        ;       alphaMax = A
6FA9 5D          6 64 ld      e, l                        ;       best move = E
6FAA             6 66 AI_Main_Next
6FAA DD 2D       6 67 dec     ixl
6FAC DD 7E 00    6 68 ld      a, (ix+0)                   ;       A is our next candidate
6FAF B7          6 69 or      a                           ;       repeat until no more candidates
6FB0 C2 8E 6F    6 70 jp      nz, AI_Main_Loop            ; }
6FB3 C9          6 71 ret
6FB4             6 73 ; ----------------------------------------------------------------------------------------------------------------------
6FB4             6 74 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FB4             6 75 ; Speccy's score.
6FB4             6 76 ;
6FB4             6 77 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FB4             6 78 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FB4             6 79 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FB4             6 80 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FB4             6 81 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FB4             6 82 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FB4             6 83 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FB4             6 84 ; could be just reproducing the best score from its sibling.
6FB4             6 85 ;
6FB4             6 86 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB4             6 87 ;
6FB4             6 88 ; Input:    D = alphaMax
6FB4             6 89 ;           E = betaMin
6FB4             6 90 ;
6FB4             6 91 ; Output:   A = "improved" betaMin
6FB4             6 92 ;           D = alphaMax
6FB4             6 93 ;           E = "improved" betaMin
6FB4             6 94 ;
6FB4             6 95 ; Uses:     AI_PLAYER (speccy side)
6FB4             6 96 ;           AI_DEPTH (recursion depth level)
6FB4             6 97 ;
6FB4             6 98 ; Destroys: BC, HL, IX, IY
6FB4             6 99 ; ----------------------------------------------------------------------------------------------------------------------
6FB4             6 100 Alphabeta_Min:
6FB4 D5          6 101 push    de
6FB5             6 103 ; check if last speccy move is a winner one
6FB5 CD 7B 74    6 105 call    PathFinder_Score            ; if (speccy won)
6FB8 B7          6 106 or      a
6FB9 C2 C3 6F    6 107 jp      nz, Alphabeta_Min_Candidates
6FBC 3A 9A 61    6 108 ld      a, (AI_DEPTH)
6FBF C6 C0       6 109 add     a, 192                      ;     return 192+depth
6FC1 D1          6 110 pop     de
6FC2 C9          6 111 ret
6FC3             6 113 Alphabeta_Min_Candidates
6FC3 CD 24 75    6 114 call    PathFinder_Candidates       ; find candidates for next move
6FC6 D1          6 115 pop     de
6FC7 DD 7E 00    6 117 ld      a, (ix+0)                   ; A is our first candidate
6FCA 21 9A 61    6 119 ld      hl, AI_DEPTH
6FCD 35          6 120 dec     (hl)                        ; depth--
6FCE CA 0E 70    6 121 jp      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
6FD1             6 123 Alphabeta_Min_Loop                                          ; for each candidate {
6FD1 D5          6 124 push    de                          ;       store alphaMax and betaMin
6FD2 26 7D       6 126 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FD4 6F          6 127 ld      l, a
6FD5 E5          6 128 push    hl
6FD6 3A 99 61    6 130 ld      a, (AI_PLAYER)              ;       get speccy side
6FD9 EE 7C       6 131 xor     $7C                         ;       switch to player side
6FDB CD F7 70    6 132 call    PathFinder_PutToken         ;       BRAINIAC_play
6FDE CD 52 70    6 133 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
6FE1 E1          6 135 pop     hl                          ;       restore candidate position
6FE2 CD FD 70    6 136 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FE5 D1          6 138 pop     de                          ;       restore alphaMax and betaMin
6FE6 BB          6 140 cp      e
6FE7 30 06       6 141 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
6FE9 BA          6 143 cp      d
6FEA 38 12       6 144 jr      c, Alphabeta_Min_Exit
6FEC 28 10       6 145 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FEE 5F          6 147 ld      e, a                        ;       betaMin = A
6FEF             6 149 Alphabeta_Min_Next
6FEF DD 2D       6 150 dec     ixl
6FF1 DD 7E 00    6 151 ld      a, (ix+0)                   ;       A is our next candidate
6FF4 B7          6 152 or      a                           ;       repeat until no more candidates
6FF5 C2 D1 6F    6 153 jp      nz, Alphabeta_Min_Loop      ; }
6FF8 7B          6 155 ld      a, e                        ; return betaMin
6FF9 21 9A 61    6 157 ld      hl, AI_DEPTH
6FFC 34          6 158 inc     (hl)                        ; depth++
6FFD C9          6 159 ret
6FFE             6 161 Alphabeta_Min_Exit
6FFE 5F          6 162 ld      e, a                        ; (discard remaining candidates)
6FFF AF          6 163 xor     a
7000             6 164 Alphabeta_Min_Skip
7000 DD 2D       6 165 dec     ixl
7002 DD BE 00    6 166 cp      (ix+0)
7005 C2 00 70    6 167 jp      nz, Alphabeta_Min_Skip
7008 7B          6 168 ld      a, e
7009 21 9A 61    6 170 ld      hl, AI_DEPTH
700C 34          6 171 inc     (hl)                        ; (depth++)
700D C9          6 172 ret
700E             6 174 ; ----------------------------------------------------------------------------------------------------------------------
700E             6 175 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
700E             6 176 ; beta pruning, when it requires MINIMIZING Speccy's score.
700E             6 177 ;
700E             6 178 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
700E             6 179 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
700E             6 180 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
700E             6 181 ; faster.
700E             6 182 ;
700E             6 183 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
700E             6 184 ;
700E             6 185 ; Input:    A = first candidate
700E             6 186 ;           D = alphaMax
700E             6 187 ;           E = betaMin
700E             6 188 ;
700E             6 189 ; Output:   A = "improved" betaMin
700E             6 190 ;           D = alphaMax
700E             6 191 ;           E = "improved" betaMin
700E             6 192 ;
700E             6 193 ; Uses:     AI_PLAYER (speccy side)
700E             6 194 ;           AI_DEPTH (recursion depth level)
700E             6 195 ;
700E             6 196 ; Destroys: BC, HL, IX, IY
700E             6 197 ; ----------------------------------------------------------------------------------------------------------------------
700E             6 198 Heuristic_Min:                                              ; for each candidate {
700E D5          6 199 push    de                          ;       store alphaMax and betaMin
700F 26 7D       6 201 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7011 6F          6 202 ld      l, a
7012 E5          6 203 push    hl
7013 3A 99 61    6 205 ld      a, (AI_PLAYER)              ;       get speccy side
7016 EE 7C       6 206 xor     $7C                         ;       switch to player side
7018 CD F7 70    6 207 call    PathFinder_PutToken         ;       BRAINIAC_play
701B CD 7B 74    6 209 call    PathFinder_Score            ;       if (player won)
701E FE FF       6 210 cp      -1
7020 C2 25 70    6 211 jp      nz, Heuristic_Min_Continue
7023 3E 40       6 212 ld      a, 64                       ;           A = 64
7025             6 213 Heuristic_Min_Continue
7025 E1          6 214 pop     hl
7026 CD FD 70    6 215 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7029 D1          6 217 pop     de
702A BB          6 219 cp      e
702B 30 06       6 220 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
702D BA          6 222 cp      d
702E 38 12       6 223 jr      c, Heuristic_Min_Exit
7030 28 10       6 224 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
7032 5F          6 226 ld      e, a                        ;       betaMin = A
7033             6 228 Heuristic_Min_Next
7033 DD 2D       6 229 dec     ixl
7035 DD 7E 00    6 230 ld      a, (ix+0)                   ;       A is our next candidate
7038 B7          6 231 or      a                           ;       repeat until no more candidates
7039 C2 0E 70    6 232 jp      nz, Heuristic_Min           ; }
703C 7B          6 234 ld      a, e                        ; return betaMin
703D 21 9A 61    6 236 ld      hl, AI_DEPTH
7040 34          6 237 inc     (hl)                        ; depth++
7041 C9          6 238 ret
7042             6 240 Heuristic_Min_Exit
7042 5F          6 241 ld      e, a                        ; (discard remaining candidates)
7043 AF          6 242 xor     a
7044             6 243 Heuristic_Min_Skip
7044 DD 2D       6 244 dec     ixl
7046 DD BE 00    6 245 cp      (ix+0)
7049 C2 44 70    6 246 jp      nz, Heuristic_Min_Skip
704C 7B          6 247 ld      a, e
704D 21 9A 61    6 249 ld      hl, AI_DEPTH
7050 34          6 250 inc     (hl)                        ; (depth++)
7051 C9          6 251 ret
7052             6 253 ; ----------------------------------------------------------------------------------------------------------------------
7052             6 254 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
7052             6 255 ; Speccy's score.
7052             6 256 ;
7052             6 257 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
7052             6 258 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
7052             6 259 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
7052             6 260 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
7052             6 261 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
7052             6 262 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
7052             6 263 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
7052             6 264 ; the same score and could be just reproducing the best score from its sibling.
7052             6 265 ;
7052             6 266 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7052             6 267 ;
7052             6 268 ; Input:    D = alphaMax
7052             6 269 ;           E = betaMin
7052             6 270 ;
7052             6 271 ; Output:   A = "improved" alphaMax
7052             6 272 ;           D = "improved" alphaMax
7052             6 273 ;           E = betaMin
7052             6 274 ;
7052             6 275 ; Uses:     AI_PLAYER (speccy side)
7052             6 276 ;           AI_DEPTH (recursion depth level)
7052             6 277 ;
7052             6 278 ; Destroys: BC, HL, IX, IY
7052             6 279 ; ----------------------------------------------------------------------------------------------------------------------
7052             6 280 Alphabeta_Max:
7052 D5          6 281 push    de
7053             6 283 ; check if last player move is a winner one
7053 CD 7B 74    6 285 call    PathFinder_Score            ; if (player won)
7056 FE FF       6 286 cp      -1
7058 C2 63 70    6 287 jp      nz, Alphabeta_Max_Candidates
705B 3A 9A 61    6 288 ld      a, (AI_DEPTH)
705E 2F          6 289 cpl
705F C6 41       6 290 add     a, 64+1                     ;     return 64-depth
7061 D1          6 291 pop     de
7062 C9          6 292 ret
7063             6 294 Alphabeta_Max_Candidates
7063 CD 24 75    6 295 call    PathFinder_Candidates       ; find candidates for next move
7066 D1          6 296 pop     de
7067 DD 7E 00    6 298 ld      a, (ix+0)                   ; A is our first candidate
706A 21 9A 61    6 300 ld      hl, AI_DEPTH
706D 35          6 301 dec     (hl)                        ; depth--
706E CA AC 70    6 302 jp      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
7071             6 304 Alphabeta_Max_Loop                                          ; for each candidate {
7071 D5          6 305 push    de                          ;       store alphaMax and betaMin
7072 26 7D       6 307 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7074 6F          6 308 ld      l, a
7075 E5          6 309 push    hl
7076 3A 99 61    6 311 ld      a, (AI_PLAYER)              ;       get speccy side
7079 CD F7 70    6 312 call    PathFinder_PutToken         ;       BRAINIAC_play
707C CD B4 6F    6 313 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
707F E1          6 315 pop     hl                          ;       restore candidate position
7080 CD FD 70    6 316 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7083 D1          6 318 pop     de                          ;       restore alphaMax and betaMin
7084 BA          6 320 cp      d
7085 38 06       6 321 jr      c, Alphabeta_Max_Next
7087 28 04       6 322 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
7089 BB          6 324 cp      e
708A 30 10       6 325 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
708C 57          6 327 ld      d, a                        ;       alphaMax = A
708D             6 329 Alphabeta_Max_Next
708D DD 2D       6 330 dec     ixl
708F DD 7E 00    6 331 ld      a, (ix+0)                   ;       A is our next candidate
7092 B7          6 332 or      a                           ;       repeat until no more candidates
7093 C2 71 70    6 333 jp      nz, Alphabeta_Max_Loop      ; }
7096 7A          6 335 ld      a, d                        ; return alphaMax
7097 21 9A 61    6 337 ld      hl, AI_DEPTH
709A 34          6 338 inc     (hl)                        ; depth++
709B C9          6 339 ret
709C             6 341 Alphabeta_Max_Exit
709C 57          6 342 ld      d, a                        ; (discard remaining candidates)
709D AF          6 343 xor     a
709E             6 344 Alphabeta_Max_Skip
709E DD 2D       6 345 dec     ixl
70A0 DD BE 00    6 346 cp      (ix+0)
70A3 C2 9E 70    6 347 jp      nz, Alphabeta_Max_Skip
70A6 7A          6 348 ld      a, d
70A7 21 9A 61    6 350 ld      hl, AI_DEPTH
70AA 34          6 351 inc     (hl)                        ; (depth++)
70AB C9          6 352 ret
70AC             6 354 ; ----------------------------------------------------------------------------------------------------------------------
70AC             6 355 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70AC             6 356 ; beta pruning, when it requires MAXIMIZING Speccy's score.
70AC             6 357 ;
70AC             6 358 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70AC             6 359 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70AC             6 360 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70AC             6 361 ; faster.
70AC             6 362 ;
70AC             6 363 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70AC             6 364 ;
70AC             6 365 ; Input:    A = first candidate
70AC             6 366 ;           D = alphaMax
70AC             6 367 ;           E = betaMin
70AC             6 368 ;
70AC             6 369 ; Returns:  A = "improved" alphaMax
70AC             6 370 ;           D = "improved" alphaMax
70AC             6 371 ;           E = betaMin
70AC             6 372 ;
70AC             6 373 ; Uses:     AI_PLAYER (speccy side)
70AC             6 374 ;           AI_DEPTH (recursion depth level)
70AC             6 375 ;
70AC             6 376 ; Destroys: BC, HL, IX, IY
70AC             6 377 ; ----------------------------------------------------------------------------------------------------------------------
70AC             6 378 Heuristic_Max:                                              ; for each candidate {
70AC D5          6 379 push    de                          ;       store alphaMax and betaMin
70AD 26 7D       6 381 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70AF 6F          6 382 ld      l, a
70B0 E5          6 383 push    hl
70B1 3A 99 61    6 385 ld      a, (AI_PLAYER)              ;       get speccy side
70B4 CD F7 70    6 386 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70B7 CD 7B 74    6 388 call    PathFinder_Score            ;       if (speccy won)
70BA B7          6 389 or      a
70BB C2 C0 70    6 390 jp      nz, Heuristic_Max_Continue
70BE 3E C0       6 391 ld      a, 192                      ;           A = 192
70C0             6 392 Heuristic_Max_Continue
70C0 E1          6 393 pop     hl                          ;       restore candidate position
70C1 CD FD 70    6 394 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70C4 D1          6 396 pop     de                          ;       restore alphaMax and betaMin
70C5 BA          6 398 cp      d
70C6 38 06       6 399 jr      c, Heuristic_Max_Next
70C8 28 04       6 400 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
70CA BB          6 402 cp      e
70CB 30 10       6 403 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70CD 57          6 405 ld      d, a                        ;       alphaMax = A
70CE             6 407 Heuristic_Max_Next
70CE DD 2D       6 408 dec     ixl
70D0 DD 7E 00    6 409 ld      a, (ix+0)                   ;       A is our next candidate
70D3 B7          6 410 or      a                           ;       repeat until no more candidates
70D4 C2 AC 70    6 411 jp      nz, Heuristic_Max           ; }
70D7 7A          6 413 ld      a, d                        ; return alphaMax
70D8 21 9A 61    6 415 ld      hl, AI_DEPTH
70DB 34          6 416 inc     (hl)                        ; depth++
70DC C9          6 417 ret
70DD             6 419 Heuristic_Max_Exit
70DD 57          6 420 ld      d, a                        ; (discard remaining candidates)
70DE AF          6 421 xor     a
70DF             6 422 Heuristic_Max_Skip
70DF DD 2D       6 423 dec     ixl
70E1 DD BE 00    6 424 cp      (ix+0)
70E4 C2 DF 70    6 425 jp      nz, Heuristic_Max_Skip
70E7 7A          6 426 ld      a, d
70E8 21 9A 61    6 428 ld      hl, AI_DEPTH
70EB 34          6 429 inc     (hl)                        ; (depth++)
70EC C9          6 430 ret

; File #7: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\PathFinder.z80asm

70ED             7 1 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 2 ; PathFinder.z80asm
70ED             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
70ED             7 4 ;
70ED             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
70ED             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
70ED             7 7 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 9 CYAN                    equ     $01                         ; cyan side
70ED             7 10 RED                     equ     $02                         ; red side
70ED             7 11 WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor
70ED             7 12 EMPTY                   equ     $00                         ; empty positions on the board
70ED             7 13 SKIPPED                 equ     $01                         ; skipped positions on the board
70ED             7 14 FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
70ED             7 15 VICTORY                 equ     $03                         ; internal value if victory
70ED             7 16 ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
70ED             7 18 CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
70ED             7 19 RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
70ED             7 20 CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates
70ED             7 22 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 23 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
70ED             7 24 ;
70ED             7 25 ; Input:    -
70ED             7 26 ;
70ED             7 27 ; Output:   A = FRIEND, if current token color is cyan
70ED             7 28 ;           A = ENEMY, if current token color is red
70ED             7 29 ;
70ED             7 30 ; Uses:     TOKEN_COLOR (current token color)
70ED             7 31 ;
70ED             7 32 ; Destroys: -
70ED             7 33 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 34 PathFinder_Friend:
70ED 3A 9E 61    7 35 ld      a, (TOKEN_COLOR)            ; get current player color
70F0 1F          7 36 rra                                 ; is current player color cyan?
70F1 3E 02       7 37 ld      a, FRIEND                   ; set FRIEND in A
70F3 D8          7 38 ret     c                           ; yes, return FRIEND 
70F4 EE 7C       7 39 xor     $7C                         ; no, return ENEMY
70F6 C9          7 40 ret
70F7             7 42 ; ----------------------------------------------------------------------------------------------------------------------
70F7             7 43 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
70F7             7 44 ;
70F7             7 45 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
70F7             7 46 ;           HL = CYAN_POSITIONS token address
70F7             7 47 ;
70F7             7 48 ; Output:   -
70F7             7 49 ;
70F7             7 50 ; Destroys: -
70F7             7 51 ; ----------------------------------------------------------------------------------------------------------------------
70F7             7 52 PathFinder_PutToken:
70F7 77          7 53 ld      (hl), a                     ; put token at cyan position
70F8 24          7 54 inc     h                           ; move HL to red position address
70F9 EE 7C       7 55 xor     $7C                         ; invert side
70FB 77          7 56 ld      (hl), a                     ; put token at red position
70FC C9          7 57 ret
70FD             7 59 ; ----------------------------------------------------------------------------------------------------------------------
70FD             7 60 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
70FD             7 61 ;
70FD             7 62 ; Input:    HL = CYAN_POSITIONS token address
70FD             7 63 ;
70FD             7 64 ; Output:   -
70FD             7 65 ;
70FD             7 66 ; Destroys: -
70FD             7 67 ; ----------------------------------------------------------------------------------------------------------------------
70FD             7 68 PathFinder_EraseToken:
70FD 36 00       7 69 ld      (hl), EMPTY                 ; erase token at cyan position
70FF 24          7 70 inc     h                           ; move HL to red position address
7100 36 00       7 71 ld      (hl), EMPTY                 ; erase token at red position
7102 C9          7 72 ret
7103             7 74 ; ----------------------------------------------------------------------------------------------------------------------
7103             7 75 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
7103             7 76 ;
7103             7 77 ; Input:    DE = cyan or red board address (destiny)
7103             7 78 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
7103             7 79 ;
7103             7 80 ; Output:   -
7103             7 81 ;
7103             7 82 ; Destroys: BC, DE, HL
7103             7 83 ; ----------------------------------------------------------------------------------------------------------------------
7103             7 84 PathFinder_CopyPositions:
7103 01 31 00    7 85 ld      bc, 7*7                     ; number of positions to be copied
7106             7 86 PathFinder_CopyLoop
7106 2C          7 87 inc     l                           ; skip borders on positions
7107 2C          7 88 inc     l
7108 1C          7 89 inc     e                           ; skip borders on board
7109 1C          7 90 inc     e
710A ED A0       7 91 ldi                                 ; copy a row of 7 positions
710C ED A0       7 92 ldi
710E ED A0       7 93 ldi
7110 ED A0       7 94 ldi
7112 ED A0       7 95 ldi
7114 ED A0       7 96 ldi
7116 ED A0       7 97 ldi
7118 EA 06 71    7 98 jp      pe, PathFinder_CopyLoop     ; repeat for each row
711B C9          7 99 ret
711C             7 101 ; ----------------------------------------------------------------------------------------------------------------------
711C             7 102 ; PathFinder_Update: update current board position during heuristic function evaluation
711C             7 103 ;
711C             7 104 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
711C             7 105 ; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
711C             7 106 ; adjacent".
711C             7 107 ;
711C             7 108 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
711C             7 109 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
711C             7 110 ; follows, depending on current content:
711C             7 111 ;
711C             7 112 ; * SKIPPED: 1 + distance of neighbor closest to goal
711C             7 113 ; * FRIEND:  distance of neighbor closest to goal
711C             7 114 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
711C             7 115 ;
711C             7 116 ; Input:    Z  = flag set when (HL) is FRIEND
711C             7 117 ;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
711C             7 118 ;           HL = current position address (on either cyan boards or red boards)
711C             7 119 ;
711C             7 120 ; Output:   -
711C             7 121 ;
711C             7 122 ; Destroys: B, DE
711C             7 123 ; ----------------------------------------------------------------------------------------------------------------------
711C             7 124 PathFinder_Update:
711C 28 12       7 125 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
711E 46          7 126 ld      b, (hl)                     ; check current position
711F 10 1A       7 127 djnz    PathFinder_EMPTY
7121             7 128 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
7121             7 129 PathFinder_Skipped:
7121 71          7 130 ld      (hl), c                     ; save current distance in current position
7122 34          7 131 inc     (hl)                        ; increment distance of current position
7123 CB B6       7 132 res     6, (hl)                     ; reset friendly token flag
7125 EB          7 133 ex      de, hl                      ; store current position in DE
7126             7 134 @Queue_Tail
7126 21 00 00    7 135 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
7129 2C          7 136 inc     l                           ; move queue tail down
712A 73          7 137 ld      (hl), e                     ; store position into queue tail
712B 22 27 71    7 138 ld      (@Queue_Tail+1), hl         ; update queue tail
712E EB          7 139 ex      de, hl                      ; restore current position
712F C9          7 140 ret
7130             7 141 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
7130             7 142 PathFinder_Friendly
7130 71          7 143 ld      (hl), c                     ; save current distance in current position
7131 CB F6       7 144 set     6, (hl)                     ; set friendly token flag
7133 45          7 145 ld      b, l                        ; save current position in B
7134 D1          7 146 pop     de                          ; preserve RET address
7135 E3          7 147 ex      (sp), hl                    ; retrieve queue head
7136 70          7 148 ld      (hl), b                     ; push this position into queue head
7137 2D          7 149 dec     l                           ; move queue head up
7138 E3          7 150 ex      (sp), hl                    ; update queue head
7139 D5          7 151 push    de                          ; restore RET address
713A C9          7 152 ret
713B             7 153 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
713B             7 154 PathFinder_EMPTY
713B CB 71       7 155 bit     6, c                        ; is current distance friendly?
713D 20 E2       7 156 jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
713F 34          7 157 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
7140 C9          7 158 ret
7141             7 160 ; ----------------------------------------------------------------------------------------------------------------------
7141             7 161 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7141             7 162 ;
7141             7 163 ; Input:    -
7141             7 164 ;
7141             7 165 ; Output:   A = -1, if down edge couldn't be reached
7141             7 166 ;           A =  0, if there is chain of connected cyan tokens between the two edges
7141             7 167 ;           A = last edge position visited (-1), otherwise
7141             7 168 ;
7141             7 169 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7141             7 170 ;
7141             7 171 ; Destroys: BC, DE, HL, IY
7141             7 172 ; ----------------------------------------------------------------------------------------------------------------------
7141             7 173 PathFinder_Cyan_UpDown:
7141 21 07 7D    7 174 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7144 11 07 61    7 175 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
7147 CD 03 71    7 176 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
714A             7 178 ; entry point for PathFinder_VictoryPath
714A             7 179 PathFinder_Cyan_CheckPath:
714A FD 21 00 09 7 180 ld      iy, $0900                   ; IYH = distance to check edge positions
714E             7 181 ; IYL = last edge position visited
714E 21 00 60    7 182 ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
7151 22 27 71    7 183 ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
7154 E5          7 184 push    hl                          ; store cyan queue head
7155             7 186 ; set up cyan board (up-down) start positions distances
7155 21 09 61    7 188 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7158 0E 43       7 189 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
715A 3E 02       7 190 ld      a, FRIEND                   ; set distance to compare with
715C BE          7 191 cp      (hl)                        ; check 1st start position distance
715D D4 1C 71    7 192 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7160 2C          7 193 inc     l                           ; move HL to next start position address
7161 BE          7 194 cp      (hl)                        ; check 2nd start position distance
7162 D4 1C 71    7 195 call    nc, PathFinder_Update       ; (repeat for each start position)
7165 2C          7 196 inc     l
7166 BE          7 197 cp      (hl)                        ; check 3rd start position distance
7167 D4 1C 71    7 198 call    nc, PathFinder_Update
716A 2C          7 199 inc     l
716B BE          7 200 cp      (hl)                        ; check 4th start position distance
716C D4 1C 71    7 201 call    nc, PathFinder_Update
716F 2C          7 202 inc     l
7170 BE          7 203 cp      (hl)                        ; check 5th start position distance
7171 D4 1C 71    7 204 call    nc, PathFinder_Update
7174 2C          7 205 inc     l
7175 BE          7 206 cp      (hl)                        ; check 6th start position distance
7176 D4 1C 71    7 207 call    nc, PathFinder_Update
7179 2C          7 208 inc     l
717A C3 67 72    7 209 jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)
717D             7 211 ; ----------------------------------------------------------------------------------------------------------------------
717D             7 212 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
717D             7 213 ;
717D             7 214 ; Input:    -
717D             7 215 ;
717D             7 216 ; Output:   A = -1, if up edge couldn't be reached
717D             7 217 ;           A =  0, if there is chain of connected cyan tokens between the two edges
717D             7 218 ;           A = last edge position visited (-1), otherwise
717D             7 219 ;
717D             7 220 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
717D             7 221 ;
717D             7 222 ; Destroys: BC, DE, HL, IY
717D             7 223 ; ----------------------------------------------------------------------------------------------------------------------
717D             7 224 PathFinder_Cyan_DownUp:
717D 21 07 7D    7 225 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7180 11 4F 61    7 226 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
7183 CD 03 71    7 227 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
7186 FD 21 00 F7 7 229 ld      iy, $F700                   ; IYH = distance to check edge positions
718A             7 230 ; IYL = last edge position visited
718A 2A 27 71    7 231 ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
718D E5          7 232 push    hl                          ; initialize cyan queue head
718E             7 234 ; set up cyan board (down-up) start positions distances
718E EB          7 236 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
718F 2D          7 237 dec     l                           ; move HL to cyan boad down-up address (last position)
7190 0E 43       7 238 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7192 3E 02       7 239 ld      a, FRIEND                   ; set distance to compare with
7194 BE          7 240 cp      (hl)                        ; check 1st start position distance
7195 D4 1C 71    7 241 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7198 2D          7 242 dec     l                           ; move HL to next start position address
7199 BE          7 243 cp      (hl)                        ; check 2nd start position distance
719A D4 1C 71    7 244 call    nc, PathFinder_Update       ; (repeat for each start position)
719D 2D          7 245 dec     l
719E BE          7 246 cp      (hl)                        ; check 3rd start position distance
719F D4 1C 71    7 247 call    nc, PathFinder_Update
71A2 2D          7 248 dec     l
71A3 BE          7 249 cp      (hl)                        ; check 4th start position distance
71A4 D4 1C 71    7 250 call    nc, PathFinder_Update
71A7 2D          7 251 dec     l
71A8 BE          7 252 cp      (hl)                        ; check 5th start position distance
71A9 D4 1C 71    7 253 call    nc, PathFinder_Update
71AC 2D          7 254 dec     l
71AD BE          7 255 cp      (hl)                        ; check 6th start position distance
71AE D4 1C 71    7 256 call    nc, PathFinder_Update
71B1 2D          7 257 dec     l
71B2 C3 67 72    7 258 jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)
71B5             7 260 ; ----------------------------------------------------------------------------------------------------------------------
71B5             7 261 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71B5             7 262 ;
71B5             7 263 ; Input:    -
71B5             7 264 ;
71B5             7 265 ; Output:   A = -1, if right edge couldn't be reached
71B5             7 266 ;           A =  0, if there is chain of connected cyan tokens between the two edges
71B5             7 267 ;           A = last edge position visited (-1), otherwise
71B5             7 268 ;
71B5             7 269 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71B5             7 270 ;
71B5             7 271 ; Destroys: BC, DE, HL, IY
71B5             7 272 ; ----------------------------------------------------------------------------------------------------------------------
71B5             7 273 PathFinder_Red_LeftRight:
71B5 21 07 7E    7 274 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71B8 11 07 64    7 275 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71BB CD 03 71    7 276 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71BE             7 278 ; entry point for PathFinder_VictoryPath
71BE             7 279 PathFinder_Red_CheckPath
71BE FD 21 00 01 7 280 ld      iy, $0100                   ; IYH = distance to check edge positions
71C2             7 281 ; IYL = last edge position visited
71C2 21 00 63    7 282 ld      hl, RED_QUEUE_AREA          ; HL points to red queue area address
71C5 22 27 71    7 283 ld      (@Queue_Tail+1), hl         ; initialize red queue tail
71C8 E5          7 284 push    hl                          ; store red queue head
71C9             7 286 ; set up red board (left-right) start positions distances
71C9 21 09 64    7 288 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
71CC 0E 43       7 289 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71CE 3E 02       7 290 ld      a, FRIEND                   ; set distance to compare with
71D0 BE          7 291 cp      (hl)                        ; check 1st start position distance
71D1 D4 1C 71    7 292 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71D4 2E 12       7 293 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
71D6 BE          7 294 cp      (hl)                        ; check 2nd start position distance
71D7 D4 1C 71    7 295 call    nc, PathFinder_Update       ; (repeat for each start position)
71DA 2E 1B       7 296 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
71DC BE          7 297 cp      (hl)                        ; check 3rd start position distance
71DD D4 1C 71    7 298 call    nc, PathFinder_Update
71E0 2E 24       7 299 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
71E2 BE          7 300 cp      (hl)                        ; check 4th start position distance
71E3 D4 1C 71    7 301 call    nc, PathFinder_Update
71E6 2E 2D       7 302 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
71E8 BE          7 303 cp      (hl)                        ; check 5th start position distance
71E9 D4 1C 71    7 304 call    nc, PathFinder_Update
71EC 2E 36       7 305 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
71EE BE          7 306 cp      (hl)                        ; check 6th start position distance
71EF D4 1C 71    7 307 call    nc, PathFinder_Update
71F2 2E 3F       7 308 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
71F4 C3 67 72    7 309 jp      Path_Finder_First           ; calculate two-distances of red board (left-right)
71F7             7 311 ; ----------------------------------------------------------------------------------------------------------------------
71F7             7 312 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
71F7             7 313 ;
71F7             7 314 ; Input:    -
71F7             7 315 ;
71F7             7 316 ; Output:   A = -1, if left edge couldn't be reached
71F7             7 317 ;           A =  0, if there is chain of connected cyan tokens between the two edges
71F7             7 318 ;           A = last edge position visited (-1), otherwise
71F7             7 319 ;
71F7             7 320 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71F7             7 321 ;
71F7             7 322 ; Destroys: BC, DE, HL, IY
71F7             7 323 ; ----------------------------------------------------------------------------------------------------------------------
71F7             7 324 PathFinder_Red_RightLeft:
71F7 21 07 7E    7 325 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71FA 11 4F 64    7 326 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
71FD CD 03 71    7 327 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
7200 FD 21 00 FF 7 329 ld      iy, $FF00                   ; IYH = distance to check edge positions
7204             7 330 ; IYL = last edge position visited
7204 2A 27 71    7 331 ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
7207 E5          7 332 push    hl                          ; initialize red queue head
7208             7 334 ; set up red board (right-left) start positions distances
7208 EB          7 336 ex      de, hl                      ; take advantage of last "CopyPositions" execution
7209 2D          7 337 dec     l                           ; move HL to red board right-left address (last position)
720A 0E 43       7 338 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
720C 3E 02       7 339 ld      a, FRIEND                   ; set distance to compare with
720E BE          7 340 cp      (hl)                        ; check 1st start position distance
720F D4 1C 71    7 341 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7212 2E 84       7 342 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
7214 BE          7 343 cp      (hl)                        ; check 2nd start position distance
7215 D4 1C 71    7 344 call    nc, PathFinder_Update       ; (repeat for each start position)
7218 2E 7B       7 345 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
721A BE          7 346 cp      (hl)                        ; check 3rd start position distance
721B D4 1C 71    7 347 call    nc, PathFinder_Update
721E 2E 72       7 348 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
7220 BE          7 349 cp      (hl)                        ; check 4th start position distance
7221 D4 1C 71    7 350 call    nc, PathFinder_Update
7224 2E 69       7 351 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
7226 BE          7 352 cp      (hl)                        ; check 5th start position distance
7227 D4 1C 71    7 353 call    nc, PathFinder_Update
722A 2E 60       7 354 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
722C BE          7 355 cp      (hl)                        ; check 6th start position distance
722D D4 1C 71    7 356 call    nc, PathFinder_Update
7230 2E 57       7 357 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
7232 C3 67 72    7 358 jp      Path_Finder_First           ; calculate red two-distance (right-left)
7235             7 360 ; ----------------------------------------------------------------------------------------------------------------------
7235             7 361 ; Path_Finder: calculate two-distance metric for each board position
7235             7 362 ;
7235             7 363 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
7235             7 364 ;
7235             7 365 ; Input:    HL  = cyan or red queue area address
7235             7 366 ;           IYH = distance to check edge positions
7235             7 367 ;           IYL = 0
7235             7 368 ;
7235             7 369 ; Output:   A = -1, if corresponding edge couldn't be reached
7235             7 370 ;           A =  0, if there is chain of connected (color) tokens between the two edges
7235             7 371 ;           A = last edge position visited (-1), otherwise
7235             7 372 ;
7235             7 373 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7235             7 374 ;
7235             7 375 ; Destroys: DE, HL, IY
7235             7 376 ; ----------------------------------------------------------------------------------------------------------------------
7235             7 377 Path_Finder:
7235 2C          7 378 inc     l                           ; move queue head down
7236 E5          7 379 push    hl                          ; preserve queue head address
7237 6E          7 380 ld      l, (hl)                     ; retrieve next position to be checked
7238 24          7 381 inc     h                           ; move HL to corresponding board address
7239 4E          7 382 ld      c, (hl)                     ; retrieve distance from this position to start
723A 45          7 383 ld      b, l                        ; store current position
723B             7 385 ; look for adjacent positions
723B 7D          7 387 ld      a, l                        ; get current position
723C FD 84       7 388 add     a, iyh                      ; add distance to check edge positions
723E 6F          7 389 ld      l, a                        ; move HL to calculated position address
723F CB 7E       7 390 bit     7, (hl)                     ; is it an edge?
7241 20 34       7 391 jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions
7243 3E 02       7 393 ld      a, FRIEND                   ; set distance to compare with
7245             7 394 ; return point from PathFinder_Adjacent
7245             7 395 Path_Finder_Neighbors
7245 68          7 396 ld      l, b                        ; restore current position to be checked
7246 2C          7 397 inc     l                           ; move HL to right neighbor address
7247 BE          7 398 cp      (hl)                        ; check right neighbor distance
7248 D4 1C 71    7 399 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
724B 2D          7 400 dec     l                           ; move HL to left neighbor address
724C 2D          7 401 dec     l
724D BE          7 402 cp      (hl)                        ; check left neighbor distance
724E D4 1C 71    7 403 call    nc, PathFinder_Update       ; (repeat for each neighbor)
7251 11 F8 FF    7 404 ld      de, -WIDTH
7254 19          7 405 add     hl, de
7255 BE          7 406 cp      (hl)                        ; check upper-left neighbor distance
7256 D4 1C 71    7 407 call    nc, PathFinder_Update
7259 2C          7 408 inc     l
725A BE          7 409 cp      (hl)                        ; check upper-right neighbor distance
725B D4 1C 71    7 410 call    nc, PathFinder_Update
725E 11 10 00    7 411 ld      de, WIDTH*2
7261 19          7 412 add     hl, de
7262 BE          7 413 cp      (hl)                        ; check lower-left neighbor distance
7263 D4 1C 71    7 414 call    nc, PathFinder_Update
7266 2C          7 415 inc     l
7267             7 416 Path_Finder_First
7267 BE          7 417 cp      (hl)                        ; check lower-right neighbor distance
7268 D4 1C 71    7 418 call    nc, PathFinder_Update
726B E1          7 419 pop     hl                          ; retreive queue head address
726C 3A 27 71    7 420 ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
726F BD          7 421 cp      l                           ; is queue empty?
7270 C2 35 72    7 422 jp      nz, Path_Finder             ; no, repeat until queue is empty
7273 FD 7D       7 424 ld      a, iyl                      ; get last edge position visited
7275 3D          7 425 dec     a                           ; return A = -1, if the edge couldn't be reached
7276 C9          7 426 ret
7277             7 428 ; ----------------------------------------------------------------------------------------------------------------------
7277             7 429 ; Check adjacent hexagons.
7277             7 430 ;
7277             7 431 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
7277             7 432 ; "two cells are adjacent if they share a common edge on the board."
7277             7 433 ;
7277             7 434 ; Input:    B  = current position
7277             7 435 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
7277             7 436 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
7277             7 437 ;                edge number)
7277             7 438 ;
7277             7 439 ; Output:   A = 0, if there is a chain of connected tokens of the same color between the two edges.
7277             7 440 ;           A = FRIEND, IYL = current position, otherwise.
7277             7 441 ;
7277             7 442 ; Destroys: DE, HL
7277             7 443 ; ----------------------------------------------------------------------------------------------------------------------
7277             7 444 Path_Finder_Adjacent
7277 3E 43       7 445 ld      a, VICTORY+$40              ; set victory distance + friendly flag
7279 B9          7 446 cp      c                           ; is current distance victory and friendly?
727A 28 11       7 447 jr      z, Path_Finder_Abort        ; yes, abort path_finder
727C 7E          7 449 ld      a, (hl)                     ; get current edge position
727D E6 07       7 450 and     %00000111                   ; convert to edge number (0..6)
727F 87          7 451 add     a, a                        ; calculate vector table routine index
7280 6F          7 452 ld      l, a                        ; set index in L
7281 24          7 453 inc     h                           ; move HL to (cyan or red) vector table routine address
7282 5E          7 454 ld      e, (hl)                     ; get low byte of vector table routine address
7283 2C          7 455 inc     l                           ; move HL to high byte of vector table routine address
7284 56          7 456 ld      d, (hl)                     ; get high byte of vector table routine address
7285 EB          7 457 ex      de, hl                      ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
7286 15          7 458 dec     d                           ; move DE to cyan or red board address
7287 58          7 459 ld      e, b                        ; restore pointer to current position
7288 FD 68       7 460 ld      iyl, b                      ; last edge position visited = current position
728A 3E 02       7 461 ld      a, FRIEND                   ; set distance to compare with
728C E9          7 462 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
728D             7 463 Path_Finder_Abort
728D E1          7 464 pop     hl                          ; restore queue head address
728E AF          7 465 xor     a                           ; return A = 0
728F C9          7 466 ret
7290             7 468 ; ----------------------------------------------------------------------------------------------------------------------
7290             7 469 ;  Check two-distance of RED adjacents
7290             7 470 ; ----------------------------------------------------------------------------------------------------------------------
7290             7 471 PathFinder_RED_Edge_0
7290 EB          7 472 ex      de, hl                      ; restore pointer to current position address
7291 11 12 00    7 473 ld      de, 9*2                     ; calculate distance to adjacent #2
7294 19          7 474 add     hl, de                      ; move HL to adjacent #2 address
7295 BE          7 475 cp      (hl)                        ; check adjacent #2 distance
7296 D4 1C 71    7 476 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
7299 11 09 00    7 477 ld      de, 9                       ; calculate distance to adjacent #3
729C 19          7 478 add     hl, de                      ; move HL to adjacent #3 address
729D BE          7 479 cp      (hl)                        ; check adjacent #3 distance
729E D4 1C 71    7 480 call    nc, PathFinder_Update       ; (repeat for each adjacent)
72A1 11 09 00    7 481 ld      de, 9
72A4 19          7 482 add     hl, de
72A5 BE          7 483 cp      (hl)                        ; check adjacent #4 distance
72A6 D4 1C 71    7 484 call    nc, PathFinder_Update
72A9 11 09 00    7 485 ld      de, 9
72AC 19          7 486 add     hl, de
72AD BE          7 487 cp      (hl)                        ; check adjacent #5 distance
72AE D4 1C 71    7 488 call    nc, PathFinder_Update
72B1 11 09 00    7 489 ld      de, 9
72B4 19          7 490 add     hl, de
72B5 BE          7 491 cp      (hl)                        ; check adjacent #6 distance
72B6 D4 1C 71    7 492 call    nc, PathFinder_Update
72B9 FD 45       7 493 ld      b, iyl                      ; restore current position
72BB C3 45 72    7 494 jp      Path_Finder_Neighbors       ; continue processing neighbors
72BE             7 496 PathFinder_RED_Edge_1
72BE EB          7 497 ex      de, hl                      ; restore pointer to current position address
72BF 11 12 00    7 498 ld      de, 9*2
72C2 19          7 499 add     hl, de
72C3 BE          7 500 cp      (hl)                        ; check adjacent #3 distance
72C4 D4 1C 71    7 501 call    nc, PathFinder_Update
72C7 11 09 00    7 502 ld      de, 9
72CA 19          7 503 add     hl, de
72CB BE          7 504 cp      (hl)                        ; check adjacent #4 distance
72CC D4 1C 71    7 505 call    nc, PathFinder_Update
72CF 11 09 00    7 506 ld      de, 9
72D2 19          7 507 add     hl, de
72D3 BE          7 508 cp      (hl)                        ; check adjacent #5 distance
72D4 D4 1C 71    7 509 call    nc, PathFinder_Update
72D7 11 09 00    7 510 ld      de, 9
72DA 19          7 511 add     hl, de
72DB BE          7 512 cp      (hl)                        ; check adjacent #6 distance
72DC D4 1C 71    7 513 call    nc, PathFinder_Update
72DF FD 45       7 514 ld      b, iyl                      ; restore current position
72E1 C3 45 72    7 515 jp      Path_Finder_Neighbors       ; continue processing neighbors
72E4             7 517 PathFinder_RED_Edge_2
72E4 EB          7 518 ex      de, hl                      ; restore pointer to current position address
72E5 11 12 00    7 519 ld      de, 9*2
72E8 19          7 520 add     hl, de
72E9 BE          7 521 cp      (hl)                        ; check adjacent #4 distance
72EA D4 1C 71    7 522 call    nc, PathFinder_Update
72ED 11 09 00    7 523 ld      de, 9
72F0 19          7 524 add     hl, de
72F1 BE          7 525 cp      (hl)                        ; check adjacent #5 distance
72F2 D4 1C 71    7 526 call    nc, PathFinder_Update
72F5 11 09 00    7 527 ld      de, 9
72F8 19          7 528 add     hl, de
72F9 BE          7 529 cp      (hl)                        ; check adjacent #6 distance
72FA D4 1C 71    7 530 call    nc, PathFinder_Update
72FD 11 CA FF    7 531 ld      de, -9*6
7300 19          7 532 add     hl, de
7301 BE          7 533 cp      (hl)                        ; check adjacent #0 distance
7302 D4 1C 71    7 534 call    nc, PathFinder_Update
7305 FD 45       7 535 ld      b, iyl                      ; restore current position
7307 C3 45 72    7 536 jp      Path_Finder_Neighbors       ; continue processing neighbors
730A             7 538 PathFinder_RED_Edge_3
730A EB          7 539 ex      de, hl                      ; restore pointer to current position address
730B 11 E5 FF    7 540 ld      de, -9*3
730E 19          7 541 add     hl, de
730F BE          7 542 cp      (hl)                        ; check adjacent #0 distance
7310 D4 1C 71    7 543 call    nc, PathFinder_Update
7313 11 09 00    7 544 ld      de, 9
7316 19          7 545 add     hl, de
7317 BE          7 546 cp      (hl)                        ; check adjacent #1 distance
7318 D4 1C 71    7 547 call    nc, PathFinder_Update
731B 11 24 00    7 548 ld      de, 9*4
731E 19          7 549 add     hl, de
731F BE          7 550 cp      (hl)                        ; check adjacent #5 distance
7320 D4 1C 71    7 551 call    nc, PathFinder_Update
7323 11 09 00    7 552 ld      de, 9
7326 19          7 553 add     hl, de
7327 BE          7 554 cp      (hl)                        ; check adjacent #6 distance
7328 D4 1C 71    7 555 call    nc, PathFinder_Update
732B FD 45       7 556 ld      b, iyl                      ; restore current position
732D C3 45 72    7 557 jp      Path_Finder_Neighbors       ; continue processing neighbors
7330             7 559 PathFinder_RED_Edge_4
7330 EB          7 560 ex      de, hl                      ; restore pointer to current position address
7331 11 12 00    7 561 ld      de, 9*2
7334 19          7 562 add     hl, de
7335 BE          7 563 cp      (hl)                        ; check adjacent #6 distance
7336 D4 1C 71    7 564 call    nc, PathFinder_Update
7339 11 CA FF    7 565 ld      de, -9*6
733C 19          7 566 add     hl, de
733D BE          7 567 cp      (hl)                        ; check adjacent #0 distance
733E D4 1C 71    7 568 call    nc, PathFinder_Update
7341 11 09 00    7 569 ld      de, 9
7344 19          7 570 add     hl, de
7345 BE          7 571 cp      (hl)                        ; check adjacent #1 distance
7346 D4 1C 71    7 572 call    nc, PathFinder_Update
7349 11 09 00    7 573 ld      de, 9
734C 19          7 574 add     hl, de
734D BE          7 575 cp      (hl)                        ; check adjacent #2 distance
734E D4 1C 71    7 576 call    nc, PathFinder_Update
7351 FD 45       7 577 ld      b, iyl                      ; restore current position
7353 C3 45 72    7 578 jp      Path_Finder_Neighbors       ; continue processing neighbors
7356             7 580 PathFinder_RED_Edge_5
7356 EB          7 581 ex      de, hl                      ; restore pointer to current position address
7357 11 D3 FF    7 582 ld      de, -9*5
735A 19          7 583 add     hl, de
735B BE          7 584 cp      (hl)                        ; check adjacent #0 distance
735C D4 1C 71    7 585 call    nc, PathFinder_Update
735F 11 09 00    7 586 ld      de, 9
7362 19          7 587 add     hl, de
7363 BE          7 588 cp      (hl)                        ; check adjacent #1 distance
7364 D4 1C 71    7 589 call    nc, PathFinder_Update
7367 11 09 00    7 590 ld      de, 9
736A 19          7 591 add     hl, de
736B BE          7 592 cp      (hl)                        ; check adjacent #2 distance
736C D4 1C 71    7 593 call    nc, PathFinder_Update
736F 11 09 00    7 594 ld      de, 9
7372 19          7 595 add     hl, de
7373 BE          7 596 cp      (hl)                        ; check adjacent #3 distance
7374 D4 1C 71    7 597 call    nc, PathFinder_Update
7377 FD 45       7 598 ld      b, iyl                      ; restore current position
7379 C3 45 72    7 599 jp      Path_Finder_Neighbors       ; continue processing neighbors
737C             7 601 PathFinder_RED_Edge_6
737C EB          7 602 ex      de, hl                      ; restore pointer to current position address
737D 11 CA FF    7 603 ld      de, -9*6
7380 19          7 604 add     hl, de
7381 BE          7 605 cp      (hl)                        ; check adjacent #0 distance
7382 D4 1C 71    7 606 call    nc, PathFinder_Update
7385 11 09 00    7 607 ld      de, 9
7388 19          7 608 add     hl, de
7389 BE          7 609 cp      (hl)                        ; check adjacent #1 distance
738A D4 1C 71    7 610 call    nc, PathFinder_Update
738D 11 09 00    7 611 ld      de, 9
7390 19          7 612 add     hl, de
7391 BE          7 613 cp      (hl)                        ; check adjacent #2 distance
7392 D4 1C 71    7 614 call    nc, PathFinder_Update
7395 11 09 00    7 615 ld      de, 9
7398 19          7 616 add     hl, de
7399 BE          7 617 cp      (hl)                        ; check adjacent #3 distance
739A D4 1C 71    7 618 call    nc, PathFinder_Update
739D 11 09 00    7 619 ld      de, 9
73A0 19          7 620 add     hl, de
73A1 BE          7 621 cp      (hl)                        ; check adjacent #4 distance
73A2 D4 1C 71    7 622 call    nc, PathFinder_Update
73A5 FD 45       7 623 ld      b, iyl                      ; restore current position
73A7 C3 45 72    7 624 jp      Path_Finder_Neighbors       ; continue processing neighbors
73AA             7 626 ; ----------------------------------------------------------------------------------------------------------------------
73AA             7 627 ;  Check two-distance of CYAN adjacents
73AA             7 628 ; ----------------------------------------------------------------------------------------------------------------------
73AA             7 629 PathFinder_CYAN_Edge_0
73AA EB          7 630 ex      de, hl                      ; restore pointer to current position address
73AB 2C          7 631 inc     l
73AC 2C          7 632 inc     l
73AD BE          7 633 cp      (hl)                        ; check adjacent #2 distance
73AE D4 1C 71    7 634 call    nc, PathFinder_Update
73B1 2C          7 635 inc     l
73B2 BE          7 636 cp      (hl)                        ; check adjacent #3 distance
73B3 D4 1C 71    7 637 call    nc, PathFinder_Update
73B6 2C          7 638 inc     l
73B7 BE          7 639 cp      (hl)                        ; check adjacent #4 distance
73B8 D4 1C 71    7 640 call    nc, PathFinder_Update
73BB 2C          7 641 inc     l
73BC BE          7 642 cp      (hl)                        ; check adjacent of edge number 5
73BD D4 1C 71    7 643 call    nc, PathFinder_Update
73C0 2C          7 644 inc     l
73C1 BE          7 645 cp      (hl)                        ; check adjacent of edge number 6
73C2 D4 1C 71    7 646 call    nc, PathFinder_Update
73C5 FD 45       7 647 ld      b, iyl                      ; restore current position
73C7 C3 45 72    7 648 jp      Path_Finder_Neighbors       ; continue processing neighbors
73CA             7 650 PathFinder_CYAN_Edge_1
73CA EB          7 651 ex      de, hl                      ; restore pointer to current position address
73CB 2C          7 652 inc     l
73CC 2C          7 653 inc     l
73CD BE          7 654 cp      (hl)                        ; check adjacent #3 distance
73CE D4 1C 71    7 655 call    nc, PathFinder_Update
73D1 2C          7 656 inc     l
73D2 BE          7 657 cp      (hl)                        ; check adjacent #4 distance
73D3 D4 1C 71    7 658 call    nc, PathFinder_Update
73D6 2C          7 659 inc     l
73D7 BE          7 660 cp      (hl)                        ; check adjacent #5 distance
73D8 D4 1C 71    7 661 call    nc, PathFinder_Update
73DB 2C          7 662 inc     l
73DC BE          7 663 cp      (hl)                        ; check adjacent #6 distance
73DD D4 1C 71    7 664 call    nc, PathFinder_Update
73E0 FD 45       7 665 ld      b, iyl                      ; restore current position
73E2 C3 45 72    7 666 jp      Path_Finder_Neighbors       ; continue processing neighbors
73E5             7 668 PathFinder_CYAN_Edge_2
73E5 EB          7 669 ex      de, hl                      ; restore pointer to current position address
73E6 2D          7 670 dec     l
73E7 2D          7 671 dec     l
73E8 BE          7 672 cp      (hl)                        ; check adjacent #0 distance
73E9 D4 1C 71    7 673 call    nc, PathFinder_Update
73EC 2C          7 674 inc     l
73ED 2C          7 675 inc     l
73EE 2C          7 676 inc     l
73EF 2C          7 677 inc     l
73F0 BE          7 678 cp      (hl)                        ; check adjacent #4 distance
73F1 D4 1C 71    7 679 call    nc, PathFinder_Update
73F4 2C          7 680 inc     l
73F5 BE          7 681 cp      (hl)                        ; check adjacent #5 distance
73F6 D4 1C 71    7 682 call    nc, PathFinder_Update
73F9 2C          7 683 inc     l
73FA BE          7 684 cp      (hl)                        ; check adjacent #6 distance
73FB D4 1C 71    7 685 call    nc, PathFinder_Update
73FE FD 45       7 686 ld      b, iyl                      ; restore current position
7400 C3 45 72    7 687 jp      Path_Finder_Neighbors       ; continue processing neighbors
7403             7 689 PathFinder_CYAN_Edge_3
7403 EB          7 690 ex      de, hl                      ; restore pointer to current position address
7404 2D          7 691 dec     l
7405 2D          7 692 dec     l
7406 2D          7 693 dec     l
7407 BE          7 694 cp      (hl)                        ; check adjacent #0 distance
7408 D4 1C 71    7 695 call    nc, PathFinder_Update
740B 2C          7 696 inc     l
740C BE          7 697 cp      (hl)                        ; check adjacent #1 distance
740D D4 1C 71    7 698 call    nc, PathFinder_Update
7410 2C          7 699 inc     l
7411 2C          7 700 inc     l
7412 2C          7 701 inc     l
7413 2C          7 702 inc     l
7414 BE          7 703 cp      (hl)                        ; check adjacent #5 distance
7415 D4 1C 71    7 704 call    nc, PathFinder_Update
7418 2C          7 705 inc     l
7419 BE          7 706 cp      (hl)                        ; check adjacent #6 distance
741A D4 1C 71    7 707 call    nc, PathFinder_Update
741D FD 45       7 708 ld      b, iyl                      ; restore current position
741F C3 45 72    7 709 jp      Path_Finder_Neighbors       ; continue processing neighbors
7422             7 711 PathFinder_CYAN_Edge_4
7422 EB          7 712 ex      de, hl                      ; restore pointer to current position address
7423 2C          7 713 inc     l
7424 2C          7 714 inc     l
7425 BE          7 715 cp      (hl)                        ; check adjacent #6 distance
7426 D4 1C 71    7 716 call    nc, PathFinder_Update
7429 2D          7 717 dec     l
742A 2D          7 718 dec     l
742B 2D          7 719 dec     l
742C 2D          7 720 dec     l
742D BE          7 721 cp      (hl)                        ; check adjacent #2 distance
742E D4 1C 71    7 722 call    nc, PathFinder_Update
7431 2D          7 723 dec     l
7432 BE          7 724 cp      (hl)                        ; check adjacent #1 distance
7433 D4 1C 71    7 725 call    nc, PathFinder_Update
7436 2D          7 726 dec     l
7437 BE          7 727 cp      (hl)                        ; check adjacent #0 distance
7438 D4 1C 71    7 728 call    nc, PathFinder_Update
743B FD 45       7 729 ld      b, iyl                      ; restore current position
743D C3 45 72    7 730 jp      Path_Finder_Neighbors       ; continue processing neighbors
7440             7 732 PathFinder_CYAN_Edge_5
7440 EB          7 733 ex      de, hl                      ; restore pointer to current position address
7441 2D          7 734 dec     l
7442 2D          7 735 dec     l
7443 BE          7 736 cp      (hl)                        ; check adjacent #3 distance
7444 D4 1C 71    7 737 call    nc, PathFinder_Update
7447 2D          7 738 dec     l
7448 BE          7 739 cp      (hl)                        ; check adjacent #2 distance
7449 D4 1C 71    7 740 call    nc, PathFinder_Update
744C 2D          7 741 dec     l
744D BE          7 742 cp      (hl)                        ; check adjacent #1 distance
744E D4 1C 71    7 743 call    nc, PathFinder_Update
7451 2D          7 744 dec     l
7452 BE          7 745 cp      (hl)                        ; check adjacent #0 distance
7453 D4 1C 71    7 746 call    nc, PathFinder_Update
7456 FD 45       7 747 ld      b, iyl                      ; restore current position
7458 C3 45 72    7 748 jp      Path_Finder_Neighbors       ; continue processing neighbors
745B             7 750 PathFinder_CYAN_Edge_6
745B EB          7 751 ex      de, hl                      ; restore pointer to current position address
745C 2D          7 752 dec     l
745D 2D          7 753 dec     l
745E BE          7 754 cp      (hl)                        ; check adjacent #4 distance
745F D4 1C 71    7 755 call    nc, PathFinder_Update
7462 2D          7 756 dec     l
7463 BE          7 757 cp      (hl)                        ; check adjacent #3 distance
7464 D4 1C 71    7 758 call    nc, PathFinder_Update
7467 2D          7 759 dec     l
7468 BE          7 760 cp      (hl)                        ; check adjacent #2 distance
7469 D4 1C 71    7 761 call    nc, PathFinder_Update
746C 2D          7 762 dec     l
746D BE          7 763 cp      (hl)                        ; check adjacent #1 distance
746E D4 1C 71    7 764 call    nc, PathFinder_Update
7471 2D          7 765 dec     l
7472 BE          7 766 cp      (hl)                        ; check adjacent #0 distance
7473 D4 1C 71    7 767 call    nc, PathFinder_Update
7476 FD 45       7 768 ld      b, iyl                      ; restore current position
7478 C3 45 72    7 769 jp      Path_Finder_Neighbors       ; continue processing neighbors
747B             7 771 ; ----------------------------------------------------------------------------------------------------------------------
747B             7 772 ; PathFinder_Score: calculate board score depending on speccy color
747B             7 773 ;
747B             7 774 ; Input:    -
747B             7 775 ;
747B             7 776 ; Output:   A = -1, if speccy can't reach his opposite edge
747B             7 777 ;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
747B             7 778 ;           A = speccy heuristic evaluation, otherwise
747B             7 779 ;
747B             7 780 ; Uses:     AI_PLAYER (speccy side)
747B             7 781 ;
747B             7 782 ; Destroys: A', BC, DE, HL, IY
747B             7 783 ; ----------------------------------------------------------------------------------------------------------------------
747B             7 784 PathFinder_Score:
747B 3A 99 61    7 785 ld      a, (AI_PLAYER)              ; get speecy side
747E FE 02       7 786 cp      FRIEND                      ; is it FRIEND?
7480 28 31       7 787 jr      z, PathFinder_CyanScore     ; yes, calculate CYAN score
7482             7 789 ; ----------------------------------------------------------------------------------------------------------------------
7482             7 790 ; PathFinder_RedScore: calculate red score
7482             7 791 ;
7482             7 792 ; Input:    -
7482             7 793 ;
7482             7 794 ; Output:   A = -1, if red can't reach his opposite edge
7482             7 795 ;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
7482             7 796 ;           A = red heuristic evaluation, otherwise
7482             7 797 ;
7482             7 798 ; Uses:     POTENTIALS (board potential and attack mobility)
7482             7 799 ;
7482             7 800 ; Destroys: A', BC, DE, HL, IY
7482             7 801 ; ----------------------------------------------------------------------------------------------------------------------
7482             7 802 PathFinder_RedScore
7482 CD B5 71    7 803 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
7485 C8          7 804 ret     z                           ; if red has a chain of connected tokens, return A = 0
7486 08          7 805 ex      af, af'                     ; save first result
7487 CD F7 71    7 806 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
748A 47          7 807 ld      b, a                        ; save second result
748B 08          7 808 ex      af, af'                     ; restore first result
748C 90          7 809 sub     b                           ; subtract both results
748D 78          7 810 ld      a, b                        ; restore second result
748E C8          7 811 ret     z                           ; if red can't reach his opposite edge, return A = -1
748F CD 41 71    7 813 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
7492 08          7 814 ex      af, af'                     ; save result
7493 CD 7D 71    7 815 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
7496 47          7 816 ld      b, a                        ; save second result
7497 08          7 817 ex      af, af'                     ; restore first result
7498 90          7 818 sub     b                           ; subtract both results
7499 C8          7 819 ret     z                           ; if cyan can't reach his opposite edge, return A = 0
749A 21 09 64    7 821 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
749D 11 51 64    7 822 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74A0 CD F1 74    7 823 call    PathFinder_Potentials       ; calculate RED potentials
74A3 ED 43 97 61 7 824 ld      (POTENTIALS), bc            ; store RED potentials
74A7 21 09 61    7 826 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74AA 11 51 61    7 827 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74AD CD F1 74    7 828 call    PathFinder_Potentials       ; calculate cyan potentials
74B0 C3 E1 74    7 829 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74B3             7 831 ; ----------------------------------------------------------------------------------------------------------------------
74B3             7 832 ; PathFinder_CyanScore: calculate cyan score
74B3             7 833 ;
74B3             7 834 ; Input:    -
74B3             7 835 ;
74B3             7 836 ; Output:   A = -1, if cyan can't reach his opposite edge
74B3             7 837 ;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
74B3             7 838 ;           A = cyan heuristic evaluation, otherwise
74B3             7 839 ;
74B3             7 840 ; Uses:     POTENTIALS (board potential and attack mobility)
74B3             7 841 ;
74B3             7 842 ; Destroys: A', BC, DE, HL
74B3             7 843 ; ----------------------------------------------------------------------------------------------------------------------
74B3             7 844 PathFinder_CyanScore
74B3 CD 41 71    7 845 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74B6 C8          7 846 ret     z                           ; if cyan has a chain of connected tokens, return A = 0
74B7 08          7 847 ex      af, af'                     ; save result
74B8 CD 7D 71    7 848 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74BB 47          7 849 ld      b, a                        ; save second result
74BC 08          7 850 ex      af, af'                     ; restore first result
74BD 90          7 851 sub     b                           ; subtract both results
74BE 78          7 852 ld      a, b                        ; restore second result
74BF C8          7 853 ret     z                           ; if cyan can't reach his opposite edge, return A = -1
74C0 CD B5 71    7 855 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74C3 08          7 856 ex      af, af'                     ; save result
74C4 CD F7 71    7 857 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74C7 47          7 858 ld      b, a                        ; save second result
74C8 08          7 859 ex      af, af'                     ; restore first result
74C9 90          7 860 sub     b                           ; subtract both results
74CA C8          7 861 ret     z                           ; if red can't reach his opposite edge, return A = 0
74CB 21 09 61    7 863 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74CE 11 51 61    7 864 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74D1 CD F1 74    7 865 call    PathFinder_Potentials       ; calculate cyan potentials
74D4 ED 43 97 61 7 866 ld      (POTENTIALS), bc            ; save cyan potentials
74D8 21 09 64    7 868 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74DB 11 51 64    7 869 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74DE CD F1 74    7 870 call    PathFinder_Potentials       ; calculate red potentials
74E1             7 871 ; ----------------------------------------------------------------------------------------------------------------------
74E1             7 872 ; PathFinder_Evaluation: calculate heuristic evaluation.
74E1             7 873 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
74E1             7 874 ;
74E1             7 875 ;                                       e = M (pC - pR) - (aC - aR)
74E1             7 876 ; where:
74E1             7 877 ;   pC = cyan board potential
74E1             7 878 ;   pR = red board potential
74E1             7 879 ;   aC = cyan attack mobility
74E1             7 880 ;   aR = red attack mobility
74E1             7 881 ;    M = a large number
74E1             7 882 ;
74E1             7 883 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
74E1             7 884 ;
74E1             7 885 ; Input:    B = opponent attack mobility
74E1             7 886 ;           C = opponent board potential
74E1             7 887 ;
74E1             7 888 ; Output:   A = heuristic evaluation
74E1             7 889 ;
74E1             7 890 ; Destroys: E, HL
74E1             7 891 ; ----------------------------------------------------------------------------------------------------------------------
74E1             7 892 PathFinder_Evaluation:
74E1 21 98 61    7 893 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
74E4 78          7 894 ld      a, b                        ; get opponent's attack mobility
74E5 96          7 895 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
74E6 5F          7 896 ld      e, a                        ; save the result in E
74E7 2D          7 897 dec     l                           ; move HL to player's board potential address
74E8 79          7 898 ld      a, c                        ; get opponent's board potential
74E9 96          7 899 sub     (hl)                        ; subtract potentials -> (pC - pR)
74EA 87          7 900 add     a, a                        ; multiply by 8 -> M (pC - pR)
74EB 87          7 901 add     a, a
74EC 87          7 902 add     a, a
74ED 93          7 903 sub     e                           ; subtract result of attack mobilities subtraction
74EE             7 904 ; -> M (pC - pR) - (aC - aR)
74EE EE 80       7 905 xor     $80                         ; invert sign for easier further comparative
74F0 C9          7 906 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
74F1             7 908 ; ----------------------------------------------------------------------------------------------------------------------
74F1             7 909 ; PathFinder_Potentials: calculate board potential and attack mobility
74F1             7 910 ;
74F1             7 911 ; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
74F1             7 912 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
74F1             7 913 ;   the board.
74F1             7 914 ; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
74F1             7 915 ;
74F1             7 916 ; Input:    HL = cyan board or red board address
74F1             7 917 ;           DE = cyan board or red board address
74F1             7 918 ;
74F1             7 919 ; Output:   B = attack mobility
74F1             7 920 ;           C = board potential
74F1             7 921 ;
74F1             7 922 ; Destroys: A, DE, HL, IYL
74F1             7 923 ; ----------------------------------------------------------------------------------------------------------------------
74F1             7 924 PathFinder_Potentials:
74F1 01 FF 00    7 925 ld      bc, $00FF                   ; initialize attack mobility and board potential
74F4 FD 2E 3D    7 926 ld      iyl, 61                     ; number of cells to be checked (loop counter)
74F7             7 927 Potentials_Loop
74F7 7E          7 928 ld      a, (hl)                     ; get cell's two-distance pointed by HL
74F8 FE 40       7 929 cp      $40                         ; is cell occupied or border?
74FA 30 16       7 930 jr      nc, Potentials_Next         ; yes, skip to next cell
74FC FE 04       7 931 cp      $04                         ; cell distance was not updated?
74FE 38 1A       7 932 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
7500 1A          7 933 ld      a, (de)                     ; get cell's two-distance pointed by DE
7501 FE 04       7 934 cp      $04                         ; cell distance was not updated?
7503 38 15       7 935 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
7505 86          7 936 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
7506 77          7 937 ld      (hl), a                     ; save potential in the cell pointed by HL
7507 B9          7 938 cp      c                           ; is the new potential >= board potential?
7508 D2 0E 75    7 939 jp      nc, Potentials_Mobility     ; yes, check attack mobility
750B 4F          7 940 ld      c, a                        ; no, board potential = new potential
750C 06 01       7 941 ld      b, 1                        ; restart attack mobility
750E             7 942 Potentials_Mobility
750E C2 12 75    7 943 jp      nz, Potentials_Next         ; if (potential <> last potential) skip to next cell
7511 04          7 944 inc     b                           ; else, increment attack mobility
7512             7 945 Potentials_Next
7512 1C          7 946 inc     e                           ; move to next cell of each board
7513 2C          7 947 inc     l
7514 FD 2D       7 948 dec     iyl                         ; decrement loop counter
7516 C2 F7 74    7 949 jp      nz, Potentials_Loop         ; repeat until end of boards
7519 C9          7 950 ret
751A             7 951 Potentials_Infinite
751A CB FE       7 952 set     7, (hl)                     ; set cell potential as "infinite"
751C 1C          7 953 inc     e                           ; move to next cell of each board
751D 2C          7 954 inc     l
751E FD 2D       7 955 dec     iyl                         ; decrement loop counter
7520 C2 F7 74    7 956 jp      nz, Potentials_Loop         ; repeat until end of boards
7523 C9          7 957 ret
7524             7 959 ; ----------------------------------------------------------------------------------------------------------------------
7524             7 960 ; PathFinder_Candidates: search candidates based on score result and boards potentials
7524             7 961 ;
7524             7 962 ; Input:    A  = -1, 0 or heuristic result
7524             7 963 ;           IX = candidates area address
7524             7 964 ;
7524             7 965 ; Output:   IX = first candidate address
7524             7 966 ;
7524             7 967 ; Uses:     AI_PLAYER (speccy side)
7524             7 968 ;
7524             7 969 ; Destroys: A, A', BC, DE, HL
7524             7 970 ; ----------------------------------------------------------------------------------------------------------------------
7524             7 971 PathFinder_Candidates:
7524 DD 36 00 00 7 972 ld      (ix+0), 0                   ; set candidates endmarker
7528 B7          7 974 or      a                           ; A = 0?
7529 28 3D       7 975 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
752B 3C          7 976 inc     a                           ; A = -1?
752C 28 45       7 977 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
752E             7 979 ; if score is not -1 nor 0, fill candidates from total potentials
752E 21 09 61    7 981 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7531 11 09 64    7 982 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
7534 CD F1 74    7 983 call    PathFinder_Potentials       ; process candidates from total potentials
7537 79          7 985 ld      a, c                        ; set board potential in A
7538 08          7 986 ex      af, af'                     ; save board potential
7539 50          7 987 ld      d, b                        ; store attack mobility
753A DD 5D       7 988 ld      e, ixl                      ; store candidates position
753C             7 990 ; insert the second best board potentials in candidates area
753C             7 991 Candidates_2ndBest
753C 2E 09       7 992 ld      l, 9                        ; HL points to board potentials address (1st position)
753E 0C          7 993 inc     c                           ; increment board potential
753F 79          7 994 ld      a, c                        ; A = second best potential
7540 FE 20       7 995 cp      $20                         ; is potential >= $20? (2nd best max potential)
7542 30 13       7 996 jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential
7544 06 3D       7 997 ld      b, 61                       ; number of cells to be checked (loop counter)
7546             7 998 Candidates_2ndBest_Loop
7546 BE          7 999 cp      (hl)                        ; is current board potential = 2nd best board potential?
7547 C2 4F 75    7 1000 jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
754A DD 2C       7 1001 inc     ixl                         ; yes, insert candidate
754C DD 75 00    7 1002 ld      (ix+0), l
754F             7 1003 Candidates_2ndBest_Next
754F 2C          7 1004 inc     l                           ; move HL to next board potential address
7550 10 F4       7 1005 djnz    Candidates_2ndBest_Loop     ; repeat for each cell
7552 DD 7D       7 1006 ld      a, ixl                      ; A = current candidates position
7554 BB          7 1007 cp      e                           ; new candidates inserted?
7555 28 E5       7 1008 jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted
7557             7 1009 Candidates_2ndBest_Exit
7557 42          7 1010 ld      b, d                        ; restore attack mobility
7558 08          7 1011 ex      af, af'                     ; restore board potential
7559             7 1013 ; insert the best board potentials in candidates area
7559             7 1014 Candidates_Best
7559 2E 08       7 1015 ld      l, 8                        ; HL points to board potential address (1st position -1)
755B             7 1016 Candidates_Best_Loop
755B 2C          7 1017 inc     l                           ; move HL to next board potential address
755C BE          7 1018 cp      (hl)                        ; is current board potential equal to best board potential?
755D C2 5B 75    7 1019 jp      nz, Candidates_Best_Loop    ; no, next potential
7560 DD 2C       7 1020 inc     ixl                         ; yes, insert candidate
7562 DD 75 00    7 1021 ld      (ix+0), l
7565 10 F4       7 1022 djnz    Candidates_Best_Loop        ; repeat for each cell
7567 C9          7 1023 ret
7568             7 1025 ; ----------------------------------------------------------------------------------------------------------------------
7568             7 1026 ; Fill candidates for winner color
7568             7 1027 ; ----------------------------------------------------------------------------------------------------------------------
7568             7 1028 Candidates_Winner
7568 3A 99 61    7 1029 ld      a, (AI_PLAYER)              ; check speccy side
756B FE 02       7 1030 cp      FRIEND                      ; is it friend?
756D CA 80 75    7 1031 jp      z, Candidates_Cyan_Potential; yes, fill candidates from cyan potentials
7570 C3 93 75    7 1032 jp      Candidates_Red_Potential    ; no, fill candidates from red potentials
7573             7 1034 ; ----------------------------------------------------------------------------------------------------------------------
7573             7 1035 ; Fill candidates for defeated color
7573             7 1036 ; ----------------------------------------------------------------------------------------------------------------------
7573             7 1037 Candidates_Defeat
7573 3A 99 61    7 1038 ld      a, (AI_PLAYER)              ; check speccy side
7576 FE 02       7 1039 cp      FRIEND                      ; is it friend?
7578 28 13       7 1040 jr      z, Candidates_Red           ; yes, fill candidates from red potentials
757A             7 1042 ; if RED is defeated, candidates are chosen from cyan board potentials
757A CD 41 71    7 1044 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
757D CD 7D 71    7 1045 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
7580             7 1046 Candidates_Cyan_Potential
7580 21 09 61    7 1047 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7583 11 51 61    7 1048 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7586 CD F1 74    7 1049 call    PathFinder_Potentials       ; calculate cyan potentials
7589 79          7 1051 ld      a, c                        ; set board potential in A
758A C3 59 75    7 1052 jp      Candidates_Best             ; fill only the best candidates
758D             7 1054 ; if CYAN is defeated, candidates are chosen from red board potentials
758D             7 1055 Candidates_Red
758D CD B5 71    7 1056 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
7590 CD F7 71    7 1057 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
7593             7 1058 Candidates_Red_Potential
7593 21 09 64    7 1059 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
7596 11 51 64    7 1060 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7599 CD F1 74    7 1061 call    PathFinder_Potentials       ; calculate red potentials
759C 79          7 1063 ld      a, c                        ; set board potential in A
759D C3 59 75    7 1064 jp      Candidates_Best             ; fill only the best candidates
75A0             7 1066 ; ----------------------------------------------------------------------------------------------------------------------
75A0             7 1067 ; PathFinder_VictoryPath: calculate current player victory path
75A0             7 1068 ;
75A0             7 1069 ; Input:    -
75A0             7 1070 ;
75A0             7 1071 ; Output:   A = -1, if there isn't a victory path
75A0             7 1072 ;           A = start position (-1) of the victory path, otherwise
75A0             7 1073 ;
75A0             7 1074 ; Uses:     TOKEN_COLOR (current token color)
75A0             7 1075 ;
75A0             7 1076 ; Destroys: BC, DE, HL, IY
75A0             7 1077 ; ----------------------------------------------------------------------------------------------------------------------
75A0             7 1078 PathFinder_VictoryPath:
75A0 3A 9E 61    7 1079 ld      a, (TOKEN_COLOR)            ; get current token color
75A3 FE 05       7 1080 cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
75A5 28 0C       7 1081 jr      z, PathFinder_VictoryPath_Cyan
75A7 CD B5 71    7 1083 call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
75AA 21 45 64    7 1084 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75AD CD BF 75    7 1085 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75B0 C3 BE 71    7 1086 jp      PathFinder_Red_CheckPath    ; calculate RED victory path
75B3             7 1088 PathFinder_VictoryPath_Cyan
75B3 CD 41 71    7 1089 call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
75B6 21 45 61    7 1090 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75B9 CD BF 75    7 1091 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75BC C3 4A 71    7 1092 jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path
75BF             7 1094 ; ----------------------------------------------------------------------------------------------------------------------
75BF             7 1095 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to 1, everything else to ENEMY.
75BF             7 1096 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
75BF             7 1097 ; [color]' again to find a victory path.
75BF             7 1098 ;
75BF             7 1099 ; Coded by Einar Saukas
75BF             7 1100 ;
75BF             7 1101 ; Input:    HL = pointer to last position of [color]_BOARD
75BF             7 1102 ;
75BF             7 1103 ; Output:   -
75BF             7 1104 ;
75BF             7 1105 ; Destroys: A, BC, HL
75BF             7 1106 ; ----------------------------------------------------------------------------------------------------------------------
75BF             7 1107 PathFinder_PrepareBoard:
75BF 3E 43       7 1108 ld      a, VICTORY+$40              ; set victory distance + friendly flag
75C1 0E 07       7 1109 ld      c, 7                        ; 7 rows
75C3             7 1110 PrepareBoard_Row
75C3 06 07       7 1111 ld      b, 7                        ; 7 columns
75C5             7 1112 PrepareBoard_Column
75C5 BE          7 1113 cp      (hl)                        ; is it win condition?
75C6 36 01       7 1114 ld      (hl), 1                     ; save 1 by default
75C8 28 02       7 1115 jr      z, PrepareBoard_Next        ; yes, next position
75CA 36 7E       7 1116 ld      (hl), ENEMY                 ; no, save ENEMY
75CC             7 1117 PrepareBoard_Next
75CC 2D          7 1118 dec     l                           ; HL points to next board position
75CD 10 F6       7 1119 djnz    PrepareBoard_Column         ; repeat for each column
75CF 2D          7 1121 dec     l                           ; skip borders
75D0 2D          7 1122 dec     l
75D1 0D          7 1123 dec     c                           ; decrement rows
75D2 20 EF       7 1124 jr      nz, PrepareBoard_Row        ; repeat for each row
75D4 C9          7 1125 ret
75D5             7 1127 ; ----------------------------------------------------------------------------------------------------------------------
75D5             7 1128 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75D5             7 1129 ;
75D5             7 1130 ; Input:    B  = start position of the victory path
75D5             7 1131 ;           HL = [color]_QUEUE_AREA address
75D5             7 1132 ;
75D5             7 1133 ; Output:   -
75D5             7 1134 ;
75D5             7 1135 ; Uses:     TOKEN_COLOR (current token color)
75D5             7 1136 ;
75D5             7 1137 ; Destroys: A, BC, DE, HL, IX
75D5             7 1138 ; ----------------------------------------------------------------------------------------------------------------------
75D5             7 1139 PathFinder_BrightPath:
75D5 3A 9E 61    7 1140 ld      a, (TOKEN_COLOR)            ; get current token color
75D8 F5          7 1141 push    af                          ; store current token color
75D9 C6 40       7 1142 add     a, $40                      ; apply bright attribute
75DB 32 9E 61    7 1143 ld      (TOKEN_COLOR), a            ; save color
75DE 24          7 1145 inc     h                           ; move HL to the start position of the victory path
75DF 68          7 1146 ld      l, b
75E0 4E          7 1147 ld      c, (hl)                     ; set victory path length in C
75E1 18 1E       7 1148 jr      BrightPath_Position         ; animate and highlight the hexagon position
75E3             7 1149 BrightPath_Neighbor
75E3 2C          7 1150 inc     l                           ; move HL to left neighbor address
75E4 BE          7 1151 cp      (hl)                        ; is it the same as victory path length?
75E5 28 1A       7 1152 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75E7 2D          7 1153 dec     l
75E8 2D          7 1154 dec     l                           ; right neighbor
75E9 BE          7 1155 cp      (hl)                        ; is it the same as victory path length?
75EA 28 15       7 1156 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75EC 7D          7 1157 ld      a, l
75ED D6 08       7 1158 sub     WIDTH
75EF 6F          7 1159 ld      l, a                        ; move HL to upper-right neighbor address
75F0 79          7 1160 ld      a, c                        ; restore victory path length in A
75F1 BE          7 1161 cp      (hl)                        ; is it the same as victory path length?
75F2 28 0D       7 1162 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F4 2C          7 1163 inc     l                           ; upper-left neighbor
75F5 BE          7 1164 cp      (hl)                        ; is it the same as victory path length?
75F6 28 09       7 1165 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F8 7D          7 1166 ld      a, l
75F9 C6 10       7 1167 add     a, WIDTH*2
75FB 6F          7 1168 ld      l, a                        ; move HL to lower-right neighbor address
75FC 79          7 1169 ld      a, c                        ; restore victory path length in A
75FD BE          7 1170 cp      (hl)                        ; is it the same as victory path length?
75FE 28 01       7 1171 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7600 2C          7 1172 inc     l                           ; move HL to lower-left neighbor address
7601             7 1173 BrightPath_Position
7601 C5          7 1174 push    bc                          ; store victory path length
7602 E5          7 1175 push    hl                          ; store current position pointer
7603 CD 81 6D    7 1176 call    Main_Board2Indexes          ; convert a board position into a board indexes
7606 CD BC 6D    7 1177 call    Draw_Token                  ; animate hexagon sprite on the screen
7609 DD 21 E7 64 7 1178 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
760D CD C7 76    7 1179 call    Sound_FX                    ; play sound effect
7610 E1          7 1180 pop     hl                          ; restore current position pointer
7611 C1          7 1181 pop     bc                          ; restore victory path length
7612 0D          7 1182 dec     c                           ; decrement victory path length
7613 79          7 1183 ld      a, c                        ; set victory path length in A
7614 FE 03       7 1184 cp      VICTORY                     ; has reached victory path length?
7616 20 CB       7 1185 jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach VICTORY length
7618 F1          7 1187 pop     af                          ; restore current token color
7619 32 9E 61    7 1188 ld      (TOKEN_COLOR), a
761C C9          7 1189 ret

; File #8: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Timer.z80asm

761D             8 1 ; ----------------------------------------------------------------------------------------------------------------------
761D             8 2 ; Timer.z80asm
761D             8 3 ; Coded by Antonio Luque
761D             8 4 ;
761D             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
761D             8 6 ; ----------------------------------------------------------------------------------------------------------------------
761D             8 8 ; ----------------------------------------------------------------------------------------------------------------------
761D             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
761D             8 10 ;
761D             8 11 ; Input:    -
761D             8 12 ;
761D             8 13 ; Output:   -
761D             8 14 ;
761D             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
761D             8 16 ;
761D             8 17 ; Destroys: BC', DE', HL'
761D             8 18 ; ----------------------------------------------------------------------------------------------------------------------
761D             8 19 Timer_Interrupt:
761D F5          8 20 push    af                          ; store AF register
761E D9          8 21 exx                                 ; store BC, DE and HL registers
761F 3A E9 62    8 23 ld      a, (TIMER_FLAG)             ; check timer flag
7622 B7          8 24 or      a                           ; is timer stopped?
7623 CA 4C 76    8 25 jp      z, Timer_Exit               ; yes, exit routine
7626 21 ED 62    8 27 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
7629 3D          8 28 dec     a                           ; is red timer on?
762A C2 30 76    8 29 jp      nz, Timer_Counters          ; yes, check interrupt counter 
762D 21 EA 62    8 30 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
7630             8 31 Timer_Counters
7630 35          8 32 dec     (hl)                        ; decrement interrupt counter
7631 C2 4C 76    8 33 jp      nz, Timer_Exit              ; if not 0, exit routine
7634 36 32       8 35 ld      (hl), 50                    ; restart interrupt counter
7636 23          8 36 inc     hl                          ; move HL to seconds counter address
7637 3E 01       8 37 ld      a, 1                        ; increment seconds counter
7639 86          8 38 add     a, (hl)
763A 27          8 39 daa                                 ; convert to BCD (Binary-Coded-Decimal)
763B 77          8 40 ld      (hl), a                     ; store seconds
763C FE 60       8 41 cp      $60                         ; 60 seconds reached?
763E C2 49 76    8 42 jp      nz, Timer_Show              ; no, show timer
7641 36 00       8 43 ld      (hl), 0                     ; restart seconds counter
7643 23          8 44 inc     hl                          ; move HL to minutes counter address
7644 3E 01       8 45 ld      a, 1                        ; increment minutes counter
7646 86          8 46 add     a, (hl)
7647 27          8 47 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7648 77          8 48 ld      (hl), a                     ; store minutes
7649             8 49 Timer_Show
7649 CD 50 76    8 50 call    Timer_Display               ; display timer on the screen
764C             8 51 Timer_Exit
764C D9          8 52 exx                                 ; restore BC, DE and HL registers
764D F1          8 53 pop     af                          ; restore AF register
764E FB          8 55 ei                                  ; enable interrupts
764F C9          8 56 ret
7650             8 58 ; ----------------------------------------------------------------------------------------------------------------------
7650             8 59 ; Timer_Display: display a timer on the screen
7650             8 60 ;
7650             8 61 ; Input:    -
7650             8 62 ;
7650             8 63 ; Output:   -
7650             8 64 ;
7650             8 65 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7650             8 66 ;
7650             8 67 ; Destroys: A, BC, DE, HL
7650             8 68 ; ----------------------------------------------------------------------------------------------------------------------
7650             8 69 Timer_Display:
7650 11 EF 62    8 70 ld      de, RED_TIMER+2             ; DE points to red's minutes counter address
7653 01 E2 48    8 71 ld      bc, $48E2                   ; BC points to red's minutes screen address
7656 3A E9 62    8 72 ld      a, (TIMER_FLAG)             ; check timer flag
7659 3D          8 73 dec     a                           ; is cyan timer on?
765A C2 63 76    8 74 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
765D 11 EC 62    8 75 ld      de, CYAN_TIMER+2            ; DE points to cyan's minutes counter address
7660 01 78 40    8 76 ld      bc, $4078                   ; BC points to cyan's minutes screen address
7663             8 77 Timer_Display_Min
7663 CD 68 76    8 78 call    Timer_Display_MinSec        ; display minutes counter on screen
7666 1B          8 79 dec     de                          ; DE points to seconds counter address
7667 0C          8 80 inc     c                           ; BC points to seconds screen address
7668             8 81 Timer_Display_MinSec:
7668 1A          8 82 ld      a, (de)                     ; set min/sec counter in A
7669 1F          8 83 rra                                 ; move tens digit to the first 4th bits of A
766A 1F          8 84 rra
766B 1F          8 85 rra
766C 1F          8 86 rra
766D CD 71 76    8 87 call    Timer_Display_Digit         ; display tens digit on screen
7670 1A          8 88 ld      a, (de)                     ; set min/sec counter in A 
7671             8 89 Timer_Display_Digit:
7671 E6 0F       8 90 and     %00001111                   ; discard the last 4th bits of the digit
7673 C5          8 91 push    bc                          ; store digit screen address
7674 21 97 64    8 93 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
7677 87          8 94 add     a, a                        ; a digit is 8 bytes long
7678 87          8 95 add     a, a
7679 87          8 96 add     a, a
767A 85          8 97 add     a, l                        ; set digit index in HL
767B 6F          8 98 ld      l, a
767C 7E          8 100 ld      a, (hl)                     ; get digit tile
767D 02          8 101 ld      (bc), a                     ; put it on screen address
767E 04          8 102 inc     b                           ; move BC to next pixel-line address
767F 2C          8 103 inc     l                           ; move HL to next digit tile address
7680 7E          8 104 ld      a, (hl)                     ; (repeat 7 more times)
7681 02          8 105 ld      (bc), a
7682 04          8 106 inc     b
7683 2C          8 107 inc     l
7684 7E          8 108 ld      a, (hl)
7685 02          8 109 ld      (bc), a
7686 04          8 110 inc     b
7687 2C          8 111 inc     l
7688 7E          8 112 ld      a, (hl)
7689 02          8 113 ld      (bc), a
768A 04          8 114 inc     b
768B 2C          8 115 inc     l
768C 7E          8 116 ld      a, (hl)
768D 02          8 117 ld      (bc), a
768E 04          8 118 inc     b
768F 2C          8 119 inc     l
7690 7E          8 120 ld      a, (hl)
7691 02          8 121 ld      (bc), a
7692 04          8 122 inc     b
7693 2C          8 123 inc     l
7694 7E          8 124 ld      a, (hl)
7695 02          8 125 ld      (bc), a
7696 04          8 126 inc     b
7697 2C          8 127 inc     l
7698 7E          8 128 ld      a, (hl)
7699 02          8 129 ld      (bc), a
769A C1          8 131 pop     bc                          ; restore digit screen address
769B 0C          8 132 inc     c                           ; move screen address to next column
769C C9          8 133 ret
769D             8 135 ; ----------------------------------------------------------------------------------------------------------------------
769D             8 136 ; Timer_Display_All: display cyan and red timers
769D             8 137 ;
769D             8 138 ; Input:    -
769D             8 139 ;
769D             8 140 ; Output:   -
769D             8 141 ;
769D             8 142 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
769D             8 143 ;
769D             8 144 ; Destroys: BC, DE, HL
769D             8 145 ; ----------------------------------------------------------------------------------------------------------------------
769D             8 146 Timer_Display_All:
769D 3E 01       8 147 ld      a, 1                        ; set cyan timer on
769F 32 E9 62    8 148 ld      (TIMER_FLAG), a
76A2 CD 50 76    8 149 call    Timer_Display               ; display cyan timer
76A5 3E 02       8 151 ld      a, 2                        ; set red timer on
76A7 32 E9 62    8 152 ld      (TIMER_FLAG), a
76AA CD 50 76    8 153 call    Timer_Display               ; display red timer
76AD AF          8 155 xor     a                           ; stop timers
76AE 32 E9 62    8 156 ld      (TIMER_FLAG), a
76B1 C9          8 157 ret
76B2             8 159 ; ----------------------------------------------------------------------------------------------------------------------
76B2             8 160 ; Timer_Reset: initialize cyan and red timers
76B2             8 161 ;
76B2             8 162 ; Input:    -
76B2             8 163 ;
76B2             8 164 ; Output:   -
76B2             8 165 ;
76B2             8 166 ; Destroys: HL
76B2             8 167 ; ----------------------------------------------------------------------------------------------------------------------
76B2             8 168 Timer_Reset:
76B2 21 EA 62    8 169 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76B5 36 32       8 171 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76B7 23          8 172 inc     hl                          ; move HL to cyan's seconds counter address
76B8 36 00       8 173 ld      (hl), 0                     ; reset seconds counter
76BA 23          8 174 inc     hl                          ; move HL to cyan's minutes counter address
76BB 36 00       8 175 ld      (hl), 0                     ; reset minutes counter
76BD 23          8 176 inc     hl                          ; move HL to red's interrupt counter
76BE 36 32       8 178 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76C0 23          8 179 inc     hl                          ; move HL to red's seconds counter address
76C1 36 00       8 180 ld      (hl), 0                     ; reset seconds counter
76C3 23          8 181 inc     hl                          ; move HL to red's minutes counter address
76C4 36 00       8 182 ld      (hl), 0                     ; reset minutes counter
76C6 C9          8 183 ret

; File #9: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Sound.z80asm

76C7             9 1 ; ----------------------------------------------------------------------------------------------------------------------
76C7             9 2 ; Sound.z80asm
76C7             9 3 ; Coded with BeepFX player tool by Shiru: https://shiru.untergrund.net/software.shtml
76C7             9 4 ;
76C7             9 5 ; Adapted for Hex game by Antonio Luque
76C7             9 6 ; ----------------------------------------------------------------------------------------------------------------------
76C7             9 8 ; ----------------------------------------------------------------------------------------------------------------------
76C7             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
76C7             9 10 ; 
76C7             9 11 ; Input:    IX = tone parameters address
76C7             9 12 ;
76C7             9 13 ; Output:   -
76C7             9 14 ;
76C7             9 15 ; Destroys: A, BC, DE, HL, IY
76C7             9 16 ; ----------------------------------------------------------------------------------------------------------------------
76C7             9 17 Sound_FX:
76C7 F3          9 18 di                                  ; disable interrupts
76C8 DD 4E 00    9 20 ld      c, (ix+0)                   ; BC = frames
76CB DD 46 01    9 21 ld      b, (ix+1)
76CE DD 5E 02    9 22 ld      e, (ix+2)                   ; DE = frame length
76D1 DD 56 03    9 23 ld      d, (ix+3)
76D4 D5          9 24 push    de                          ; store frame length in IY
76D5 FD E1       9 25 pop     iy
76D7 DD 5E 04    9 26 ld      e, (ix+4)                   ; DE = pitch
76DA DD 56 05    9 27 ld      d, (ix+5)
76DD 21 00 00    9 28 ld      hl, 0                       ; reset HL
76E0             9 30 Sound_FX_Frames
76E0 C5          9 31 push    bc                          ; store frames
76E1 FD E5       9 32 push    iy                          ; restore frame length in BC
76E3 C1          9 33 pop     bc
76E4             9 34 Sound_FX_FrameLength
76E4 19          9 35 add     hl, de                      ; HL = incremented pitch
76E5 7C          9 36 ld      a, h                        ; compares with fixed duty cycle ($80 for 50% square wave)
76E6 FE 80       9 37 cp      $80                         ; if (incremented pitch < duty cycle)
76E8 9F          9 38 sbc     a, a                        ;    { A = %11111111 } else { A = %00000000 }
76E9 E6 10       9 39 and     %00010000                   ; toggling bit 4 controls the internal speaker
76EB F6 00       9 40 or      0                           ; keep border unchanged, dummy (7t)
76ED D3 FE       9 41 out     ($FE), a                    ; send bit to internal speaker
76EF 3A 00 00    9 42 ld      a, (0)                      ; dummy (13t)
76F2 0B          9 43 dec     bc                          ; decrement frame length
76F3 78          9 44 ld      a, b                        ; check frame length
76F4 B1          9 45 or      c                           ; frame length = 0?
76F5 C2 E4 76    9 46 jp      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times (loop = 88t)
76F8 DD 4E 06    9 48 ld      c, (ix+6)                   ; BC = pitch slide
76FB DD 46 07    9 49 ld      b, (ix+7)
76FE EB          9 50 ex      de, hl                      ; HL = current pitch
76FF 09          9 51 add     hl, bc                      ; increment pitch with pitch slide
7700 EB          9 52 ex      de, hl                      ; DE = new pitch
7701 C1          9 54 pop     bc                          ; restore frames
7702 0B          9 55 dec     bc                          ; decrement frames
7703 78          9 56 ld      a, b                        ; check frames
7704 B1          9 57 or      c                           ; frames = 0?
7705 20 D9       9 58 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
7707 FB          9 60 ei                                  ; enable interrupts
7708 C9          9 61 ret

; File #10: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Screen.z80asm

7709             10 1 ; ----------------------------------------------------------------------------------------------------------------------
7709             10 2 ; Screen.z80asm
7709             10 3 ; Coded by Antonio Luque
7709             10 4 ; ----------------------------------------------------------------------------------------------------------------------
7709             10 6 BLUE_INK                equ     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
7709             10 7 BLUE_PAPER              equ     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
7709             10 8 WHITE_PAPER             equ     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
7709             10 9 WHITE                   equ     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
7709             10 10 BRIGHT                  equ     %01000000                   ; mask to apply bright to attributes
7709             10 11 FLASH                   equ     %10000000                   ; mask to apply flash to attributes
7709             10 12 WHITE_FLASH0            equ     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
7709             10 13 WHITE_FLASH1            equ     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
7709             10 15 ; ----------------------------------------------------------------------------------------------------------------------
7709             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
7709             10 17 ;
7709             10 18 ; Input:    -
7709             10 19 ;
7709             10 20 ; Output:   -
7709             10 21 ;
7709             10 22 ; Destroys: BC, DE, HL
7709             10 23 ; ----------------------------------------------------------------------------------------------------------------------
7709             10 24 Screen_Clear:
7709 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
770C 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
770F 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
7710 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
7713 ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
7715 C9          10 30 ret
7716             10 32 ; ----------------------------------------------------------------------------------------------------------------------
7716             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
7716             10 34 ;
7716             10 35 ; Input:    -
7716             10 36 ;
7716             10 37 ; Output:   -
7716             10 38 ;
7716             10 39 ; Destroys: A, BC, DE, HL, IX
7716             10 40 ; ----------------------------------------------------------------------------------------------------------------------
7716             10 41 Screen_Letters:
7716 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
7719 DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
771D CD 27 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
7720 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
7723 DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
7727             10 47 Screen_Letters_Row:
7727 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
772A 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
772C             10 50 Screen_Letter_Loop
772C E5          10 51 push    hl                          ; store letter screen address
772D CD F4 6D    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
7730 E1          10 53 pop     hl                          ; restore letter screen address
7731 2C          10 54 inc     l                           ; move HL to next screen address
7732 2C          10 55 inc     l
7733 DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
7737 DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
773B DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
773D DD 2C       10 59 inc     ixl
773F 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
7741 C9          10 61 ret
7742             10 63 ; ----------------------------------------------------------------------------------------------------------------------
7742             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
7742             10 65 ;
7742             10 66 ; Input:    -
7742             10 67 ;
7742             10 68 ; Output:   -
7742             10 69 ;
7742             10 70 ; Destroys: A, BC, DE, HL, IX, IY
7742             10 71 ; ----------------------------------------------------------------------------------------------------------------------
7742             10 72 Screen_Numbers:
7742 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
7745 FD 21 F0 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
7749 DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
774D 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
774F             10 77 Screen_Number_Loop
774F FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
7752 FD 66 01    10 79 ld      h, (iy+1)
7755 E5          10 80 push    hl                          ; store pointer to number screen address
7756 D5          10 81 push    de                          ; store pointer to sprite address
7757 CD F4 6D    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
775A D1          10 83 pop     de                          ; restore pointer to sprite address
775B E1          10 84 pop     hl                          ; restore pointer to number screen address
775C DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7760 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
7764 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
7765 C6 0F       10 88 add     a, 15
7767 6F          10 89 ld      l, a
7768 CD F4 6D    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
776B DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
776F DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
7773 78          10 93 ld      a, b                        ; save loop counter
7774 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
7777 DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
7779 FD 23       10 96 inc     iy                          ; move IY to next number screen address
777B FD 23       10 97 inc     iy
777D 47          10 98 ld      b, a                        ; restore loop counter
777E 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
7780 C9          10 100 ret
7781             10 102 ; ----------------------------------------------------------------------------------------------------------------------
7781             10 103 ; Screen_Frame: draw the screen frame on the screen
7781             10 104 ;
7781             10 105 ; Input:    -
7781             10 106 ;
7781             10 107 ; Output:   -
7781             10 108 ;
7781             10 109 ; Destroys: A, BC, DE, HL, IX
7781             10 110 ; ----------------------------------------------------------------------------------------------------------------------
7781             10 111 Screen_Frame:
7781 11 29 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
7784 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
7787 CD 59 6F    10 114 call    Print_String                ; print "Level"
778A CD C6 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
778D 01 8E 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
7790 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
7793 CD 99 77    10 119 call    Screen_Frame_Border         ; draw up-border
7796 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
7799             10 121 Screen_Frame_Border:
7799 DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
779C             10 123 Screen_Frame_Loop
779C 0A          10 124 ld      a, (bc)                     ; get tile index
779D FE FF       10 125 cp      -1                          ; is it -1?
779F 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
77A1 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
77A4 CD 68 6F    10 128 call    Print_Tile                  ; print frame tile
77A7             10 129 Screen_Frame_Next
77A7 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77A8 03          10 131 inc     bc                          ; BC points to the next tile index
77A9 DD 2D       10 132 dec     ixl                         ; decrement loop counter
77AB 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77AD DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77B1 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77B5 DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77B9 DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77BD DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77C1 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77C5 C9          10 141 ret
77C6             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77C6             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77C6             10 145 ;
77C6             10 146 ; Input:    -
77C6             10 147 ;
77C6             10 148 ; Output:   -
77C6             10 149 ;
77C6             10 150 ; Destroys: A, BC, HL
77C6             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77C6             10 152 Screen_Vertical_Bars:
77C6 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
77C9 CD CF 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
77CC 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
77CF             10 156 Screen_Vertical_Bar:
77CF 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
77D1             10 158 Screen_Vertical_Loop
77D1 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
77D3 CD 00 6E    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
77D6 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
77D8 C9          10 162 ret
77D9             10 164 ; ----------------------------------------------------------------------------------------------------------------------
77D9             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
77D9             10 166 ;
77D9             10 167 ; Input:    -
77D9             10 168 ;
77D9             10 169 ; Output:   -
77D9             10 170 ;
77D9             10 171 ; Uses:     TOKEN_COLOR (current token color)
77D9             10 172 ;
77D9             10 173 ; Destroys: A, BC, DE, HL, IX
77D9             10 174 ; ----------------------------------------------------------------------------------------------------------------------
77D9             10 175 Screen_Tokens:
77D9 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
77DB 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
77DE CD E6 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
77E1 3E 02       10 180 ld      a, RED_COLOR                ; set token color
77E3 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
77E6             10 182 Screen_Tokens_Draw:
77E6 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77E9 CD 0F 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
77EC DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
77EF DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
77F2 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
77F5 C3 E1 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
77F8             10 190 ; ----------------------------------------------------------------------------------------------------------------------
77F8             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
77F8             10 192 ;
77F8             10 193 ; Input:    -
77F8             10 194 ;
77F8             10 195 ; Output:   -
77F8             10 196 ;
77F8             10 197 ; Destroys: IX
77F8             10 198 ; ----------------------------------------------------------------------------------------------------------------------
77F8             10 199 Screen_Timer_Quotes:
77F8 DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
77FC DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7800 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7804 DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
7806 DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
780A DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
780E DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
7811 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
7815 DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
7819 DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
781D DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7821 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7825 DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
7827 DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
782B DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
782F DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
7832 DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
7836 DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
783A C9          10 219 ret
783B             10 221 ; ----------------------------------------------------------------------------------------------------------------------
783B             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
783B             10 223 ;
783B             10 224 ; Input:    -
783B             10 225 ;
783B             10 226 ; Output:   -
783B             10 227 ;
783B             10 228 ; Destroys: BC, IX
783B             10 229 ; ----------------------------------------------------------------------------------------------------------------------
783B             10 230 Screen_Color_Statics:
783B DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
783F 0E 07       10 232 ld      c, WHITE                    ; set color in C
7841 CD 6B 78    10 233 call    Screen_Apply_Color          ; apply color
7844 DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
7847 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
7849 CD 6B 78    10 236 call    Screen_Apply_Color          ; apply color
784C DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7850 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
7852 CD 6B 78    10 239 call    Screen_Apply_Color          ; apply color
7855 DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
7858 0E 07       10 241 ld      c, WHITE                    ; set color in C
785A CD 6B 78    10 242 call    Screen_Apply_Color          ; apply color
785D DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7861 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
7863 CD 6B 78    10 245 call    Screen_Apply_Color          ; apply color
7866 DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
7869 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
786B             10 248 Screen_Apply_Color:
786B 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
786D             10 250 Screen_Apply_Color_Loop:
786D DD 71 00    10 251 ld      (ix+0), c                   ; apply color
7870 DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
7872 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
7874 C9          10 254 ret
7875             10 256 ; ----------------------------------------------------------------------------------------------------------------------
7875             10 257 ; Screen_Last_Level: show last level screen and input game level
7875             10 258 ;
7875             10 259 ; Input:    -
7875             10 260 ;
7875             10 261 ; Output:   -
7875             10 262 ;
7875             10 263 ; Uses:     GAME_LEVEL (current game level)
7875             10 264 ;
7875             10 265 ; Destroys: A, BC, DE, HL, IX, IY
7875             10 266 ; ----------------------------------------------------------------------------------------------------------------------
7875             10 267 Screen_Last_Level:
7875 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
7878 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
787B CD 59 6F    10 270 call    Print_String                ; print "Press any key"
787E DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
7882 01 38 0D    10 272 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7885 CD 6D 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
7888 CD C5 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
788B CD 09 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
788E CD 4E 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7891 DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
7895 01 C7 11    10 279 ld      bc, 17*256+WHITE_FLASH1     ; B = string length (loop counter), C = color attributes
7898 CD 6D 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
789B 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
789E 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
78A1 CD 59 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
78A4 DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78A8 CD C7 76    10 285 call    Sound_FX                    ; play sound fx
78AB F3          10 287 di                                  ; disable interrupts
78AC DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78B0 01 07 1C    10 289 ld      bc, 28*256+WHITE            ; B = string length (loop counter), C = color attributes
78B3 CD 6D 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78B6 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78B9 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78BC CD 59 6F    10 293 call    Print_String                ; print "Well done!..."
78BF DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78C2 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78C4 CD 6D 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78C7 DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
78CB DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
78CF DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
78D3 13          10 300 inc     de                          ; move DE to next string address
78D4 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
78D6 CD 59 6F    10 302 call    Print_String                ; print "Choose..."
78D9             10 303 Screen_Choose_Level
78D9 CD C5 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
78DC FE 31       10 305 cp      '1'                         ; is it < '1' ?
78DE 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
78E0 FE 35       10 307 cp      '5'                         ; is it >= '5' ?
78E2 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
78E4 D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
78E6 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
78E9 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
78EA C9          10 312 ret
78EB             10 314 ; ----------------------------------------------------------------------------------------------------------------------
78EB             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
78EB             10 316 ;
78EB             10 317 ; Input:    -
78EB             10 318 ;
78EB             10 319 ; Output:   -
78EB             10 320 ;
78EB             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
78EB             10 322 ;           THREE_ROW (three-in-a-row counter)
78EB             10 323 ;
78EB             10 324 ; Destroys: A, C, HL, IX
78EB             10 325 ; ----------------------------------------------------------------------------------------------------------------------
78EB             10 326 Screen_ThreeRow:
78EB 21 9C 61    10 327 ld      hl, LEVEL_COLOR             ; HL points to level color address
78EE 4E          10 328 ld      c, (hl)                     ; save level color in C
78EF CD 07 79    10 329 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
78F2 3A 0F 62    10 330 ld      a, (THREE_ROW)              ; A = three-in-a-row counter
78F5 B7          10 331 or      a                           ; is it 0?
78F6 C8          10 332 ret     z                           ; yes, return
78F7 3D          10 333 dec     a                           ; is it 1?
78F8 28 09       10 334 jr      z, Screen_ThreeRow_1        ; yes, color first mark
78FA 3D          10 335 dec     a                           ; is it 2?
78FB 28 03       10 336 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
78FD DD 71 00    10 337 ld      (ix+0), c                   ; color 3rd mark
7900             10 338 Screen_ThreeRow_2
7900 DD 71 01    10 339 ld      (ix+1), c                   ; color 2nd mark
7903             10 340 Screen_ThreeRow_1
7903 DD 71 02    10 341 ld      (ix+2), c                   ; color 1st mark
7906 C9          10 342 ret
7907             10 344 ; ----------------------------------------------------------------------------------------------------------------------
7907             10 345 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
7907             10 346 ;
7907             10 347 ; Input:    -
7907             10 348 ;
7907             10 349 ; Output:   IX = three-in-a-row marks attribute address
7907             10 350 ;
7907             10 351 ; Destroys: -
7907             10 352 ; ----------------------------------------------------------------------------------------------------------------------
7907             10 353 Screen_Clear_ThreeRow:
7907 DD 21 F2 5A 10 354 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
790B DD 36 00 01 10 355 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
790F DD 36 01 01 10 356 ld      (ix+1), BLUE_INK
7913 DD 36 02 01 10 357 ld      (ix+2), BLUE_INK
7917 C9          10 358 ret
7918             10 360 ; ----------------------------------------------------------------------------------------------------------------------
7918             10 361 ; Screen_Frame_Color: set up frame color and print level number depending on current level
7918             10 362 ;
7918             10 363 ; Input:    HL = game level address
7918             10 364 ;
7918             10 365 ; Output:   -
7918             10 366 ;
7918             10 367 ; Uses:     LEVEL_COLOR (current level color for frame border)
7918             10 368 ;
7918             10 369 ; Destroys: A, BC, DE, HL
7918             10 370 ; ----------------------------------------------------------------------------------------------------------------------
7918             10 371 Screen_Frame_Color:
7918 06 00       10 372 ld      b, 0                        ; set game level in BC
791A 4E          10 373 ld      c, (hl)
791B 3E 30       10 374 ld      a, $30                      ; convert game level number to game level character
791D 81          10 375 add     a, c
791E 21 0F 40    10 376 ld      hl, $400F                   ; HL points to screen address of game level
7921 CD 65 6F    10 377 call    Print_Char                  ; print game level
7924 21 0F 62    10 378 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
7927 09          10 379 add     hl, bc                      ; use BC as index for color map address
7928 7E          10 380 ld      a, (hl)                     ; A = level color
7929 CD 3E 79    10 381 call    Screen_Tiles_Color          ; color the frame according to the current level
792C E6 07       10 382 and     %00000111                   ; mask color
792E 32 9C 61    10 383 ld      (LEVEL_COLOR), a            ; save masked color
7931 17          10 384 rla                                 ; rotate to text level color
7932 17          10 385 rla
7933 17          10 386 rla
7934 21 08 58    10 387 ld      hl, $5808                   ; HL points to attribute address of level text
7937 06 09       10 388 ld      b, 9                        ; length of level text (loop counter)
7939             10 389 Screen_Level_Loop
7939 77          10 390 ld      (hl), a                     ; apply color to level text
793A 2C          10 391 inc     l                           ; HL points to attr address of next character of level text
793B 10 FC       10 392 djnz    Screen_Level_Loop           ; repeat for each character of level text
793D C9          10 393 ret
793E             10 395 ; ----------------------------------------------------------------------------------------------------------------------
793E             10 396 ; Screen_Tiles_Color: apply color to the frame tiles
793E             10 397 ;
793E             10 398 ; Input:    A = color to apply
793E             10 399 ;
793E             10 400 ; Output:   -
793E             10 401 ;
793E             10 402 ; Destroys: BC, DE, HL
793E             10 403 ; ----------------------------------------------------------------------------------------------------------------------
793E             10 404 Screen_Tiles_Color:
793E             10 405 ; color up row
793E 21 01 58    10 407 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
7941 06 06       10 408 ld      b, 6                        ; number of tiles (loop counter)
7943             10 409 Screen_Tiles_URow1
7943 77          10 410 ld      (hl), a                     ; apply color
7944 2C          10 411 inc     l                           ; move HL to the next attribute address
7945 10 FC       10 412 djnz    Screen_Tiles_URow1          ; repeat for each tile
7947 2E 12       10 413 ld      l, $12                      ; move HL to the next attribute address
7949 06 0D       10 414 ld      b, 13                       ; number of tiles (loop counter)
794B             10 415 Screen_Tiles_URow2
794B 77          10 416 ld      (hl), a                     ; apply color
794C 2C          10 417 inc     l                           ; move HL to the next attribute address
794D 10 FC       10 418 djnz    Screen_Tiles_URow2          ; repeat for each tile
794F             10 420 ; color vertical bars
794F 2E 00       10 422 ld      l, 0                        ; move HL to the next attribute address
7951 11 1F 00    10 423 ld      de, 31                      ; attribute address displacement (for each bar)
7954 0E 03       10 424 ld      c, 3                        ; number of screen thirds (outer loop counter)
7956             10 425 Screen_Tiles_VBar1
7956 06 08       10 426 ld      b, 8                        ; number of tiles (inner loop counter)
7958             10 427 Screen_Tiles_VBar2
7958 77          10 428 ld      (hl), a                     ; apply color
7959 19          10 429 add     hl, de                      ; move HL to the right column
795A 77          10 430 ld      (hl), a                     ; apply color
795B 2C          10 431 inc     l                           ; move HL to the next attribute address
795C 10 FA       10 432 djnz    Screen_Tiles_VBar2          ; repeat for each tile
795E 24          10 433 inc     h                           ; move HL to the next screen third
795F 0D          10 434 dec     c                           ; decrement number of thirds
7960 20 F4       10 435 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
7962             10 437 ; color bottom row
7962 21 E1 5A    10 439 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
7965 06 10       10 440 ld      b, 16                       ; number of tiles (loop counter)
7967             10 441 Screen_Tiles_BRow1
7967 77          10 442 ld      (hl), a                     ; apply color
7968 2C          10 443 inc     l                           ; move HL to the next attribute address
7969 10 FC       10 444 djnz    Screen_Tiles_BRow1          ; repeat for each tile
796B 2E F6       10 445 ld      l, $F6                      ; move HL to the next attribute address
796D 06 09       10 446 ld      b, 9                        ; number of tiles (loop counter)
796F             10 447 Screen_Tiles_BRow2
796F 77          10 448 ld      (hl), a                     ; apply color
7970 2C          10 449 inc     l                           ; move HL to the next attribute address
7971 10 FC       10 450 djnz    Screen_Tiles_BRow2          ; repeat for each tile
7973 C9          10 451 ret
7974             10 453 ; ----------------------------------------------------------------------------------------------------------------------
7974             10 454 ; Screen_Menu: show main menu and wait for an option
7974             10 455 ;
7974             10 456 ; Input:    -
7974             10 457 ;
7974             10 458 ; Output:   -
7974             10 459 ;
7974             10 460 ; Uses:     GAME_LEVEL (current game level)
7974             10 461 ;
7974             10 462 ; Destroys: A, BC, DE, HL, IX, IY
7974             10 463 ; ----------------------------------------------------------------------------------------------------------------------
7974             10 464 Screen_Menu:
7974 CD 09 77    10 465 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7977 CD 4E 7C    10 466 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
797A             10 467 Screen_Menu_Strings
797A 21 80 59    10 468 ld      hl, $5980                   ; HL points to menu text area attributes address
797D 11 81 59    10 469 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
7980 36 00       10 470 ld      (hl), 0                     ; set first attribute text area in black
7982 01 7F 01    10 471 ld      bc, 32*12-1                 ; length of text area attributes (-1 already set)
7985 ED B0       10 472 ldir                                ; set the rest of text area attributes in black
7987 DD 21 CA 59 10 474 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
798B DD 36 FF 78 10 475 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
798F 01 47 0D    10 476 ld      bc, 13*256+WHITE_FLASH0     ; B = string length-1 (loop counter), C = color attributes
7992 CD 6D 78    10 477 call    Screen_Apply_Color_Loop     ; apply color to string area
7995 11 80 67    10 478 ld      de, STR_OPTIONS             ; DE points to string address
7998 21 C9 48    10 479 ld      hl, $48C9                   ; HL points to string screen address
799B CD 59 6F    10 480 call    Print_String                ; print "Start new game"
799E DD 21 2A 5A 10 481 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
79A2 DD 36 FF 78 10 482 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79A6 06 0A       10 483 ld      b, 10                       ; string length-1 (loop counter)
79A8 CD 6D 78    10 484 call    Screen_Apply_Color_Loop     ; apply color to string area
79AB 13          10 485 inc     de                          ; move DE to "How to play" string address
79AC 21 29 50    10 486 ld      hl, $5029                   ; HL points to string screen address
79AF CD 59 6F    10 487 call    Print_String                ; print "How to play"
79B2 DD 2E 8A    10 488 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79B5 DD 36 FF 78 10 489 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79B9 CD 6B 78    10 490 call    Screen_Apply_Color          ; apply color to string area
79BC 13          10 491 inc     de                          ; move DE to "Credits" string address
79BD 2E 89       10 492 ld      l, $89                      ; HL points to string screen address
79BF CD 59 6F    10 493 call    Print_String                ; print "Credits"
79C2             10 494 Screen_Menu_Options
79C2 CD C5 6E    10 495 call    Input_Key_Scan              ; wait for a key pressed
79C5 FE 73       10 496 cp      's'                         ; is it 's'?
79C7 C8          10 497 ret     z                           ; yes, return
79C8 FE 63       10 498 cp      'c'                         ; is it 'c'?
79CA CA DE 7B    10 499 jp      z, Screen_Menu_Credits      ; yes, show credits
79CD FE 68       10 500 cp      'h'                         ; is it 'h'?
79CF 20 F1       10 501 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
79D1             10 503 ; ----------------------------------------------------------------------------------------------------------------------
79D1             10 504 ; Show "How to play" pages
79D1             10 505 ; ----------------------------------------------------------------------------------------------------------------------
79D1             10 506 Screen_Menu_How2Play
79D1 CD 09 77    10 507 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79D4 CD 16 77    10 508 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
79D7 CD 42 77    10 509 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
79DA CD 81 77    10 510 call    Screen_Frame                ; draw the screen frame
79DD 21 9D 61    10 512 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
79E0 34          10 513 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
79E1 CD 18 79    10 514 call    Screen_Frame_Color          ; set up frame color depending on current level
79E4 CD 07 79    10 515 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
79E7 11 4A 68    10 517 ld      de, STR_BUTTONS             ; DE points to "Next" string address
79EA 21 DB 50    10 518 ld      hl, $50DB                   ; HL points to string screen address
79ED CD 59 6F    10 519 call    Print_String                ; print "Next"
79F0 13          10 520 inc     de                          ; move DE to "Back" string address
79F1 21 C1 50    10 521 ld      hl, $50C1                   ; HL points to string screen address
79F4 CD 59 6F    10 522 call    Print_String                ; print "Back"
79F7             10 524 Screen_How2Play_RED
79F7 21 5E 58    10 525 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
79FA CD 88 7C    10 526 call    Screen_Clear_Text           ; clear text area attributes
79FD CD A1 6D    10 527 call    Draw_Board                  ; draw an empty hexagons board
7A00             10 529 ; text for RED
7A00 DD 21 01 5A 10 531 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
7A04 01 07 07    10 532 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7A07 CD 6D 78    10 533 call    Screen_Apply_Color_Loop     ; apply color to string area
7A0A 11 5D 68    10 534 ld      de, STR_HELP1               ; DE points to string address
7A0D 21 01 50    10 535 ld      hl, $5001                   ; HL points to string screen address
7A10 CD 59 6F    10 536 call    Print_String                ; print "Connect"
7A13 DD 2E 21    10 537 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A16 06 08       10 538 ld      b, 8                        ; string length (loop counter)
7A18 CD 6D 78    10 539 call    Screen_Apply_Color_Loop     ; apply color to string area
7A1B 13          10 540 inc     de                          ; move DE to "left and" string address
7A1C 2E 21       10 541 ld      l, $21                      ; HL points to string screen address
7A1E CD 59 6F    10 542 call    Print_String                ; print "left and"
7A21 DD 2E 41    10 543 ld      ixl, $41                    ; IX points to "right" string attributes address
7A24 06 05       10 544 ld      b, 5                        ; set string length (loop counter)
7A26 CD 6D 78    10 545 call    Screen_Apply_Color_Loop     ; apply color to string area
7A29 11 75 68    10 546 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A2C 2E 41       10 547 ld      l, $41                      ; HL points to string screen address
7A2E CD 59 6F    10 548 call    Print_String                ; print "right"
7A31 DD 2E 61    10 549 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A34 06 07       10 550 ld      b, 7                        ; set string length (loop counter)
7A36 CD 6D 78    10 551 call    Screen_Apply_Color_Loop     ; apply color to string area
7A39 11 80 68    10 552 ld      de, STR_HELP4               ; DE points to "borders" string address
7A3C 2E 61       10 553 ld      l, $61                      ; HL points to string screen address
7A3E CD 59 6F    10 554 call    Print_String                ; print "borders"
7A41 DD 2E 81    10 555 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A44 CD 6B 78    10 556 call    Screen_Apply_Color          ; apply color to string area
7A47 13          10 557 inc     de                          ; move DE to "to win" string address
7A48 2E 81       10 558 ld      l, $81                      ; HL points to string screen address
7A4A CD 59 6F    10 559 call    Print_String                ; print "to win"
7A4D DD 21 E3 59 10 560 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A51 01 42 03    10 561 ld      bc, 3*256+RED_COLOR+BRIGHT  ; B = string length (loop counter), C = color attributes
7A54 CD 6D 78    10 562 call    Screen_Apply_Color_Loop     ; apply color to string area
7A57 11 54 68    10 563 ld      de, STR_RED                 ; DE points to "RED" string address
7A5A 21 E3 48    10 564 ld      hl, $48E3                   ; HL points to string screen address
7A5D CD 59 6F    10 565 call    Print_String                ; print "RED"
7A60             10 567 ; draw RED sample board
7A60 FD 21 3A 67 10 569 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A64 11 3E 66    10 570 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A67 06 07       10 571 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A69 3E 42       10 572 ld      a, RED_COLOR+BRIGHT         ; set token color
7A6B 32 9E 61    10 573 ld      (TOKEN_COLOR), a            ; save token color
7A6E CD 73 7C    10 574 call    Screen_Hexagons_Loop        ; draw tokens
7A71 06 02       10 575 ld      b, 2                        ; number of red tokens (loop counter)
7A73 3E 02       10 576 ld      a, RED_COLOR                ; set token color
7A75 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7A78 CD 73 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7A7B 06 09       10 579 ld      b, 9                        ; number of cyan tokens (loop counter)
7A7D 3E 05       10 580 ld      a, CYAN_COLOR               ; set token color
7A7F 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7A82 CD 73 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7A85             10 584 ; wait for "Next" option pressed
7A85 DD 21 C1 5A 10 586 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A89 01 00 04    10 587 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7A8C CD 6D 78    10 588 call    Screen_Apply_Color_Loop     ; hide "Back" string
7A8F DD 2E DC    10 589 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7A92 DD 36 FF 78 10 590 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7A96 01 47 03    10 591 ld      bc, 3*256+WHITE_FLASH0      ; B = string length-1 (loop counter), C = color attributes
7A99 CD 6D 78    10 592 call    Screen_Apply_Color_Loop     ; apply color to string area
7A9C             10 593 Screen_How2PlayRED_End
7A9C CD C5 6E    10 594 call    Input_Key_Scan              ; wait for a key pressed
7A9F FE 6E       10 595 cp      'n'                         ; is it 'n'?
7AA1 20 F9       10 596 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7AA3             10 598 Screen_How2Play_CYAN
7AA3 21 0F 58    10 599 ld      hl, $580F                   ; HL points to level number attribute address
7AA6 CB BE       10 600 res     7, (hl)                     ; reset flash attribute
7AA8 26 40       10 601 ld      h, $40                      ; HL points to level number screen address
7AAA 3E 31       10 602 ld      a, '1'                      ; set level number (char)
7AAC CD 65 6F    10 603 call    Print_Char                  ; print '1'
7AAF CD 07 79    10 604 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7AB2 21 C9 59    10 606 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7AB5 CD 88 7C    10 607 call    Screen_Clear_Text           ; clear text area attributes
7AB8 CD A1 6D    10 608 call    Draw_Board                  ; draw an empty hexagons board
7ABB             10 610 ; text for CYAN
7ABB DD 21 98 58 10 612 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7ABF 01 07 07    10 613 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7AC2 CD 6D 78    10 614 call    Screen_Apply_Color_Loop     ; apply color to string area
7AC5 11 5D 68    10 615 ld      de, STR_HELP1               ; DE points to "Connect" string address
7AC8 21 98 40    10 616 ld      hl, $4098                   ; HL points to string screen address
7ACB CD 59 6F    10 617 call    Print_String                ; print "Connect"
7ACE DD 2E B9    10 618 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7AD1 CD 6B 78    10 619 call    Screen_Apply_Color          ; apply color to string area
7AD4 11 6E 68    10 620 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7AD7 2E B9       10 621 ld      l, $B9                      ; HL points to string screen address
7AD9 CD 59 6F    10 622 call    Print_String                ; print "up and"
7ADC DD 2E DB    10 623 ld      ixl, $DB                    ; IX points to "down" string attributes address
7ADF 06 04       10 624 ld      b, 4                        ; string length (loop counter)
7AE1 CD 6D 78    10 625 call    Screen_Apply_Color_Loop     ; apply color to string area
7AE4 11 7B 68    10 626 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7AE7 2E DB       10 627 ld      l, $DB                      ; HL points to string screen address
7AE9 CD 59 6F    10 628 call    Print_String                ; print "down"
7AEC DD 2E F8    10 629 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7AEF 06 07       10 630 ld      b, 7                        ; string length (loop counter)
7AF1 CD 6D 78    10 631 call    Screen_Apply_Color_Loop     ; apply color to string area
7AF4 13          10 632 inc     de                          ; move DE to "borders" string address
7AF5 2E F8       10 633 ld      l, $F8                      ; HL points to string screen address
7AF7 CD 59 6F    10 634 call    Print_String                ; print "borders"
7AFA DD 21 19 59 10 635 ld      ix, $5919                   ; IX points to "to win" string attributes address
7AFE CD 6B 78    10 636 call    Screen_Apply_Color          ; apply color to string area
7B01 13          10 637 inc     de                          ; move DE to "to win" string address
7B02 21 19 48    10 638 ld      hl, $4819                   ; HL points to string screen address
7B05 CD 59 6F    10 639 call    Print_String                ; print "to win"
7B08 DD 21 7A 58 10 640 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B0C 01 45 04    10 641 ld      bc, $0445                   ; B = string length (loop counter)
7B0F             10 642 ; C = color attributes (cyan+bright)
7B0F CD 6D 78    10 643 call    Screen_Apply_Color_Loop     ; apply color to string area
7B12 11 58 68    10 644 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B15 21 7A 40    10 645 ld      hl, $407A                   ; HL points to string screen address
7B18 CD 59 6F    10 646 call    Print_String                ; print "CYAN"
7B1B             10 648 ; draw CYAN sample board
7B1B FD 21 5E 67 10 650 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B1F 11 3E 66    10 651 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B22 06 07       10 652 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B24 3E 45       10 653 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B26 32 9E 61    10 654 ld      (TOKEN_COLOR), a            ; save token color
7B29 CD 73 7C    10 655 call    Screen_Hexagons_Loop        ; draw tokens
7B2C 06 02       10 656 ld      b, 2                        ; number of cyan tokens (loop counter)
7B2E 3E 05       10 657 ld      a, CYAN_COLOR               ; set token color
7B30 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B33 CD 73 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B36 06 08       10 660 ld      b, 8                        ; number of red tokens (loop counter)
7B38 3E 02       10 661 ld      a, RED_COLOR                ; set token color
7B3A 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B3D CD 73 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B40             10 665 ; wait for "Next" or "Back" options pressed
7B40 DD 21 C2 5A 10 667 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B44 DD 36 FF 78 10 668 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B48 01 47 03    10 669 ld      bc, 3*256+WHITE_FLASH0      ; B = string length (-1), C = color attributes
7B4B CD 6D 78    10 670 call    Screen_Apply_Color_Loop     ; apply color to string area
7B4E             10 671 Screen_How2PlayCYAN_End
7B4E CD C5 6E    10 672 call    Input_Key_Scan              ; wait for a key pressed
7B51 FE 62       10 673 cp      'b'                         ; is it 'b'?
7B53 CA F7 79    10 674 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B56 FE 6E       10 675 cp      'n'                         ; is it 'n'?
7B58 20 F4       10 676 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B5A             10 678 Screen_How2Play_LevelUp
7B5A 21 5E 58    10 679 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B5D CD 88 7C    10 680 call    Screen_Clear_Text           ; clear text area attributes
7B60             10 682 ; text for Level Up
7B60 DD 21 21 5A 10 684 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B64 01 07 09    10 685 ld      bc, 9*256+WHITE             ; B = string length (loop counter), C = color attributes
7B67 CD 6D 78    10 686 call    Screen_Apply_Color_Loop     ; apply color to string area
7B6A 11 8F 68    10 687 ld      de, STR_HELP                ; DE points to "Win three" string address
7B6D 21 21 50    10 688 ld      hl, $5021                   ; HL points to string screen address
7B70 CD 59 6F    10 689 call    Print_String                ; print "Win three"
7B73 DD 2E 41    10 690 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B76 06 08       10 691 ld      b, 8                        ; string length (loop counter)
7B78 CD 6D 78    10 692 call    Screen_Apply_Color_Loop     ; apply color to string area
7B7B 13          10 693 inc     de                          ; move DE to "times in" string address
7B7C 2E 41       10 694 ld      l, $41                      ; HL points to string screen address
7B7E CD 59 6F    10 695 call    Print_String                ; print "times in"
7B81 DD 2E 61    10 696 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B84 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7B86 CD 6D 78    10 698 call    Screen_Apply_Color_Loop     ; apply color to string area
7B89 13          10 699 inc     de                          ; move DE to "a row to" string address
7B8A 2E 61       10 700 ld      l, $61                      ; HL points to string screen address
7B8C CD 59 6F    10 701 call    Print_String                ; print "a row to"
7B8F DD 2E 81    10 702 ld      ixl, $81                    ; IX points to "level up" string attributes address
7B92 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7B94 CD 6D 78    10 704 call    Screen_Apply_Color_Loop     ; apply color to string area
7B97 13          10 705 inc     de                          ; move DE to "level up" string address
7B98 2E 81       10 706 ld      l, $81                      ; HL points to string screen address
7B9A CD 59 6F    10 707 call    Print_String                ; print "level up"
7B9D             10 709 ; reset bright of cyan tokens
7B9D FD 21 5E 67 10 711 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7BA1 11 3E 66    10 712 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7BA4 06 07       10 713 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7BA6 3E 05       10 714 ld      a, CYAN_COLOR               ; set new token color
7BA8 32 9E 61    10 715 ld      (TOKEN_COLOR), a            ; save color
7BAB CD 73 7C    10 716 call    Screen_Hexagons_Loop        ; draw tokens
7BAE             10 718 ; set flash attribute of level number and three-in-a-row marks
7BAE 21 0F 58    10 720 ld      hl, $580F                   ; HL points to level number attribute address
7BB1 CB FE       10 721 set     7, (hl)                     ; set flash attribute
7BB3 21 0F 40    10 722 ld      hl, $400F                   ; HL points to level number screen address
7BB6 3E 32       10 723 ld      a, '2'                      ; set new level
7BB8 CD 65 6F    10 724 call    Print_Char                  ; print new level
7BBB DD 21 F2 5A 10 725 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BBF DD 36 00 B8 10 726 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BC3 DD 36 01 B8 10 727 ld      (ix+1), WHITE_PAPER+FLASH
7BC7 DD 36 02 B8 10 728 ld      (ix+2), WHITE_PAPER+FLASH
7BCB             10 730 ; wait for "Next" or "Back" options pressed
7BCB             10 732 Screen_How2Play_End
7BCB CD C5 6E    10 733 call    Input_Key_Scan              ; wait for a key pressed
7BCE FE 62       10 734 cp      'b'                         ; is it 'b'?
7BD0 CA A3 7A    10 735 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7BD3 FE 6E       10 736 cp      'n'                         ; is it 'n'?
7BD5 20 F4       10 737 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7BD7 21 9D 61    10 739 ld      hl, GAME_LEVEL              ; HL points to game level address
7BDA 35          10 740 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7BDB C3 74 79    10 741 jp      Screen_Menu                 ; return to main menu
7BDE             10 743 ; ----------------------------------------------------------------------------------------------------------------------
7BDE             10 744 ; Show credits
7BDE             10 745 ; ----------------------------------------------------------------------------------------------------------------------
7BDE             10 746 Screen_Menu_Credits
7BDE DD 21 84 59 10 747 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7BE2 01 47 19    10 748 ld      bc, 25*256+WHITE_FLASH0     ; B = string length (loop counter), C = color attributes
7BE5 CD 6D 78    10 749 call    Screen_Apply_Color_Loop     ; apply color to string area
7BE8 11 A3 67    10 750 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7BEB 21 84 48    10 751 ld      hl, $4884                   ; HL points to string screen address
7BEE CD 59 6F    10 752 call    Print_String                ; print "Design..."
7BF1 DD 2E C4    10 753 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7BF4 06 19       10 754 ld      b, 25                       ; string length (loop counter)
7BF6 CD 6D 78    10 755 call    Screen_Apply_Color_Loop     ; apply color to string area
7BF9 13          10 756 inc     de                          ; move DE to to "Code..." string address
7BFA 2E C4       10 757 ld      l, $C4                      ; HL points to string screen address
7BFC CD 59 6F    10 758 call    Print_String                ; print "Code..."
7BFF DD 2E E4    10 759 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7C02 06 18       10 760 ld      b, 24                       ; string length (loop counter)
7C04 CD 6D 78    10 761 call    Screen_Apply_Color_Loop     ; apply color to string area
7C07 13          10 762 inc     de                          ; move DE to "Einar Saukas" string address
7C08 2E E4       10 763 ld      l, $E4                      ; HL points to string screen address
7C0A CD 59 6F    10 764 call    Print_String                ; print "Einar Saukas"
7C0D DD 21 24 5A 10 765 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C11 06 18       10 766 ld      b, 24                       ; string length (loop counter)
7C13 CD 6D 78    10 767 call    Screen_Apply_Color_Loop     ; apply color to string area
7C16 13          10 768 inc     de                          ; move DE to "Font..." string address
7C17 21 24 50    10 769 ld      hl, $5024                   ; HL points to string screen address
7C1A CD 59 6F    10 770 call    Print_String                ; print "Font..."
7C1D DD 2E 64    10 771 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C20 06 18       10 772 ld      b, 24                       ; string length (loop counter)
7C22 CD 6D 78    10 773 call    Screen_Apply_Color_Loop     ; apply color to string area
7C25 13          10 774 inc     de                          ; move DE to "Graphics..." string address
7C26 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7C28 CD 59 6F    10 776 call    Print_String                ; print "Graphics..."
7C2B DD 2E 84    10 777 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C2E 06 19       10 778 ld      b, 25                       ; string length (loop counter)
7C30 CD 6D 78    10 779 call    Screen_Apply_Color_Loop     ; apply color to string area
7C33 13          10 780 inc     de                          ; move DE to "Antonio Luque" string address
7C34 2E 84       10 781 ld      l, $84                      ; HL points to string screen address
7C36 CD 59 6F    10 782 call    Print_String                ; print "Antonio Luque"
7C39 DD 2E E9    10 783 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C3C 01 38 0D    10 784 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7C3F CD 6D 78    10 785 call    Screen_Apply_Color_Loop     ; apply color to string area
7C42 13          10 786 inc     de                          ; move DE to "Press any key" string address
7C43 2E E9       10 787 ld      l, $E9                      ; HL points to string screen address
7C45 CD 59 6F    10 788 call    Print_String                ; print "Press any key"
7C48 CD C5 6E    10 789 call    Input_Key_Scan              ; wait for a key pressed
7C4B C3 7A 79    10 790 jp      Screen_Menu_Strings         ; return to main menu
7C4E             10 792 ; ----------------------------------------------------------------------------------------------------------------------
7C4E             10 793 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C4E             10 794 ;
7C4E             10 795 ; Input:    -
7C4E             10 796 ;
7C4E             10 797 ; Output:   -
7C4E             10 798 ;
7C4E             10 799 ; Uses:     TOKEN_COLOR (current token color)
7C4E             10 800 ;
7C4E             10 801 ; Destroys: A, BC, DE, HL, IX, IY
7C4E             10 802 ; ----------------------------------------------------------------------------------------------------------------------
7C4E             10 803 Screen_Hexagons:
7C4E FD 21 EA 66 10 804 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C52 3E 07       10 805 ld      a, WHITE                    ; set hexagon color
7C54 32 9E 61    10 806 ld      (TOKEN_COLOR), a            ; save hexagon color
7C57 11 7E 65    10 807 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C5A 06 1C       10 808 ld      b, 28                       ; number of empty hexagons (loop counter)
7C5C CD 73 7C    10 809 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C5F 3E 05       10 810 ld      a, CYAN_COLOR               ; set token color
7C61 32 9E 61    10 811 ld      (TOKEN_COLOR), a            ; save hexagon color
7C64 11 3E 66    10 812 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C67 06 06       10 813 ld      b, 6                        ; number of cyan tokens (loop counter)
7C69 CD 73 7C    10 814 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C6C 3E 02       10 815 ld      a, RED_COLOR                ; set token color
7C6E 32 9E 61    10 816 ld      (TOKEN_COLOR), a            ; save hexagon color
7C71 06 06       10 817 ld      b, 6                        ; number of red tokens (loop counter)
7C73             10 818 Screen_Hexagons_Loop:
7C73 FD 6E 00    10 819 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C76 FD 66 01    10 820 ld      h, (iy+1)
7C79 CD 0F 6E    10 821 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C7C D5          10 822 push    de                          ; store hexagon/token sprite address
7C7D CD E1 6D    10 823 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C80 D1          10 824 pop     de                          ; restore hexagon/token sprite address
7C81 FD 23       10 825 inc     iy                          ; move IY to next hexagon/token screen address
7C83 FD 23       10 826 inc     iy
7C85 10 EC       10 827 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C87 C9          10 828 ret
7C88             10 830 ; ----------------------------------------------------------------------------------------------------------------------
7C88             10 831 ; Screen_Clear_Text: clean a text attributes area
7C88             10 832 ;
7C88             10 833 ; Input:    HL = text area attributes address
7C88             10 834 ;
7C88             10 835 ; Output:   -
7C88             10 836 ;
7C88             10 837 ; Destroys: BC, DE, HL
7C88             10 838 ; ----------------------------------------------------------------------------------------------------------------------
7C88             10 839 Screen_Clear_Text:
7C88 01 30 00    10 840 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7C8B             10 841 Screen_ClearText_Loop
7C8B 11 18 00    10 842 ld      de, 24                      ; displacement for each text row
7C8E 19          10 843 add     hl, de                      ; add displacement to text area attributes address
7C8F 54          10 844 ld      d, h                        ; DE points to text area attributes address
7C90 5D          10 845 ld      e, l
7C91 36 00       10 846 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7C93 13          10 847 inc     de                          ; move DE to next byte attribute address
7C94 ED A0       10 848 ldi                                 ; set attributes color for the rest of bytes of current row
7C96 ED A0       10 849 ldi
7C98 ED A0       10 850 ldi
7C9A ED A0       10 851 ldi
7C9C ED A0       10 852 ldi
7C9E ED A0       10 853 ldi
7CA0 ED A0       10 854 ldi
7CA2 ED A0       10 855 ldi
7CA4 EA 8B 7C    10 856 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7CA7 C9          10 857 ret

; File #0: C:\Users\Antonio Luque\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

7CA8             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CA8             0 20 ; Credits and acknowledgements:
7CA8             0 21 ;
7CA8             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CA8             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CA8             0 24 ;   "King+" font and TOKEN graphics.
7CA8             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CA8             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CA8             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CA8             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CA8             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CA8             0 30 ;
7CA8             0 31 ; - Special thanks to my wife Sonia.
7CA8             0 32 ; ----------------------------------------------------------------------------------------------------------------------
