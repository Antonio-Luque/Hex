
; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   ORG     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         DEFS    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 DEFB      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 DEFB                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 DEFB    0                           ; board potential
6198 00          1 51 DEFB    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               DEFB    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                DEFB    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             DEFB    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             DEFB    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              DEFB    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             DEFB    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            DEFB    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 DEFB    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 DEFB    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 DEFB    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 DEFB    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 DEFB    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 DEFB    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 DEFB    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 DEFM    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;ORG     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 AD 73       1 85 DEFW    PathFinder_CYAN_Edge_0
6202 CD 73       1 86 DEFW    PathFinder_CYAN_Edge_1
6204 E8 73       1 87 DEFW    PathFinder_CYAN_Edge_2
6206 06 74       1 88 DEFW    PathFinder_CYAN_Edge_3
6208 25 74       1 89 DEFW    PathFinder_CYAN_Edge_4
620A 43 74       1 90 DEFW    PathFinder_CYAN_Edge_5
620C 5E 74       1 91 DEFW    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E 00          1 96 THREE_ROW               DEFB    0                           ; three-in-a-row counter
620F 0F 0E 0C 0B 1 97 ROW_COLOR_MAP           DEFB    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6213 0D 0A       1 97 
6215 00 2D 30 00 1 98 STR_MOVE                DEFB    0, '-', '0', 0, '\0'        ; formatted move string
6219 00          1 98 
621A 53 70 65 63 1 99 STR_SPECCY              DEFM    "Speccy\0"
621E 63 79 00    1 99 
6221 50 6C 61 79 1 100 STR_PLAYER              DEFM    "Player\0"
6225 65 72 00    1 100 
6228 4C 65 76 65 1 101 STR_LEVELTEXT           DEFM    "Level\0"
622C 6C 00       1 101 
622E 46 49 4C 4C 1 102 STR_FILLED              DEFM    "FILLED\0"
6232 45 44 00    1 102 
6235 57 41 49 54 1 103 STR_WAIT                DEFM    "WAIT\0"
6239 00          1 103 
623A 20 57 49 4E 1 104 STR_WINNER              DEFM    " WINS \0"
623E 53 20 00    1 104 
6241 20 20 20 20 1 105 STR_EMPTY4              DEFM    "    \0"
6245 00          1 105 
6246 20 20 20 20 1 106 STR_EMPTY6              DEFM    "      \0"
624A 20 20 00    1 106 
624D             1 108 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 109 ; Conversion table: from position to XY board indexes
624D             1 110 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 111 BOARD_COORDINATES:
624D 00 00 00 00 1 112 DEFB    $00, $00, $00, $00, $00, $00, $00, $00
6251 00 00 00 00 1 112 
6255 00 09 0A 0B 1 113 DEFB    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
6259 0C 0D 0E 0F 1 113 
625D 00 12 13 14 1 114 DEFB    $00, $12, $13, $14, $15, $16, $17, $18
6261 15 16 17 18 1 114 
6265 00 1B 1C 1D 1 115 DEFB    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
6269 1E 1F 20 21 1 115 
626D 00 24 25 26 1 116 DEFB    $00, $24, $25, $26, $27, $28, $29, $2A
6271 27 28 29 2A 1 116 
6275 00 2D 2E 2F 1 117 DEFB    $00, $2D, $2E, $2F, $30, $31, $32, $33
6279 30 31 32 33 1 117 
627D 00 36 37 38 1 118 DEFB    $00, $36, $37, $38, $39, $3A, $3B, $3C
6281 39 3A 3B 3C 1 118 
6285 00 3F 40 41 1 119 DEFB    $00, $3F, $40, $41, $42, $43, $44, $45
6289 42 43 44 45 1 119 
628D             1 121 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 122 ; Graphics map indexes for the frame tiles
628D             1 123 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 124 FRAME_MAP:
628D 00 01 01 01 1 125 DEFB      0,   1,   1,   1,   1,   1,   2,   3
6291 01 01 02 03 1 125 
6295 04 FF FF FF 1 126 DEFB      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
6299 FF FF FF FF 1 126 
629D 05 06 07 01 1 127 DEFB      5,   6,   7,   1,   1,   1,   1,   1
62A1 01 01 01 01 1 127 
62A5 01 01 01 01 1 128 DEFB      1,   1,   1,   1,   1,   1,   1,   8
62A9 01 01 01 08 1 128 
62AD 09 01 01 01 1 129 DEFB      9,   1,   1,   1,   1,   1,   1,   1
62B1 01 01 01 01 1 129 
62B5 01 01 01 01 1 130 DEFB      1,   1,   1,   1,   1,   1,   1,   1
62B9 01 01 01 01 1 130 
62BD 0A 06 0D 0D 1 131 DEFB     10,   6,  13,  13,  13,   3,  11,   1
62C1 0D 03 0B 01 1 131 
62C5 01 01 01 01 1 132 DEFB      1,   1,   1,   1,   1,   1,   1,  12
62C9 01 01 01 0C 1 132 
62CD             1 134 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 135 ; Definition of a small "Opening Book" for speccy first move
62CD             1 136 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 137 OPENINGS:
62CD 0F 14 16 17 1 138 DEFB    $0F, $14, $16, $17, $18, $1C, $1D
62D1 18 1C 1D    1 138 
62D4 1E 1F 20 24 1 139 DEFB    $1E, $1F, $20, $24, $25, $26, $27
62D8 25 26 27    1 139 
62DB 28 29 2A 2E 1 140 DEFB    $28, $29, $2A, $2E, $2F, $30, $31
62DF 2F 30 31    1 140 
62E2 32 36 37 38 1 141 DEFB    $32, $36, $37, $38, $3A, $3F
62E6 3A 3F       1 141 
62E8             1 143 ; ----------------------------------------------------------------------------------------------------------------------
62E8             1 144 ; Timer variables
62E8             1 145 ; ----------------------------------------------------------------------------------------------------------------------
62E8 00          1 146 TIMER_FLAG              DEFB    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62E9             1 147 ; for each timer:
62E9             1 148 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62E9             1 149 ;   2nd byte = seconds counter
62E9             1 150 ;   3th byte = minutes counter
62E9 32 00 00    1 151 CYAN_TIMER              DEFB    50, 0, 0
62EC 32 00 00    1 152 RED_TIMER               DEFB    50, 0, 0
62EF             1 154 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 155 ; Screen addresses look-up array for board numbers
62EF             1 156 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 157 NUMBER_SCREEN:
62EF A5 43 E6 43 1 158 DEFW    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F3 27 4B 68 4B 1 158 
62F7 A9 4B EA 4B 1 158 
62FB 2B 53       1 158 
62FD FF FF FF    1 160 FILLER_1                DEFB    $FF, $FF, $FF               ; filler to align next block (not used)
6300             1 162 ;ORG     $6300
6300             1 163 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 164 ; Circular queue
6300             1 165 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 166 RED_QUEUE_AREA          DEFS    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 166 
6308 00 00 00 00 1 166 
630C 00 00 00 00 1 166 
6310 00 00 00 00 1 166 
6314 00 00 00 00 1 166 
6318 00 00 00 00 1 166 
631C 00 00 00 00 1 166 
6320 00 00 00 00 1 166 
6324 00 00 00 00 1 166 
6328 00 00 00 00 1 166 
632C 00 00 00 00 1 166 
6330 00 00 00 00 1 166 
6334 00 00 00 00 1 166 
6338 00 00 00 00 1 166 
633C 00 00 00 00 1 166 
6340 00 00 00 00 1 166 
6344 00 00 00 00 1 166 
6348 00 00 00 00 1 166 
634C 00 00 00 00 1 166 
6350 00 00 00 00 1 166 
6354 00 00 00 00 1 166 
6358 00 00 00 00 1 166 
635C 00 00 00 00 1 166 
6360 00 00 00 00 1 166 
6364 00 00 00 00 1 166 
6368 00 00 00 00 1 166 
636C 00 00 00 00 1 166 
6370 00 00 00 00 1 166 
6374 00 00 00 00 1 166 
6378 00 00 00 00 1 166 
637C 00 00 00 00 1 166 
6380 00 00 00 00 1 166 
6384 00 00 00 00 1 166 
6388 00 00 00 00 1 166 
638C 00 00 00 00 1 166 
6390 00 00 00 00 1 166 
6394 00 00 00 00 1 166 
6398 00 00 00 00 1 166 
639C 00 00 00 00 1 166 
63A0 00 00 00 00 1 166 
63A4 00 00 00 00 1 166 
63A8 00 00 00 00 1 166 
63AC 00 00 00 00 1 166 
63B0 00 00 00 00 1 166 
63B4 00 00 00 00 1 166 
63B8 00 00 00 00 1 166 
63BC 00 00 00 00 1 166 
63C0 00 00 00 00 1 166 
63C4 00 00 00 00 1 166 
63C8 00 00 00 00 1 166 
63CC 00 00 00 00 1 166 
63D0 00 00 00 00 1 166 
63D4 00 00 00 00 1 166 
63D8 00 00 00 00 1 166 
63DC 00 00 00 00 1 166 
63E0 00 00 00 00 1 166 
63E4 00 00 00 00 1 166 
63E8 00 00 00 00 1 166 
63EC 00 00 00 00 1 166 
63F0 00 00 00 00 1 166 
63F4 00 00 00 00 1 166 
63F8 00 00 00 00 1 166 
63FC 00 00 00 00 1 166 
6400             1 168 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 169 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 170 ; 
6400             1 171 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 172 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 173 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 174 ; 
6400             1 175 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 176 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 177 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 178 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 179 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 180 DEFB      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 180 
6408 7F 00 00 00 1 181 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 181 
6410 80          1 181 
6411 7F 00 00 00 1 182 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 182 
6419 81          1 182 
641A 7F 00 00 00 1 183 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 183 
6422 82          1 183 
6423 7F 00 00 00 1 184 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 184 
642B 83          1 184 
642C 7F 00 00 00 1 185 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 185 
6434 84          1 185 
6435 7F 00 00 00 1 186 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 186 
643D 85          1 186 
643E 7F 00 00 00 1 187 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 187 
6446 86          1 187 
6447 7F 7F 7F 7F 1 188 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 188 
644F 7F          1 188 
6450             1 189 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 190 DEFB    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 190 
6458 7F          1 190 
6459 81 00 00 00 1 191 DEFB       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 191 
6461 7F          1 191 
6462 82 00 00 00 1 192 DEFB          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 192 
646A 7F          1 192 
646B 83 00 00 00 1 193 DEFB             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 193 
6473 7F          1 193 
6474 84 00 00 00 1 194 DEFB                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 194 
647C 7F          1 194 
647D 85 00 00 00 1 195 DEFB                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 195 
6485 7F          1 195 
6486 86 00 00 00 1 196 DEFB                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 196 
648E 7F          1 196 
648F 7F 7F 7F 7F 1 197 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 197 
6497             1 199 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 200 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 201 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 202 TIMER_DIGITS:
6497 00 0F 0B 0B 1 203 DEFB    $00, $0F, $0B, $0B, $0B, $0F, $00, $00
649B 0B 0F 00 00 1 203 
649F 00 06 0E 06 1 204 DEFB    $00, $06, $0E, $06, $06, $06, $00, $00
64A3 06 06 00 00 1 204 
64A7 00 0F 03 0F 1 205 DEFB    $00, $0F, $03, $0F, $08, $0F, $00, $00
64AB 08 0F 00 00 1 205 
64AF 00 0F 03 07 1 206 DEFB    $00, $0F, $03, $07, $03, $0F, $00, $00
64B3 03 0F 00 00 1 206 
64B7 00 0B 0B 0F 1 207 DEFB    $00, $0B, $0B, $0F, $03, $03, $00, $00
64BB 03 03 00 00 1 207 
64BF 00 0F 08 0F 1 208 DEFB    $00, $0F, $08, $0F, $03, $0F, $00, $00
64C3 03 0F 00 00 1 208 
64C7 00 0F 0C 0F 1 209 DEFB    $00, $0F, $0C, $0F, $0D, $0F, $00, $00
64CB 0D 0F 00 00 1 209 
64CF 00 0F 03 03 1 210 DEFB    $00, $0F, $03, $03, $03, $03, $00, $00
64D3 03 03 00 00 1 210 
64D7 00 0F 0B 0F 1 211 DEFB    $00, $0F, $0B, $0F, $0B, $0F, $00, $00
64DB 0B 0F 00 00 1 211 
64DF 00 0F 0B 0F 1 212 DEFB    $00, $0F, $0B, $0F, $03, $0F, $00, $00
64E3 03 0F 00 00 1 212 
64E7             1 214 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 215 ; Tone parameters for sound effects
64E7             1 216 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 217 ; for each tone (from left to right):
64E7             1 218 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 219 ;   - length of a frame (1..65536)
64E7             1 220 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 221 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 222 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 223 TOKEN_FX                DEFW       1, 1000, 1400,   0
64EB 78 05 00 00 1 223 
64EF 05 00 88 13 1 224 WINNER_FX               DEFW       5, 5000,  200, 100
64F3 C8 00 64 00 1 224 
64F7 E8 03 0A 00 1 225 FILLED_FX               DEFW    1000,   10,  100,   0
64FB 64 00 00 00 1 225 
64FF FF          1 227 FILLER_2                DEFB    $FF                         ; filler to align next block (not used)
6500             1 229 ;ORG     $6500
6500             1 230 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 231 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 232 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 233 RED_VECTOR_TABLE:
6500 93 72       1 234 DEFW    PathFinder_RED_Edge_0
6502 C1 72       1 235 DEFW    PathFinder_RED_Edge_1
6504 E7 72       1 236 DEFW    PathFinder_RED_Edge_2
6506 0D 73       1 237 DEFW    PathFinder_RED_Edge_3
6508 33 73       1 238 DEFW    PathFinder_RED_Edge_4
650A 59 73       1 239 DEFW    PathFinder_RED_Edge_5
650C 7F 73       1 240 DEFW    PathFinder_RED_Edge_6
650E             1 242 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 243 ; Graphics for the screen frame
650E             1 244 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 245 FRAME_TILES:
650E 00 00 1F 3F 1 246 DEFB    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C
6512 3F 3F 3C 3C 1 246 
6516 00 00 FF FF 1 247 DEFB    $00, $00, $FF, $FF, $FF, $FF, $00, $00
651A FF FF 00 00 1 247 
651E 00 00 FF FE 1 248 DEFB    $00, $00, $FF, $FE, $FE, $FF, $00, $00
6522 FE FF 00 00 1 248 
6526 03 07 0F 0F 1 249 DEFB    $03, $07, $0F, $0F, $0F, $0F, $07, $03
652A 0F 0F 07 03 1 249 
652E FF FE FC FC 1 250 DEFB    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF
6532 FC FC FE FF 1 250 
6536 FF 7F 3F 3F 1 251 DEFB    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF
653A 3F 3F 7F FF 1 251 
653E C0 E0 F0 F0 1 252 DEFB    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0
6542 F0 F0 E0 C0 1 252 
6546 00 00 FF 7F 1 253 DEFB    $00, $00, $FF, $7F, $7F, $FF, $00, $00
654A 7F FF 00 00 1 253 
654E 00 00 F8 FC 1 254 DEFB    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C
6552 FC FC 3C 3C 1 254 
6556 3C 3C 3F 3F 1 255 DEFB    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00
655A 3F 1F 00 00 1 255 
655E 00 00 FE FF 1 256 DEFB    $00, $00, $FE, $FF, $FF, $FE, $00, $00
6562 FF FE 00 00 1 256 
6566 00 00 7F FF 1 257 DEFB    $00, $00, $7F, $FF, $FF, $7F, $00, $00
656A FF 7F 00 00 1 257 
656E 3C 3C FC FC 1 258 DEFB    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00
6572 FC F8 00 00 1 258 
6576 00 00 38 7C 1 259 DEFB    $00, $00, $38, $7C, $7C, $38, $00, $00
657A 7C 38 00 00 1 259 
657E             1 261 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 262 ; Hexagon sprites
657E             1 263 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 264 HEXAGON_EMPTY:
657E 07 E0 18 18 1 265 DEFB    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 265 
6586 48 02 48 02 1 266 DEFB    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 266 
658E 40 02 40 02 1 267 DEFB    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 267 
6596 20 24 20 04 1 268 DEFB    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 268 
659E             1 269 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 270 DEFB    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 270 
65A6 24 04 24 04 1 271 DEFB    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 271 
65AE 20 04 20 04 1 272 DEFB    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 272 
65B6 10 48 10 08 1 273 DEFB    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 273 
65BE 01 80 02 40 1 275 DEFB    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 275 
65C6 0A 10 0A 10 1 276 DEFB    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 276 
65CE 08 10 08 10 1 277 DEFB    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 277 
65D6 08 90 04 20 1 278 DEFB    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 278 
65DE 00 80 00 80 1 280 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 280 
65E6 00 80 00 80 1 281 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 281 
65EE 00 80 00 80 1 282 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 282 
65F6 00 80 00 80 1 283 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 283 
65FE 01 80 02 40 1 285 DEFB    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 285 
6606 0B D0 0B D0 1 286 DEFB    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 286 
660E 0B D0 0B D0 1 287 DEFB    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 287 
6616 0B D0 05 A0 1 288 DEFB    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 288 
661E 03 C0 0C 30 1 290 DEFB    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 290 
6626 2F F4 2F F4 1 291 DEFB    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 291 
662E 2F F4 2F F4 1 292 DEFB    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 292 
6636 17 E8 13 C8 1 293 DEFB    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 293 
663E             1 294 HEXAGON_TOKEN:
663E 07 E0 18 18 1 295 DEFB    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 295 
6646 5F FA 5F FA 1 296 DEFB    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 296 
664E 5F FA 5F FA 1 297 DEFB    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 297 
6656 2F F4 27 E4 1 298 DEFB    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 298 
665E             1 300 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 301 ; Board letter sprites
665E             1 302 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 303 LETTER_SPRITES:
665E 3C 7E FF C3 1 304 DEFB    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C
6662 F3 C3 D3 C3 1 304 
6666 7E 3C       1 304 
6668 3C 7E CF CF 1 305 DEFB    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C
666C C3 CB CB C3 1 305 
6670 7E 3C       1 305 
6672 3C 7E FF E3 1 306 DEFB    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C
6676 CF CF CF E3 1 306 
667A 7E 3C       1 306 
667C 3C 7E F3 F3 1 307 DEFB    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C
6680 C3 D3 D3 C3 1 307 
6684 7E 3C       1 307 
6686 3C 7E FF E3 1 308 DEFB    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C
668A CB C3 CF E3 1 308 
668E 7E 3C       1 308 
6690 3C 7E E3 CF 1 309 DEFB    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C
6694 C7 CF CF CF 1 309 
6698 7E 3C       1 309 
669A 3C 7E FF E3 1 310 DEFB    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C
669E D3 D3 E3 F3 1 310 
66A2 46 3C       1 310 
66A4             1 312 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 313 ; Board number sprites
66A4             1 314 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 315 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 316 DEFB    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C
66A8 E7 E7 E7 E7 1 316 
66AC 7E 3C       1 316 
66AE 3C 7E E7 D3 1 317 DEFB    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C
66B2 F3 E7 CF C3 1 317 
66B6 7E 3C       1 317 
66B8 3C 7E C7 F3 1 318 DEFB    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C
66BC E3 F3 F3 C7 1 318 
66C0 7E 3C       1 318 
66C2 3C 7E D3 D3 1 319 DEFB    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C
66C6 C3 F3 F3 F3 1 319 
66CA 7E 3C       1 319 
66CC 3C 7E C3 CF 1 320 DEFB    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C
66D0 C7 F3 F3 C7 1 320 
66D4 7E 3C       1 320 
66D6 3C 7E E3 CF 1 321 DEFB    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C
66DA C3 CB CB C3 1 321 
66DE 7E 3C       1 321 
66E0 3C 7E C3 F3 1 322 DEFB    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C
66E4 F3 E7 E7 E7 1 322 
66E8 7E 3C       1 322 
66EA             1 324 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 325 ; Screen addresses for menu hexagons
66EA             1 326 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 327 MENU_HEXAGONS:
66EA 01 40 05 40 1 328 DEFW    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 328 
66F2 0F 40 13 40 1 328 
66F6 1A 40       1 328 
66F8 45 40 48 40 1 329 DEFW    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 329 
6700 81 40 83 40 1 329 
6704 85 40       1 329 
6706 88 40 8A 40 1 330 DEFW    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 330 
670E C1 40 D0 40 1 330 
6712 D9 40       1 330 
6714 05 48 08 48 1 331 DEFW    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 331 
671C 19 48 1B 48 1 331 
6720 1D 48       1 331 
6722 0A 40 59 40 1 332 DEFW    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 332 
672A D2 40 0C 48 1 332 
672E 1C 40       1 332 
6730 41 40 50 40 1 333 DEFW    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 333 
6738 0F 48       1 333 
673A             1 334 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 335 DEFW    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 335 
6742 EF 40 F1 40 1 335 
6746 B2 40       1 335 
6748 E9 40 6F 48 1 336 DEFW    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 336 
6750 AA 48 AC 40 1 336 
6754 EF 48       1 336 
6756 2A 48 6D 48 1 337 DEFW    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 337 
675E             1 338 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 339 DEFW    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 339 
6766 AE 48 EF 48 1 339 
676A 2E 50       1 339 
676C AC 48 B4 48 1 340 DEFW    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 340 
6774 2E 48 F1 40 1 340 
6778 F3 40       1 340 
677A 73 48 B2 48 1 341 DEFW    $4873, $48B2, $5030
677E 30 50       1 341 
6780             1 343 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 344 ; Strings
6780             1 345 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 346 STR_OPTIONS:
6780 53 74 61 72 1 347 DEFM    "Start new game\0"
6784 74 20 6E 65 1 347 
6788 77 20 67 61 1 347 
678C 6D 65 00    1 347 
678F 48 6F 77 20 1 348 DEFM    "How to play\0"
6793 74 6F 20 70 1 348 
6797 6C 61 79 00 1 348 
679B 43 72 65 64 1 349 DEFM    "Credits\0"
679F 69 74 73 00 1 349 
67A3             1 350 STR_CREDITS:
67A3 44 65 73 69 1 351 DEFM    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 351 
67AB 20 20 20 20 1 351 
67AF 41 6E 74 6F 1 351 
67B3 6E 69 6F 20 1 351 
67B7 4C 75 71 75 1 351 
67BB 65 00       1 351 
67BD 43 6F 64 65 1 352 DEFM    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 352 
67C5 20 20 20 20 1 352 
67C9 41 6E 74 6F 1 352 
67CD 6E 69 6F 20 1 352 
67D1 4C 75 71 75 1 352 
67D5 65 00       1 352 
67D7 20 20 20 20 1 353 DEFM    "            Einar Saukas\0"
67DB 20 20 20 20 1 353 
67DF 20 20 20 20 1 353 
67E3 45 69 6E 61 1 353 
67E7 72 20 53 61 1 353 
67EB 75 6B 61 73 1 353 
67EF 00          1 353 
67F0 46 6F 6E 74 1 354 DEFM    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 354 
67F8 20 20 20 20 1 354 
67FC 45 69 6E 61 1 354 
6800 72 20 53 61 1 354 
6804 75 6B 61 73 1 354 
6808 00          1 354 
6809 47 72 61 70 1 355 DEFM    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 355 
6811 3A 20 20 20 1 355 
6815 45 69 6E 61 1 355 
6819 72 20 53 61 1 355 
681D 75 6B 61 73 1 355 
6821 00          1 355 
6822 20 20 20 20 1 356 DEFM    "            Antonio Luque\0"
6826 20 20 20 20 1 356 
682A 20 20 20 20 1 356 
682E 41 6E 74 6F 1 356 
6832 6E 69 6F 20 1 356 
6836 4C 75 71 75 1 356 
683A 65 00       1 356 
683C 50 72 65 73 1 357 STR_PRESSKEY            DEFM    "Press any key\0"
6840 73 20 61 6E 1 357 
6844 79 20 6B 65 1 357 
6848 79 00       1 357 
684A             1 358 STR_BUTTONS:
684A 4E 65 78 74 1 359 DEFM    "Next\0"
684E 00          1 359 
684F 42 61 63 6B 1 360 DEFM    "Back\0"
6853 00          1 360 
6854 52 45 44 00 1 361 STR_RED                 DEFM    "RED\0"
6858 43 59 41 4E 1 362 STR_CYAN                DEFM    "CYAN\0"
685C 00          1 362 
685D 43 6F 6E 6E 1 363 STR_HELP1               DEFM    "Connect\0"
6861 65 63 74 00 1 363 
6865 6C 65 66 74 1 364 STR_HELP2_RED           DEFM    "left and\0"
6869 20 61 6E 64 1 364 
686D 00          1 364 
686E 75 70 20 61 1 365 STR_HELP2_CYAN          DEFM    "up and\0"
6872 6E 64 00    1 365 
6875 72 69 67 68 1 366 STR_HELP3_RED           DEFM    "right\0"
6879 74 00       1 366 
687B 64 6F 77 6E 1 367 STR_HELP3_CYAN          DEFM    "down\0"
687F 00          1 367 
6880 62 6F 72 64 1 368 STR_HELP4               DEFM    "borders\0"
6884 65 72 73 00 1 368 
6888 74 6F 20 77 1 369 STR_HELP5               DEFM    "to win\0"
688C 69 6E 00    1 369 
688F             1 370 STR_HELP:
688F 57 69 6E 20 1 371 DEFM    "Win three\0"
6893 74 68 72 65 1 371 
6897 65 00       1 371 
6899 74 69 6D 65 1 372 DEFM    "times in\0"
689D 73 20 69 6E 1 372 
68A1 00          1 372 
68A2 61 20 72 6F 1 373 DEFM    "a row to\0"
68A6 77 20 74 6F 1 373 
68AA 00          1 373 
68AB 6C 65 76 65 1 374 DEFM    "level up\0"
68AF 6C 20 75 70 1 374 
68B3 00          1 374 
68B4 20 43 4F 4E 1 375 STR_CONGRATS            DEFM    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 375 
68BC 55 4C 41 54 1 375 
68C0 49 4F 4E 53 1 375 
68C4 20 00       1 375 
68C6             1 376 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 377 DEFM    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 377 
68CE 65 21 20 4C 1 377 
68D2 61 73 74 20 1 377 
68D6 6C 65 76 65 1 377 
68DA 6C 20 70 61 1 377 
68DE 73 73 65 64 1 377 
68E2 00          1 377 
68E3 43 68 6F 6F 1 378 DEFM    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 378 
68EB 65 76 65 6C 1 378 
68EF 20 74 6F 20 1 378 
68F3 72 65 73 74 1 378 
68F7 61 72 74 2C 1 378 
68FB 20 31 2D 34 1 378 
68FF 00          1 378 
6900             1 380 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 381 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 382 ; this font was designed by Einar Saukas for Hex game
6900             1 383 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 384 FONT:
6900 00 00 00 00 1 385 INCLUDEBIN "King+.bin"
6904 00 00 00 00 1 385 
6908 00 18 18 18 1 385 
690C 00 18 18 00 1 385 
6910 00 24 24 00 1 385 
6914 00 00 00 00 1 385 
6918 00 24 7E 24 1 385 
691C 24 7E 24 00 1 385 
6920 00 08 3E 28 1 385 
6924 3E 0A 3E 08 1 385 
6928 00 62 64 08 1 385 
692C 10 26 46 00 1 385 
6930 00 10 28 10 1 385 
6934 2A 44 3A 00 1 385 
6938 00 18 30 00 1 385 
693C 00 00 00 00 1 385 
6940 06 0C 08 08 1 385 
6944 08 0C 06 00 1 385 
6948 60 30 10 10 1 385 
694C 10 30 60 00 1 385 
6950 00 00 14 08 1 385 
6954 3E 08 14 00 1 385 
6958 00 00 08 08 1 385 
695C 3E 08 08 00 1 385 
6960 00 00 00 00 1 385 
6964 00 0C 18 30 1 385 
6968 00 00 00 7E 1 385 
696C 7E 00 00 00 1 385 
6970 00 00 00 00 1 385 
6974 30 70 70 00 1 385 
6978 02 06 0C 18 1 385 
697C 30 60 40 00 1 385 
6980 00 7E 62 62 1 385 
6984 62 62 7E 00 1 385 
6988 00 18 38 18 1 385 
698C 18 18 3C 00 1 385 
6990 00 38 4C 4C 1 385 
6994 18 30 7C 00 1 385 
6998 00 3C 62 0C 1 385 
699C 06 66 3C 00 1 385 
69A0 00 30 30 30 1 385 
69A4 30 34 3E 04 1 385 
69A8 00 7E 60 7E 1 385 
69AC 06 66 3C 00 1 385 
69B0 00 30 60 7C 1 385 
69B4 66 66 3C 00 1 385 
69B8 00 7E 46 0C 1 385 
69BC 18 30 60 00 1 385 
69C0 00 3C 66 3C 1 385 
69C4 66 66 3C 00 1 385 
69C8 00 3C 66 66 1 385 
69CC 3E 06 3C 00 1 385 
69D0 00 00 08 18 1 385 
69D4 00 08 18 00 1 385 
69D8 00 00 04 0C 1 385 
69DC 00 0C 18 30 1 385 
69E0 00 00 04 08 1 385 
69E4 10 08 04 00 1 385 
69E8 00 00 00 3E 1 385 
69EC 00 3E 00 00 1 385 
69F0 00 00 10 08 1 385 
69F4 04 08 10 00 1 385 
69F8 00 3C 42 04 1 385 
69FC 08 00 08 00 1 385 
6A00 00 3C 4A 56 1 385 
6A04 5E 40 3C 00 1 385 
6A08 00 7E 46 46 1 385 
6A0C 7E 46 46 00 1 385 
6A10 00 7C 62 7C 1 385 
6A14 62 62 7C 00 1 385 
6A18 00 7E 66 60 1 385 
6A1C 60 66 7E 00 1 385 
6A20 00 7C 46 46 1 385 
6A24 46 46 7C 00 1 385 
6A28 00 7E 60 7C 1 385 
6A2C 60 60 7E 00 1 385 
6A30 00 7E 60 7C 1 385 
6A34 60 60 60 00 1 385 
6A38 00 3E 62 60 1 385 
6A3C 66 66 3E 00 1 385 
6A40 00 62 62 7E 1 385 
6A44 62 62 62 00 1 385 
6A48 00 18 18 18 1 385 
6A4C 18 18 18 00 1 385 
6A50 00 0C 0C 0C 1 385 
6A54 0C 4C 38 00 1 385 
6A58 00 66 64 68 1 385 
6A5C 7E 46 66 00 1 385 
6A60 00 60 60 60 1 385 
6A64 60 60 7E 00 1 385 
6A68 00 7E 56 56 1 385 
6A6C 56 56 56 00 1 385 
6A70 00 7E 46 46 1 385 
6A74 46 46 46 00 1 385 
6A78 00 7E 62 62 1 385 
6A7C 62 62 7E 00 1 385 
6A80 00 7E 62 62 1 385 
6A84 7E 60 60 00 1 385 
6A88 00 7C 64 64 1 385 
6A8C 64 64 7E 00 1 385 
6A90 00 7C 62 64 1 385 
6A94 7C 46 46 00 1 385 
6A98 00 7E 60 7E 1 385 
6A9C 06 06 7E 00 1 385 
6AA0 00 7E 18 18 1 385 
6AA4 18 18 18 00 1 385 
6AA8 00 62 62 62 1 385 
6AAC 62 62 7E 00 1 385 
6AB0 00 62 62 62 1 385 
6AB4 62 34 18 00 1 385 
6AB8 00 6A 6A 6A 1 385 
6ABC 6A 6A 7E 00 1 385 
6AC0 00 62 62 34 1 385 
6AC4 4E 46 46 00 1 385 
6AC8 00 62 62 7E 1 385 
6ACC 18 18 18 00 1 385 
6AD0 00 7E 06 1C 1 385 
6AD4 38 60 7E 00 1 385 
6AD8 00 0E 08 08 1 385 
6ADC 08 08 0E 00 1 385 
6AE0 00 00 40 20 1 385 
6AE4 10 08 04 00 1 385 
6AE8 00 70 10 10 1 385 
6AEC 10 10 70 00 1 385 
6AF0 00 08 1C 2A 1 385 
6AF4 08 08 08 08 1 385 
6AF8 00 00 00 00 1 385 
6AFC 00 00 00 FF 1 385 
6B00 0C 12 10 38 1 385 
6B04 10 10 3E 00 1 385 
6B08 00 00 3C 06 1 385 
6B0C 7E 46 7E 00 1 385 
6B10 00 60 60 7E 1 385 
6B14 62 62 7E 00 1 385 
6B18 00 00 7E 62 1 385 
6B1C 60 62 7E 00 1 385 
6B20 00 06 06 7E 1 385 
6B24 46 46 7E 00 1 385 
6B28 00 00 7E 46 1 385 
6B2C 7E 60 7E 00 1 385 
6B30 00 1E 30 3C 1 385 
6B34 30 30 30 00 1 385 
6B38 00 00 7E 46 1 385 
6B3C 46 3E 06 3E 1 385 
6B40 00 60 60 7C 1 385 
6B44 66 66 66 00 1 385 
6B48 00 18 00 38 1 385 
6B4C 18 18 3C 00 1 385 
6B50 00 0C 00 0C 1 385 
6B54 0C 0C 4C 38 1 385 
6B58 00 20 2C 38 1 385 
6B5C 38 2C 26 00 1 385 
6B60 00 18 18 18 1 385 
6B64 18 18 0E 00 1 385 
6B68 00 00 6C 56 1 385 
6B6C 56 56 46 00 1 385 
6B70 00 00 7C 46 1 385 
6B74 46 46 46 00 1 385 
6B78 00 00 3C 46 1 385 
6B7C 46 46 3C 00 1 385 
6B80 00 00 7C 66 1 385 
6B84 66 7C 60 60 1 385 
6B88 00 00 3E 46 1 385 
6B8C 46 3E 06 06 1 385 
6B90 00 00 3C 62 1 385 
6B94 60 60 60 00 1 385 
6B98 00 00 3C 60 1 385 
6B9C 3C 06 3C 00 1 385 
6BA0 00 30 78 30 1 385 
6BA4 30 30 1C 00 1 385 
6BA8 00 00 46 46 1 385 
6BAC 46 46 3C 00 1 385 
6BB0 00 00 46 46 1 385 
6BB4 2C 3C 18 00 1 385 
6BB8 00 00 46 56 1 385 
6BBC 56 56 2C 00 1 385 
6BC0 00 00 46 2C 1 385 
6BC4 18 2C 46 00 1 385 
6BC8 00 00 46 46 1 385 
6BCC 46 3E 06 3C 1 385 
6BD0 00 00 7E 0C 1 385 
6BD4 18 30 7E 00 1 385 
6BD8 00 0E 08 30 1 385 
6BDC 08 08 0E 00 1 385 
6BE0 00 08 08 08 1 385 
6BE4 08 2A 1C 08 1 385 
6BE8 00 70 10 0C 1 385 
6BEC 10 10 70 00 1 385 
6BF0 00 14 28 00 1 385 
6BF4 00 00 00 00 1 385 
6BF8 FF 81 81 81 1 385 
6BFC 81 81 81 FF 1 385 

; File #2: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Main.z80asm

6C00             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 2 ; Main.z80asm
6C00             2 3 ; Coded by Antonio Luque
6C00             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 6 CYAN_COLOR              EQU     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6C00             2 7 RED_COLOR               EQU     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6C00             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 10 ; Entry point of the program - Initialization
6C00             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 12 Main                    ENT     $                           ; SpectNet IDE pragma: defines the entry code of the program
6C00 F3          2 14 di                                  ; disable interrupts
6C01             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6C01 21 2A 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6C04 FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C08 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C0B FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C0E 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C10 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C12 ED 5E       2 24 im      2                           ; set interrupt mode 2
6C14             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C14             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C14             2 28 ; resultant vector address is formed as follows:
6C14             2 29 ;
6C14             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C14             2 31 ; Source: 
6C14             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
6C14             2 33 ;
6C14             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C14             2 35 ; memory area and it is used by some ROM routines, but none of them are called by HEX2 program.
6C14 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C17 AF          2 39 xor     a                           ; set border color (black)
6C18 D3 FE       2 40 out     ($FE), a
6C1A CD 81 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C1D             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 44 ; Start new game
6C1D             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 46 Main_Start
6C1D CD 16 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C20 CD 23 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C23 CD 4F 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C26 CD 8E 77    2 50 call    Screen_Frame                ; draw the screen frame
6C29 CD E6 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C2C CD 05 78    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C2F CD 48 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C32 FB          2 55 ei                                  ; enable interrupts
6C33             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 58 ; New level
6C33             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 60 Main_New_Level
6C33 3E 04       2 61 ld      a, 4                        ; maximum level
6C35 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C38 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C39 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C3B CD 82 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C3E 18 DD       2 66 jr      Main_Start                  ; start a new game
6C40             2 67 Main_Increment_Level
6C40 34          2 68 inc     (hl)                        ; increment game level
6C41 CD 25 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C44 CD 14 79    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C47 AF          2 71 xor     a                           ; initialize three-in-a-row counter
6C48 32 0E 62    2 72 ld      (THREE_ROW), a
6C4B             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 75 ; Start new match
6C4B             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 77 Main_Start_Match
6C4B             2 78 ; set up timers and clear last messages
6C4B CD BF 76    2 80 call    Timer_Reset                 ; reset timers
6C4E CD AA 76    2 81 call    Timer_Display_All           ; display timers
6C51 CD 0A 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C54 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C56 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C59 CD 34 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C5C             2 87 ; swap players' colors
6C5C 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C5F EE 07       2 90 xor     %00000111                   ; swap color
6C61 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C64 CD EC 6E    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C67             2 94 ; initialize positions and draw empty board
6C67 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C6A 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C6D 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C6F 01 FF 01    2 99 ld      bc, 256*2-1                 ; length of cyan + red positions areas (-1 already set)
6C72 ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C74 CD 9C 6D    2 101 call    Draw_Board                  ; draw an empty hexagons board
6C77             2 103 ; initialize draw token delay, move number and token color
6C77 3E 0A       2 105 ld      a, 10                       ; set delay duration for animate hexagons
6C79 32 CB 6D    2 106 ld      (@Token_Delay+1), a
6C7C 3E 01       2 107 ld      a, 1                        ; initialize move number
6C7E 32 9B 61    2 108 ld      (MOVE_NUMBER), a
6C81 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C83             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 112 ; Process players moves - Match loop
6C83             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 114 Main_Match_Loop
6C83             2 115 ; check player turn
6C83 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C86 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C89 BE          2 119 cp      (hl)                        ; check player color
6C8A CC 2E 6D    2 120 call    z, Main_GetPlayer_Move      ; if player color = current token color, get player move
6C8D C4 E3 6C    2 121 call    nz, Main_GetSpeccy_Move     ; else, get speccy move (previous call always set Z flag)
6C90             2 123 ; update positions with player/speccy move
6C90 CD F4 70    2 125 call    PathFinder_Friend           ; get player/speccy side
6C93 CD FD 70    2 126 call    PathFinder_PutToken         ; put token on cyan and red positions
6C96             2 128 ; draw token on the board
6C96 AF          2 130 xor     a                           ; stop timers
6C97 32 E8 62    2 131 ld      (TIMER_FLAG), a
6C9A CD B7 6D    2 132 call    Draw_Token                  ; animate hexagon sprite on the screen
6C9D DD 21 E7 64 2 133 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6CA1 CD D4 76    2 134 call    Sound_FX                    ; play sound effect
6CA4             2 136 ; check for a winner
6CA4 CD A6 75    2 138 call    PathFinder_VictoryPath      ; check current player victory path
6CA7 3C          2 139 inc     a                           ; is there a victory path?
6CA8 20 0C       2 140 jr      nz, Main_Match_End          ; yes, match ends
6CAA 21 9B 61    2 142 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CAD 34          2 143 inc     (hl)                        ; increment move number
6CAE             2 145 ; swap players' token color
6CAE 3A 9E 61    2 147 ld      a, (TOKEN_COLOR)            ; get current token color
6CB1 EE 07       2 148 xor     %00000111                   ; swap token color
6CB3 C3 83 6C    2 149 jp      Main_Match_Loop             ; repeat match loop
6CB6             2 151 ; ----------------------------------------------------------------------------------------------------------------------
6CB6             2 152 ; Current player wins the match
6CB6             2 153 ; ----------------------------------------------------------------------------------------------------------------------
6CB6             2 154 Main_Match_End
6CB6 CD DC 75    2 155 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CB9 11 3A 62    2 157 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CBC CD 12 6F    2 158 call    Print_Alert                 ; print string
6CBF 3A 9E 61    2 160 ld      a, (TOKEN_COLOR)            ; get current token color
6CC2 21 9F 61    2 161 ld      hl, PLAYER_COLOR            ; get player color
6CC5 BE          2 162 cp      (hl)                        ; is player color = current token color?
6CC6 21 0E 62    2 163 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CC9 28 04       2 164 jr      z, Main_ThreeRow_Increment  ; yes, go to increment three-in-a-row counter
6CCB 35          2 165 dec     (hl)                        ; decrement three-in-a-row counter
6CCC F2 D0 6C    2 166 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CCF             2 167 Main_ThreeRow_Increment
6CCF 34          2 168 inc     (hl)                        ; increment three-in-a-row counter
6CD0             2 169 Main_ThreeRow_Show
6CD0 CD F8 78    2 170 call    Screen_ThreeRow             ; show three-in-a-row marks
6CD3 3E FF       2 171 ld      a, 255                      ; set delay duration
6CD5 CD 8C 6D    2 172 call    Main_Delay                  ; execute delay
6CD8 3A 0E 62    2 173 ld      a, (THREE_ROW)              ; check three row counter
6CDB FE 03       2 174 cp      3                           ; is it 3?
6CDD CA 33 6C    2 175 jp      z, Main_New_Level           ; yes, start a new level
6CE0 C3 4B 6C    2 176 jp      Main_Start_Match            ; start a new match
6CE3             2 178 ; ----------------------------------------------------------------------------------------------------------------------
6CE3             2 179 ; Main_GetSpeccy_Move: get the speccy move
6CE3             2 180 ;
6CE3             2 181 ; Input:     A = current token color
6CE3             2 182 ;
6CE3             2 183 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CE3             2 184 ;           HL = CYAN_POSITIONS move address
6CE3             2 185 ;
6CE3             2 186 ; Uses:     MOVE_NUMBER (current move number)
6CE3             2 187 ;           GAME_LEVEL (current game level)
6CE3             2 188 ;           AI_DEPTH (recursion depth level)
6CE3             2 189 ;           STR_MOVE (formatted move string)
6CE3             2 190 ;
6CE3             2 191 ; Destroys: A, DE, IX, IY
6CE3             2 192 ; ----------------------------------------------------------------------------------------------------------------------
6CE3             2 193 Main_GetSpeccy_Move:
6CE3 E6 03       2 194 and     %00000011                   ; calculate speccy's timer flag based on current token color
6CE5 32 E8 62    2 195 ld      (TIMER_FLAG), a             ; (re)start speccy timer
6CE8 CD 2C 6F    2 197 call    Print_Wait                  ; print "WAIT" message
6CEB 3A 9B 61    2 198 ld      a, (MOVE_NUMBER)            ; get move number
6CEE 3D          2 199 dec     a                           ; is it cyan first move?
6CEF 28 2A       2 200 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CF1 DD 21 00 7F 2 202 ld      ix, CANDIDATES              ; IX points to candidates list address
6CF5 3A 9D 61    2 203 ld      a, (GAME_LEVEL)             ; get game level
6CF8 32 9A 61    2 204 ld      (AI_DEPTH), a               ; save recursion depth level
6CFB CD F4 70    2 205 call    PathFinder_Friend           ; get speccy side
6CFE CD 80 6F    2 206 call    BRAINIAC_best_move          ; get speccy best move
6D01 6B          2 207 ld      l, e                        ; set node index in L
6D02             2 208 Main_GetSpeccy_Positions
6D02 26 7D       2 209 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D04 E5          2 210 push    hl                          ; store CYAN_POSITIONS move address
6D05 CD 7A 6D    2 211 call    Main_Board2Indexes          ; convert board position to indexes
6D08 78          2 212 ld      a, b                        ; get 1..7 column
6D09 C6 60       2 213 add     a, $60                      ; adjust to charset ('a'..'g')
6D0B 32 15 62    2 214 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D0E 79          2 215 ld      a, c                        ; get 1..7 row
6D0F C6 30       2 216 add     a, $30                      ; adjust to charset ('1'..'7')
6D11 32 18 62    2 217 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D14 C5          2 218 push    bc                          ; store hexagon board indexes
6D15 CD 3C 6F    2 219 call    Print_Move                  ; print Speccy move
6D18 C1          2 220 pop     bc                          ; restore hexagon board indexes
6D19 E1          2 221 pop     hl                          ; restore CYAN_POSITIONS move address
6D1A C9          2 222 ret
6D1B             2 223 Main_GetSpeccy_Book
6D1B ED 5F       2 224 ld      a, r                        ; get a pseudo-random number (0..127)
6D1D E6 1F       2 225 and     %00011111                   ; number is in range (0..31)
6D1F FE 1B       2 226 cp      27                          ; is it >= 27?
6D21 30 F8       2 227 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D23 21 CD 62    2 228 ld      hl, OPENINGS                ; HL points to opening book address
6D26 16 00       2 229 ld      d, 0                        ; set index in DE
6D28 5F          2 230 ld      e, a
6D29 19          2 231 add     hl, de                      ; HL points to move index address
6D2A 6E          2 232 ld      l, (hl)                     ; get move from opening book
6D2B C3 02 6D    2 233 jp      Main_GetSpeccy_Positions    ; get speccy move positions
6D2E             2 235 ; ----------------------------------------------------------------------------------------------------------------------
6D2E             2 236 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D2E             2 237 ;
6D2E             2 238 ; Input:     A = current token color
6D2E             2 239 ;
6D2E             2 240 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D2E             2 241 ;           HL = CYAN_POSITIONS move address
6D2E             2 242 ;           Z  = flag set
6D2E             2 243 ;
6D2E             2 244 ; Uses:     STR_MOVE (formatted move string)
6D2E             2 245 ;
6D2E             2 246 ; Destroys: A, DE, IX
6D2E             2 247 ; ----------------------------------------------------------------------------------------------------------------------
6D2E             2 248 Main_GetPlayer_Move:
6D2E E6 03       2 249 and     %00000011                   ; calculate player's timer flag based on current token color
6D30 32 E8 62    2 250 ld      (TIMER_FLAG), a             ; (re)start player timer
6D33             2 251 Main_GetPlayer_Input
6D33 CD 34 6F    2 252 call    Print_Clear_Move            ; clear player last move
6D36 CD 26 6E    2 253 call    Input_Move                  ; wait for input player move
6D39 CD 3C 6F    2 254 call    Print_Move                  ; print player move
6D3C 3A 15 62    2 256 ld      a, (STR_MOVE+0)             ; get column ('a'..'g')
6D3F D6 60       2 257 sub     $60                         ; convert to number (1..7)
6D41 47          2 258 ld      b, a                        ; set column index in B
6D42 3A 18 62    2 259 ld      a, (STR_MOVE+3)             ; get row ('1'..'7')
6D45 D6 30       2 260 sub     $30                         ; convert to number (1..7)
6D47 4F          2 261 ld      c, a                        ; set row index in C
6D48 11 4D 62    2 262 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D4B CD 6D 6D    2 263 call    Main_Search_Table           ; search board position in board coordinates
6D4E 6E          2 264 ld      l, (hl)                     ; set board position of player move
6D4F 26 7D       2 265 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D51 3E 00       2 266 ld      a, EMPTY                    ; check position
6D53 BE          2 267 cp      (hl)                        ; is position empty?
6D54 C8          2 268 ret     z                           ; yes, return with Z flag set
6D55             2 270 ; illegal player move (position not empty)
6D55 11 2E 62    2 272 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D58 CD 12 6F    2 273 call    Print_Alert                 ; print string
6D5B DD 21 F7 64 2 274 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D5F CD D4 76    2 275 call    Sound_FX                    ; play sound fx
6D62 3E 50       2 276 ld      a, 80                       ; set delay counter
6D64 CD 8C 6D    2 277 call    Main_Delay                  ; execute delay
6D67 CD 0A 6F    2 278 call    Print_Clear_Alert           ; clear alert message
6D6A C3 33 6D    2 279 jp      Main_GetPlayer_Input        ; repeat player input until move is legal
6D6D             2 281 ; ----------------------------------------------------------------------------------------------------------------------
6D6D             2 282 ; Main_Search_Table: search an element in a 8x8 bytes table
6D6D             2 283 ;
6D6D             2 284 ; Input:    BC = element indexes (B = column, C = row)
6D6D             2 285 ;           DE = table address in which to search for the element
6D6D             2 286 ;
6D6D             2 287 ; Output:   DE = address of first element in the C row of the table
6D6D             2 288 ;           HL = address of the element in the BC indexes of the table
6D6D             2 289 ;
6D6D             2 290 ; Destroys: -
6D6D             2 291 ; ----------------------------------------------------------------------------------------------------------------------
6D6D             2 292 Main_Search_Table:
6D6D 26 00       2 293 ld      h, 0                        ; first, get the C row in table
6D6F 69          2 294 ld      l, c                        ; set index in HL
6D70 29          2 295 add     hl, hl                      ; a row is 8 bytes long
6D71 29          2 296 add     hl, hl
6D72 29          2 297 add     hl, hl
6D73 19          2 298 add     hl, de                      ; HL points to the address of C row 
6D74 EB          2 299 ex      de, hl                      ; DE points to the address of C row
6D75 26 00       2 300 ld      h, 0                        ; go for to the B column
6D77 68          2 301 ld      l, b                        ; set index in HL
6D78 19          2 302 add     hl, de                      ; HL points to the address of BC indexes
6D79 C9          2 303 ret
6D7A             2 305 ; ----------------------------------------------------------------------------------------------------------------------
6D7A             2 306 ; Main_Board2Indexes: convert a board position into a board indexes
6D7A             2 307 ;
6D7A             2 308 ; Input:    L  = board position
6D7A             2 309 ;
6D7A             2 310 ; Output:   BC = board indexes (B = column, C = row)
6D7A             2 311 ;
6D7A             2 312 ; Destroys: HL
6D7A             2 313 ; ----------------------------------------------------------------------------------------------------------------------
6D7A             2 314 Main_Board2Indexes:
6D7A 7D          2 315 ld      a, l                        ; set board position in A to compare later
6D7B 21 8D 62    2 317 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D7E 0E 07       2 318 ld      c, 7                        ; 7 rows
6D80             2 319 Main_Board2Indexes_Row
6D80 06 07       2 320 ld      b, 7                        ; 7 columns
6D82             2 321 Main_Board2Indexes_Col
6D82 2B          2 322 dec     hl                          ; move HL to next board position address
6D83 BE          2 323 cp      (hl)                        ; is A the position?
6D84 C8          2 324 ret     z                           ; yes, return board indexes
6D85 10 FB       2 325 djnz    Main_Board2Indexes_Col      ; repeat for each column
6D87 2B          2 326 dec     hl                          ; skip borders
6D88 0D          2 327 dec     c                           ; decrement row
6D89 C3 80 6D    2 328 jp      Main_Board2Indexes_Row      ; loop until find position
6D8C             2 330 ; ----------------------------------------------------------------------------------------------------------------------
6D8C             2 331 ; Main_Delay: execute a delay
6D8C             2 332 ;
6D8C             2 333 ; Input:    A = delay counter
6D8C             2 334 ;
6D8C             2 335 ; Output:   -
6D8C             2 336 ;
6D8C             2 337 ; Destroys: A
6D8C             2 338 ; ----------------------------------------------------------------------------------------------------------------------
6D8C             2 339 Main_Delay:
6D8C C5          2 340 push    bc                          ; store BC register
6D8D             2 341 Main_Delay_Outer
6D8D F5          2 342 push    af                          ; store delay counter (outer loop)
6D8E 01 40 06    2 343 ld      bc, 1600                    ; set inner loop counter in BC
6D91             2 344 Main_Delay_Inner
6D91 0B          2 345 dec     bc                          ; decrement inner loop counter
6D92 78          2 346 ld      a, b                        ; check inner loop counter
6D93 B1          2 347 or      c
6D94 20 FB       2 348 jr      nz, Main_Delay_Inner        ; repeat until inner loop counter = 0
6D96 F1          2 349 pop     af                          ; restore delay counter
6D97 3D          2 350 dec     a                           ; decrement delay counter
6D98 20 F3       2 351 jr      nz, Main_Delay_Outer        ; repeat until delay counter = 0
6D9A C1          2 352 pop     bc                          ; restore BC register
6D9B C9          2 353 ret

; File #3: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Draw.z80asm

6D9C             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6D9C             3 2 ; Draw.z80asm
6D9C             3 3 ; Coded by Antonio Luque
6D9C             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6D9C             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6D9C             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6D9C             3 8 ;
6D9C             3 9 ; Input:    -
6D9C             3 10 ;
6D9C             3 11 ; Output:   -
6D9C             3 12 ;
6D9C             3 13 ; Uses:     TOKEN_COLOR (current token color)
6D9C             3 14 ;
6D9C             3 15 ; Destroys: A, BC, DE, HL, IXL
6D9C             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6D9C             3 17 Draw_Board:
6D9C 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6D9E 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6DA1 0E 07       3 20 ld      c, 7                        ; 7 rows
6DA3             3 21 Draw_Board_Row
6DA3 06 07       3 22 ld      b, 7                        ; 7 columns
6DA5             3 23 Draw_Board_Column
6DA5 CD D2 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DA8 CD 0A 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DAB 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DAE CD DC 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DB1 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DB3 0D          3 29 dec     c                           ; decrement row
6DB4 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DB6 C9          3 31 ret
6DB7             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DB7             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DB7             3 35 ;
6DB7             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DB7             3 37 ;
6DB7             3 38 ; Output:   -
6DB7             3 39 ;
6DB7             3 40 ; Destroys: A, BC, DE, HL, IXL
6DB7             3 41 ; ----------------------------------------------------------------------------------------------------------------------
6DB7             3 42 Draw_Token:
6DB7 CD D2 6D    3 43 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DBA 01 04 06    3 44 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DBD 11 9E 65    3 45 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DC0             3 46 Draw_Token_Loop
6DC0 E5          3 47 push    hl                          ; store hexagon screen address
6DC1 CD DC 6D    3 48 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DC4 E1          3 49 pop     hl                          ; restore hexagon screen address
6DC5 78          3 50 ld      a, b                        ; check loop counter
6DC6 B9          3 51 cp      c                           ; is it 4?
6DC7 CC 0A 6E    3 52 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DCA             3 53 @Token_Delay
6DCA 3E 00       3 54 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DCC CD 8C 6D    3 55 call    Main_Delay                  ; execute delay
6DCF 10 EF       3 56 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DD1 C9          3 57 ret
6DD2             3 59 ; ----------------------------------------------------------------------------------------------------------------------
6DD2             3 60 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DD2             3 61 ;
6DD2             3 62 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DD2             3 63 ;
6DD2             3 64 ; Output:   HL = hexagon screen address 
6DD2             3 65 ;
6DD2             3 66 ; Destroys: A, DE
6DD2             3 67 ; ----------------------------------------------------------------------------------------------------------------------
6DD2             3 68 Draw_GetHEX_Screen:
6DD2 11 98 61    3 69 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DD5 CD 6D 6D    3 70 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DD8 6E          3 71 ld      l, (hl)                     ; set the low byte of the screen address in L
6DD9 1A          3 72 ld      a, (de)                     ; set the high byte of the screen address in H
6DDA 67          3 73 ld      h, a
6DDB C9          3 74 ret
6DDC             3 76 ; ----------------------------------------------------------------------------------------------------------------------
6DDC             3 77 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DDC             3 78 ;
6DDC             3 79 ; Input:    DE = hexagon sprite address
6DDC             3 80 ;           HL = hexagon screen address
6DDC             3 81 ;
6DDC             3 82 ; Output:   DE = next hexagon sprite address
6DDC             3 83 ;
6DDC             3 84 ; Destroys: A, HL, IXL
6DDC             3 85 ; ----------------------------------------------------------------------------------------------------------------------
6DDC             3 86 Draw_Sprite_Hexagon:
6DDC DD 2E 10    3 87 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DDF             3 88 Draw_Sprite_HexLoop
6DDF 1A          3 89 ld      a, (de)                     ; get sprite byte
6DE0 77          3 90 ld      (hl), a                     ; put sprite byte on screen
6DE1 13          3 91 inc     de                          ; move DE to next sprite byte address
6DE2 2C          3 92 inc     l                           ; move HL to next screen column
6DE3 1A          3 93 ld      a, (de)                     ; get sprite byte
6DE4 77          3 94 ld      (hl), a                     ; put sprite byte on screen
6DE5 13          3 95 inc     de                          ; move DE to next sprite byte
6DE6 2D          3 96 dec     l                           ; move HL to previous screen column
6DE7 CD FB 6D    3 97 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DEA DD 2D       3 98 dec     ixl                         ; decrement sprite height
6DEC 20 F1       3 99 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6DEE C9          3 100 ret
6DEF             3 102 ; ----------------------------------------------------------------------------------------------------------------------
6DEF             3 103 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6DEF             3 104 ;
6DEF             3 105 ; Input:    DE = letter/number sprite address
6DEF             3 106 ;           HL = letter/number screen address
6DEF             3 107 ;
6DEF             3 108 ; Output:   DE = next letter/number sprite address
6DEF             3 109 ;
6DEF             3 110 ; Destroys: A, C, HL
6DEF             3 111 ; ----------------------------------------------------------------------------------------------------------------------
6DEF             3 112 Draw_Sprite_LetterNum:
6DEF 0E 0A       3 113 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6DF1             3 114 Draw_Sprite_Loop
6DF1 1A          3 115 ld      a, (de)                     ; get sprite byte
6DF2 77          3 116 ld      (hl), a                     ; put sprite byte on screen
6DF3 13          3 117 inc     de                          ; move DE to next sprite byte address
6DF4 CD FB 6D    3 118 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DF7 0D          3 119 dec     c                           ; decrement sprite height
6DF8 20 F7       3 120 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6DFA C9          3 121 ret
6DFB             3 123 ; ----------------------------------------------------------------------------------------------------------------------
6DFB             3 124 ; Draw_Down_PixelLine: move HL down one pixel-line
6DFB             3 125 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6DFB             3 126 ;
6DFB             3 127 ; The screen address of a pixel-line is encoded as follows:
6DFB             3 128 ;
6DFB             3 129 ;             H           |           L
6DFB             3 130 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DFB             3 131 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6DFB             3 132 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DFB             3 133 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6DFB             3 134 ;
6DFB             3 135 ; where:
6DFB             3 136 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6DFB             3 137 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6DFB             3 138 ;
6DFB             3 139 ; Input:    HL = pixel-line address
6DFB             3 140 ;
6DFB             3 141 ; Output:   HL = next (down) pixel-line address
6DFB             3 142 ;
6DFB             3 143 ; Destroys: A
6DFB             3 144 ; ----------------------------------------------------------------------------------------------------------------------
6DFB             3 145 Draw_Down_PixelLine:
6DFB 24          3 146 inc     h                           ; move HL down one pixel-line
6DFC 7C          3 147 ld      a, h                        ; get high byte of pixel-line address
6DFD E6 07       3 148 and     %00000111                   ; is pixel-line address inside a character line?
6DFF C0          3 149 ret     nz                          ; yes, return
6E00 7D          3 150 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6E01 C6 20       3 151 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E03 6F          3 152 ld      l, a                        ; move HL down one character line
6E04 D8          3 153 ret     c                           ; a third was crossed? yes, return
6E05 7C          3 154 ld      a, h                        ; get high byte of pixel-line address
6E06 D6 08       3 155 sub     8                           ; clean up the bit from Y6
6E08 67          3 156 ld      h, a                        ; HL points to next (down) pixel-line address
6E09 C9          3 157 ret
6E0A             3 159 ; ----------------------------------------------------------------------------------------------------------------------
6E0A             3 160 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E0A             3 161 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E0A             3 162 ;
6E0A             3 163 ; This routine converts a screen address (HL) into an attribute address (IX):
6E0A             3 164 ;
6E0A             3 165 ;             H           |           L
6E0A             3 166 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0A             3 167 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E0A             3 168 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0A             3 169 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E0A             3 170 ;
6E0A             3 171 ;            IXH          |          IXL
6E0A             3 172 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0A             3 173 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E0A             3 174 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E0A             3 175 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E0A             3 176 ;
6E0A             3 177 ; where:
6E0A             3 178 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E0A             3 179 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E0A             3 180 ;
6E0A             3 181 ; Input:    HL = screen address of the hexagon
6E0A             3 182 ;
6E0A             3 183 ; Output:   IX = attribute address of the hexagon
6E0A             3 184 ;
6E0A             3 185 ; Uses:     TOKEN_COLOR (current token color)
6E0A             3 186 ;
6E0A             3 187 ; Destroys: A
6E0A             3 188 ; ----------------------------------------------------------------------------------------------------------------------
6E0A             3 189 Draw_Hexagon_Color:
6E0A 7C          3 190 ld      a, h                        ; get high byte of screen address
6E0B F6 87       3 191 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E0D 1F          3 192 rra                                 ; shift Y7-Y6 two positions
6E0E 1F          3 193 rra
6E0F CB 3F       3 194 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E11 DD 67       3 195 ld      ixh, a                      ; set high byte of attribute address in IXH
6E13 7D          3 196 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E14 DD 6F       3 197 ld      ixl, a                      ; set low byte of attribute address in IXL
6E16 3A 9E 61    3 198 ld      a, (TOKEN_COLOR)            ; get current token color
6E19 DD 77 00    3 199 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E1C DD 77 01    3 200 ld      (ix+1), a
6E1F DD 77 20    3 201 ld      (ix+32), a
6E22 DD 77 21    3 202 ld      (ix+33), a
6E25 C9          3 203 ret

; File #4: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Input.z80asm

6E26             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E26             4 2 ; Input.z80asm
6E26             4 3 ; Coded by Antonio Luque
6E26             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E26             4 6 MAX_CHARS               EQU     2                           ; maximum of input chars
6E26             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E26             4 9 ; Input_Move: wait for input a move from keyboard
6E26             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E26             4 11 ;
6E26             4 12 ; Input:    -
6E26             4 13 ;
6E26             4 14 ; Output:   -
6E26             4 15 ;
6E26             4 16 ; Uses:     TOKEN_COLOR (current token color)
6E26             4 17 ;           STR_MOVE (formatted move string)
6E26             4 18 ;
6E26             4 19 ; Destroys: A, A', BC, DE, HL, IX
6E26             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E26             4 21 Input_Move:
6E26 01 00 02    4 22 ld      bc, MAX_CHARS*256           ; B = maximum of input chars, C = chars counter
6E29 DD 21 83 5A 4 24 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E2D 21 83 50    4 25 ld      hl, $5083                   ; HL points to screen address of RED input text
6E30 3A 9E 61    4 26 ld      a, (TOKEN_COLOR)            ; check current player color
6E33 FE 02       4 27 cp      RED_COLOR                   ; is RED the current token color?
6E35 28 07       4 28 jr      z, Input_Start              ; yes, start input
6E37 DD 21 19 59 4 29 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E3B 21 19 48    4 30 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E3E             4 31 Input_Start
6E3E DD 36 00 C7 4 32 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E42 3E 5F       4 33 ld      a, '_'                      ; text input cursor
6E44 CD 66 6F    4 34 call    Print_Char                  ; print cursor
6E47             4 35 Input_Loop
6E47 CD C0 6E    4 36 call    Input_Key_Scan              ; scan for a key pressed
6E4A FE 0D       4 38 cp      $0D                         ; is it ENTER?
6E4C 28 64       4 39 jr      z, Input_Enter              ; yes, perform enter pressed
6E4E FE 30       4 40 cp      '0'                         ; is it "delete"? (char '0' acts as delete, without Shift)
6E50 28 42       4 41 jr      z, Input_Delete             ; yes, perform delete char
6E52 08          4 42 ex      af, af'                     ; store char in A'
6E53 79          4 43 ld      a, c                        ; check number of chars inserted
6E54 B8          4 44 cp      b                           ; chars limit reached?
6E55 28 F0       4 45 jr      z, Input_Loop               ; yes, repeat input loop
6E57 B7          4 47 or      a                           ; is it the first char?
6E58 20 21       4 48 jr      nz, Input_Numbers           ; no, perform input of 2nd char
6E5A             4 50 ; restrict first char to 'a'-'g'
6E5A 08          4 52 ex      af, af'                     ; restore char
6E5B FE 61       4 53 cp      'a'                         ; is it < 'a'?
6E5D 38 E8       4 54 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E5F FE 68       4 55 cp      'h'                         ; is it >= 'g'?
6E61 30 E4       4 56 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E63             4 58 ; char is valid as column
6E63 32 15 62    4 60 ld      (STR_MOVE+0), a             ; save char in player move
6E66 DD 36 00 47 4 61 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E6A CD 66 6F    4 62 call    Print_Char                  ; print key pressed
6E6D 0C          4 63 inc     c                           ; increment chars counter
6E6E 2C          4 64 inc     l                           ; increment X position of current input screen location
6E6F DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E71 3E 2D       4 66 ld      a, '-'                      ; set dash char
6E73 CD 66 6F    4 67 call    Print_Char                  ; print key pressed
6E76 2C          4 68 inc     l                           ; increment X position of current input screen location
6E77 DD 2C       4 69 inc     ixl                         ; increment X position of current input attr location
6E79 18 C3       4 70 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E7B             4 71 Input_Numbers
6E7B             4 72 ; restrict second char to '1'-'7'
6E7B 08          4 74 ex      af, af'                     ; restore char
6E7C FE 31       4 75 cp      '1'                         ; is it < '1'?
6E7E 38 C7       4 76 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E80 FE 38       4 77 cp      '8'                         ; is it >= '8'?
6E82 30 C3       4 78 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E84             4 80 ; char is valid as row
6E84 32 18 62    4 82 ld      (STR_MOVE+3), a             ; save char in player move
6E87 DD 36 00 47 4 83 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E8B CD 66 6F    4 84 call    Print_Char                  ; print key pressed
6E8E 0C          4 85 inc     c                           ; increment chars counter
6E8F 2C          4 86 inc     l                           ; increment X position of current input screen location
6E90 DD 2C       4 87 inc     ixl                         ; increment X position of current input attr location
6E92 18 AA       4 88 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E94             4 90 ; player pressed "delete" (char '0')
6E94             4 91 Input_Delete
6E94 79          4 92 ld      a, c                        ; get char counter
6E95 B7          4 93 or      a                           ; is it 0?
6E96 28 AF       4 94 jr      z, Input_Loop               ; repeat input loop (no chars to delete)
6E98 DD 36 00 47 4 96 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E9C B8          4 97 cp      b                           ; is it the first char?
6E9D 28 08       4 98 jr      z, Input_Delete_Char        ; yes, continue delete
6E9F 3E 20       4 99 ld      a, ' '                      ; empty char
6EA1 CD 66 6F    4 100 call    Print_Char                  ; delete cursor and last char
6EA4 2D          4 101 dec     l                           ; decrement X position of input screen location
6EA5 DD 2D       4 102 dec     ixl                         ; decrement X position of input attr location
6EA7             4 103 Input_Delete_Char
6EA7 0D          4 104 dec     c                           ; decrement char counter
6EA8 3E 20       4 105 ld      a, ' '                      ; empty char
6EAA CD 66 6F    4 106 call    Print_Char                  ; delete cursor and last char
6EAD 2D          4 107 dec     l                           ; decrement X position of player input screen location
6EAE DD 2D       4 108 dec     ixl                         ; decrement X position of player input attr location
6EB0 18 8C       4 109 jr      Input_Start                 ; get next char
6EB2             4 111 ; player pressed ENTER
6EB2             4 112 Input_Enter
6EB2 79          4 113 ld      a, c                        ; check char counter  
6EB3 B8          4 114 cp      b                           ; is it < MAX_CHARS?
6EB4 38 91       4 115 jr      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EB6 DD 36 00 47 4 117 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EBA 3E 20       4 118 ld      a, ' '                      ; empty char
6EBC CD 66 6F    4 119 call    Print_Char                  ; delete cursor
6EBF C9          4 120 ret
6EC0             4 122 ; ----------------------------------------------------------------------------------------------------------------------
6EC0             4 123 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EC0             4 124 ;
6EC0             4 125 ;                           Bit
6EC0             4 126 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EC0             4 127 ;  ------+-------+-------+-------+-------+-------+
6EC0             4 128 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EC0             4 129 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EC0             4 130 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EC0             4 131 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EC0             4 132 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EC0             4 133 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EC0             4 134 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EC0             4 135 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EC0             4 136 ;
6EC0             4 137 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EC0             4 138 ;
6EC0             4 139 ; Input:    -
6EC0             4 140 ;
6EC0             4 141 ; Output:   A = ASCII code of key pressed
6EC0             4 142 ;
6EC0             4 143 ; Destroys: DE
6EC0             4 144 ; ----------------------------------------------------------------------------------------------------------------------
6EC0             4 145 Input_Key_Scan:
6EC0 C5          4 146 push    bc                          ; store registers
6EC1 E5          4 147 push    hl
6EC2             4 148 Input_Key_Released
6EC2 01 FE FE    4 149 ld      bc, $FEFE                   ; set keyboard port (see above)
6EC5             4 150 Input_Key_Released_Line
6EC5 ED 78       4 151 in      a, (c)                      ; read port
6EC7 2F          4 152 cpl                                 ; invert bits
6EC8 E6 1F       4 153 and     %00011111                   ; check 0 to 4 bits
6ECA 20 F6       4 154 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6ECC CB 00       4 155 rlc     b                           ; move BC to the next port
6ECE 38 F5       4 156 jr      c, Input_Key_Released_Line  ; repeat for each port
6ED0 11 05 00    4 157 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6ED3             4 158 Input_Key_Pressed_Begin
6ED3 21 D8 61    4 159 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6ED6             4 160 Input_Key_Pressed_Line
6ED6 ED 78       4 161 in      a, (c)                      ; read port
6ED8 2F          4 162 cpl                                 ; invert bits
6ED9 E6 1F       4 163 and     %00011111                   ; check 0 to 4 bits
6EDB 20 08       4 164 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6EDD 19          4 165 add     hl, de                      ; HL points to the next KEY_MAP block
6EDE CB 00       4 166 rlc     b                           ; move BC to the next port
6EE0 38 F4       4 167 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6EE2 18 EF       4 168 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6EE4             4 169 Input_Key_Next
6EE4 23          4 170 inc     hl                          ; move HL to the next character
6EE5             4 171 Input_Key_Pressed
6EE5 1F          4 172 rra                                 ; rotate bits of port readed
6EE6 30 FC       4 173 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6EE8 7E          4 174 ld      a, (hl)                     ; return key pressed (ASCII) in A
6EE9 E1          4 175 pop     hl                          ; restore registers
6EEA C1          4 176 pop     bc
6EEB C9          4 177 ret

; File #5: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Print.z80asm

6EEC             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6EEC             5 2 ; Print.z80asm
6EEC             5 3 ; Coded by Antonio Luque
6EEC             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6EEC             5 6 CHAR_SET                EQU     FONT-256                    ; address of character set data, adjusted for ASCII codes
6EEC             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6EEC             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6EEC             5 10 ;
6EEC             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6EEC             5 12 ;
6EEC             5 13 ; Output:   -
6EEC             5 14 ;
6EEC             5 15 ; Destroys: A, BC, DE, HL
6EEC             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6EEC             5 17 Print_Players:
6EEC 11 21 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6EEF 01 1A 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6EF2 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6EF5 FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6EF7 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6EF9 11 1A 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6EFC 01 21 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6EFF             5 25 Print_Players_Strings
6EFF CD 59 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6F02 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F03 59          5 28 ld      e, c
6F04 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F07 C3 59 6F    5 30 jp      Print_String                ; print "Player" or "Speccy"
6F0A             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F0A             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F0A             5 34 ;
6F0A             5 35 ; Input:    -
6F0A             5 36 ; Output:   -
6F0A             5 37 ; Destroys: A, BC, DE, HL, IX
6F0A             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F0A             5 39 Print_Clear_Alert:
6F0A 11 46 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F0D 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F0F C3 14 6F    5 42 jp      Print_Alert_XY              ; print (clear) alert string
6F12             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F12             5 45 ; Print_Alert: print an alert message below the current player input move
6F12             5 46 ;
6F12             5 47 ; Input:    DE = alert message string address
6F12             5 48 ;
6F12             5 49 ; Output:   -
6F12             5 50 ;
6F12             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F12             5 52 ;
6F12             5 53 ; Destroys: A, BC, DE, HL, IX
6F12             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F12             5 55 Print_Alert:
6F12 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F14             5 57 Print_Alert_XY
6F14 DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F18 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F1B 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F1E FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F20 28 34       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F22 DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F26 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F29 C3 56 6F    5 65 jp      Print_String_Color          ; print alert string with color
6F2C             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F2C             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F2C             5 69 ;
6F2C             5 70 ; Input:    -
6F2C             5 71 ;
6F2C             5 72 ; Output:   -
6F2C             5 73 ;
6F2C             5 74 ; Destroys: A, BC, DE, HL, IX
6F2C             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F2C             5 76 Print_Wait:
6F2C 11 35 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F2F 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F31 C3 41 6F    5 79 jp      Print_Move_XY               ; print wait string
6F34             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F34             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F34             5 83 ;
6F34             5 84 ; Input:    -
6F34             5 85 ;
6F34             5 86 ; Output:   -
6F34             5 87 ;
6F34             5 88 ; Destroys: A, BC, DE, HL, IX
6F34             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F34             5 90 Print_Clear_Move:
6F34 11 41 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F37 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F39 C3 41 6F    5 93 jp      Print_Move_XY               ; print (clear) move string
6F3C             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F3C             5 96 ; Print_Move: print a formatted move at current player input move location 
6F3C             5 97 ;
6F3C             5 98 ; Input:    -
6F3C             5 99 ;
6F3C             5 100 ; Output:   -
6F3C             5 101 ;
6F3C             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F3C             5 103 ;
6F3C             5 104 ; Destroys: A, BC, DE, HL, IX
6F3C             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F3C             5 106 Print_Move:
6F3C 11 15 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F3F 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F41             5 109 Print_Move_XY
6F41 DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F45 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F48 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F4B FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F4D 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F4F DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F53 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F56             5 117 Print_String_Color
6F56 CD 78 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F59             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F59             5 120 ; Print_String: print a string on the screen
6F59             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F59             5 122 ;
6F59             5 123 ; Input:    DE = string address (ending with 0)
6F59             5 124 ;           HL = string screen address
6F59             5 125 ;
6F59             5 126 ; Output:   -
6F59             5 127 ;
6F59             5 128 ; Destroys: A, DE, HL
6F59             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F59             5 130 Print_String:
6F59 1A          5 131 ld      a, (de)                     ; get string character
6F5A B7          5 132 or      a                           ; is it 0? (end of string)
6F5B C8          5 133 ret     z                           ; yes, return
6F5C D5          5 134 push    de                          ; store pointer to string address
6F5D CD 66 6F    5 135 call    Print_Char                  ; print character
6F60 D1          5 136 pop     de                          ; restore pointer to string address
6F61 13          5 137 inc     de                          ; move DE to next string character
6F62 2C          5 138 inc     l                           ; move HL to next screen column
6F63 C3 59 6F    5 139 jp      Print_String                ; repeat until end of string
6F66             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F66             5 142 ; Print_Char: print a character on the screen
6F66             5 143 ;
6F66             5 144 ; Input:    A  = character to print (ASCII)
6F66             5 145 ;           HL = character screen address
6F66             5 146 ;
6F66             5 147 ; Output:   -
6F66             5 148 ;
6F66             5 149 ; Destroys: A, DE
6F66             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F66             5 151 Print_Char:
6F66 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F69             5 153 Print_Tile:
6F69 E5          5 154 push    hl                          ; store pointer to character/tile screen address
6F6A 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F6C 6F          5 156 ld      l, a
6F6D 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6F6E 29          5 158 add     hl, hl
6F6F 29          5 159 add     hl, hl
6F70 19          5 160 add     hl, de                      ; move HL to character/tile address
6F71 EB          5 161 ex      de, hl                      ; DE points to character/tile address
6F72 E1          5 162 pop     hl                          ; restore pointer to character/tile screen address
6F73 C5          5 163 push    bc                          ; store BC register
6F74 4C          5 164 ld      c, h                        ; save high byte of character/tile screen address
6F75 06 08       5 165 ld      b, 8                        ; number of character/tile bytes (loop counter)
6F77             5 166 Print_Tile_Pixels
6F77 1A          5 167 ld      a, (de)                     ; get character/tile byte
6F78 77          5 168 ld      (hl), a                     ; put character/tile byte on screen
6F79 13          5 169 inc     de                          ; move DE to next character/tile byte
6F7A 24          5 170 inc     h                           ; move HL down one pixel-line
6F7B 10 FA       5 171 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6F7D 61          5 172 ld      h, c                        ; restore high byte of character/tile screen address
6F7E C1          5 173 pop     bc                          ; restore BC register
6F7F C9          5 174 ret

; File #6: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Brainiac.z80asm

6F80             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6F80             6 2 ; Brainiac.z80asm
6F80             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F80             6 4 ;
6F80             6 5 ; Adapted for Hex game by Einar Saukas
6F80             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6F80             6 8 MIN_VALUE               EQU     0                           ; alphaBeta pruning minimum value
6F80             6 9 MAX_VALUE               EQU     255                         ; alphaBeta pruning maximum value
6F80             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6F80             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6F80             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6F80             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6F80             6 15 ; depth.
6F80             6 16 ;
6F80             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F80             6 18 ;
6F80             6 19 ; Input:    A   = speccy side (FRIEND or ENEMY)
6F80             6 20 ;           IX  = candidates vector address
6F80             6 21 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
6F80             6 22 ;
6F80             6 23 ; Output:   E  = selected position (speccy move)
6F80             6 24 ;
6F80             6 25 ; Uses:     AI_PLAYER (speccy side)
6F80             6 26 ;           AI_DEPTH (recursion depth level)
6F80             6 27 ;
6F80             6 28 ; Destroys: A, A', BC, D, HL, IX, IY
6F80             6 29 ; ----------------------------------------------------------------------------------------------------------------------
6F80             6 30 BRAINIAC_best_move:
6F80 32 99 61    6 31 ld      (AI_PLAYER), a              ; save speccy side
6F83 CD 7E 74    6 33 call    PathFinder_Score            ; get board score (needed to get candidates)
6F86 CD 21 75    6 34 call    PathFinder_Candidates       ; get candidates from board potentials
6F89             6 36 ; BRAINIAC start
6F89             6 37 AI_First_Candidate
6F89 DD 7E 00    6 38 ld      a, (ix+0)                   ; A is our first candidate
6F8C 5F          6 40 ld      e, a                        ; E = best speccy move (initialization)
6F8D 16 00       6 41 ld      d, MIN_VALUE                ; D = alphaMax
6F8F             6 43 AI_Main_Loop                                                ; for each candidate {
6F8F D5          6 44 push    de                          ;       store alphaMax and best speccy move
6F90 26 7D       6 46 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F92 6F          6 47 ld      l, a
6F93 E5          6 48 push    hl
6F94 3A 99 61    6 50 ld      a, (AI_PLAYER)              ;       get speccy side
6F97 CD FD 70    6 51 call    PathFinder_PutToken         ;       BRAINIAC_play
6F9A EE 7C       6 52 xor     $7C                         ;       restore speccy side
6F9C 1E FF       6 53 ld      e, MAX_VALUE                ;       E = betaMin
6F9E CD B7 6F    6 54 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6FA1 E1          6 56 pop     hl                          ;       restore candidate position
6FA2 CD 03 71    6 57 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FA5 D1          6 59 pop     de                          ;       restore alphaMax and best player node
6FA6 BA          6 61 cp      d
6FA7 38 04       6 62 jr      c, AI_Main_Next
6FA9 28 02       6 63 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FAB 57          6 65 ld      d, a                        ;       alphaMax = A
6FAC 5D          6 66 ld      e, l                        ;       best move = E
6FAD             6 68 AI_Main_Next
6FAD DD 2D       6 69 dec     ixl
6FAF DD 7E 00    6 70 ld      a, (ix+0)                   ;       A is our next candidate
6FB2 B7          6 71 or      a                           ;       repeat until no more candidates
6FB3 C2 8F 6F    6 72 jp      nz, AI_Main_Loop            ; }
6FB6 C9          6 73 ret
6FB7             6 75 ; ----------------------------------------------------------------------------------------------------------------------
6FB7             6 76 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FB7             6 77 ; Speccy's score.
6FB7             6 78 ;
6FB7             6 79 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FB7             6 80 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FB7             6 81 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FB7             6 82 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FB7             6 83 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FB7             6 84 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FB7             6 85 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FB7             6 86 ; could be just reproducing the best score from its sibling.
6FB7             6 87 ;
6FB7             6 88 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB7             6 89 ;
6FB7             6 90 ; Input:    A   = speccy side (FRIEND or ENEMY)
6FB7             6 91 ;           D   = alphaMax
6FB7             6 92 ;           E   = betaMin
6FB7             6 93 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
6FB7             6 94 ;
6FB7             6 95 ; Output:   A = "improved" betaMin
6FB7             6 96 ;           D = alphaMax
6FB7             6 97 ;           E = "improved" betaMin
6FB7             6 98 ;
6FB7             6 99 ; Uses:     AI_PLAYER (speccy side)
6FB7             6 100 ;           AI_DEPTH (recursion depth level)
6FB7             6 101 ;
6FB7             6 102 ; Destroys: BC, HL, IX, IY
6FB7             6 103 ; ----------------------------------------------------------------------------------------------------------------------
6FB7             6 104 Alphabeta_Min:
6FB7 D5          6 105 push    de
6FB8             6 107 ; check if last speccy move is a winner one
6FB8 CD 7E 74    6 109 call    PathFinder_Score            ; if (speccy won)
6FBB B7          6 110 or      a
6FBC C2 C6 6F    6 111 jp      nz, Alphabeta_Min_Candidates
6FBF 3A 9A 61    6 112 ld      a, (AI_DEPTH)
6FC2 C6 E0       6 113 add     a, 224                      ;     return 224+depth
6FC4 D1          6 114 pop     de
6FC5 C9          6 115 ret
6FC6             6 117 Alphabeta_Min_Candidates
6FC6 CD 21 75    6 118 call    PathFinder_Candidates       ; find candidates for next move
6FC9 D1          6 119 pop     de
6FCA DD 7E 00    6 121 ld      a, (ix+0)                   ; A is our first candidate
6FCD 21 9A 61    6 123 ld      hl, AI_DEPTH
6FD0 35          6 124 dec     (hl)                        ; depth--
6FD1 CA 11 70    6 125 jp      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
6FD4             6 127 Alphabeta_Min_Loop                                          ; for each candidate {
6FD4 D5          6 128 push    de                          ;       store alphaMax and betaMin
6FD5 26 7D       6 130 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FD7 6F          6 131 ld      l, a
6FD8 E5          6 132 push    hl
6FD9 3A 99 61    6 134 ld      a, (AI_PLAYER)              ;       get speccy side
6FDC EE 7C       6 135 xor     $7C                         ;       switch to player side
6FDE CD FD 70    6 136 call    PathFinder_PutToken         ;       BRAINIAC_play
6FE1 CD 55 70    6 137 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
6FE4 E1          6 139 pop     hl                          ;       restore candidate position
6FE5 CD 03 71    6 140 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FE8 D1          6 142 pop     de                          ;       restore alphaMax and betaMin
6FE9 BB          6 144 cp      e
6FEA 30 06       6 145 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
6FEC BA          6 147 cp      d
6FED 38 12       6 148 jr      c, Alphabeta_Min_Exit
6FEF 28 10       6 149 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FF1 5F          6 151 ld      e, a                        ;       betaMin = A
6FF2             6 153 Alphabeta_Min_Next
6FF2 DD 2D       6 154 dec     ixl
6FF4 DD 7E 00    6 155 ld      a, (ix+0)                   ;       A is our next candidate
6FF7 B7          6 156 or      a                           ;       repeat until no more candidates
6FF8 C2 D4 6F    6 157 jp      nz, Alphabeta_Min_Loop      ; }
6FFB 7B          6 159 ld      a, e                        ; return betaMin
6FFC 21 9A 61    6 161 ld      hl, AI_DEPTH
6FFF 34          6 162 inc     (hl)                        ; depth++
7000 C9          6 163 ret
7001             6 165 Alphabeta_Min_Exit
7001 5F          6 166 ld      e, a                        ; (discard remaining candidates)
7002 AF          6 167 xor     a
7003             6 168 Alphabeta_Min_Skip
7003 DD 2D       6 169 dec     ixl
7005 DD BE 00    6 170 cp      (ix+0)
7008 C2 03 70    6 171 jp      nz, Alphabeta_Min_Skip
700B 7B          6 172 ld      a, e
700C 21 9A 61    6 174 ld      hl, AI_DEPTH
700F 34          6 175 inc     (hl)                        ; (depth++)
7010 C9          6 176 ret
7011             6 178 ; ----------------------------------------------------------------------------------------------------------------------
7011             6 179 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
7011             6 180 ; beta pruning, when it requires MINIMIZING Speccy's score.
7011             6 181 ;
7011             6 182 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
7011             6 183 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
7011             6 184 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
7011             6 185 ; faster.
7011             6 186 ;
7011             6 187 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7011             6 188 ;
7011             6 189 ; Input:    A = first candidate
7011             6 190 ;           D = alphaMax
7011             6 191 ;           E = betaMin
7011             6 192 ;
7011             6 193 ; Output:   A = "improved" betaMin
7011             6 194 ;           D = alphaMax
7011             6 195 ;           E = "improved" betaMin
7011             6 196 ;
7011             6 197 ; Uses:     AI_PLAYER (speccy side)
7011             6 198 ;           AI_DEPTH (recursion depth level)
7011             6 199 ;
7011             6 200 ; Destroys: BC, HL, IX, IY
7011             6 201 ; ----------------------------------------------------------------------------------------------------------------------
7011             6 202 Heuristic_Min:                                              ; for each candidate {
7011 D5          6 203 push    de                          ;       store alphaMax and betaMin
7012 26 7D       6 205 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7014 6F          6 206 ld      l, a
7015 E5          6 207 push    hl
7016 3A 99 61    6 209 ld      a, (AI_PLAYER)              ;       get speccy side
7019 EE 7C       6 210 xor     $7C                         ;       switch to player side
701B CD FD 70    6 211 call    PathFinder_PutToken         ;       BRAINIAC_play
701E CD 7E 74    6 213 call    PathFinder_Score            ;       if (player won)
7021 FE FF       6 214 cp      -1
7023 C2 28 70    6 215 jp      nz, Heuristic_Min_Continue
7026 3E 20       6 216 ld      a, 32                       ;           A = 32
7028             6 217 Heuristic_Min_Continue
7028 E1          6 218 pop     hl
7029 CD 03 71    6 219 call    PathFinder_EraseToken       ;       BRAINIAC_undo
702C D1          6 221 pop     de
702D BB          6 223 cp      e
702E 30 06       6 224 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
7030 BA          6 226 cp      d
7031 38 12       6 227 jr      c, Heuristic_Min_Exit
7033 28 10       6 228 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
7035 5F          6 230 ld      e, a                        ;       betaMin = A
7036             6 232 Heuristic_Min_Next
7036 DD 2D       6 233 dec     ixl
7038 DD 7E 00    6 234 ld      a, (ix+0)                   ;       A is our next candidate
703B B7          6 235 or      a                           ;       repeat until no more candidates
703C C2 11 70    6 236 jp      nz, Heuristic_Min           ; }
703F 7B          6 238 ld      a, e                        ; return betaMin
7040 21 9A 61    6 240 ld      hl, AI_DEPTH
7043 34          6 241 inc     (hl)                        ; depth++
7044 C9          6 242 ret
7045             6 244 Heuristic_Min_Exit
7045 5F          6 245 ld      e, a                        ; (discard remaining candidates)
7046 AF          6 246 xor     a
7047             6 247 Heuristic_Min_Skip
7047 DD 2D       6 248 dec     ixl
7049 DD BE 00    6 249 cp      (ix+0)
704C C2 47 70    6 250 jp      nz, Heuristic_Min_Skip
704F 7B          6 251 ld      a, e
7050 21 9A 61    6 253 ld      hl, AI_DEPTH
7053 34          6 254 inc     (hl)                        ; (depth++)
7054 C9          6 255 ret
7055             6 257 ; ----------------------------------------------------------------------------------------------------------------------
7055             6 258 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
7055             6 259 ; Speccy's score.
7055             6 260 ;
7055             6 261 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
7055             6 262 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
7055             6 263 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
7055             6 264 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
7055             6 265 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
7055             6 266 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
7055             6 267 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
7055             6 268 ; the same score and could be just reproducing the best score from its sibling.
7055             6 269 ;
7055             6 270 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7055             6 271 ;
7055             6 272 ; Input:    A   = speccy side (FRIEND or ENEMY)
7055             6 273 ;           D   = alphaMax
7055             6 274 ;           E   = betaMin
7055             6 275 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
7055             6 276 ;
7055             6 277 ; Output:   A = "improved" alphaMax
7055             6 278 ;           D = "improved" alphaMax
7055             6 279 ;           E = betaMin
7055             6 280 ;
7055             6 281 ; Uses:     AI_PLAYER (speccy side)
7055             6 282 ;           AI_DEPTH (recursion depth level)
7055             6 283 ;
7055             6 284 ; Destroys: BC, HL, IX, IY
7055             6 285 ; ----------------------------------------------------------------------------------------------------------------------
7055             6 286 Alphabeta_Max:
7055 D5          6 287 push    de
7056             6 289 ; check if last player move is a winner one
7056 CD 7E 74    6 291 call    PathFinder_Score            ; if (player won)
7059 FE FF       6 292 cp      -1
705B C2 66 70    6 293 jp      nz, Alphabeta_Max_Candidates
705E 3A 9A 61    6 294 ld      a, (AI_DEPTH)
7061 2F          6 295 cpl
7062 C6 21       6 296 add     a, 32+1                     ;     return 32-depth
7064 D1          6 297 pop     de
7065 C9          6 298 ret
7066             6 300 Alphabeta_Max_Candidates
7066 CD 21 75    6 301 call    PathFinder_Candidates       ; find candidates for next move
7069 D1          6 302 pop     de
706A DD 7E 00    6 304 ld      a, (ix+0)                   ; A is our first candidate
706D 21 9A 61    6 306 ld      hl, AI_DEPTH
7070 35          6 307 dec     (hl)                        ; depth--
7071 CA B1 70    6 308 jp      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
7074             6 310 Alphabeta_Max_Loop                                          ; for each candidate {
7074 D5          6 311 push    de                          ;       store alphaMax and betaMin
7075 26 7D       6 313 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7077 6F          6 314 ld      l, a
7078 E5          6 315 push    hl
7079 3A 99 61    6 317 ld      a, (AI_PLAYER)              ;       get speccy side
707C CD FD 70    6 318 call    PathFinder_PutToken         ;       BRAINIAC_play
707F EE 7C       6 319 xor     $7C                         ;       restore speccy side
7081 CD B7 6F    6 320 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
7084 E1          6 322 pop     hl                          ;       restore candidate position
7085 CD 03 71    6 323 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7088 D1          6 325 pop     de                          ;       restore alphaMax and betaMin
7089 BA          6 327 cp      d
708A 38 06       6 328 jr      c, Alphabeta_Max_Next
708C 28 04       6 329 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
708E BB          6 331 cp      e
708F 30 10       6 332 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
7091 57          6 334 ld      d, a                        ;       alphaMax = A
7092             6 336 Alphabeta_Max_Next
7092 DD 2D       6 337 dec     ixl
7094 DD 7E 00    6 338 ld      a, (ix+0)                   ;       A is our next candidate
7097 B7          6 339 or      a                           ;       repeat until no more candidates
7098 C2 74 70    6 340 jp      nz, Alphabeta_Max_Loop      ; }
709B 7A          6 342 ld      a, d                        ; return alphaMax
709C 21 9A 61    6 344 ld      hl, AI_DEPTH
709F 34          6 345 inc     (hl)                        ; depth++
70A0 C9          6 346 ret
70A1             6 348 Alphabeta_Max_Exit
70A1 57          6 349 ld      d, a                        ; (discard remaining candidates)
70A2 AF          6 350 xor     a
70A3             6 351 Alphabeta_Max_Skip
70A3 DD 2D       6 352 dec     ixl
70A5 DD BE 00    6 353 cp      (ix+0)
70A8 C2 A3 70    6 354 jp      nz, Alphabeta_Max_Skip
70AB 7A          6 355 ld      a, d
70AC 21 9A 61    6 357 ld      hl, AI_DEPTH
70AF 34          6 358 inc     (hl)                        ; (depth++)
70B0 C9          6 359 ret
70B1             6 361 ; ----------------------------------------------------------------------------------------------------------------------
70B1             6 362 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70B1             6 363 ; beta pruning, when it requires MAXIMIZING Speccy's score.
70B1             6 364 ;
70B1             6 365 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70B1             6 366 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70B1             6 367 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70B1             6 368 ; faster.
70B1             6 369 ;
70B1             6 370 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70B1             6 371 ;
70B1             6 372 ; Input:    A = first candidate
70B1             6 373 ;           D = alphaMax
70B1             6 374 ;           E = betaMin
70B1             6 375 ;
70B1             6 376 ; Returns:  A = "improved" alphaMax
70B1             6 377 ;           D = "improved" alphaMax
70B1             6 378 ;           E = betaMin
70B1             6 379 ;
70B1             6 380 ; Uses:     AI_PLAYER (speccy side)
70B1             6 381 ;           AI_DEPTH (recursion depth level)
70B1             6 382 ;
70B1             6 383 ; Destroys: BC, HL, IX, IY
70B1             6 384 ; ----------------------------------------------------------------------------------------------------------------------
70B1             6 385 Heuristic_Max:                                              ; for each candidate {
70B1 D5          6 386 push    de                          ;       store alphaMax and betaMin
70B2 26 7D       6 388 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70B4 6F          6 389 ld      l, a
70B5 E5          6 390 push    hl
70B6 3A 99 61    6 392 ld      a, (AI_PLAYER)              ;       get speccy side
70B9 CD FD 70    6 393 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70BC EE 7C       6 394 xor     $7C                         ;       restore speccy side
70BE CD 7E 74    6 396 call    PathFinder_Score            ;       if (speccy won)
70C1 B7          6 397 or      a
70C2 C2 C7 70    6 398 jp      nz, Heuristic_Max_Continue
70C5 3E E0       6 399 ld      a, 224                      ;           A = 224
70C7             6 400 Heuristic_Max_Continue
70C7 E1          6 401 pop     hl                          ;       restore candidate position
70C8 CD 03 71    6 402 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70CB D1          6 404 pop     de                          ;       restore alphaMax and betaMin
70CC BA          6 406 cp      d
70CD 38 06       6 407 jr      c, Heuristic_Max_Next
70CF 28 04       6 408 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
70D1 BB          6 410 cp      e
70D2 30 10       6 411 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70D4 57          6 413 ld      d, a                        ;       alphaMax = A
70D5             6 415 Heuristic_Max_Next
70D5 DD 2D       6 416 dec     ixl
70D7 DD 7E 00    6 417 ld      a, (ix+0)                   ;       A is our next candidate
70DA B7          6 418 or      a                           ;       repeat until no more candidates
70DB C2 B1 70    6 419 jp      nz, Heuristic_Max           ; }
70DE 7A          6 421 ld      a, d                        ; return alphaMax
70DF 21 9A 61    6 423 ld      hl, AI_DEPTH
70E2 34          6 424 inc     (hl)                        ; depth++
70E3 C9          6 425 ret
70E4             6 427 Heuristic_Max_Exit
70E4 57          6 428 ld      d, a                        ; (discard remaining candidates)
70E5 AF          6 429 xor     a
70E6             6 430 Heuristic_Max_Skip
70E6 DD 2D       6 431 dec     ixl
70E8 DD BE 00    6 432 cp      (ix+0)
70EB C2 E6 70    6 433 jp      nz, Heuristic_Max_Skip
70EE 7A          6 434 ld      a, d
70EF 21 9A 61    6 436 ld      hl, AI_DEPTH
70F2 34          6 437 inc     (hl)                        ; (depth++)
70F3 C9          6 438 ret

; File #7: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\PathFinder.z80asm

70F4             7 1 ; ----------------------------------------------------------------------------------------------------------------------
70F4             7 2 ; PathFinder.z80asm
70F4             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
70F4             7 4 ;
70F4             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
70F4             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
70F4             7 7 ; ----------------------------------------------------------------------------------------------------------------------
70F4             7 9 EMPTY                   EQU     $00                         ; empty positions on the board
70F4             7 10 SKIPPED                 EQU     $01                         ; skipped positions on the board
70F4             7 11 FRIEND                  EQU     $02                         ; positions occupied by friendly tokens on the board
70F4             7 12 ENEMY                   EQU     $7E                         ; positions occupied by opponent tokens on the board
70F4             7 13 VICTORY                 EQU     $03                         ; internal value if victory
70F4             7 14 WIDTH                   EQU     $08                         ; distance to up-left/down-right neighbor
70F4             7 16 CYAN_POSITIONS          EQU     $7D00                       ; a 256-aligned memory area reserved for cyan positions
70F4             7 17 RED_POSITIONS           EQU     $7E00                       ; a 256-aligned memory area reserved for red positions
70F4             7 18 CANDIDATES              EQU     $7F00                       ; a 256-aligned memory area reserved to store candidates
70F4             7 20 ; ----------------------------------------------------------------------------------------------------------------------
70F4             7 21 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
70F4             7 22 ;
70F4             7 23 ; Input:    -
70F4             7 24 ;
70F4             7 25 ; Output:   A   = FRIEND if current token color is cyan, or A = ENEMY if current token color is red
70F4             7 26 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70F4             7 27 ;
70F4             7 28 ; Uses:     TOKEN_COLOR (current token color)
70F4             7 29 ;
70F4             7 30 ; Destroys: -
70F4             7 31 ; ----------------------------------------------------------------------------------------------------------------------
70F4             7 32 PathFinder_Friend:
70F4 3A 9E 61    7 33 ld      a, (TOKEN_COLOR)            ; get current player color
70F7 EE 07       7 34 xor     $07                         ; is current player color cyan?
70F9 E0          7 35 ret     po                          ; yes, return FRIEND 
70FA 3E 7E       7 36 ld      a, ENEMY                    ; no, return ENEMY
70FC C9          7 37 ret
70FD             7 39 ; ----------------------------------------------------------------------------------------------------------------------
70FD             7 40 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
70FD             7 41 ;
70FD             7 42 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
70FD             7 43 ;           HL = CYAN_POSITIONS token address
70FD             7 44 ;
70FD             7 45 ; Output:   A   = inverted side (FRIEND or ENEMY)
70FD             7 46 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70FD             7 47 ;
70FD             7 48 ; Destroys: -
70FD             7 49 ; ----------------------------------------------------------------------------------------------------------------------
70FD             7 50 PathFinder_PutToken:
70FD 77          7 51 ld      (hl), a                     ; put token at cyan position
70FE 24          7 52 inc     h                           ; move HL to red position address
70FF EE 7C       7 53 xor     $7C                         ; invert side
7101 77          7 54 ld      (hl), a                     ; put token at red position
7102 C9          7 55 ret
7103             7 57 ; ----------------------------------------------------------------------------------------------------------------------
7103             7 58 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
7103             7 59 ;
7103             7 60 ; Input:    HL = CYAN_POSITIONS token address
7103             7 61 ;
7103             7 62 ; Output:   -
7103             7 63 ;
7103             7 64 ; Destroys: -
7103             7 65 ; ----------------------------------------------------------------------------------------------------------------------
7103             7 66 PathFinder_EraseToken:
7103 36 00       7 67 ld      (hl), EMPTY                 ; erase token at cyan position
7105 24          7 68 inc     h                           ; move HL to red position address
7106 36 00       7 69 ld      (hl), EMPTY                 ; erase token at red position
7108 C9          7 70 ret
7109             7 72 ; ----------------------------------------------------------------------------------------------------------------------
7109             7 73 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
7109             7 74 ;
7109             7 75 ; Input:    DE = cyan or red board address (destiny)
7109             7 76 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
7109             7 77 ;
7109             7 78 ; Output:   DE = cyan or red board address (last position+1)
7109             7 79 ;
7109             7 80 ; Destroys: BC, HL
7109             7 81 ; ----------------------------------------------------------------------------------------------------------------------
7109             7 82 PathFinder_CopyPositions:
7109 01 31 00    7 83 ld      bc, 7*7                     ; number of positions to be copied
710C             7 84 PathFinder_CopyLoop
710C 2C          7 85 inc     l                           ; skip borders on positions
710D 2C          7 86 inc     l
710E 1C          7 87 inc     e                           ; skip borders on board
710F 1C          7 88 inc     e
7110 ED A0       7 89 ldi                                 ; copy a row of 7 positions
7112 ED A0       7 90 ldi
7114 ED A0       7 91 ldi
7116 ED A0       7 92 ldi
7118 ED A0       7 93 ldi
711A ED A0       7 94 ldi
711C ED A0       7 95 ldi
711E EA 0C 71    7 96 jp      pe, PathFinder_CopyLoop     ; repeat for each row
7121 C9          7 97 ret
7122             7 99 ; ----------------------------------------------------------------------------------------------------------------------
7122             7 100 ; PathFinder_Update: update current board position during heuristic function evaluation
7122             7 101 ;
7122             7 102 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
7122             7 103 ; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
7122             7 104 ; adjacent".
7122             7 105 ;
7122             7 106 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
7122             7 107 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
7122             7 108 ; follows, depending on current content:
7122             7 109 ;
7122             7 110 ; * SKIPPED: 1 + distance of neighbor closest to goal
7122             7 111 ; * FRIEND:  distance of neighbor closest to goal
7122             7 112 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
7122             7 113 ;
7122             7 114 ; Input:    Z  = flag set when (HL) is FRIEND
7122             7 115 ;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
7122             7 116 ;           HL = current position address (on either cyan boards or red boards)
7122             7 117 ;
7122             7 118 ; Output:   -
7122             7 119 ;
7122             7 120 ; Destroys: B, DE
7122             7 121 ; ----------------------------------------------------------------------------------------------------------------------
7122             7 122 PathFinder_Update:
7122 28 12       7 123 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
7124 46          7 124 ld      b, (hl)                     ; check current position
7125 10 1A       7 125 djnz    PathFinder_EMPTY            ; if (hl) = EMPTY, jump below
7127             7 126 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
7127             7 127 PathFinder_Skipped:
7127 71          7 128 ld      (hl), c                     ; save current distance in current position
7128 34          7 129 inc     (hl)                        ; increment distance of current position
7129 CB B6       7 130 res     6, (hl)                     ; reset friendly token flag
712B EB          7 131 ex      de, hl                      ; store current position in DE
712C             7 132 @Queue_Tail
712C 21 00 00    7 133 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
712F 2C          7 134 inc     l                           ; move queue tail down
7130 73          7 135 ld      (hl), e                     ; store position into queue tail
7131 22 2D 71    7 136 ld      (@Queue_Tail+1), hl         ; update queue tail
7134 EB          7 137 ex      de, hl                      ; restore current position
7135 C9          7 138 ret
7136             7 139 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
7136             7 140 PathFinder_Friendly
7136 71          7 141 ld      (hl), c                     ; save current distance in current position
7137 CB F6       7 142 set     6, (hl)                     ; set friendly token flag
7139 45          7 143 ld      b, l                        ; save current position in B
713A D1          7 144 pop     de                          ; preserve RET address
713B E3          7 145 ex      (sp), hl                    ; retrieve queue head
713C 70          7 146 ld      (hl), b                     ; push this position into queue head
713D 2D          7 147 dec     l                           ; move queue head up
713E E3          7 148 ex      (sp), hl                    ; update queue head
713F D5          7 149 push    de                          ; restore RET address
7140 C9          7 150 ret
7141             7 151 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
7141             7 152 PathFinder_EMPTY
7141 CB 71       7 153 bit     6, c                        ; is current distance friendly?
7143 20 E2       7 154 jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
7145 34          7 155 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
7146 C9          7 156 ret
7147             7 158 ; ----------------------------------------------------------------------------------------------------------------------
7147             7 159 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7147             7 160 ;
7147             7 161 ; Input:    -
7147             7 162 ;
7147             7 163 ; Output:   A  = -1, if down edge couldn't be reached
7147             7 164 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
7147             7 165 ;           A  = last edge position visited (-1), otherwise
7147             7 166 ;           HL = cyan queue head address
7147             7 167 ;
7147             7 168 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7147             7 169 ;
7147             7 170 ; Destroys: BC, DE, IY
7147             7 171 ; ----------------------------------------------------------------------------------------------------------------------
7147             7 172 PathFinder_Cyan_UpDown:
7147 21 07 7D    7 173 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
714A 11 07 61    7 174 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
714D CD 09 71    7 175 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
7150             7 177 ; entry point for PathFinder_VictoryPath
7150             7 178 PathFinder_Cyan_CheckPath:
7150 FD 21 00 09 7 179 ld      iy, $0900                   ; IYH = distance to check edge positions
7154             7 180 ; IYL = last edge position visited
7154 21 00 60    7 181 ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
7157 22 2D 71    7 182 ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
715A E5          7 183 push    hl                          ; store cyan queue head
715B             7 185 ; set up cyan board (up-down) start positions distances
715B 21 09 61    7 187 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
715E 0E 43       7 188 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7160 3E 02       7 189 ld      a, FRIEND                   ; set distance to compare with
7162 BE          7 190 cp      (hl)                        ; check 1st start position distance
7163 D4 22 71    7 191 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7166 2C          7 192 inc     l                           ; move HL to next start position address
7167 BE          7 193 cp      (hl)                        ; check 2nd start position distance
7168 D4 22 71    7 194 call    nc, PathFinder_Update       ; (repeat for each start position)
716B 2C          7 195 inc     l
716C BE          7 196 cp      (hl)                        ; check 3rd start position distance
716D D4 22 71    7 197 call    nc, PathFinder_Update
7170 2C          7 198 inc     l
7171 BE          7 199 cp      (hl)                        ; check 4th start position distance
7172 D4 22 71    7 200 call    nc, PathFinder_Update
7175 2C          7 201 inc     l
7176 BE          7 202 cp      (hl)                        ; check 5th start position distance
7177 D4 22 71    7 203 call    nc, PathFinder_Update
717A 2C          7 204 inc     l
717B BE          7 205 cp      (hl)                        ; check 6th start position distance
717C D4 22 71    7 206 call    nc, PathFinder_Update
717F 2C          7 207 inc     l
7180 C3 6D 72    7 208 jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)
7183             7 210 ; ----------------------------------------------------------------------------------------------------------------------
7183             7 211 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
7183             7 212 ;
7183             7 213 ; Input:    -
7183             7 214 ;
7183             7 215 ; Output:   A  = -1, if up edge couldn't be reached
7183             7 216 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
7183             7 217 ;           A  = last edge position visited (-1), otherwise
7183             7 218 ;           HL = cyan queue head address
7183             7 219 ;
7183             7 220 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7183             7 221 ;
7183             7 222 ; Destroys: BC, DE, IY
7183             7 223 ; ----------------------------------------------------------------------------------------------------------------------
7183             7 224 PathFinder_Cyan_DownUp:
7183 21 07 7D    7 225 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7186 11 4F 61    7 226 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
7189 CD 09 71    7 227 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
718C FD 21 00 F7 7 229 ld      iy, $F700                   ; IYH = distance to check edge positions
7190             7 230 ; IYL = last edge position visited
7190 2A 2D 71    7 231 ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
7193 E5          7 232 push    hl                          ; initialize cyan queue head
7194             7 234 ; set up cyan board (down-up) start positions distances
7194 EB          7 236 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
7195 2D          7 237 dec     l                           ; move HL to cyan boad down-up address (last position)
7196 0E 43       7 238 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7198 3E 02       7 239 ld      a, FRIEND                   ; set distance to compare with
719A BE          7 240 cp      (hl)                        ; check 1st start position distance
719B D4 22 71    7 241 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
719E 2D          7 242 dec     l                           ; move HL to next start position address
719F BE          7 243 cp      (hl)                        ; check 2nd start position distance
71A0 D4 22 71    7 244 call    nc, PathFinder_Update       ; (repeat for each start position)
71A3 2D          7 245 dec     l
71A4 BE          7 246 cp      (hl)                        ; check 3rd start position distance
71A5 D4 22 71    7 247 call    nc, PathFinder_Update
71A8 2D          7 248 dec     l
71A9 BE          7 249 cp      (hl)                        ; check 4th start position distance
71AA D4 22 71    7 250 call    nc, PathFinder_Update
71AD 2D          7 251 dec     l
71AE BE          7 252 cp      (hl)                        ; check 5th start position distance
71AF D4 22 71    7 253 call    nc, PathFinder_Update
71B2 2D          7 254 dec     l
71B3 BE          7 255 cp      (hl)                        ; check 6th start position distance
71B4 D4 22 71    7 256 call    nc, PathFinder_Update
71B7 2D          7 257 dec     l
71B8 C3 6D 72    7 258 jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)
71BB             7 260 ; ----------------------------------------------------------------------------------------------------------------------
71BB             7 261 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71BB             7 262 ;
71BB             7 263 ; Input:    -
71BB             7 264 ;
71BB             7 265 ; Output:   A  = -1, if right edge couldn't be reached
71BB             7 266 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
71BB             7 267 ;           A  = last edge position visited (-1), otherwise
71BB             7 268 ;           HL = red queue head address
71BB             7 269 ;
71BB             7 270 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71BB             7 271 ;
71BB             7 272 ; Destroys: BC, DE, IY
71BB             7 273 ; ----------------------------------------------------------------------------------------------------------------------
71BB             7 274 PathFinder_Red_LeftRight:
71BB 21 07 7E    7 275 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71BE 11 07 64    7 276 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71C1 CD 09 71    7 277 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71C4             7 279 ; entry point for PathFinder_VictoryPath
71C4             7 280 PathFinder_Red_CheckPath
71C4 FD 21 00 01 7 281 ld      iy, $0100                   ; IYH = distance to check edge positions
71C8             7 282 ; IYL = last edge position visited
71C8 21 00 63    7 283 ld      hl, RED_QUEUE_AREA          ; HL points to red queue area address
71CB 22 2D 71    7 284 ld      (@Queue_Tail+1), hl         ; initialize red queue tail
71CE E5          7 285 push    hl                          ; store red queue head
71CF             7 287 ; set up red board (left-right) start positions distances
71CF 21 09 64    7 289 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
71D2 0E 43       7 290 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71D4 3E 02       7 291 ld      a, FRIEND                   ; set distance to compare with
71D6 BE          7 292 cp      (hl)                        ; check 1st start position distance
71D7 D4 22 71    7 293 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71DA 2E 12       7 294 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
71DC BE          7 295 cp      (hl)                        ; check 2nd start position distance
71DD D4 22 71    7 296 call    nc, PathFinder_Update       ; (repeat for each start position)
71E0 2E 1B       7 297 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
71E2 BE          7 298 cp      (hl)                        ; check 3rd start position distance
71E3 D4 22 71    7 299 call    nc, PathFinder_Update
71E6 2E 24       7 300 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
71E8 BE          7 301 cp      (hl)                        ; check 4th start position distance
71E9 D4 22 71    7 302 call    nc, PathFinder_Update
71EC 2E 2D       7 303 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
71EE BE          7 304 cp      (hl)                        ; check 5th start position distance
71EF D4 22 71    7 305 call    nc, PathFinder_Update
71F2 2E 36       7 306 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
71F4 BE          7 307 cp      (hl)                        ; check 6th start position distance
71F5 D4 22 71    7 308 call    nc, PathFinder_Update
71F8 2E 3F       7 309 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
71FA C3 6D 72    7 310 jp      Path_Finder_First           ; calculate two-distances of red board (left-right)
71FD             7 312 ; ----------------------------------------------------------------------------------------------------------------------
71FD             7 313 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
71FD             7 314 ;
71FD             7 315 ; Input:    -
71FD             7 316 ;
71FD             7 317 ; Output:   A  = -1, if left edge couldn't be reached
71FD             7 318 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
71FD             7 319 ;           A  = last edge position visited (-1), otherwise
71FD             7 320 ;           HL = red queue head address
71FD             7 321 ;
71FD             7 322 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71FD             7 323 ;
71FD             7 324 ; Destroys: BC, DE, IY
71FD             7 325 ; ----------------------------------------------------------------------------------------------------------------------
71FD             7 326 PathFinder_Red_RightLeft:
71FD 21 07 7E    7 327 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
7200 11 4F 64    7 328 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
7203 CD 09 71    7 329 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
7206 FD 21 00 FF 7 331 ld      iy, $FF00                   ; IYH = distance to check edge positions
720A             7 332 ; IYL = last edge position visited
720A 2A 2D 71    7 333 ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
720D E5          7 334 push    hl                          ; initialize red queue head
720E             7 336 ; set up red board (right-left) start positions distances
720E EB          7 338 ex      de, hl                      ; take advantage of last "CopyPositions" execution
720F 2D          7 339 dec     l                           ; move HL to red board right-left address (last position)
7210 0E 43       7 340 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7212 3E 02       7 341 ld      a, FRIEND                   ; set distance to compare with
7214 BE          7 342 cp      (hl)                        ; check 1st start position distance
7215 D4 22 71    7 343 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7218 2E 84       7 344 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
721A BE          7 345 cp      (hl)                        ; check 2nd start position distance
721B D4 22 71    7 346 call    nc, PathFinder_Update       ; (repeat for each start position)
721E 2E 7B       7 347 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
7220 BE          7 348 cp      (hl)                        ; check 3rd start position distance
7221 D4 22 71    7 349 call    nc, PathFinder_Update
7224 2E 72       7 350 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
7226 BE          7 351 cp      (hl)                        ; check 4th start position distance
7227 D4 22 71    7 352 call    nc, PathFinder_Update
722A 2E 69       7 353 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
722C BE          7 354 cp      (hl)                        ; check 5th start position distance
722D D4 22 71    7 355 call    nc, PathFinder_Update
7230 2E 60       7 356 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
7232 BE          7 357 cp      (hl)                        ; check 6th start position distance
7233 D4 22 71    7 358 call    nc, PathFinder_Update
7236 2E 57       7 359 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
7238 C3 6D 72    7 360 jp      Path_Finder_First           ; calculate red two-distance (right-left)
723B             7 362 ; ----------------------------------------------------------------------------------------------------------------------
723B             7 363 ; Path_Finder: calculate two-distance metric for each board position
723B             7 364 ;
723B             7 365 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
723B             7 366 ;
723B             7 367 ; Input:    HL  = cyan or red queue area address
723B             7 368 ;           IYH = distance to check edge positions
723B             7 369 ;           IYL = 0
723B             7 370 ;
723B             7 371 ; Output:   A   = -1, if corresponding edge couldn't be reached
723B             7 372 ;           A   =  0, if there is chain of connected (color) tokens between the two edges
723B             7 373 ;           A   = last edge position visited (-1), otherwise
723B             7 374 ;           HL  = cyan or red queue head address
723B             7 375 ;
723B             7 376 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
723B             7 377 ;
723B             7 378 ; Destroys: BC, DE, IY
723B             7 379 ; ----------------------------------------------------------------------------------------------------------------------
723B             7 380 Path_Finder:
723B 2C          7 381 inc     l                           ; move queue head down
723C E5          7 382 push    hl                          ; preserve queue head address
723D 6E          7 383 ld      l, (hl)                     ; retrieve next position to be checked
723E 24          7 384 inc     h                           ; move HL to corresponding board address
723F 4E          7 385 ld      c, (hl)                     ; retrieve distance from this position to start
7240 5D          7 386 ld      e, l                        ; store current position
7241             7 388 ; look for adjacent positions
7241 7D          7 390 ld      a, l                        ; get current position
7242 FD 84       7 391 add     a, iyh                      ; add distance to check edge positions
7244 6F          7 392 ld      l, a                        ; move HL to calculated position address
7245 CB 7E       7 393 bit     7, (hl)                     ; is it an edge?
7247 20 34       7 394 jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions
7249 3E 02       7 396 ld      a, FRIEND                   ; set distance to compare with
724B             7 397 ; return point from PathFinder_Adjacent
724B             7 398 Path_Finder_Neighbors
724B 6B          7 399 ld      l, e                        ; restore current position to be checked
724C 2C          7 400 inc     l                           ; move HL to right neighbor address
724D BE          7 401 cp      (hl)                        ; check right neighbor distance
724E D4 22 71    7 402 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7251 2D          7 403 dec     l                           ; move HL to left neighbor address
7252 2D          7 404 dec     l
7253 BE          7 405 cp      (hl)                        ; check left neighbor distance
7254 D4 22 71    7 406 call    nc, PathFinder_Update       ; (repeat for each neighbor)
7257 11 F8 FF    7 407 ld      de, -WIDTH
725A 19          7 408 add     hl, de
725B BE          7 409 cp      (hl)                        ; check upper-left neighbor distance
725C D4 22 71    7 410 call    nc, PathFinder_Update
725F 2C          7 411 inc     l
7260 BE          7 412 cp      (hl)                        ; check upper-right neighbor distance
7261 D4 22 71    7 413 call    nc, PathFinder_Update
7264 11 10 00    7 414 ld      de, WIDTH*2
7267 19          7 415 add     hl, de
7268 BE          7 416 cp      (hl)                        ; check lower-left neighbor distance
7269 D4 22 71    7 417 call    nc, PathFinder_Update
726C 2C          7 418 inc     l
726D             7 419 Path_Finder_First
726D BE          7 420 cp      (hl)                        ; check lower-right neighbor distance
726E D4 22 71    7 421 call    nc, PathFinder_Update
7271 E1          7 422 pop     hl                          ; retreive queue head address
7272 3A 2D 71    7 423 ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
7275 BD          7 424 cp      l                           ; is queue empty?
7276 C2 3B 72    7 425 jp      nz, Path_Finder             ; no, repeat until queue is empty
7279 FD 7D       7 427 ld      a, iyl                      ; get last edge position visited
727B 3D          7 428 dec     a                           ; return A = -1, if the edge couldn't be reached
727C C9          7 429 ret
727D             7 431 ; ----------------------------------------------------------------------------------------------------------------------
727D             7 432 ; Check adjacent hexagons.
727D             7 433 ;
727D             7 434 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
727D             7 435 ; "two cells are adjacent if they share a common edge on the board."
727D             7 436 ;
727D             7 437 ; Input:    E  = current position
727D             7 438 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
727D             7 439 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
727D             7 440 ;                edge number)
727D             7 441 ;
727D             7 442 ; Output:   A  = 0 and HL = cyan or red queue head address, if there is a chain of connected tokens of the same color
727D             7 443 ;                between the two edges.
727D             7 444 ;           A  = FRIEND and E = current position, otherwise.
727D             7 445 ;
727D             7 446 ; Destroys: BC, D
727D             7 447 ; ----------------------------------------------------------------------------------------------------------------------
727D             7 448 Path_Finder_Adjacent
727D 3E 43       7 449 ld      a, VICTORY+$40              ; set victory distance + friendly flag
727F B9          7 450 cp      c                           ; is current distance victory and friendly?
7280 28 0E       7 451 jr      z, Path_Finder_Abort        ; yes, abort path_finder
7282 FD 6B       7 453 ld      iyl, e                      ; update last edge position visited
7284 54          7 454 ld      d, h                        ; store pointer to current position address in DE
7285 6E          7 455 ld      l, (hl)                     ; get current edge position
7286 CB 25       7 456 sla     l                           ; calculate vector table routine index
7288 24          7 457 inc     h                           ; move HL to (cyan or red) vector table routine address
7289 7E          7 458 ld      a, (hl)                     ; get low byte of vector table routine address
728A 2C          7 459 inc     l                           ; move HL to high byte of vector table routine address
728B 66          7 460 ld      h, (hl)                     ; get high byte of vector table routine address
728C 6F          7 461 ld      l, a                        ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
728D 3E 02       7 462 ld      a, FRIEND                   ; set distance to compare with
728F E9          7 463 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
7290             7 464 Path_Finder_Abort
7290 E1          7 465 pop     hl                          ; restore queue head address
7291 AF          7 466 xor     a                           ; return A = 0
7292 C9          7 467 ret
7293             7 469 ; ----------------------------------------------------------------------------------------------------------------------
7293             7 470 ;  Check two-distance of RED adjacents
7293             7 471 ; ----------------------------------------------------------------------------------------------------------------------
7293             7 472 PathFinder_RED_Edge_0
7293 EB          7 473 ex      de, hl                      ; restore pointer to current position address
7294 11 12 00    7 474 ld      de, 9*2                     ; calculate distance to adjacent #2
7297 19          7 475 add     hl, de                      ; move HL to adjacent #2 address
7298 BE          7 476 cp      (hl)                        ; check adjacent #2 distance
7299 D4 22 71    7 477 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
729C 11 09 00    7 478 ld      de, 9                       ; calculate distance to adjacent #3
729F 19          7 479 add     hl, de                      ; move HL to adjacent #3 address
72A0 BE          7 480 cp      (hl)                        ; check adjacent #3 distance
72A1 D4 22 71    7 481 call    nc, PathFinder_Update       ; (repeat for each adjacent)
72A4 11 09 00    7 482 ld      de, 9
72A7 19          7 483 add     hl, de
72A8 BE          7 484 cp      (hl)                        ; check adjacent #4 distance
72A9 D4 22 71    7 485 call    nc, PathFinder_Update
72AC 11 09 00    7 486 ld      de, 9
72AF 19          7 487 add     hl, de
72B0 BE          7 488 cp      (hl)                        ; check adjacent #5 distance
72B1 D4 22 71    7 489 call    nc, PathFinder_Update
72B4 11 09 00    7 490 ld      de, 9
72B7 19          7 491 add     hl, de
72B8 BE          7 492 cp      (hl)                        ; check adjacent #6 distance
72B9 D4 22 71    7 493 call    nc, PathFinder_Update
72BC FD 5D       7 494 ld      e, iyl                      ; restore current position
72BE C3 4B 72    7 495 jp      Path_Finder_Neighbors       ; continue processing neighbors
72C1             7 497 PathFinder_RED_Edge_1
72C1 EB          7 498 ex      de, hl                      ; restore pointer to current position address
72C2 11 12 00    7 499 ld      de, 9*2
72C5 19          7 500 add     hl, de
72C6 BE          7 501 cp      (hl)                        ; check adjacent #3 distance
72C7 D4 22 71    7 502 call    nc, PathFinder_Update
72CA 11 09 00    7 503 ld      de, 9
72CD 19          7 504 add     hl, de
72CE BE          7 505 cp      (hl)                        ; check adjacent #4 distance
72CF D4 22 71    7 506 call    nc, PathFinder_Update
72D2 11 09 00    7 507 ld      de, 9
72D5 19          7 508 add     hl, de
72D6 BE          7 509 cp      (hl)                        ; check adjacent #5 distance
72D7 D4 22 71    7 510 call    nc, PathFinder_Update
72DA 11 09 00    7 511 ld      de, 9
72DD 19          7 512 add     hl, de
72DE BE          7 513 cp      (hl)                        ; check adjacent #6 distance
72DF D4 22 71    7 514 call    nc, PathFinder_Update
72E2 FD 5D       7 515 ld      e, iyl                      ; restore current position
72E4 C3 4B 72    7 516 jp      Path_Finder_Neighbors       ; continue processing neighbors
72E7             7 518 PathFinder_RED_Edge_2
72E7 EB          7 519 ex      de, hl                      ; restore pointer to current position address
72E8 11 12 00    7 520 ld      de, 9*2
72EB 19          7 521 add     hl, de
72EC BE          7 522 cp      (hl)                        ; check adjacent #4 distance
72ED D4 22 71    7 523 call    nc, PathFinder_Update
72F0 11 09 00    7 524 ld      de, 9
72F3 19          7 525 add     hl, de
72F4 BE          7 526 cp      (hl)                        ; check adjacent #5 distance
72F5 D4 22 71    7 527 call    nc, PathFinder_Update
72F8 11 09 00    7 528 ld      de, 9
72FB 19          7 529 add     hl, de
72FC BE          7 530 cp      (hl)                        ; check adjacent #6 distance
72FD D4 22 71    7 531 call    nc, PathFinder_Update
7300 11 CA FF    7 532 ld      de, -9*6
7303 19          7 533 add     hl, de
7304 BE          7 534 cp      (hl)                        ; check adjacent #0 distance
7305 D4 22 71    7 535 call    nc, PathFinder_Update
7308 FD 5D       7 536 ld      e, iyl                      ; restore current position
730A C3 4B 72    7 537 jp      Path_Finder_Neighbors       ; continue processing neighbors
730D             7 539 PathFinder_RED_Edge_3
730D EB          7 540 ex      de, hl                      ; restore pointer to current position address
730E 11 E5 FF    7 541 ld      de, -9*3
7311 19          7 542 add     hl, de
7312 BE          7 543 cp      (hl)                        ; check adjacent #0 distance
7313 D4 22 71    7 544 call    nc, PathFinder_Update
7316 11 09 00    7 545 ld      de, 9
7319 19          7 546 add     hl, de
731A BE          7 547 cp      (hl)                        ; check adjacent #1 distance
731B D4 22 71    7 548 call    nc, PathFinder_Update
731E 11 24 00    7 549 ld      de, 9*4
7321 19          7 550 add     hl, de
7322 BE          7 551 cp      (hl)                        ; check adjacent #5 distance
7323 D4 22 71    7 552 call    nc, PathFinder_Update
7326 11 09 00    7 553 ld      de, 9
7329 19          7 554 add     hl, de
732A BE          7 555 cp      (hl)                        ; check adjacent #6 distance
732B D4 22 71    7 556 call    nc, PathFinder_Update
732E FD 5D       7 557 ld      e, iyl                      ; restore current position
7330 C3 4B 72    7 558 jp      Path_Finder_Neighbors       ; continue processing neighbors
7333             7 560 PathFinder_RED_Edge_4
7333 EB          7 561 ex      de, hl                      ; restore pointer to current position address
7334 11 12 00    7 562 ld      de, 9*2
7337 19          7 563 add     hl, de
7338 BE          7 564 cp      (hl)                        ; check adjacent #6 distance
7339 D4 22 71    7 565 call    nc, PathFinder_Update
733C 11 CA FF    7 566 ld      de, -9*6
733F 19          7 567 add     hl, de
7340 BE          7 568 cp      (hl)                        ; check adjacent #0 distance
7341 D4 22 71    7 569 call    nc, PathFinder_Update
7344 11 09 00    7 570 ld      de, 9
7347 19          7 571 add     hl, de
7348 BE          7 572 cp      (hl)                        ; check adjacent #1 distance
7349 D4 22 71    7 573 call    nc, PathFinder_Update
734C 11 09 00    7 574 ld      de, 9
734F 19          7 575 add     hl, de
7350 BE          7 576 cp      (hl)                        ; check adjacent #2 distance
7351 D4 22 71    7 577 call    nc, PathFinder_Update
7354 FD 5D       7 578 ld      e, iyl                      ; restore current position
7356 C3 4B 72    7 579 jp      Path_Finder_Neighbors       ; continue processing neighbors
7359             7 581 PathFinder_RED_Edge_5
7359 EB          7 582 ex      de, hl                      ; restore pointer to current position address
735A 11 D3 FF    7 583 ld      de, -9*5
735D 19          7 584 add     hl, de
735E BE          7 585 cp      (hl)                        ; check adjacent #0 distance
735F D4 22 71    7 586 call    nc, PathFinder_Update
7362 11 09 00    7 587 ld      de, 9
7365 19          7 588 add     hl, de
7366 BE          7 589 cp      (hl)                        ; check adjacent #1 distance
7367 D4 22 71    7 590 call    nc, PathFinder_Update
736A 11 09 00    7 591 ld      de, 9
736D 19          7 592 add     hl, de
736E BE          7 593 cp      (hl)                        ; check adjacent #2 distance
736F D4 22 71    7 594 call    nc, PathFinder_Update
7372 11 09 00    7 595 ld      de, 9
7375 19          7 596 add     hl, de
7376 BE          7 597 cp      (hl)                        ; check adjacent #3 distance
7377 D4 22 71    7 598 call    nc, PathFinder_Update
737A FD 5D       7 599 ld      e, iyl                      ; restore current position
737C C3 4B 72    7 600 jp      Path_Finder_Neighbors       ; continue processing neighbors
737F             7 602 PathFinder_RED_Edge_6
737F EB          7 603 ex      de, hl                      ; restore pointer to current position address
7380 11 CA FF    7 604 ld      de, -9*6
7383 19          7 605 add     hl, de
7384 BE          7 606 cp      (hl)                        ; check adjacent #0 distance
7385 D4 22 71    7 607 call    nc, PathFinder_Update
7388 11 09 00    7 608 ld      de, 9
738B 19          7 609 add     hl, de
738C BE          7 610 cp      (hl)                        ; check adjacent #1 distance
738D D4 22 71    7 611 call    nc, PathFinder_Update
7390 11 09 00    7 612 ld      de, 9
7393 19          7 613 add     hl, de
7394 BE          7 614 cp      (hl)                        ; check adjacent #2 distance
7395 D4 22 71    7 615 call    nc, PathFinder_Update
7398 11 09 00    7 616 ld      de, 9
739B 19          7 617 add     hl, de
739C BE          7 618 cp      (hl)                        ; check adjacent #3 distance
739D D4 22 71    7 619 call    nc, PathFinder_Update
73A0 11 09 00    7 620 ld      de, 9
73A3 19          7 621 add     hl, de
73A4 BE          7 622 cp      (hl)                        ; check adjacent #4 distance
73A5 D4 22 71    7 623 call    nc, PathFinder_Update
73A8 FD 5D       7 624 ld      e, iyl                      ; restore current position
73AA C3 4B 72    7 625 jp      Path_Finder_Neighbors       ; continue processing neighbors
73AD             7 627 ; ----------------------------------------------------------------------------------------------------------------------
73AD             7 628 ;  Check two-distance of CYAN adjacents
73AD             7 629 ; ----------------------------------------------------------------------------------------------------------------------
73AD             7 630 PathFinder_CYAN_Edge_0
73AD EB          7 631 ex      de, hl                      ; restore pointer to current position address
73AE 2C          7 632 inc     l
73AF 2C          7 633 inc     l
73B0 BE          7 634 cp      (hl)                        ; check adjacent #2 distance
73B1 D4 22 71    7 635 call    nc, PathFinder_Update
73B4 2C          7 636 inc     l
73B5 BE          7 637 cp      (hl)                        ; check adjacent #3 distance
73B6 D4 22 71    7 638 call    nc, PathFinder_Update
73B9 2C          7 639 inc     l
73BA BE          7 640 cp      (hl)                        ; check adjacent #4 distance
73BB D4 22 71    7 641 call    nc, PathFinder_Update
73BE 2C          7 642 inc     l
73BF BE          7 643 cp      (hl)                        ; check adjacent of edge number 5
73C0 D4 22 71    7 644 call    nc, PathFinder_Update
73C3 2C          7 645 inc     l
73C4 BE          7 646 cp      (hl)                        ; check adjacent of edge number 6
73C5 D4 22 71    7 647 call    nc, PathFinder_Update
73C8 FD 5D       7 648 ld      e, iyl                      ; restore current position
73CA C3 4B 72    7 649 jp      Path_Finder_Neighbors       ; continue processing neighbors
73CD             7 651 PathFinder_CYAN_Edge_1
73CD EB          7 652 ex      de, hl                      ; restore pointer to current position address
73CE 2C          7 653 inc     l
73CF 2C          7 654 inc     l
73D0 BE          7 655 cp      (hl)                        ; check adjacent #3 distance
73D1 D4 22 71    7 656 call    nc, PathFinder_Update
73D4 2C          7 657 inc     l
73D5 BE          7 658 cp      (hl)                        ; check adjacent #4 distance
73D6 D4 22 71    7 659 call    nc, PathFinder_Update
73D9 2C          7 660 inc     l
73DA BE          7 661 cp      (hl)                        ; check adjacent #5 distance
73DB D4 22 71    7 662 call    nc, PathFinder_Update
73DE 2C          7 663 inc     l
73DF BE          7 664 cp      (hl)                        ; check adjacent #6 distance
73E0 D4 22 71    7 665 call    nc, PathFinder_Update
73E3 FD 5D       7 666 ld      e, iyl                      ; restore current position
73E5 C3 4B 72    7 667 jp      Path_Finder_Neighbors       ; continue processing neighbors
73E8             7 669 PathFinder_CYAN_Edge_2
73E8 EB          7 670 ex      de, hl                      ; restore pointer to current position address
73E9 2D          7 671 dec     l
73EA 2D          7 672 dec     l
73EB BE          7 673 cp      (hl)                        ; check adjacent #0 distance
73EC D4 22 71    7 674 call    nc, PathFinder_Update
73EF 2C          7 675 inc     l
73F0 2C          7 676 inc     l
73F1 2C          7 677 inc     l
73F2 2C          7 678 inc     l
73F3 BE          7 679 cp      (hl)                        ; check adjacent #4 distance
73F4 D4 22 71    7 680 call    nc, PathFinder_Update
73F7 2C          7 681 inc     l
73F8 BE          7 682 cp      (hl)                        ; check adjacent #5 distance
73F9 D4 22 71    7 683 call    nc, PathFinder_Update
73FC 2C          7 684 inc     l
73FD BE          7 685 cp      (hl)                        ; check adjacent #6 distance
73FE D4 22 71    7 686 call    nc, PathFinder_Update
7401 FD 5D       7 687 ld      e, iyl                      ; restore current position
7403 C3 4B 72    7 688 jp      Path_Finder_Neighbors       ; continue processing neighbors
7406             7 690 PathFinder_CYAN_Edge_3
7406 EB          7 691 ex      de, hl                      ; restore pointer to current position address
7407 2D          7 692 dec     l
7408 2D          7 693 dec     l
7409 2D          7 694 dec     l
740A BE          7 695 cp      (hl)                        ; check adjacent #0 distance
740B D4 22 71    7 696 call    nc, PathFinder_Update
740E 2C          7 697 inc     l
740F BE          7 698 cp      (hl)                        ; check adjacent #1 distance
7410 D4 22 71    7 699 call    nc, PathFinder_Update
7413 2C          7 700 inc     l
7414 2C          7 701 inc     l
7415 2C          7 702 inc     l
7416 2C          7 703 inc     l
7417 BE          7 704 cp      (hl)                        ; check adjacent #5 distance
7418 D4 22 71    7 705 call    nc, PathFinder_Update
741B 2C          7 706 inc     l
741C BE          7 707 cp      (hl)                        ; check adjacent #6 distance
741D D4 22 71    7 708 call    nc, PathFinder_Update
7420 FD 5D       7 709 ld      e, iyl                      ; restore current position
7422 C3 4B 72    7 710 jp      Path_Finder_Neighbors       ; continue processing neighbors
7425             7 712 PathFinder_CYAN_Edge_4
7425 EB          7 713 ex      de, hl                      ; restore pointer to current position address
7426 2C          7 714 inc     l
7427 2C          7 715 inc     l
7428 BE          7 716 cp      (hl)                        ; check adjacent #6 distance
7429 D4 22 71    7 717 call    nc, PathFinder_Update
742C 2D          7 718 dec     l
742D 2D          7 719 dec     l
742E 2D          7 720 dec     l
742F 2D          7 721 dec     l
7430 BE          7 722 cp      (hl)                        ; check adjacent #2 distance
7431 D4 22 71    7 723 call    nc, PathFinder_Update
7434 2D          7 724 dec     l
7435 BE          7 725 cp      (hl)                        ; check adjacent #1 distance
7436 D4 22 71    7 726 call    nc, PathFinder_Update
7439 2D          7 727 dec     l
743A BE          7 728 cp      (hl)                        ; check adjacent #0 distance
743B D4 22 71    7 729 call    nc, PathFinder_Update
743E FD 5D       7 730 ld      e, iyl                      ; restore current position
7440 C3 4B 72    7 731 jp      Path_Finder_Neighbors       ; continue processing neighbors
7443             7 733 PathFinder_CYAN_Edge_5
7443 EB          7 734 ex      de, hl                      ; restore pointer to current position address
7444 2D          7 735 dec     l
7445 2D          7 736 dec     l
7446 BE          7 737 cp      (hl)                        ; check adjacent #3 distance
7447 D4 22 71    7 738 call    nc, PathFinder_Update
744A 2D          7 739 dec     l
744B BE          7 740 cp      (hl)                        ; check adjacent #2 distance
744C D4 22 71    7 741 call    nc, PathFinder_Update
744F 2D          7 742 dec     l
7450 BE          7 743 cp      (hl)                        ; check adjacent #1 distance
7451 D4 22 71    7 744 call    nc, PathFinder_Update
7454 2D          7 745 dec     l
7455 BE          7 746 cp      (hl)                        ; check adjacent #0 distance
7456 D4 22 71    7 747 call    nc, PathFinder_Update
7459 FD 5D       7 748 ld      e, iyl                      ; restore current position
745B C3 4B 72    7 749 jp      Path_Finder_Neighbors       ; continue processing neighbors
745E             7 751 PathFinder_CYAN_Edge_6
745E EB          7 752 ex      de, hl                      ; restore pointer to current position address
745F 2D          7 753 dec     l
7460 2D          7 754 dec     l
7461 BE          7 755 cp      (hl)                        ; check adjacent #4 distance
7462 D4 22 71    7 756 call    nc, PathFinder_Update
7465 2D          7 757 dec     l
7466 BE          7 758 cp      (hl)                        ; check adjacent #3 distance
7467 D4 22 71    7 759 call    nc, PathFinder_Update
746A 2D          7 760 dec     l
746B BE          7 761 cp      (hl)                        ; check adjacent #2 distance
746C D4 22 71    7 762 call    nc, PathFinder_Update
746F 2D          7 763 dec     l
7470 BE          7 764 cp      (hl)                        ; check adjacent #1 distance
7471 D4 22 71    7 765 call    nc, PathFinder_Update
7474 2D          7 766 dec     l
7475 BE          7 767 cp      (hl)                        ; check adjacent #0 distance
7476 D4 22 71    7 768 call    nc, PathFinder_Update
7479 FD 5D       7 769 ld      e, iyl                      ; restore current position
747B C3 4B 72    7 770 jp      Path_Finder_Neighbors       ; continue processing neighbors
747E             7 772 ; ----------------------------------------------------------------------------------------------------------------------
747E             7 773 ; PathFinder_Score: calculate board score depending on speccy color
747E             7 774 ;
747E             7 775 ; Input:    P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
747E             7 776 ;
747E             7 777 ; Output:   A = -1, if speccy can't reach his opposite edge
747E             7 778 ;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
747E             7 779 ;           A = speccy heuristic evaluation, otherwise
747E             7 780 ;
747E             7 781 ; Uses:     -
747E             7 782 ;
747E             7 783 ; Destroys: A', BC, DE, HL, IY
747E             7 784 ; ----------------------------------------------------------------------------------------------------------------------
747E             7 785 PathFinder_Score:
747E E2 B2 74    7 786 jp      po, PathFinder_CyanScore    ; if speccy side is FRIEND, calculate CYAN score
7481             7 788 ; ----------------------------------------------------------------------------------------------------------------------
7481             7 789 ; PathFinder_RedScore: calculate red score
7481             7 790 ;
7481             7 791 ; Input:    -
7481             7 792 ;
7481             7 793 ; Output:   A = -1, if red can't reach his opposite edge
7481             7 794 ;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
7481             7 795 ;           A = red heuristic evaluation, otherwise
7481             7 796 ;
7481             7 797 ; Uses:     POTENTIALS (board potential and attack mobility)
7481             7 798 ;
7481             7 799 ; Destroys: A', BC, DE, HL, IY
7481             7 800 ; ----------------------------------------------------------------------------------------------------------------------
7481             7 801 PathFinder_RedScore
7481 CD BB 71    7 802 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
7484 C8          7 803 ret     z                           ; if red has a chain of connected tokens, return A = 0
7485 08          7 804 ex      af, af'                     ; save first result
7486 CD FD 71    7 805 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
7489 47          7 806 ld      b, a                        ; save second result
748A 08          7 807 ex      af, af'                     ; restore first result
748B 90          7 808 sub     b                           ; subtract both results
748C 78          7 809 ld      a, b                        ; restore second result
748D C8          7 810 ret     z                           ; if red can't reach his opposite edge, return A = -1
748E CD 47 71    7 812 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
7491 08          7 813 ex      af, af'                     ; save result
7492 CD 83 71    7 814 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
7495 47          7 815 ld      b, a                        ; save second result
7496 08          7 816 ex      af, af'                     ; restore first result
7497 90          7 817 sub     b                           ; subtract both results
7498 C8          7 818 ret     z                           ; if cyan can't reach his opposite edge, return A = 0
7499 21 09 64    7 820 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
749C 11 51 64    7 821 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
749F CD F0 74    7 822 call    PathFinder_Potentials       ; calculate RED potentials
74A2 ED 43 97 61 7 823 ld      (POTENTIALS), bc            ; store RED potentials
74A6 21 09 61    7 825 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74A9 11 51 61    7 826 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74AC CD F0 74    7 827 call    PathFinder_Potentials       ; calculate cyan potentials
74AF C3 E0 74    7 828 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74B2             7 830 ; ----------------------------------------------------------------------------------------------------------------------
74B2             7 831 ; PathFinder_CyanScore: calculate cyan score
74B2             7 832 ;
74B2             7 833 ; Input:    -
74B2             7 834 ;
74B2             7 835 ; Output:   A = -1, if cyan can't reach his opposite edge
74B2             7 836 ;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
74B2             7 837 ;           A = cyan heuristic evaluation, otherwise
74B2             7 838 ;
74B2             7 839 ; Uses:     POTENTIALS (board potential and attack mobility)
74B2             7 840 ;
74B2             7 841 ; Destroys: A', BC, DE, HL
74B2             7 842 ; ----------------------------------------------------------------------------------------------------------------------
74B2             7 843 PathFinder_CyanScore
74B2 CD 47 71    7 844 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74B5 C8          7 845 ret     z                           ; if cyan has a chain of connected tokens, return A = 0
74B6 08          7 846 ex      af, af'                     ; save result
74B7 CD 83 71    7 847 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74BA 47          7 848 ld      b, a                        ; save second result
74BB 08          7 849 ex      af, af'                     ; restore first result
74BC 90          7 850 sub     b                           ; subtract both results
74BD 78          7 851 ld      a, b                        ; restore second result
74BE C8          7 852 ret     z                           ; if cyan can't reach his opposite edge, return A = -1
74BF CD BB 71    7 854 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74C2 08          7 855 ex      af, af'                     ; save result
74C3 CD FD 71    7 856 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74C6 47          7 857 ld      b, a                        ; save second result
74C7 08          7 858 ex      af, af'                     ; restore first result
74C8 90          7 859 sub     b                           ; subtract both results
74C9 C8          7 860 ret     z                           ; if red can't reach his opposite edge, return A = 0
74CA 21 09 61    7 862 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74CD 11 51 61    7 863 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74D0 CD F0 74    7 864 call    PathFinder_Potentials       ; calculate cyan potentials
74D3 ED 43 97 61 7 865 ld      (POTENTIALS), bc            ; save cyan potentials
74D7 21 09 64    7 867 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74DA 11 51 64    7 868 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74DD CD F0 74    7 869 call    PathFinder_Potentials       ; calculate red potentials
74E0             7 870 ; ----------------------------------------------------------------------------------------------------------------------
74E0             7 871 ; PathFinder_Evaluation: calculate heuristic evaluation.
74E0             7 872 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
74E0             7 873 ;
74E0             7 874 ;                                       e = M (pC - pR) - (aC - aR)
74E0             7 875 ; where:
74E0             7 876 ;   pC = cyan board potential
74E0             7 877 ;   pR = red board potential
74E0             7 878 ;   aC = cyan attack mobility
74E0             7 879 ;   aR = red attack mobility
74E0             7 880 ;    M = a large number
74E0             7 881 ;
74E0             7 882 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
74E0             7 883 ;
74E0             7 884 ; Input:    B = opponent attack mobility
74E0             7 885 ;           C = opponent board potential
74E0             7 886 ;
74E0             7 887 ; Output:   A = heuristic evaluation
74E0             7 888 ;
74E0             7 889 ; Destroys: E, HL
74E0             7 890 ; ----------------------------------------------------------------------------------------------------------------------
74E0             7 891 PathFinder_Evaluation:
74E0 21 98 61    7 892 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
74E3 78          7 893 ld      a, b                        ; get opponent's attack mobility
74E4 96          7 894 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
74E5 5F          7 895 ld      e, a                        ; save the result in E
74E6 2D          7 896 dec     l                           ; move HL to player's board potential address
74E7 79          7 897 ld      a, c                        ; get opponent's board potential
74E8 96          7 898 sub     (hl)                        ; subtract potentials -> (pC - pR)
74E9 87          7 899 add     a, a                        ; multiply by 8 -> M (pC - pR)
74EA 87          7 900 add     a, a
74EB 87          7 901 add     a, a
74EC 93          7 902 sub     e                           ; subtract result of attack mobilities subtraction
74ED             7 903 ; -> M (pC - pR) - (aC - aR)
74ED EE 80       7 904 xor     $80                         ; invert sign for easier further comparative
74EF C9          7 905 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
74F0             7 907 ; ----------------------------------------------------------------------------------------------------------------------
74F0             7 908 ; PathFinder_Potentials: calculate board potential and attack mobility
74F0             7 909 ;
74F0             7 910 ; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
74F0             7 911 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
74F0             7 912 ;   the board.
74F0             7 913 ; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
74F0             7 914 ;
74F0             7 915 ; Input:    HL = cyan board or red board address
74F0             7 916 ;           DE = cyan board or red board address
74F0             7 917 ;
74F0             7 918 ; Output:   B = attack mobility
74F0             7 919 ;           C = board potential
74F0             7 920 ;
74F0             7 921 ; Destroys: A, DE, HL, IYL
74F0             7 922 ; ----------------------------------------------------------------------------------------------------------------------
74F0             7 923 PathFinder_Potentials:
74F0 01 FF 00    7 924 ld      bc, $00FF                   ; initialize attack mobility and board potential
74F3 FD 2E 3D    7 925 ld      iyl, 61                     ; number of cells to be checked (loop counter)
74F6             7 926 Potentials_Loop
74F6 7E          7 927 ld      a, (hl)                     ; get cell's two-distance pointed by HL
74F7 FE 40       7 928 cp      $40                         ; is cell occupied or border?
74F9 30 14       7 929 jr      nc, Potentials_Next         ; yes, skip to next cell
74FB FE 04       7 930 cp      $04                         ; cell distance was not updated?
74FD 38 18       7 931 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
74FF 1A          7 932 ld      a, (de)                     ; get cell's two-distance pointed by DE
7500 FE 04       7 933 cp      $04                         ; cell distance was not updated?
7502 38 13       7 934 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
7504 86          7 935 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
7505 77          7 936 ld      (hl), a                     ; save potential in the cell pointed by HL
7506 B9          7 937 cp      c                           ; is the new potential = board potential?
7507 28 05       7 938 jr      z, Potentials_Increment     ; yes, increment attack mobility
7509 30 04       7 939 jr      nc, Potentials_Next         ; if (new potential > board potential) skip to next cell
750B 4F          7 940 ld      c, a                        ; board potential = new potential
750C 06 00       7 941 ld      b, 0                        ; restart attack mobility
750E             7 942 Potentials_Increment
750E 04          7 943 inc     b                           ; increment attack mobility
750F             7 944 Potentials_Next
750F 1C          7 945 inc     e                           ; move to next cell of each board
7510 2C          7 946 inc     l
7511 FD 2D       7 947 dec     iyl                         ; decrement loop counter
7513 C2 F6 74    7 948 jp      nz, Potentials_Loop         ; repeat until end of boards
7516 C9          7 949 ret
7517             7 950 Potentials_Infinite
7517 CB FE       7 951 set     7, (hl)                     ; set cell potential as "infinite"
7519 1C          7 952 inc     e                           ; move to next cell of each board
751A 2C          7 953 inc     l
751B FD 2D       7 954 dec     iyl                         ; decrement loop counter
751D C2 F6 74    7 955 jp      nz, Potentials_Loop         ; repeat until end of boards
7520 C9          7 956 ret
7521             7 958 ; ----------------------------------------------------------------------------------------------------------------------
7521             7 959 ; PathFinder_Candidates: search candidates based on score result and boards potentials
7521             7 960 ;
7521             7 961 ; Input:    A  = -1, 0 or heuristic result
7521             7 962 ;           IX = candidates area address
7521             7 963 ;
7521             7 964 ; Output:   IX = first candidate address
7521             7 965 ;
7521             7 966 ; Uses:     AI_PLAYER (speccy side)
7521             7 967 ;
7521             7 968 ; Destroys: A, A', BC, DE, HL
7521             7 969 ; ----------------------------------------------------------------------------------------------------------------------
7521             7 970 PathFinder_Candidates:
7521 DD 36 00 00 7 971 ld      (ix+0), 0                   ; set candidates endmarker
7525 B7          7 973 or      a                           ; is speccy the winner?
7526 28 3D       7 974 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
7528 3C          7 975 inc     a                           ; is speccy defeated?
7529 28 4E       7 976 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
752B             7 978 ; if score is not -1 nor 0, fill candidates from total potentials
752B 21 09 61    7 980 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
752E 11 09 64    7 981 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
7531 CD F0 74    7 982 call    PathFinder_Potentials       ; process candidates from total potentials
7534 79          7 984 ld      a, c                        ; set board potential in A
7535 08          7 985 ex      af, af'                     ; save board potential
7536 50          7 986 ld      d, b                        ; store attack mobility
7537 DD 5D       7 987 ld      e, ixl                      ; store candidates position
7539             7 989 ; insert the second best board potentials in candidates area
7539             7 990 Candidates_2ndBest
7539 2E 09       7 991 ld      l, 9                        ; HL points to board potentials address (1st position)
753B 0C          7 992 inc     c                           ; increment board potential
753C 79          7 993 ld      a, c                        ; A = second best potential
753D FE 20       7 994 cp      $20                         ; is potential >= $20? (2nd best max potential)
753F 30 13       7 995 jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential
7541 06 3D       7 997 ld      b, 61                       ; number of cells to be checked (loop counter)
7543             7 998 Candidates_2ndBest_Loop
7543 BE          7 999 cp      (hl)                        ; is current board potential = 2nd best board potential?
7544 C2 4C 75    7 1000 jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
7547 DD 2C       7 1001 inc     ixl                         ; yes, insert candidate
7549 DD 75 00    7 1002 ld      (ix+0), l
754C             7 1003 Candidates_2ndBest_Next
754C 2C          7 1004 inc     l                           ; move HL to next board potential address
754D 10 F4       7 1005 djnz    Candidates_2ndBest_Loop     ; repeat for each cell
754F DD 7D       7 1006 ld      a, ixl                      ; A = current candidates position
7551 BB          7 1007 cp      e                           ; new candidates inserted?
7552 28 E5       7 1008 jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted
7554             7 1010 Candidates_2ndBest_Exit
7554 42          7 1011 ld      b, d                        ; restore attack mobility
7555 08          7 1012 ex      af, af'                     ; restore board potential
7556             7 1014 ; insert the best board potentials in candidates area
7556             7 1015 Candidates_Best
7556 2E 08       7 1016 ld      l, 8                        ; HL points to board potential address (1st position -1)
7558             7 1017 Candidates_Best_Loop
7558 2C          7 1018 inc     l                           ; move HL to next board potential address
7559 BE          7 1019 cp      (hl)                        ; is current board potential equal to best board potential?
755A C2 58 75    7 1020 jp      nz, Candidates_Best_Loop    ; no, next potential
755D DD 2C       7 1021 inc     ixl                         ; yes, insert candidate
755F DD 75 00    7 1022 ld      (ix+0), l
7562 10 F4       7 1023 djnz    Candidates_Best_Loop        ; repeat for each cell
7564 C9          7 1024 ret
7565             7 1026 ; ----------------------------------------------------------------------------------------------------------------------
7565             7 1027 ; Fill candidates for winner color
7565             7 1028 ; ----------------------------------------------------------------------------------------------------------------------
7565             7 1029 Candidates_Winner
7565 3A 99 61    7 1030 ld      a, (AI_PLAYER)              ; check speccy side
7568 B7          7 1031 or      a                           ; is it FRIEND?
7569 E2 86 75    7 1032 jp      po, Candidates_Winner_Cyan  ; yes, fill candidates from cyan potentials
756C 21 09 64    7 1034 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
756F 11 51 64    7 1035 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7572 CD F0 74    7 1036 call    PathFinder_Potentials       ; calculate red potentials
7575 79          7 1037 ld      a, c                        ; set board potential in A
7576 C3 56 75    7 1038 jp      Candidates_Best             ; fill only the best candidates
7579             7 1040 ; ----------------------------------------------------------------------------------------------------------------------
7579             7 1041 ; Fill candidates for defeated color
7579             7 1042 ; ----------------------------------------------------------------------------------------------------------------------
7579             7 1043 Candidates_Defeat
7579 3A 99 61    7 1044 ld      a, (AI_PLAYER)              ; check speccy side
757C B7          7 1045 or      a                           ; is it FRIEND?
757D E2 93 75    7 1046 jp      po, Candidates_Defeat_Red   ; yes, fill candidates from red potentials
7580             7 1048 ; if RED is defeated, candidates are chosen from cyan board potentials
7580 CD 47 71    7 1050 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
7583 CD 83 71    7 1051 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
7586             7 1052 Candidates_Winner_Cyan
7586 21 09 61    7 1053 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7589 11 51 61    7 1054 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
758C CD F0 74    7 1055 call    PathFinder_Potentials       ; calculate cyan potentials
758F 79          7 1056 ld      a, c                        ; set board potential in A
7590 C3 56 75    7 1057 jp      Candidates_Best             ; fill only the best candidates
7593             7 1059 ; if CYAN is defeated, candidates are chosen from red board potentials
7593             7 1060 Candidates_Defeat_Red
7593 CD BB 71    7 1061 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
7596 CD FD 71    7 1062 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
7599 21 09 64    7 1063 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
759C 11 51 64    7 1064 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
759F CD F0 74    7 1065 call    PathFinder_Potentials       ; calculate red potentials
75A2 79          7 1066 ld      a, c                        ; set board potential in A
75A3 C3 56 75    7 1067 jp      Candidates_Best             ; fill only the best candidates
75A6             7 1069 ; ----------------------------------------------------------------------------------------------------------------------
75A6             7 1070 ; PathFinder_VictoryPath: calculate current player victory path
75A6             7 1071 ;
75A6             7 1072 ; Input:    -
75A6             7 1073 ;
75A6             7 1074 ; Output:   A   = -1, if there isn't a victory path
75A6             7 1075 ;           A   = start position (-1) of the victory path, otherwise
75A6             7 1076 ;           HL  = cyan or red queue head address
75A6             7 1077 ;
75A6             7 1078 ; Uses:     TOKEN_COLOR (current token color)
75A6             7 1079 ;
75A6             7 1080 ; Destroys: BC, DE, HL, IY
75A6             7 1081 ; ----------------------------------------------------------------------------------------------------------------------
75A6             7 1082 PathFinder_VictoryPath:
75A6 3A 9E 61    7 1083 ld      a, (TOKEN_COLOR)            ; get current token color
75A9 FE 05       7 1084 cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
75AB 28 0C       7 1085 jr      z, PathFinder_VictoryPath_Cyan
75AD CD BB 71    7 1087 call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
75B0 21 45 64    7 1088 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75B3 CD C5 75    7 1089 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75B6 C3 C4 71    7 1090 jp      PathFinder_Red_CheckPath    ; calculate RED victory path
75B9             7 1092 PathFinder_VictoryPath_Cyan
75B9 CD 47 71    7 1093 call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
75BC 21 45 61    7 1094 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75BF CD C5 75    7 1095 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75C2 C3 50 71    7 1096 jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path
75C5             7 1098 ; ----------------------------------------------------------------------------------------------------------------------
75C5             7 1099 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to 1, everything else to ENEMY.
75C5             7 1100 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
75C5             7 1101 ; [color]' again to find a victory path.
75C5             7 1102 ;
75C5             7 1103 ; Coded by Einar Saukas
75C5             7 1104 ;
75C5             7 1105 ; Input:    HL = pointer to last position of [color]_BOARD
75C5             7 1106 ;
75C5             7 1107 ; Output:   -
75C5             7 1108 ;
75C5             7 1109 ; Destroys: A, BC, HL
75C5             7 1110 ; ----------------------------------------------------------------------------------------------------------------------
75C5             7 1111 PathFinder_PrepareBoard:
75C5 3E 43       7 1112 ld      a, VICTORY+$40              ; set victory distance + friendly flag
75C7 0E 07       7 1113 ld      c, 7                        ; 7 rows
75C9             7 1114 PrepareBoard_Row
75C9 06 07       7 1115 ld      b, 7                        ; 7 columns
75CB             7 1116 PrepareBoard_Column
75CB BE          7 1117 cp      (hl)                        ; check win condition
75CC 36 01       7 1118 ld      (hl), 1                     ; save 1 by default
75CE 28 02       7 1119 jr      z, PrepareBoard_Next        ; if win condition, skip to position
75D0 36 7E       7 1120 ld      (hl), ENEMY                 ; else, save ENEMY
75D2             7 1121 PrepareBoard_Next
75D2 2D          7 1122 dec     l                           ; HL points to next board position
75D3 10 F6       7 1123 djnz    PrepareBoard_Column         ; repeat for each column
75D5 2D          7 1125 dec     l                           ; skip borders
75D6 2D          7 1126 dec     l
75D7 0D          7 1127 dec     c                           ; decrement rows
75D8 C2 C9 75    7 1128 jp      nz, PrepareBoard_Row        ; repeat for each row
75DB C9          7 1129 ret
75DC             7 1131 ; ----------------------------------------------------------------------------------------------------------------------
75DC             7 1132 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75DC             7 1133 ;
75DC             7 1134 ; Input:    A  = start position of the victory path
75DC             7 1135 ;           HL = cyan or red queue head address
75DC             7 1136 ;
75DC             7 1137 ; Output:   -
75DC             7 1138 ;
75DC             7 1139 ; Uses:     TOKEN_COLOR (current token color)
75DC             7 1140 ;
75DC             7 1141 ; Destroys: A, BC, DE, HL, IX
75DC             7 1142 ; ----------------------------------------------------------------------------------------------------------------------
75DC             7 1143 PathFinder_BrightPath:
75DC 6F          7 1144 ld      l, a                        ; move HL to the start position of the victory path
75DD 24          7 1145 inc     h
75DE 4E          7 1146 ld      c, (hl)                     ; set current victory path length in C
75DF 06 03       7 1147 ld      b, VICTORY                  ; set victory length in B
75E1 3A 9E 61    7 1149 ld      a, (TOKEN_COLOR)            ; get current token color
75E4 C6 40       7 1150 add     a, $40                      ; switch on bright attribute
75E6 32 9E 61    7 1151 ld      (TOKEN_COLOR), a
75E9 3E 03       7 1152 ld      a, 3                        ; set delay duration for animate hexagons
75EB 32 CB 6D    7 1153 ld      (@Token_Delay+1), a
75EE C3 0D 76    7 1155 jp      BrightPath_Position         ; animate and highlight the hexagon position
75F1             7 1156 BrightPath_Neighbor
75F1 2C          7 1157 inc     l                           ; move HL to left neighbor address
75F2 BE          7 1158 cp      (hl)                        ; is it the same as current victory path length?
75F3 28 18       7 1159 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F5 2D          7 1160 dec     l                           ; move HL to right neighbor address
75F6 2D          7 1161 dec     l
75F7 BE          7 1162 cp      (hl)                        ; is it the same as current victory path length?
75F8 28 13       7 1163 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75FA 11 F8 FF    7 1164 ld      de, -WIDTH                  ; move HL to upper-right neighbor address
75FD 19          7 1165 add     hl, de
75FE BE          7 1166 cp      (hl)                        ; is it the same as current victory path length?
75FF 28 0C       7 1167 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7601 2C          7 1168 inc     l                           ; move HL to upper-left neighbor address
7602 BE          7 1169 cp      (hl)                        ; is it the same as current victory path length?
7603 28 08       7 1170 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7605 11 10 00    7 1171 ld      de, WIDTH*2                 ; move HL to lower-right neighbor address
7608 19          7 1172 add     hl, de
7609 BE          7 1173 cp      (hl)                        ; is it the same as current victory path length?
760A 28 01       7 1174 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
760C 2C          7 1175 inc     l                           ; move HL to lower-left neighbor address
760D             7 1176 BrightPath_Position
760D C5          7 1177 push    bc                          ; store current victory path length
760E E5          7 1178 push    hl                          ; store current position pointer
760F CD 7A 6D    7 1179 call    Main_Board2Indexes          ; convert a board position into a board indexes
7612 CD B7 6D    7 1180 call    Draw_Token                  ; animate hexagon sprite on the screen
7615 DD 21 E7 64 7 1181 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
7619 CD D4 76    7 1182 call    Sound_FX                    ; play sound effect
761C E1          7 1183 pop     hl                          ; restore current position pointer
761D C1          7 1184 pop     bc                          ; restore current victory path length
761E 0D          7 1185 dec     c                           ; decrement current victory path length
761F 79          7 1186 ld      a, c                        ; set current victory path length in A
7620 B8          7 1187 cp      b                           ; has reached victory length?
7621 C2 F1 75    7 1188 jp      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach victory length
7624 21 9E 61    7 1190 ld      hl, TOKEN_COLOR             ; get current token color address
7627 CB B6       7 1191 res     6, (hl)                     ; switch off bright attribute
7629 C9          7 1192 ret

; File #8: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Timer.z80asm

762A             8 1 ; ----------------------------------------------------------------------------------------------------------------------
762A             8 2 ; Timer.z80asm
762A             8 3 ; Coded by Antonio Luque
762A             8 4 ;
762A             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
762A             8 6 ; ----------------------------------------------------------------------------------------------------------------------
762A             8 8 ; ----------------------------------------------------------------------------------------------------------------------
762A             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
762A             8 10 ;
762A             8 11 ; Input:    -
762A             8 12 ;
762A             8 13 ; Output:   -
762A             8 14 ;
762A             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
762A             8 16 ;
762A             8 17 ; Destroys: BC', DE', HL'
762A             8 18 ; ----------------------------------------------------------------------------------------------------------------------
762A             8 19 Timer_Interrupt:
762A F5          8 20 push    af                          ; store AF register
762B D9          8 21 exx                                 ; store BC, DE and HL registers
762C 3A E8 62    8 23 ld      a, (TIMER_FLAG)             ; check timer flag
762F B7          8 24 or      a                           ; is timer stopped?
7630 CA 59 76    8 25 jp      z, Timer_Exit               ; yes, exit routine
7633 21 EC 62    8 27 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
7636 3D          8 28 dec     a                           ; is red timer on?
7637 C2 3D 76    8 29 jp      nz, Timer_Counters          ; yes, check interrupt counter 
763A 21 E9 62    8 30 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
763D             8 31 Timer_Counters
763D 35          8 32 dec     (hl)                        ; decrement interrupt counter
763E C2 59 76    8 33 jp      nz, Timer_Exit              ; if not 0, exit routine
7641 36 32       8 35 ld      (hl), 50                    ; restart interrupt counter
7643 23          8 36 inc     hl                          ; move HL to seconds counter address
7644 3E 01       8 37 ld      a, 1                        ; increment seconds counter
7646 86          8 38 add     a, (hl)
7647 27          8 39 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7648 77          8 40 ld      (hl), a                     ; store seconds
7649 FE 60       8 41 cp      $60                         ; 60 seconds reached?
764B C2 56 76    8 42 jp      nz, Timer_Show              ; no, show timer
764E 36 00       8 43 ld      (hl), 0                     ; restart seconds counter
7650 23          8 44 inc     hl                          ; move HL to minutes counter address
7651 3E 01       8 45 ld      a, 1                        ; increment minutes counter
7653 86          8 46 add     a, (hl)
7654 27          8 47 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7655 77          8 48 ld      (hl), a                     ; store minutes
7656             8 49 Timer_Show
7656 CD 5D 76    8 50 call    Timer_Display               ; display timer on the screen
7659             8 51 Timer_Exit
7659 D9          8 52 exx                                 ; restore BC, DE and HL registers
765A F1          8 53 pop     af                          ; restore AF register
765B FB          8 55 ei                                  ; enable interrupts
765C C9          8 56 ret
765D             8 58 ; ----------------------------------------------------------------------------------------------------------------------
765D             8 59 ; Timer_Display: display a timer on the screen
765D             8 60 ;
765D             8 61 ; Input:    -
765D             8 62 ;
765D             8 63 ; Output:   -
765D             8 64 ;
765D             8 65 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
765D             8 66 ;
765D             8 67 ; Destroys: A, BC, DE, HL
765D             8 68 ; ----------------------------------------------------------------------------------------------------------------------
765D             8 69 Timer_Display:
765D 01 EE 62    8 70 ld      bc, RED_TIMER+2             ; BC points to red's minutes counter address
7660 11 E2 48    8 71 ld      de, $48E2                   ; DE points to red's minutes screen address
7663 3A E8 62    8 72 ld      a, (TIMER_FLAG)             ; check timer flag
7666 3D          8 73 dec     a                           ; is cyan timer on?
7667 C2 70 76    8 74 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
766A 01 EB 62    8 75 ld      bc, CYAN_TIMER+2            ; BC points to cyan's minutes counter address
766D 11 78 40    8 76 ld      de, $4078                   ; DE points to cyan's minutes screen address
7670             8 77 Timer_Display_Min
7670 CD 75 76    8 78 call    Timer_Display_MinSec        ; display minutes counter on screen
7673 0B          8 79 dec     bc                          ; BC points to seconds counter address
7674 1C          8 80 inc     e                           ; DE points to seconds screen address
7675             8 81 Timer_Display_MinSec:
7675 0A          8 82 ld      a, (bc)                     ; set min/sec counter in A
7676 1F          8 83 rra                                 ; move tens digit to the first 4th bits of A
7677 1F          8 84 rra
7678 1F          8 85 rra
7679 1F          8 86 rra
767A CD 7E 76    8 87 call    Timer_Display_Digit         ; display tens digit on screen
767D 0A          8 88 ld      a, (bc)                     ; set min/sec counter in A 
767E             8 89 Timer_Display_Digit:
767E E6 0F       8 90 and     %00001111                   ; discard the last 4th bits of the digit
7680 D5          8 91 push    de                          ; store digit screen address
7681 21 97 64    8 93 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
7684 87          8 94 add     a, a                        ; a digit is 8 bytes long
7685 87          8 95 add     a, a
7686 87          8 96 add     a, a
7687 85          8 97 add     a, l                        ; set digit index in HL
7688 6F          8 98 ld      l, a
7689 7E          8 100 ld      a, (hl)                     ; get digit tile
768A 12          8 101 ld      (de), a                     ; put it on screen address
768B 14          8 102 inc     d                           ; move DE to next pixel-line address
768C 2C          8 103 inc     l                           ; move HL to next digit tile address
768D 7E          8 104 ld      a, (hl)                     ; (repeat 7 more times)
768E 12          8 105 ld      (de), a
768F 14          8 106 inc     d
7690 2C          8 107 inc     l
7691 7E          8 108 ld      a, (hl)
7692 12          8 109 ld      (de), a
7693 14          8 110 inc     d
7694 2C          8 111 inc     l
7695 7E          8 112 ld      a, (hl)
7696 12          8 113 ld      (de), a
7697 14          8 114 inc     d
7698 2C          8 115 inc     l
7699 7E          8 116 ld      a, (hl)
769A 12          8 117 ld      (de), a
769B 14          8 118 inc     d
769C 2C          8 119 inc     l
769D 7E          8 120 ld      a, (hl)
769E 12          8 121 ld      (de), a
769F 14          8 122 inc     d
76A0 2C          8 123 inc     l
76A1 7E          8 124 ld      a, (hl)
76A2 12          8 125 ld      (de), a
76A3 14          8 126 inc     d
76A4 2C          8 127 inc     l
76A5 7E          8 128 ld      a, (hl)
76A6 12          8 129 ld      (de), a
76A7 D1          8 131 pop     de                          ; restore digit screen address
76A8 1C          8 132 inc     e                           ; move screen address to next column
76A9 C9          8 133 ret
76AA             8 135 ; ----------------------------------------------------------------------------------------------------------------------
76AA             8 136 ; Timer_Display_All: display cyan and red timers
76AA             8 137 ;
76AA             8 138 ; Input:    -
76AA             8 139 ;
76AA             8 140 ; Output:   -
76AA             8 141 ;
76AA             8 142 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
76AA             8 143 ;
76AA             8 144 ; Destroys: BC, DE, HL
76AA             8 145 ; ----------------------------------------------------------------------------------------------------------------------
76AA             8 146 Timer_Display_All:
76AA 3E 01       8 147 ld      a, 1                        ; set cyan timer on
76AC 32 E8 62    8 148 ld      (TIMER_FLAG), a
76AF CD 5D 76    8 149 call    Timer_Display               ; display cyan timer
76B2 3E 02       8 151 ld      a, 2                        ; set red timer on
76B4 32 E8 62    8 152 ld      (TIMER_FLAG), a
76B7 CD 5D 76    8 153 call    Timer_Display               ; display red timer
76BA AF          8 155 xor     a                           ; stop timers
76BB 32 E8 62    8 156 ld      (TIMER_FLAG), a
76BE C9          8 157 ret
76BF             8 159 ; ----------------------------------------------------------------------------------------------------------------------
76BF             8 160 ; Timer_Reset: initialize cyan and red timers
76BF             8 161 ;
76BF             8 162 ; Input:    -
76BF             8 163 ;
76BF             8 164 ; Output:   -
76BF             8 165 ;
76BF             8 166 ; Destroys: HL
76BF             8 167 ; ----------------------------------------------------------------------------------------------------------------------
76BF             8 168 Timer_Reset:
76BF 21 E9 62    8 169 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76C2 36 32       8 171 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76C4 23          8 172 inc     hl                          ; move HL to cyan's seconds counter address
76C5 36 00       8 173 ld      (hl), 0                     ; reset seconds counter
76C7 23          8 174 inc     hl                          ; move HL to cyan's minutes counter address
76C8 36 00       8 175 ld      (hl), 0                     ; reset minutes counter
76CA 23          8 176 inc     hl                          ; move HL to red's interrupt counter
76CB 36 32       8 178 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76CD 23          8 179 inc     hl                          ; move HL to red's seconds counter address
76CE 36 00       8 180 ld      (hl), 0                     ; reset seconds counter
76D0 23          8 181 inc     hl                          ; move HL to red's minutes counter address
76D1 36 00       8 182 ld      (hl), 0                     ; reset minutes counter
76D3 C9          8 183 ret

; File #9: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Sound.z80asm

76D4             9 1 ; ----------------------------------------------------------------------------------------------------------------------
76D4             9 2 ; Sound.z80asm
76D4             9 3 ; Coded with BeepFX player tool by Shiru: https://shiru.untergrund.net/software.shtml
76D4             9 4 ;
76D4             9 5 ; Adapted for Hex game by Antonio Luque
76D4             9 6 ; ----------------------------------------------------------------------------------------------------------------------
76D4             9 8 ; ----------------------------------------------------------------------------------------------------------------------
76D4             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
76D4             9 10 ; 
76D4             9 11 ; Input:    IX = tone parameters address
76D4             9 12 ;
76D4             9 13 ; Output:   -
76D4             9 14 ;
76D4             9 15 ; Destroys: A, BC, DE, HL, IY
76D4             9 16 ; ----------------------------------------------------------------------------------------------------------------------
76D4             9 17 Sound_FX:
76D4 F3          9 18 di                                  ; disable interrupts
76D5 DD 4E 00    9 20 ld      c, (ix+0)                   ; BC = frames
76D8 DD 46 01    9 21 ld      b, (ix+1)
76DB DD 5E 02    9 22 ld      e, (ix+2)                   ; DE = frame length
76DE DD 56 03    9 23 ld      d, (ix+3)
76E1 D5          9 24 push    de                          ; store frame length in IY
76E2 FD E1       9 25 pop     iy
76E4 DD 5E 04    9 26 ld      e, (ix+4)                   ; DE = pitch
76E7 DD 56 05    9 27 ld      d, (ix+5)
76EA 21 00 00    9 28 ld      hl, 0                       ; reset HL
76ED             9 30 Sound_FX_Frames
76ED C5          9 31 push    bc                          ; store frames
76EE FD E5       9 32 push    iy                          ; restore frame length in BC
76F0 C1          9 33 pop     bc
76F1             9 34 Sound_FX_FrameLength
76F1 19          9 35 add     hl, de                      ; HL = incremented pitch
76F2 7C          9 36 ld      a, h                        ; compares with fixed duty cycle ($80 for 50% square wave)
76F3 FE 80       9 37 cp      $80                         ; if (incremented pitch < duty cycle)
76F5 9F          9 38 sbc     a, a                        ;    { A = %11111111 } else { A = %00000000 }
76F6 E6 10       9 39 and     %00010000                   ; toggling bit 4 controls the internal speaker
76F8 F6 00       9 40 or      0                           ; keep border unchanged, dummy (7t)
76FA D3 FE       9 41 out     ($FE), a                    ; send bit to internal speaker
76FC 3A 00 00    9 42 ld      a, (0)                      ; dummy (13t)
76FF 0B          9 43 dec     bc                          ; decrement frame length
7700 78          9 44 ld      a, b                        ; check frame length
7701 B1          9 45 or      c                           ; frame length = 0?
7702 C2 F1 76    9 46 jp      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times (loop = 88t)
7705 DD 4E 06    9 48 ld      c, (ix+6)                   ; BC = pitch slide
7708 DD 46 07    9 49 ld      b, (ix+7)
770B EB          9 50 ex      de, hl                      ; HL = current pitch
770C 09          9 51 add     hl, bc                      ; increment pitch with pitch slide
770D EB          9 52 ex      de, hl                      ; DE = new pitch
770E C1          9 54 pop     bc                          ; restore frames
770F 0B          9 55 dec     bc                          ; decrement frames
7710 78          9 56 ld      a, b                        ; check frames
7711 B1          9 57 or      c                           ; frames = 0?
7712 20 D9       9 58 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
7714 FB          9 60 ei                                  ; enable interrupts
7715 C9          9 61 ret

; File #10: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Screen.z80asm

7716             10 1 ; ----------------------------------------------------------------------------------------------------------------------
7716             10 2 ; Screen.z80asm
7716             10 3 ; Coded by Antonio Luque
7716             10 4 ; ----------------------------------------------------------------------------------------------------------------------
7716             10 6 BLUE_INK                EQU     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
7716             10 7 BLUE_PAPER              EQU     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
7716             10 8 WHITE_PAPER             EQU     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
7716             10 9 WHITE                   EQU     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
7716             10 10 BRIGHT                  EQU     %01000000                   ; mask to apply bright to attributes
7716             10 11 FLASH                   EQU     %10000000                   ; mask to apply flash to attributes
7716             10 12 WHITE_FLASH0            EQU     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
7716             10 13 WHITE_FLASH1            EQU     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
7716             10 15 ; ----------------------------------------------------------------------------------------------------------------------
7716             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
7716             10 17 ;
7716             10 18 ; Input:    -
7716             10 19 ;
7716             10 20 ; Output:   -
7716             10 21 ;
7716             10 22 ; Destroys: BC, DE, HL
7716             10 23 ; ----------------------------------------------------------------------------------------------------------------------
7716             10 24 Screen_Clear:
7716 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
7719 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
771C 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
771D 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
7720 ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
7722 C9          10 30 ret
7723             10 32 ; ----------------------------------------------------------------------------------------------------------------------
7723             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
7723             10 34 ;
7723             10 35 ; Input:    -
7723             10 36 ;
7723             10 37 ; Output:   -
7723             10 38 ;
7723             10 39 ; Destroys: A, BC, DE, HL, IX
7723             10 40 ; ----------------------------------------------------------------------------------------------------------------------
7723             10 41 Screen_Letters:
7723 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
7726 DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
772A CD 34 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
772D 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
7730 DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
7734             10 47 Screen_Letters_Row:
7734 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
7737 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
7739             10 50 Screen_Letter_Loop
7739 E5          10 51 push    hl                          ; store letter screen address
773A CD EF 6D    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
773D E1          10 53 pop     hl                          ; restore letter screen address
773E 2C          10 54 inc     l                           ; move HL to next screen address
773F 2C          10 55 inc     l
7740 DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
7744 DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
7748 DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
774A DD 2C       10 59 inc     ixl
774C 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
774E C9          10 61 ret
774F             10 63 ; ----------------------------------------------------------------------------------------------------------------------
774F             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
774F             10 65 ;
774F             10 66 ; Input:    -
774F             10 67 ;
774F             10 68 ; Output:   -
774F             10 69 ;
774F             10 70 ; Destroys: A, BC, DE, HL, IX, IY
774F             10 71 ; ----------------------------------------------------------------------------------------------------------------------
774F             10 72 Screen_Numbers:
774F 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
7752 FD 21 EF 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
7756 DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
775A 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
775C             10 77 Screen_Number_Loop
775C FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
775F FD 66 01    10 79 ld      h, (iy+1)
7762 E5          10 80 push    hl                          ; store pointer to number screen address
7763 D5          10 81 push    de                          ; store pointer to sprite address
7764 CD EF 6D    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
7767 D1          10 83 pop     de                          ; restore pointer to sprite address
7768 E1          10 84 pop     hl                          ; restore pointer to number screen address
7769 DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
776D DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
7771 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
7772 C6 0F       10 88 add     a, 15
7774 6F          10 89 ld      l, a
7775 CD EF 6D    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
7778 DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
777C DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
7780 78          10 93 ld      a, b                        ; save loop counter
7781 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
7784 DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
7786 FD 23       10 96 inc     iy                          ; move IY to next number screen address
7788 FD 23       10 97 inc     iy
778A 47          10 98 ld      b, a                        ; restore loop counter
778B 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
778D C9          10 100 ret
778E             10 102 ; ----------------------------------------------------------------------------------------------------------------------
778E             10 103 ; Screen_Frame: draw the screen frame on the screen
778E             10 104 ;
778E             10 105 ; Input:    -
778E             10 106 ;
778E             10 107 ; Output:   -
778E             10 108 ;
778E             10 109 ; Destroys: A, BC, DE, HL, IX
778E             10 110 ; ----------------------------------------------------------------------------------------------------------------------
778E             10 111 Screen_Frame:
778E 11 28 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
7791 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
7794 CD 59 6F    10 114 call    Print_String                ; print "Level"
7797 CD D3 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
779A 01 8D 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
779D 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
77A0 CD A6 77    10 119 call    Screen_Frame_Border         ; draw up-border
77A3 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
77A6             10 121 Screen_Frame_Border:
77A6 DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
77A9             10 123 Screen_Frame_Loop
77A9 0A          10 124 ld      a, (bc)                     ; get tile index
77AA FE FF       10 125 cp      -1                          ; is it -1?
77AC 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
77AE 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
77B1 CD 69 6F    10 128 call    Print_Tile                  ; print frame tile
77B4             10 129 Screen_Frame_Next
77B4 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77B5 03          10 131 inc     bc                          ; BC points to the next tile index
77B6 DD 2D       10 132 dec     ixl                         ; decrement loop counter
77B8 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77BA DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77BE DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77C2 DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77C6 DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77CA DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77CE DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77D2 C9          10 141 ret
77D3             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77D3             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77D3             10 145 ;
77D3             10 146 ; Input:    -
77D3             10 147 ;
77D3             10 148 ; Output:   -
77D3             10 149 ;
77D3             10 150 ; Destroys: A, BC, HL
77D3             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77D3             10 152 Screen_Vertical_Bars:
77D3 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
77D6 CD DC 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
77D9 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
77DC             10 156 Screen_Vertical_Bar:
77DC 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
77DE             10 158 Screen_Vertical_Loop
77DE 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
77E0 CD FB 6D    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
77E3 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
77E5 C9          10 162 ret
77E6             10 164 ; ----------------------------------------------------------------------------------------------------------------------
77E6             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
77E6             10 166 ;
77E6             10 167 ; Input:    -
77E6             10 168 ;
77E6             10 169 ; Output:   -
77E6             10 170 ;
77E6             10 171 ; Uses:     TOKEN_COLOR (current token color)
77E6             10 172 ;
77E6             10 173 ; Destroys: A, BC, DE, HL, IX
77E6             10 174 ; ----------------------------------------------------------------------------------------------------------------------
77E6             10 175 Screen_Tokens:
77E6 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
77E8 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
77EB CD F3 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
77EE 3E 02       10 180 ld      a, RED_COLOR                ; set token color
77F0 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
77F3             10 182 Screen_Tokens_Draw:
77F3 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77F6 CD 0A 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
77F9 DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
77FC DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
77FF 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7802 C3 DC 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
7805             10 190 ; ----------------------------------------------------------------------------------------------------------------------
7805             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
7805             10 192 ;
7805             10 193 ; Input:    -
7805             10 194 ;
7805             10 195 ; Output:   -
7805             10 196 ;
7805             10 197 ; Destroys: IX
7805             10 198 ; ----------------------------------------------------------------------------------------------------------------------
7805             10 199 Screen_Timer_Quotes:
7805 DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
7809 DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
780D DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7811 DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
7813 DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7817 DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
781B DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
781E DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
7822 DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
7826 DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
782A DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
782E DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7832 DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
7834 DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7838 DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
783C DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
783F DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
7843 DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
7847 C9          10 219 ret
7848             10 221 ; ----------------------------------------------------------------------------------------------------------------------
7848             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
7848             10 223 ;
7848             10 224 ; Input:    -
7848             10 225 ;
7848             10 226 ; Output:   -
7848             10 227 ;
7848             10 228 ; Destroys: BC, IX
7848             10 229 ; ----------------------------------------------------------------------------------------------------------------------
7848             10 230 Screen_Color_Statics:
7848 DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
784C 0E 07       10 232 ld      c, WHITE                    ; set color in C
784E CD 78 78    10 233 call    Screen_Apply_Color          ; apply color
7851 DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
7854 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
7856 CD 78 78    10 236 call    Screen_Apply_Color          ; apply color
7859 DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
785D 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
785F CD 78 78    10 239 call    Screen_Apply_Color          ; apply color
7862 DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
7865 0E 07       10 241 ld      c, WHITE                    ; set color in C
7867 CD 78 78    10 242 call    Screen_Apply_Color          ; apply color
786A DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
786E 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
7870 CD 78 78    10 245 call    Screen_Apply_Color          ; apply color
7873 DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
7876 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
7878             10 248 Screen_Apply_Color:
7878 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
787A             10 250 Screen_Apply_Color_Loop:
787A DD 71 00    10 251 ld      (ix+0), c                   ; apply color
787D DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
787F 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
7881 C9          10 254 ret
7882             10 256 ; ----------------------------------------------------------------------------------------------------------------------
7882             10 257 ; Screen_Last_Level: show last level screen and input game level
7882             10 258 ;
7882             10 259 ; Input:    -
7882             10 260 ;
7882             10 261 ; Output:   -
7882             10 262 ;
7882             10 263 ; Uses:     GAME_LEVEL (current game level)
7882             10 264 ;
7882             10 265 ; Destroys: A, BC, DE, HL, IX, IY
7882             10 266 ; ----------------------------------------------------------------------------------------------------------------------
7882             10 267 Screen_Last_Level:
7882 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
7885 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
7888 CD 59 6F    10 270 call    Print_String                ; print "Press any key"
788B DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
788F 01 38 0D    10 272 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7892 CD 7A 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
7895 CD C0 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
7898 CD 16 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
789B CD 5B 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
789E DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
78A2 01 C7 11    10 279 ld      bc, 17*256+WHITE_FLASH1     ; B = string length (loop counter), C = color attributes
78A5 CD 7A 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
78A8 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
78AB 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
78AE CD 59 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
78B1 DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78B5 CD D4 76    10 285 call    Sound_FX                    ; play sound fx
78B8 F3          10 287 di                                  ; disable interrupts
78B9 DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78BD 01 07 1C    10 289 ld      bc, 28*256+WHITE            ; B = string length (loop counter), C = color attributes
78C0 CD 7A 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78C3 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78C6 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78C9 CD 59 6F    10 293 call    Print_String                ; print "Well done!..."
78CC DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78CF 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78D1 CD 7A 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78D4 DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
78D8 DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
78DC DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
78E0 13          10 300 inc     de                          ; move DE to next string address
78E1 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
78E3 CD 59 6F    10 302 call    Print_String                ; print "Choose..."
78E6             10 303 Screen_Choose_Level
78E6 CD C0 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
78E9 FE 31       10 305 cp      '1'                         ; is it < '1' ?
78EB 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
78ED FE 35       10 307 cp      '5'                         ; is it >= '5' ?
78EF 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
78F1 D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
78F3 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
78F6 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
78F7 C9          10 312 ret
78F8             10 314 ; ----------------------------------------------------------------------------------------------------------------------
78F8             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
78F8             10 316 ;
78F8             10 317 ; Input:    -
78F8             10 318 ;
78F8             10 319 ; Output:   -
78F8             10 320 ;
78F8             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
78F8             10 322 ;           THREE_ROW (three-in-a-row counter)
78F8             10 323 ;
78F8             10 324 ; Destroys: A, C, HL, IX
78F8             10 325 ; ----------------------------------------------------------------------------------------------------------------------
78F8             10 326 Screen_ThreeRow:
78F8 21 9C 61    10 327 ld      hl, LEVEL_COLOR             ; HL points to level color address
78FB 4E          10 328 ld      c, (hl)                     ; save level color in C
78FC CD 14 79    10 329 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
78FF 3A 0E 62    10 330 ld      a, (THREE_ROW)              ; A = three-in-a-row counter
7902 B7          10 331 or      a                           ; is it 0?
7903 C8          10 332 ret     z                           ; yes, return
7904 3D          10 333 dec     a                           ; is it 1?
7905 28 09       10 334 jr      z, Screen_ThreeRow_1        ; yes, color first mark
7907 3D          10 335 dec     a                           ; is it 2?
7908 28 03       10 336 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
790A DD 71 00    10 337 ld      (ix+0), c                   ; color 3rd mark
790D             10 338 Screen_ThreeRow_2
790D DD 71 01    10 339 ld      (ix+1), c                   ; color 2nd mark
7910             10 340 Screen_ThreeRow_1
7910 DD 71 02    10 341 ld      (ix+2), c                   ; color 1st mark
7913 C9          10 342 ret
7914             10 344 ; ----------------------------------------------------------------------------------------------------------------------
7914             10 345 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
7914             10 346 ;
7914             10 347 ; Input:    -
7914             10 348 ;
7914             10 349 ; Output:   IX = three-in-a-row marks attribute address
7914             10 350 ;
7914             10 351 ; Destroys: -
7914             10 352 ; ----------------------------------------------------------------------------------------------------------------------
7914             10 353 Screen_Clear_ThreeRow:
7914 DD 21 F2 5A 10 354 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
7918 DD 36 00 01 10 355 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
791C DD 36 01 01 10 356 ld      (ix+1), BLUE_INK
7920 DD 36 02 01 10 357 ld      (ix+2), BLUE_INK
7924 C9          10 358 ret
7925             10 360 ; ----------------------------------------------------------------------------------------------------------------------
7925             10 361 ; Screen_Frame_Color: set up frame color and print level number depending on current level
7925             10 362 ;
7925             10 363 ; Input:    HL = game level address
7925             10 364 ;
7925             10 365 ; Output:   -
7925             10 366 ;
7925             10 367 ; Uses:     LEVEL_COLOR (current level color for frame border)
7925             10 368 ;
7925             10 369 ; Destroys: A, BC, DE, HL
7925             10 370 ; ----------------------------------------------------------------------------------------------------------------------
7925             10 371 Screen_Frame_Color:
7925 06 00       10 372 ld      b, 0                        ; set game level in BC
7927 4E          10 373 ld      c, (hl)
7928 3E 30       10 374 ld      a, $30                      ; convert game level number to game level character
792A 81          10 375 add     a, c
792B 21 0F 40    10 376 ld      hl, $400F                   ; HL points to screen address of game level
792E CD 66 6F    10 377 call    Print_Char                  ; print game level
7931 21 0E 62    10 378 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
7934 09          10 379 add     hl, bc                      ; use BC as index for color map address
7935 7E          10 380 ld      a, (hl)                     ; A = level color
7936 CD 4B 79    10 381 call    Screen_Tiles_Color          ; color the frame according to the current level
7939 E6 07       10 382 and     %00000111                   ; mask color
793B 32 9C 61    10 383 ld      (LEVEL_COLOR), a            ; save masked color
793E 17          10 384 rla                                 ; rotate to text level color
793F 17          10 385 rla
7940 17          10 386 rla
7941 21 08 58    10 387 ld      hl, $5808                   ; HL points to attribute address of level text
7944 06 09       10 388 ld      b, 9                        ; length of level text (loop counter)
7946             10 389 Screen_Level_Loop
7946 77          10 390 ld      (hl), a                     ; apply color to level text
7947 2C          10 391 inc     l                           ; HL points to attr address of next character of level text
7948 10 FC       10 392 djnz    Screen_Level_Loop           ; repeat for each character of level text
794A C9          10 393 ret
794B             10 395 ; ----------------------------------------------------------------------------------------------------------------------
794B             10 396 ; Screen_Tiles_Color: apply color to the frame tiles
794B             10 397 ;
794B             10 398 ; Input:    A = color to apply
794B             10 399 ;
794B             10 400 ; Output:   -
794B             10 401 ;
794B             10 402 ; Destroys: BC, DE, HL
794B             10 403 ; ----------------------------------------------------------------------------------------------------------------------
794B             10 404 Screen_Tiles_Color:
794B             10 405 ; color up row
794B 21 01 58    10 407 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
794E 06 06       10 408 ld      b, 6                        ; number of tiles (loop counter)
7950             10 409 Screen_Tiles_URow1
7950 77          10 410 ld      (hl), a                     ; apply color
7951 2C          10 411 inc     l                           ; move HL to the next attribute address
7952 10 FC       10 412 djnz    Screen_Tiles_URow1          ; repeat for each tile
7954 2E 12       10 413 ld      l, $12                      ; move HL to the next attribute address
7956 06 0D       10 414 ld      b, 13                       ; number of tiles (loop counter)
7958             10 415 Screen_Tiles_URow2
7958 77          10 416 ld      (hl), a                     ; apply color
7959 2C          10 417 inc     l                           ; move HL to the next attribute address
795A 10 FC       10 418 djnz    Screen_Tiles_URow2          ; repeat for each tile
795C             10 420 ; color vertical bars
795C 2E 00       10 422 ld      l, 0                        ; move HL to the next attribute address
795E 11 1F 00    10 423 ld      de, 31                      ; attribute address displacement (for each bar)
7961 0E 03       10 424 ld      c, 3                        ; number of screen thirds (outer loop counter)
7963             10 425 Screen_Tiles_VBar1
7963 06 08       10 426 ld      b, 8                        ; number of tiles (inner loop counter)
7965             10 427 Screen_Tiles_VBar2
7965 77          10 428 ld      (hl), a                     ; apply color
7966 19          10 429 add     hl, de                      ; move HL to the right column
7967 77          10 430 ld      (hl), a                     ; apply color
7968 2C          10 431 inc     l                           ; move HL to the next attribute address
7969 10 FA       10 432 djnz    Screen_Tiles_VBar2          ; repeat for each tile
796B 24          10 433 inc     h                           ; move HL to the next screen third
796C 0D          10 434 dec     c                           ; decrement number of thirds
796D 20 F4       10 435 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
796F             10 437 ; color bottom row
796F 21 E1 5A    10 439 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
7972 06 10       10 440 ld      b, 16                       ; number of tiles (loop counter)
7974             10 441 Screen_Tiles_BRow1
7974 77          10 442 ld      (hl), a                     ; apply color
7975 2C          10 443 inc     l                           ; move HL to the next attribute address
7976 10 FC       10 444 djnz    Screen_Tiles_BRow1          ; repeat for each tile
7978 2E F6       10 445 ld      l, $F6                      ; move HL to the next attribute address
797A 06 09       10 446 ld      b, 9                        ; number of tiles (loop counter)
797C             10 447 Screen_Tiles_BRow2
797C 77          10 448 ld      (hl), a                     ; apply color
797D 2C          10 449 inc     l                           ; move HL to the next attribute address
797E 10 FC       10 450 djnz    Screen_Tiles_BRow2          ; repeat for each tile
7980 C9          10 451 ret
7981             10 453 ; ----------------------------------------------------------------------------------------------------------------------
7981             10 454 ; Screen_Menu: show main menu and wait for an option
7981             10 455 ;
7981             10 456 ; Input:    -
7981             10 457 ;
7981             10 458 ; Output:   -
7981             10 459 ;
7981             10 460 ; Uses:     GAME_LEVEL (current game level)
7981             10 461 ;
7981             10 462 ; Destroys: A, BC, DE, HL, IX, IY
7981             10 463 ; ----------------------------------------------------------------------------------------------------------------------
7981             10 464 Screen_Menu:
7981 CD 16 77    10 465 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7984 CD 5B 7C    10 466 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7987             10 467 Screen_Menu_Strings
7987 21 80 59    10 468 ld      hl, $5980                   ; HL points to menu text area attributes address
798A 11 81 59    10 469 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
798D 36 00       10 470 ld      (hl), 0                     ; set first attribute text area in black
798F 01 7F 01    10 471 ld      bc, 32*12-1                 ; length of text area attributes (-1 already set)
7992 ED B0       10 472 ldir                                ; set the rest of text area attributes in black
7994 DD 21 CA 59 10 474 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
7998 DD 36 FF 78 10 475 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
799C 01 47 0D    10 476 ld      bc, 13*256+WHITE_FLASH0     ; B = string length-1 (loop counter), C = color attributes
799F CD 7A 78    10 477 call    Screen_Apply_Color_Loop     ; apply color to string area
79A2 11 80 67    10 478 ld      de, STR_OPTIONS             ; DE points to string address
79A5 21 C9 48    10 479 ld      hl, $48C9                   ; HL points to string screen address
79A8 CD 59 6F    10 480 call    Print_String                ; print "Start new game"
79AB DD 21 2A 5A 10 481 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
79AF DD 36 FF 78 10 482 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79B3 06 0A       10 483 ld      b, 10                       ; string length-1 (loop counter)
79B5 CD 7A 78    10 484 call    Screen_Apply_Color_Loop     ; apply color to string area
79B8 13          10 485 inc     de                          ; move DE to "How to play" string address
79B9 21 29 50    10 486 ld      hl, $5029                   ; HL points to string screen address
79BC CD 59 6F    10 487 call    Print_String                ; print "How to play"
79BF DD 2E 8A    10 488 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79C2 DD 36 FF 78 10 489 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79C6 CD 78 78    10 490 call    Screen_Apply_Color          ; apply color to string area
79C9 13          10 491 inc     de                          ; move DE to "Credits" string address
79CA 2E 89       10 492 ld      l, $89                      ; HL points to string screen address
79CC CD 59 6F    10 493 call    Print_String                ; print "Credits"
79CF             10 494 Screen_Menu_Options
79CF CD C0 6E    10 495 call    Input_Key_Scan              ; wait for a key pressed
79D2 FE 73       10 496 cp      's'                         ; is it 's'?
79D4 C8          10 497 ret     z                           ; yes, return
79D5 FE 63       10 498 cp      'c'                         ; is it 'c'?
79D7 CA EB 7B    10 499 jp      z, Screen_Menu_Credits      ; yes, show credits
79DA FE 68       10 500 cp      'h'                         ; is it 'h'?
79DC 20 F1       10 501 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
79DE             10 503 ; ----------------------------------------------------------------------------------------------------------------------
79DE             10 504 ; Show "How to play" pages
79DE             10 505 ; ----------------------------------------------------------------------------------------------------------------------
79DE             10 506 Screen_Menu_How2Play
79DE CD 16 77    10 507 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79E1 CD 23 77    10 508 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
79E4 CD 4F 77    10 509 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
79E7 CD 8E 77    10 510 call    Screen_Frame                ; draw the screen frame
79EA 21 9D 61    10 512 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
79ED 34          10 513 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
79EE CD 25 79    10 514 call    Screen_Frame_Color          ; set up frame color depending on current level
79F1 CD 14 79    10 515 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
79F4 11 4A 68    10 517 ld      de, STR_BUTTONS             ; DE points to "Next" string address
79F7 21 DB 50    10 518 ld      hl, $50DB                   ; HL points to string screen address
79FA CD 59 6F    10 519 call    Print_String                ; print "Next"
79FD 13          10 520 inc     de                          ; move DE to "Back" string address
79FE 21 C1 50    10 521 ld      hl, $50C1                   ; HL points to string screen address
7A01 CD 59 6F    10 522 call    Print_String                ; print "Back"
7A04             10 524 Screen_How2Play_RED
7A04 21 5E 58    10 525 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7A07 CD 95 7C    10 526 call    Screen_Clear_Text           ; clear text area attributes
7A0A CD 9C 6D    10 527 call    Draw_Board                  ; draw an empty hexagons board
7A0D             10 529 ; text for RED
7A0D DD 21 01 5A 10 531 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
7A11 01 07 07    10 532 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7A14 CD 7A 78    10 533 call    Screen_Apply_Color_Loop     ; apply color to string area
7A17 11 5D 68    10 534 ld      de, STR_HELP1               ; DE points to string address
7A1A 21 01 50    10 535 ld      hl, $5001                   ; HL points to string screen address
7A1D CD 59 6F    10 536 call    Print_String                ; print "Connect"
7A20 DD 2E 21    10 537 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A23 06 08       10 538 ld      b, 8                        ; string length (loop counter)
7A25 CD 7A 78    10 539 call    Screen_Apply_Color_Loop     ; apply color to string area
7A28 13          10 540 inc     de                          ; move DE to "left and" string address
7A29 2E 21       10 541 ld      l, $21                      ; HL points to string screen address
7A2B CD 59 6F    10 542 call    Print_String                ; print "left and"
7A2E DD 2E 41    10 543 ld      ixl, $41                    ; IX points to "right" string attributes address
7A31 06 05       10 544 ld      b, 5                        ; set string length (loop counter)
7A33 CD 7A 78    10 545 call    Screen_Apply_Color_Loop     ; apply color to string area
7A36 11 75 68    10 546 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A39 2E 41       10 547 ld      l, $41                      ; HL points to string screen address
7A3B CD 59 6F    10 548 call    Print_String                ; print "right"
7A3E DD 2E 61    10 549 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A41 06 07       10 550 ld      b, 7                        ; set string length (loop counter)
7A43 CD 7A 78    10 551 call    Screen_Apply_Color_Loop     ; apply color to string area
7A46 11 80 68    10 552 ld      de, STR_HELP4               ; DE points to "borders" string address
7A49 2E 61       10 553 ld      l, $61                      ; HL points to string screen address
7A4B CD 59 6F    10 554 call    Print_String                ; print "borders"
7A4E DD 2E 81    10 555 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A51 CD 78 78    10 556 call    Screen_Apply_Color          ; apply color to string area
7A54 13          10 557 inc     de                          ; move DE to "to win" string address
7A55 2E 81       10 558 ld      l, $81                      ; HL points to string screen address
7A57 CD 59 6F    10 559 call    Print_String                ; print "to win"
7A5A DD 21 E3 59 10 560 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A5E 01 42 03    10 561 ld      bc, 3*256+RED_COLOR+BRIGHT  ; B = string length (loop counter), C = color attributes
7A61 CD 7A 78    10 562 call    Screen_Apply_Color_Loop     ; apply color to string area
7A64 11 54 68    10 563 ld      de, STR_RED                 ; DE points to "RED" string address
7A67 21 E3 48    10 564 ld      hl, $48E3                   ; HL points to string screen address
7A6A CD 59 6F    10 565 call    Print_String                ; print "RED"
7A6D             10 567 ; draw RED sample board
7A6D FD 21 3A 67 10 569 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A71 11 3E 66    10 570 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A74 06 07       10 571 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A76 3E 42       10 572 ld      a, RED_COLOR+BRIGHT         ; set token color
7A78 32 9E 61    10 573 ld      (TOKEN_COLOR), a            ; save token color
7A7B CD 80 7C    10 574 call    Screen_Hexagons_Loop        ; draw tokens
7A7E 06 02       10 575 ld      b, 2                        ; number of red tokens (loop counter)
7A80 3E 02       10 576 ld      a, RED_COLOR                ; set token color
7A82 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7A85 CD 80 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7A88 06 09       10 579 ld      b, 9                        ; number of cyan tokens (loop counter)
7A8A 3E 05       10 580 ld      a, CYAN_COLOR               ; set token color
7A8C 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7A8F CD 80 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7A92             10 584 ; wait for "Next" option pressed
7A92 DD 21 C1 5A 10 586 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A96 01 00 04    10 587 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7A99 CD 7A 78    10 588 call    Screen_Apply_Color_Loop     ; hide "Back" string
7A9C DD 2E DC    10 589 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7A9F DD 36 FF 78 10 590 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7AA3 01 47 03    10 591 ld      bc, 3*256+WHITE_FLASH0      ; B = string length-1 (loop counter), C = color attributes
7AA6 CD 7A 78    10 592 call    Screen_Apply_Color_Loop     ; apply color to string area
7AA9             10 593 Screen_How2PlayRED_End
7AA9 CD C0 6E    10 594 call    Input_Key_Scan              ; wait for a key pressed
7AAC FE 6E       10 595 cp      'n'                         ; is it 'n'?
7AAE 20 F9       10 596 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7AB0             10 598 Screen_How2Play_CYAN
7AB0 21 0F 58    10 599 ld      hl, $580F                   ; HL points to level number attribute address
7AB3 CB BE       10 600 res     7, (hl)                     ; reset flash attribute
7AB5 26 40       10 601 ld      h, $40                      ; HL points to level number screen address
7AB7 3E 31       10 602 ld      a, '1'                      ; set level number (char)
7AB9 CD 66 6F    10 603 call    Print_Char                  ; print '1'
7ABC CD 14 79    10 604 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7ABF 21 C9 59    10 606 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7AC2 CD 95 7C    10 607 call    Screen_Clear_Text           ; clear text area attributes
7AC5 CD 9C 6D    10 608 call    Draw_Board                  ; draw an empty hexagons board
7AC8             10 610 ; text for CYAN
7AC8 DD 21 98 58 10 612 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7ACC 01 07 07    10 613 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7ACF CD 7A 78    10 614 call    Screen_Apply_Color_Loop     ; apply color to string area
7AD2 11 5D 68    10 615 ld      de, STR_HELP1               ; DE points to "Connect" string address
7AD5 21 98 40    10 616 ld      hl, $4098                   ; HL points to string screen address
7AD8 CD 59 6F    10 617 call    Print_String                ; print "Connect"
7ADB DD 2E B9    10 618 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7ADE CD 78 78    10 619 call    Screen_Apply_Color          ; apply color to string area
7AE1 11 6E 68    10 620 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7AE4 2E B9       10 621 ld      l, $B9                      ; HL points to string screen address
7AE6 CD 59 6F    10 622 call    Print_String                ; print "up and"
7AE9 DD 2E DB    10 623 ld      ixl, $DB                    ; IX points to "down" string attributes address
7AEC 06 04       10 624 ld      b, 4                        ; string length (loop counter)
7AEE CD 7A 78    10 625 call    Screen_Apply_Color_Loop     ; apply color to string area
7AF1 11 7B 68    10 626 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7AF4 2E DB       10 627 ld      l, $DB                      ; HL points to string screen address
7AF6 CD 59 6F    10 628 call    Print_String                ; print "down"
7AF9 DD 2E F8    10 629 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7AFC 06 07       10 630 ld      b, 7                        ; string length (loop counter)
7AFE CD 7A 78    10 631 call    Screen_Apply_Color_Loop     ; apply color to string area
7B01 13          10 632 inc     de                          ; move DE to "borders" string address
7B02 2E F8       10 633 ld      l, $F8                      ; HL points to string screen address
7B04 CD 59 6F    10 634 call    Print_String                ; print "borders"
7B07 DD 21 19 59 10 635 ld      ix, $5919                   ; IX points to "to win" string attributes address
7B0B CD 78 78    10 636 call    Screen_Apply_Color          ; apply color to string area
7B0E 13          10 637 inc     de                          ; move DE to "to win" string address
7B0F 21 19 48    10 638 ld      hl, $4819                   ; HL points to string screen address
7B12 CD 59 6F    10 639 call    Print_String                ; print "to win"
7B15 DD 21 7A 58 10 640 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B19 01 45 04    10 641 ld      bc, $0445                   ; B = string length (loop counter)
7B1C             10 642 ; C = color attributes (cyan+bright)
7B1C CD 7A 78    10 643 call    Screen_Apply_Color_Loop     ; apply color to string area
7B1F 11 58 68    10 644 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B22 21 7A 40    10 645 ld      hl, $407A                   ; HL points to string screen address
7B25 CD 59 6F    10 646 call    Print_String                ; print "CYAN"
7B28             10 648 ; draw CYAN sample board
7B28 FD 21 5E 67 10 650 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B2C 11 3E 66    10 651 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B2F 06 07       10 652 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B31 3E 45       10 653 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B33 32 9E 61    10 654 ld      (TOKEN_COLOR), a            ; save token color
7B36 CD 80 7C    10 655 call    Screen_Hexagons_Loop        ; draw tokens
7B39 06 02       10 656 ld      b, 2                        ; number of cyan tokens (loop counter)
7B3B 3E 05       10 657 ld      a, CYAN_COLOR               ; set token color
7B3D 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B40 CD 80 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B43 06 08       10 660 ld      b, 8                        ; number of red tokens (loop counter)
7B45 3E 02       10 661 ld      a, RED_COLOR                ; set token color
7B47 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B4A CD 80 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B4D             10 665 ; wait for "Next" or "Back" options pressed
7B4D DD 21 C2 5A 10 667 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B51 DD 36 FF 78 10 668 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B55 01 47 03    10 669 ld      bc, 3*256+WHITE_FLASH0      ; B = string length (-1), C = color attributes
7B58 CD 7A 78    10 670 call    Screen_Apply_Color_Loop     ; apply color to string area
7B5B             10 671 Screen_How2PlayCYAN_End
7B5B CD C0 6E    10 672 call    Input_Key_Scan              ; wait for a key pressed
7B5E FE 62       10 673 cp      'b'                         ; is it 'b'?
7B60 CA 04 7A    10 674 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B63 FE 6E       10 675 cp      'n'                         ; is it 'n'?
7B65 20 F4       10 676 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B67             10 678 Screen_How2Play_LevelUp
7B67 21 5E 58    10 679 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B6A CD 95 7C    10 680 call    Screen_Clear_Text           ; clear text area attributes
7B6D             10 682 ; text for Level Up
7B6D DD 21 21 5A 10 684 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B71 01 07 09    10 685 ld      bc, 9*256+WHITE             ; B = string length (loop counter), C = color attributes
7B74 CD 7A 78    10 686 call    Screen_Apply_Color_Loop     ; apply color to string area
7B77 11 8F 68    10 687 ld      de, STR_HELP                ; DE points to "Win three" string address
7B7A 21 21 50    10 688 ld      hl, $5021                   ; HL points to string screen address
7B7D CD 59 6F    10 689 call    Print_String                ; print "Win three"
7B80 DD 2E 41    10 690 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B83 06 08       10 691 ld      b, 8                        ; string length (loop counter)
7B85 CD 7A 78    10 692 call    Screen_Apply_Color_Loop     ; apply color to string area
7B88 13          10 693 inc     de                          ; move DE to "times in" string address
7B89 2E 41       10 694 ld      l, $41                      ; HL points to string screen address
7B8B CD 59 6F    10 695 call    Print_String                ; print "times in"
7B8E DD 2E 61    10 696 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B91 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7B93 CD 7A 78    10 698 call    Screen_Apply_Color_Loop     ; apply color to string area
7B96 13          10 699 inc     de                          ; move DE to "a row to" string address
7B97 2E 61       10 700 ld      l, $61                      ; HL points to string screen address
7B99 CD 59 6F    10 701 call    Print_String                ; print "a row to"
7B9C DD 2E 81    10 702 ld      ixl, $81                    ; IX points to "level up" string attributes address
7B9F 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7BA1 CD 7A 78    10 704 call    Screen_Apply_Color_Loop     ; apply color to string area
7BA4 13          10 705 inc     de                          ; move DE to "level up" string address
7BA5 2E 81       10 706 ld      l, $81                      ; HL points to string screen address
7BA7 CD 59 6F    10 707 call    Print_String                ; print "level up"
7BAA             10 709 ; reset bright of cyan tokens
7BAA FD 21 5E 67 10 711 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7BAE 11 3E 66    10 712 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7BB1 06 07       10 713 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7BB3 3E 05       10 714 ld      a, CYAN_COLOR               ; set new token color
7BB5 32 9E 61    10 715 ld      (TOKEN_COLOR), a            ; save color
7BB8 CD 80 7C    10 716 call    Screen_Hexagons_Loop        ; draw tokens
7BBB             10 718 ; set flash attribute of level number and three-in-a-row marks
7BBB 21 0F 58    10 720 ld      hl, $580F                   ; HL points to level number attribute address
7BBE CB FE       10 721 set     7, (hl)                     ; set flash attribute
7BC0 21 0F 40    10 722 ld      hl, $400F                   ; HL points to level number screen address
7BC3 3E 32       10 723 ld      a, '2'                      ; set new level
7BC5 CD 66 6F    10 724 call    Print_Char                  ; print new level
7BC8 DD 21 F2 5A 10 725 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BCC DD 36 00 B8 10 726 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BD0 DD 36 01 B8 10 727 ld      (ix+1), WHITE_PAPER+FLASH
7BD4 DD 36 02 B8 10 728 ld      (ix+2), WHITE_PAPER+FLASH
7BD8             10 730 ; wait for "Next" or "Back" options pressed
7BD8             10 732 Screen_How2Play_End
7BD8 CD C0 6E    10 733 call    Input_Key_Scan              ; wait for a key pressed
7BDB FE 62       10 734 cp      'b'                         ; is it 'b'?
7BDD CA B0 7A    10 735 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7BE0 FE 6E       10 736 cp      'n'                         ; is it 'n'?
7BE2 20 F4       10 737 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7BE4 21 9D 61    10 739 ld      hl, GAME_LEVEL              ; HL points to game level address
7BE7 35          10 740 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7BE8 C3 81 79    10 741 jp      Screen_Menu                 ; return to main menu
7BEB             10 743 ; ----------------------------------------------------------------------------------------------------------------------
7BEB             10 744 ; Show credits
7BEB             10 745 ; ----------------------------------------------------------------------------------------------------------------------
7BEB             10 746 Screen_Menu_Credits
7BEB DD 21 84 59 10 747 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7BEF 01 47 19    10 748 ld      bc, 25*256+WHITE_FLASH0     ; B = string length (loop counter), C = color attributes
7BF2 CD 7A 78    10 749 call    Screen_Apply_Color_Loop     ; apply color to string area
7BF5 11 A3 67    10 750 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7BF8 21 84 48    10 751 ld      hl, $4884                   ; HL points to string screen address
7BFB CD 59 6F    10 752 call    Print_String                ; print "Design..."
7BFE DD 2E C4    10 753 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7C01 06 19       10 754 ld      b, 25                       ; string length (loop counter)
7C03 CD 7A 78    10 755 call    Screen_Apply_Color_Loop     ; apply color to string area
7C06 13          10 756 inc     de                          ; move DE to to "Code..." string address
7C07 2E C4       10 757 ld      l, $C4                      ; HL points to string screen address
7C09 CD 59 6F    10 758 call    Print_String                ; print "Code..."
7C0C DD 2E E4    10 759 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7C0F 06 18       10 760 ld      b, 24                       ; string length (loop counter)
7C11 CD 7A 78    10 761 call    Screen_Apply_Color_Loop     ; apply color to string area
7C14 13          10 762 inc     de                          ; move DE to "Einar Saukas" string address
7C15 2E E4       10 763 ld      l, $E4                      ; HL points to string screen address
7C17 CD 59 6F    10 764 call    Print_String                ; print "Einar Saukas"
7C1A DD 21 24 5A 10 765 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C1E 06 18       10 766 ld      b, 24                       ; string length (loop counter)
7C20 CD 7A 78    10 767 call    Screen_Apply_Color_Loop     ; apply color to string area
7C23 13          10 768 inc     de                          ; move DE to "Font..." string address
7C24 21 24 50    10 769 ld      hl, $5024                   ; HL points to string screen address
7C27 CD 59 6F    10 770 call    Print_String                ; print "Font..."
7C2A DD 2E 64    10 771 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C2D 06 18       10 772 ld      b, 24                       ; string length (loop counter)
7C2F CD 7A 78    10 773 call    Screen_Apply_Color_Loop     ; apply color to string area
7C32 13          10 774 inc     de                          ; move DE to "Graphics..." string address
7C33 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7C35 CD 59 6F    10 776 call    Print_String                ; print "Graphics..."
7C38 DD 2E 84    10 777 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C3B 06 19       10 778 ld      b, 25                       ; string length (loop counter)
7C3D CD 7A 78    10 779 call    Screen_Apply_Color_Loop     ; apply color to string area
7C40 13          10 780 inc     de                          ; move DE to "Antonio Luque" string address
7C41 2E 84       10 781 ld      l, $84                      ; HL points to string screen address
7C43 CD 59 6F    10 782 call    Print_String                ; print "Antonio Luque"
7C46 DD 2E E9    10 783 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C49 01 38 0D    10 784 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7C4C CD 7A 78    10 785 call    Screen_Apply_Color_Loop     ; apply color to string area
7C4F 13          10 786 inc     de                          ; move DE to "Press any key" string address
7C50 2E E9       10 787 ld      l, $E9                      ; HL points to string screen address
7C52 CD 59 6F    10 788 call    Print_String                ; print "Press any key"
7C55 CD C0 6E    10 789 call    Input_Key_Scan              ; wait for a key pressed
7C58 C3 87 79    10 790 jp      Screen_Menu_Strings         ; return to main menu
7C5B             10 792 ; ----------------------------------------------------------------------------------------------------------------------
7C5B             10 793 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C5B             10 794 ;
7C5B             10 795 ; Input:    -
7C5B             10 796 ;
7C5B             10 797 ; Output:   -
7C5B             10 798 ;
7C5B             10 799 ; Uses:     TOKEN_COLOR (current token color)
7C5B             10 800 ;
7C5B             10 801 ; Destroys: A, BC, DE, HL, IX, IY
7C5B             10 802 ; ----------------------------------------------------------------------------------------------------------------------
7C5B             10 803 Screen_Hexagons:
7C5B FD 21 EA 66 10 804 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C5F 3E 07       10 805 ld      a, WHITE                    ; set hexagon color
7C61 32 9E 61    10 806 ld      (TOKEN_COLOR), a            ; save hexagon color
7C64 11 7E 65    10 807 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C67 06 1C       10 808 ld      b, 28                       ; number of empty hexagons (loop counter)
7C69 CD 80 7C    10 809 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C6C 3E 05       10 810 ld      a, CYAN_COLOR               ; set token color
7C6E 32 9E 61    10 811 ld      (TOKEN_COLOR), a            ; save hexagon color
7C71 11 3E 66    10 812 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C74 06 06       10 813 ld      b, 6                        ; number of cyan tokens (loop counter)
7C76 CD 80 7C    10 814 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C79 3E 02       10 815 ld      a, RED_COLOR                ; set token color
7C7B 32 9E 61    10 816 ld      (TOKEN_COLOR), a            ; save hexagon color
7C7E 06 06       10 817 ld      b, 6                        ; number of red tokens (loop counter)
7C80             10 818 Screen_Hexagons_Loop:
7C80 FD 6E 00    10 819 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C83 FD 66 01    10 820 ld      h, (iy+1)
7C86 CD 0A 6E    10 821 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C89 D5          10 822 push    de                          ; store hexagon/token sprite address
7C8A CD DC 6D    10 823 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C8D D1          10 824 pop     de                          ; restore hexagon/token sprite address
7C8E FD 23       10 825 inc     iy                          ; move IY to next hexagon/token screen address
7C90 FD 23       10 826 inc     iy
7C92 10 EC       10 827 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C94 C9          10 828 ret
7C95             10 830 ; ----------------------------------------------------------------------------------------------------------------------
7C95             10 831 ; Screen_Clear_Text: clean a text attributes area
7C95             10 832 ;
7C95             10 833 ; Input:    HL = text area attributes address
7C95             10 834 ;
7C95             10 835 ; Output:   -
7C95             10 836 ;
7C95             10 837 ; Destroys: BC, DE, HL
7C95             10 838 ; ----------------------------------------------------------------------------------------------------------------------
7C95             10 839 Screen_Clear_Text:
7C95 01 30 00    10 840 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7C98             10 841 Screen_ClearText_Loop
7C98 11 18 00    10 842 ld      de, 24                      ; displacement for each text row
7C9B 19          10 843 add     hl, de                      ; add displacement to text area attributes address
7C9C 54          10 844 ld      d, h                        ; DE points to text area attributes address
7C9D 5D          10 845 ld      e, l
7C9E 36 00       10 846 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7CA0 13          10 847 inc     de                          ; move DE to next byte attribute address
7CA1 ED A0       10 848 ldi                                 ; set attributes color for the rest of bytes of current row
7CA3 ED A0       10 849 ldi
7CA5 ED A0       10 850 ldi
7CA7 ED A0       10 851 ldi
7CA9 ED A0       10 852 ldi
7CAB ED A0       10 853 ldi
7CAD ED A0       10 854 ldi
7CAF ED A0       10 855 ldi
7CB1 EA 98 7C    10 856 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7CB4 C9          10 857 ret

; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

7CB5             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CB5             0 20 ; Credits and acknowledgements:
7CB5             0 21 ;
7CB5             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CB5             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CB5             0 24 ;   "King+" font and TOKEN graphics.
7CB5             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CB5             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CB5             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CB5             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CB5             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CB5             0 30 ;
7CB5             0 31 ; - Special thanks to my wife Sonia.
7CB5             0 32 ; ----------------------------------------------------------------------------------------------------------------------
