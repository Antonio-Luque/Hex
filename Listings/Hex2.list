
; File #0: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   org     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         defs    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 defb                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 defb    0                           ; board potential
6198 00          1 51 defb    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               defb    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                defb    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             defb    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             defb    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              defb    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             defb    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            defb    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 defb    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 defb    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 defb    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 defb    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 defb    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 defb    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 defb    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 defm    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;org     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 D1 73       1 85 defw    PathFinder_CYAN_Edge_0
6202 F1 73       1 86 defw    PathFinder_CYAN_Edge_1
6204 0C 74       1 87 defw    PathFinder_CYAN_Edge_2
6206 2A 74       1 88 defw    PathFinder_CYAN_Edge_3
6208 49 74       1 89 defw    PathFinder_CYAN_Edge_4
620A 67 74       1 90 defw    PathFinder_CYAN_Edge_5
620C 82 74       1 91 defw    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 96 PLAYER_MOVE:                                                ; player move in ASCII format
620E 00          1 97 defb    0                           ; column ('a'..'g')
620F 00          1 98 defb    0                           ; row ('1'..'7')
6210 00          1 99 CHAR_COUNT              defb    0                           ; number of current characters in input player move
6211 00          1 100 THREE_ROW               defb    0                           ; three-in-a-row counter
6212 0F 0E 0C 0B 1 101 ROW_COLOR_MAP           defb    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6216 0D 0A       1 101 
6218 00 2D 30 00 1 102 STR_MOVE                defb    0, '-', '0', 0, '\0'        ; formatted move string
621C 00          1 102 
621D 53 70 65 63 1 103 STR_SPECCY              defm    "Speccy\0"
6221 63 79 00    1 103 
6224 50 6C 61 79 1 104 STR_PLAYER              defm    "Player\0"
6228 65 72 00    1 104 
622B 4C 65 76 65 1 105 STR_LEVELTEXT           defm    "Level\0"
622F 6C 00       1 105 
6231 46 49 4C 4C 1 106 STR_FILLED              defm    "FILLED\0"
6235 45 44 00    1 106 
6238 57 41 49 54 1 107 STR_WAIT                defm    "WAIT\0"
623C 00          1 107 
623D 20 57 49 4E 1 108 STR_WINNER              defm    " WINS \0"
6241 53 20 00    1 108 
6244 20 20 20 20 1 109 STR_EMPTY4              defm    "    \0"
6248 00          1 109 
6249 20 20 20 20 1 110 STR_EMPTY6              defm    "      \0"
624D 20 20 00    1 110 
6250             1 112 ; ----------------------------------------------------------------------------------------------------------------------
6250             1 113 ; Conversion table: from position to XY board indexes
6250             1 114 ; ----------------------------------------------------------------------------------------------------------------------
6250             1 115 BOARD_COORDINATES:
6250 00 00 00 00 1 116 defb    $00, $00, $00, $00, $00, $00, $00, $00
6254 00 00 00 00 1 116 
6258 00 09 0A 0B 1 117 defb    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
625C 0C 0D 0E 0F 1 117 
6260 00 12 13 14 1 118 defb    $00, $12, $13, $14, $15, $16, $17, $18
6264 15 16 17 18 1 118 
6268 00 1B 1C 1D 1 119 defb    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
626C 1E 1F 20 21 1 119 
6270 00 24 25 26 1 120 defb    $00, $24, $25, $26, $27, $28, $29, $2A
6274 27 28 29 2A 1 120 
6278 00 2D 2E 2F 1 121 defb    $00, $2D, $2E, $2F, $30, $31, $32, $33
627C 30 31 32 33 1 121 
6280 00 36 37 38 1 122 defb    $00, $36, $37, $38, $39, $3A, $3B, $3C
6284 39 3A 3B 3C 1 122 
6288 00 3F 40 41 1 123 defb    $00, $3F, $40, $41, $42, $43, $44, $45
628C 42 43 44 45 1 123 
6290             1 125 ; ----------------------------------------------------------------------------------------------------------------------
6290             1 126 ; Graphics map indexes for the frame tiles
6290             1 127 ; ----------------------------------------------------------------------------------------------------------------------
6290             1 128 FRAME_MAP:
6290 00 01 01 01 1 129 defb      0,   1,   1,   1,   1,   1,   2,   3
6294 01 01 02 03 1 129 
6298 04 FF FF FF 1 130 defb      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
629C FF FF FF FF 1 130 
62A0 05 06 07 01 1 131 defb      5,   6,   7,   1,   1,   1,   1,   1
62A4 01 01 01 01 1 131 
62A8 01 01 01 01 1 132 defb      1,   1,   1,   1,   1,   1,   1,   8
62AC 01 01 01 08 1 132 
62B0 09 01 01 01 1 133 defb      9,   1,   1,   1,   1,   1,   1,   1
62B4 01 01 01 01 1 133 
62B8 01 01 01 01 1 134 defb      1,   1,   1,   1,   1,   1,   1,   1
62BC 01 01 01 01 1 134 
62C0 0A 06 0D 0D 1 135 defb     10,   6,  13,  13,  13,   3,  11,   1
62C4 0D 03 0B 01 1 135 
62C8 01 01 01 01 1 136 defb      1,   1,   1,   1,   1,   1,   1,  12
62CC 01 01 01 0C 1 136 
62D0             1 138 ; ----------------------------------------------------------------------------------------------------------------------
62D0             1 139 ; Definition of a small "Opening Book" for speccy first move
62D0             1 140 ; ----------------------------------------------------------------------------------------------------------------------
62D0             1 141 OPENINGS:
62D0 0F 14 16 17 1 142 defb    $0F, $14, $16, $17, $18, $1C, $1D
62D4 18 1C 1D    1 142 
62D7 1E 1F 20 24 1 143 defb    $1E, $1F, $20, $24, $25, $26, $27
62DB 25 26 27    1 143 
62DE 28 29 2A 2E 1 144 defb    $28, $29, $2A, $2E, $2F, $30, $31
62E2 2F 30 31    1 144 
62E5 32 36 37 38 1 145 defb    $32, $36, $37, $38, $3A, $3F
62E9 3A 3F       1 145 
62EB             1 147 ; ----------------------------------------------------------------------------------------------------------------------
62EB             1 148 ; Timer variables
62EB             1 149 ; ----------------------------------------------------------------------------------------------------------------------
62EB 00          1 150 TIMER_FLAG              defb    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62EC             1 151 ; for each timer:
62EC             1 152 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62EC             1 153 ;   2nd byte = seconds counter
62EC             1 154 ;   3th byte = minutes counter
62EC 32 00 00    1 155 CYAN_TIMER              defb    50, 0, 0
62EF 32 00 00    1 156 RED_TIMER               defb    50, 0, 0
62F2             1 158 ; ----------------------------------------------------------------------------------------------------------------------
62F2             1 159 ; Screen addresses look-up array for board numbers
62F2             1 160 ; ----------------------------------------------------------------------------------------------------------------------
62F2             1 161 NUMBER_SCREEN:
62F2 A5 43 E6 43 1 162 defw    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F6 27 4B 68 4B 1 162 
62FA A9 4B EA 4B 1 162 
62FE 2B 53       1 162 
6300             1 164 ;org     $6300
6300             1 165 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 166 ; Circular queue
6300             1 167 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 168 RED_QUEUE_AREA          defs    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 168 
6308 00 00 00 00 1 168 
630C 00 00 00 00 1 168 
6310 00 00 00 00 1 168 
6314 00 00 00 00 1 168 
6318 00 00 00 00 1 168 
631C 00 00 00 00 1 168 
6320 00 00 00 00 1 168 
6324 00 00 00 00 1 168 
6328 00 00 00 00 1 168 
632C 00 00 00 00 1 168 
6330 00 00 00 00 1 168 
6334 00 00 00 00 1 168 
6338 00 00 00 00 1 168 
633C 00 00 00 00 1 168 
6340 00 00 00 00 1 168 
6344 00 00 00 00 1 168 
6348 00 00 00 00 1 168 
634C 00 00 00 00 1 168 
6350 00 00 00 00 1 168 
6354 00 00 00 00 1 168 
6358 00 00 00 00 1 168 
635C 00 00 00 00 1 168 
6360 00 00 00 00 1 168 
6364 00 00 00 00 1 168 
6368 00 00 00 00 1 168 
636C 00 00 00 00 1 168 
6370 00 00 00 00 1 168 
6374 00 00 00 00 1 168 
6378 00 00 00 00 1 168 
637C 00 00 00 00 1 168 
6380 00 00 00 00 1 168 
6384 00 00 00 00 1 168 
6388 00 00 00 00 1 168 
638C 00 00 00 00 1 168 
6390 00 00 00 00 1 168 
6394 00 00 00 00 1 168 
6398 00 00 00 00 1 168 
639C 00 00 00 00 1 168 
63A0 00 00 00 00 1 168 
63A4 00 00 00 00 1 168 
63A8 00 00 00 00 1 168 
63AC 00 00 00 00 1 168 
63B0 00 00 00 00 1 168 
63B4 00 00 00 00 1 168 
63B8 00 00 00 00 1 168 
63BC 00 00 00 00 1 168 
63C0 00 00 00 00 1 168 
63C4 00 00 00 00 1 168 
63C8 00 00 00 00 1 168 
63CC 00 00 00 00 1 168 
63D0 00 00 00 00 1 168 
63D4 00 00 00 00 1 168 
63D8 00 00 00 00 1 168 
63DC 00 00 00 00 1 168 
63E0 00 00 00 00 1 168 
63E4 00 00 00 00 1 168 
63E8 00 00 00 00 1 168 
63EC 00 00 00 00 1 168 
63F0 00 00 00 00 1 168 
63F4 00 00 00 00 1 168 
63F8 00 00 00 00 1 168 
63FC 00 00 00 00 1 168 
6400             1 170 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 171 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 172 ; 
6400             1 173 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 174 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 175 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 176 ; 
6400             1 177 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 178 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 179 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 180 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 181 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 182 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 182 
6408 7F 00 00 00 1 183 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 183 
6410 80          1 183 
6411 7F 00 00 00 1 184 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 184 
6419 81          1 184 
641A 7F 00 00 00 1 185 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 185 
6422 82          1 185 
6423 7F 00 00 00 1 186 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 186 
642B 83          1 186 
642C 7F 00 00 00 1 187 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 187 
6434 84          1 187 
6435 7F 00 00 00 1 188 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 188 
643D 85          1 188 
643E 7F 00 00 00 1 189 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 189 
6446 86          1 189 
6447 7F 7F 7F 7F 1 190 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 190 
644F 7F          1 190 
6450             1 191 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 192 defb    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 192 
6458 7F          1 192 
6459 81 00 00 00 1 193 defb       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 193 
6461 7F          1 193 
6462 82 00 00 00 1 194 defb          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 194 
646A 7F          1 194 
646B 83 00 00 00 1 195 defb             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 195 
6473 7F          1 195 
6474 84 00 00 00 1 196 defb                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 196 
647C 7F          1 196 
647D 85 00 00 00 1 197 defb                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 197 
6485 7F          1 197 
6486 86 00 00 00 1 198 defb                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 198 
648E 7F          1 198 
648F 7F 7F 7F 7F 1 199 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 199 
6497             1 201 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 202 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 203 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 204 TIMER_DIGITS:
6497 00 0F 0B 0B 1 205 defb    $00, $0F, $0B, $0B, $0B, $0F, $00, $00              ; 0
649B 0B 0F 00 00 1 205 
649F 00 06 0E 06 1 206 defb    $00, $06, $0E, $06, $06, $06, $00, $00              ; 1
64A3 06 06 00 00 1 206 
64A7 00 0F 03 0F 1 207 defb    $00, $0F, $03, $0F, $08, $0F, $00, $00              ; 2
64AB 08 0F 00 00 1 207 
64AF 00 0F 03 07 1 208 defb    $00, $0F, $03, $07, $03, $0F, $00, $00              ; 3
64B3 03 0F 00 00 1 208 
64B7 00 0B 0B 0F 1 209 defb    $00, $0B, $0B, $0F, $03, $03, $00, $00              ; 4 
64BB 03 03 00 00 1 209 
64BF 00 0F 08 0F 1 210 defb    $00, $0F, $08, $0F, $03, $0F, $00, $00              ; 5
64C3 03 0F 00 00 1 210 
64C7 00 0F 0C 0F 1 211 defb    $00, $0F, $0C, $0F, $0D, $0F, $00, $00              ; 6
64CB 0D 0F 00 00 1 211 
64CF 00 0F 03 03 1 212 defb    $00, $0F, $03, $03, $03, $03, $00, $00              ; 7
64D3 03 03 00 00 1 212 
64D7 00 0F 0B 0F 1 213 defb    $00, $0F, $0B, $0F, $0B, $0F, $00, $00              ; 8
64DB 0B 0F 00 00 1 213 
64DF 00 0F 0B 0F 1 214 defb    $00, $0F, $0B, $0F, $03, $0F, $00, $00              ; 9
64E3 03 0F 00 00 1 214 
64E7             1 216 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 217 ; Tone parameters for sound effects
64E7             1 218 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 219 ; for each tone (from left to right):
64E7             1 220 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 221 ;   - length of a frame (1..65536)
64E7             1 222 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 223 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 224 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 225 TOKEN_FX                defw       1, 1000, 1400,   0
64EB 78 05 00 00 1 225 
64EF 05 00 88 13 1 226 WINNER_FX               defw       5, 5000,  200, 100
64F3 C8 00 64 00 1 226 
64F7 E8 03 0A 00 1 227 FILLED_FX               defw    1000,   10,  100,   0
64FB 64 00 00 00 1 227 
64FF FF          1 229 FILLER                  defb    $FF                         ; filler to align next block (not used)
6500             1 231 ;org     $6500
6500             1 232 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 233 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 234 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 235 RED_VECTOR_TABLE:
6500 B7 72       1 236 defw    PathFinder_RED_Edge_0
6502 E5 72       1 237 defw    PathFinder_RED_Edge_1
6504 0B 73       1 238 defw    PathFinder_RED_Edge_2
6506 31 73       1 239 defw    PathFinder_RED_Edge_3
6508 57 73       1 240 defw    PathFinder_RED_Edge_4
650A 7D 73       1 241 defw    PathFinder_RED_Edge_5
650C A3 73       1 242 defw    PathFinder_RED_Edge_6
650E             1 244 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 245 ; Graphics for the screen frame
650E             1 246 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 247 FRAME_TILES:
650E 00 00 1F 3F 1 248 defb    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C              ; 00: up-left corner
6512 3F 3F 3C 3C 1 248 
6516 00 00 FF FF 1 249 defb    $00, $00, $FF, $FF, $FF, $FF, $00, $00              ; 01: horizontal bar
651A FF FF 00 00 1 249 
651E 00 00 FF FE 1 250 defb    $00, $00, $FF, $FE, $FE, $FF, $00, $00              ; 02: concave left
6522 FE FF 00 00 1 250 
6526 03 07 0F 0F 1 251 defb    $03, $07, $0F, $0F, $0F, $0F, $07, $03              ; 03: end frame 1
652A 0F 0F 07 03 1 251 
652E FF FE FC FC 1 252 defb    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF              ; 04: level left
6532 FC FC FE FF 1 252 
6536 FF 7F 3F 3F 1 253 defb    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF              ; 05: level right
653A 3F 3F 7F FF 1 253 
653E C0 E0 F0 F0 1 254 defb    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0              ; 06: end frame 2
6542 F0 F0 E0 C0 1 254 
6546 00 00 FF 7F 1 255 defb    $00, $00, $FF, $7F, $7F, $FF, $00, $00              ; 07: concave right
654A 7F FF 00 00 1 255 
654E 00 00 F8 FC 1 256 defb    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C              ; 08: up-right corner
6552 FC FC 3C 3C 1 256 
6556 3C 3C 3F 3F 1 257 defb    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00              ; 09: bottom-left corner
655A 3F 1F 00 00 1 257 
655E 00 00 FE FF 1 258 defb    $00, $00, $FE, $FF, $FF, $FE, $00, $00              ; 10: convex left
6562 FF FE 00 00 1 258 
6566 00 00 7F FF 1 259 defb    $00, $00, $7F, $FF, $FF, $7F, $00, $00              ; 11: convex right
656A FF 7F 00 00 1 259 
656E 3C 3C FC FC 1 260 defb    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00              ; 12: bottom-right corner
6572 FC F8 00 00 1 260 
6576 00 00 38 7C 1 261 defb    $00, $00, $38, $7C, $7C, $38, $00, $00              ; 13: level marks
657A 7C 38 00 00 1 261 
657E             1 263 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 264 ; Hexagon sprites
657E             1 265 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 266 HEXAGON_EMPTY:
657E 07 E0 18 18 1 267 defb    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 267 
6586 48 02 48 02 1 268 defb    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 268 
658E 40 02 40 02 1 269 defb    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 269 
6596 20 24 20 04 1 270 defb    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 270 
659E             1 271 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 272 defb    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 272 
65A6 24 04 24 04 1 273 defb    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 273 
65AE 20 04 20 04 1 274 defb    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 274 
65B6 10 48 10 08 1 275 defb    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 275 
65BE 01 80 02 40 1 277 defb    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 277 
65C6 0A 10 0A 10 1 278 defb    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 278 
65CE 08 10 08 10 1 279 defb    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 279 
65D6 08 90 04 20 1 280 defb    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 280 
65DE 00 80 00 80 1 282 defb    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 282 
65E6 00 80 00 80 1 283 defb    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 283 
65EE 00 80 00 80 1 284 defb    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 284 
65F6 00 80 00 80 1 285 defb    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 285 
65FE 01 80 02 40 1 287 defb    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 287 
6606 0B D0 0B D0 1 288 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 288 
660E 0B D0 0B D0 1 289 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 289 
6616 0B D0 05 A0 1 290 defb    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 290 
661E 03 C0 0C 30 1 292 defb    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 292 
6626 2F F4 2F F4 1 293 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 293 
662E 2F F4 2F F4 1 294 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 294 
6636 17 E8 13 C8 1 295 defb    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 295 
663E             1 296 HEXAGON_TOKEN:
663E 07 E0 18 18 1 297 defb    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 297 
6646 5F FA 5F FA 1 298 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 298 
664E 5F FA 5F FA 1 299 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 299 
6656 2F F4 27 E4 1 300 defb    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 300 
665E             1 302 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 303 ; Board letter sprites
665E             1 304 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 305 LETTER_SPRITES:
665E 3C 7E FF C3 1 306 defb    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C    ; a
6662 F3 C3 D3 C3 1 306 
6666 7E 3C       1 306 
6668 3C 7E CF CF 1 307 defb    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C    ; b
666C C3 CB CB C3 1 307 
6670 7E 3C       1 307 
6672 3C 7E FF E3 1 308 defb    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C    ; c
6676 CF CF CF E3 1 308 
667A 7E 3C       1 308 
667C 3C 7E F3 F3 1 309 defb    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C    ; d
6680 C3 D3 D3 C3 1 309 
6684 7E 3C       1 309 
6686 3C 7E FF E3 1 310 defb    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C    ; e
668A CB C3 CF E3 1 310 
668E 7E 3C       1 310 
6690 3C 7E E3 CF 1 311 defb    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C    ; f
6694 C7 CF CF CF 1 311 
6698 7E 3C       1 311 
669A 3C 7E FF E3 1 312 defb    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C    ; g
669E D3 D3 E3 F3 1 312 
66A2 46 3C       1 312 
66A4             1 314 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 315 ; Board number sprites
66A4             1 316 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 317 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 318 defb    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C    ; 1
66A8 E7 E7 E7 E7 1 318 
66AC 7E 3C       1 318 
66AE 3C 7E E7 D3 1 319 defb    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C    ; 2
66B2 F3 E7 CF C3 1 319 
66B6 7E 3C       1 319 
66B8 3C 7E C7 F3 1 320 defb    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C    ; 3
66BC E3 F3 F3 C7 1 320 
66C0 7E 3C       1 320 
66C2 3C 7E D3 D3 1 321 defb    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C    ; 4
66C6 C3 F3 F3 F3 1 321 
66CA 7E 3C       1 321 
66CC 3C 7E C3 CF 1 322 defb    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C    ; 5
66D0 C7 F3 F3 C7 1 322 
66D4 7E 3C       1 322 
66D6 3C 7E E3 CF 1 323 defb    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C    ; 6
66DA C3 CB CB C3 1 323 
66DE 7E 3C       1 323 
66E0 3C 7E C3 F3 1 324 defb    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C    ; 7
66E4 F3 E7 E7 E7 1 324 
66E8 7E 3C       1 324 
66EA             1 326 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 327 ; Screen addresses for menu hexagons
66EA             1 328 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 329 MENU_HEXAGONS:
66EA 01 40 05 40 1 330 defw    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 330 
66F2 0F 40 13 40 1 330 
66F6 1A 40       1 330 
66F8 45 40 48 40 1 331 defw    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 331 
6700 81 40 83 40 1 331 
6704 85 40       1 331 
6706 88 40 8A 40 1 332 defw    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 332 
670E C1 40 D0 40 1 332 
6712 D9 40       1 332 
6714 05 48 08 48 1 333 defw    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 333 
671C 19 48 1B 48 1 333 
6720 1D 48       1 333 
6722 0A 40 59 40 1 334 defw    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 334 
672A D2 40 0C 48 1 334 
672E 1C 40       1 334 
6730 41 40 50 40 1 335 defw    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 335 
6738 0F 48       1 335 
673A             1 336 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 337 defw    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 337 
6742 EF 40 F1 40 1 337 
6746 B2 40       1 337 
6748 E9 40 6F 48 1 338 defw    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 338 
6750 AA 48 AC 40 1 338 
6754 EF 48       1 338 
6756 2A 48 6D 48 1 339 defw    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 339 
675E             1 340 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 341 defw    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 341 
6766 AE 48 EF 48 1 341 
676A 2E 50       1 341 
676C AC 48 B4 48 1 342 defw    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 342 
6774 2E 48 F1 40 1 342 
6778 F3 40       1 342 
677A 73 48 B2 48 1 343 defw    $4873, $48B2, $5030
677E 30 50       1 343 
6780             1 345 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 346 ; Strings
6780             1 347 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 348 STR_OPTIONS:
6780 53 74 61 72 1 349 defm    "Start new game\0"
6784 74 20 6E 65 1 349 
6788 77 20 67 61 1 349 
678C 6D 65 00    1 349 
678F 48 6F 77 20 1 350 defm    "How to play\0"
6793 74 6F 20 70 1 350 
6797 6C 61 79 00 1 350 
679B 43 72 65 64 1 351 defm    "Credits\0"
679F 69 74 73 00 1 351 
67A3             1 352 STR_CREDITS:
67A3 44 65 73 69 1 353 defm    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 353 
67AB 20 20 20 20 1 353 
67AF 41 6E 74 6F 1 353 
67B3 6E 69 6F 20 1 353 
67B7 4C 75 71 75 1 353 
67BB 65 00       1 353 
67BD 43 6F 64 65 1 354 defm    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 354 
67C5 20 20 20 20 1 354 
67C9 41 6E 74 6F 1 354 
67CD 6E 69 6F 20 1 354 
67D1 4C 75 71 75 1 354 
67D5 65 00       1 354 
67D7 20 20 20 20 1 355 defm    "            Einar Saukas\0"
67DB 20 20 20 20 1 355 
67DF 20 20 20 20 1 355 
67E3 45 69 6E 61 1 355 
67E7 72 20 53 61 1 355 
67EB 75 6B 61 73 1 355 
67EF 00          1 355 
67F0 46 6F 6E 74 1 356 defm    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 356 
67F8 20 20 20 20 1 356 
67FC 45 69 6E 61 1 356 
6800 72 20 53 61 1 356 
6804 75 6B 61 73 1 356 
6808 00          1 356 
6809 47 72 61 70 1 357 defm    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 357 
6811 3A 20 20 20 1 357 
6815 45 69 6E 61 1 357 
6819 72 20 53 61 1 357 
681D 75 6B 61 73 1 357 
6821 00          1 357 
6822 20 20 20 20 1 358 defm    "            Antonio Luque\0"
6826 20 20 20 20 1 358 
682A 20 20 20 20 1 358 
682E 41 6E 74 6F 1 358 
6832 6E 69 6F 20 1 358 
6836 4C 75 71 75 1 358 
683A 65 00       1 358 
683C 50 72 65 73 1 359 STR_PRESSKEY            defm    "Press any key\0"
6840 73 20 61 6E 1 359 
6844 79 20 6B 65 1 359 
6848 79 00       1 359 
684A             1 360 STR_BUTTONS:
684A 4E 65 78 74 1 361 defm    "Next\0"
684E 00          1 361 
684F 42 61 63 6B 1 362 defm    "Back\0"
6853 00          1 362 
6854 52 45 44 00 1 363 STR_RED                 defm    "RED\0"
6858 43 59 41 4E 1 364 STR_CYAN                defm    "CYAN\0"
685C 00          1 364 
685D 43 6F 6E 6E 1 365 STR_HELP1               defm    "Connect\0"
6861 65 63 74 00 1 365 
6865 6C 65 66 74 1 366 STR_HELP2_RED           defm    "left and\0"
6869 20 61 6E 64 1 366 
686D 00          1 366 
686E 75 70 20 61 1 367 STR_HELP2_CYAN          defm    "up and\0"
6872 6E 64 00    1 367 
6875 72 69 67 68 1 368 STR_HELP3_RED           defm    "right\0"
6879 74 00       1 368 
687B 64 6F 77 6E 1 369 STR_HELP3_CYAN          defm    "down\0"
687F 00          1 369 
6880 62 6F 72 64 1 370 STR_HELP4               defm    "borders\0"
6884 65 72 73 00 1 370 
6888 74 6F 20 77 1 371 STR_HELP5               defm    "to win\0"
688C 69 6E 00    1 371 
688F             1 372 STR_HELP:
688F 57 69 6E 20 1 373 defm    "Win three\0"
6893 74 68 72 65 1 373 
6897 65 00       1 373 
6899 74 69 6D 65 1 374 defm    "times in\0"
689D 73 20 69 6E 1 374 
68A1 00          1 374 
68A2 61 20 72 6F 1 375 defm    "a row to\0"
68A6 77 20 74 6F 1 375 
68AA 00          1 375 
68AB 6C 65 76 65 1 376 defm    "level up\0"
68AF 6C 20 75 70 1 376 
68B3 00          1 376 
68B4 20 43 4F 4E 1 377 STR_CONGRATS            defm    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 377 
68BC 55 4C 41 54 1 377 
68C0 49 4F 4E 53 1 377 
68C4 20 00       1 377 
68C6             1 378 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 379 defm    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 379 
68CE 65 21 20 4C 1 379 
68D2 61 73 74 20 1 379 
68D6 6C 65 76 65 1 379 
68DA 6C 20 70 61 1 379 
68DE 73 73 65 64 1 379 
68E2 00          1 379 
68E3 43 68 6F 6F 1 380 defm    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 380 
68EB 65 76 65 6C 1 380 
68EF 20 74 6F 20 1 380 
68F3 72 65 73 74 1 380 
68F7 61 72 74 2C 1 380 
68FB 20 31 2D 34 1 380 
68FF 00          1 380 
6900             1 382 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 383 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 384 ; this font was designed by Einar Saukas for Hex game
6900             1 385 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 386 FONT:
6900 00 00 00 00 1 387 includebin "King+.bin"
6904 00 00 00 00 1 387 
6908 00 18 18 18 1 387 
690C 00 18 18 00 1 387 
6910 00 24 24 00 1 387 
6914 00 00 00 00 1 387 
6918 00 24 7E 24 1 387 
691C 24 7E 24 00 1 387 
6920 00 08 3E 28 1 387 
6924 3E 0A 3E 08 1 387 
6928 00 62 64 08 1 387 
692C 10 26 46 00 1 387 
6930 00 10 28 10 1 387 
6934 2A 44 3A 00 1 387 
6938 00 18 30 00 1 387 
693C 00 00 00 00 1 387 
6940 06 0C 08 08 1 387 
6944 08 0C 06 00 1 387 
6948 60 30 10 10 1 387 
694C 10 30 60 00 1 387 
6950 00 00 14 08 1 387 
6954 3E 08 14 00 1 387 
6958 00 00 08 08 1 387 
695C 3E 08 08 00 1 387 
6960 00 00 00 00 1 387 
6964 00 0C 18 30 1 387 
6968 00 00 00 7E 1 387 
696C 7E 00 00 00 1 387 
6970 00 00 00 00 1 387 
6974 30 70 70 00 1 387 
6978 02 06 0C 18 1 387 
697C 30 60 40 00 1 387 
6980 00 7E 62 62 1 387 
6984 62 62 7E 00 1 387 
6988 00 18 38 18 1 387 
698C 18 18 3C 00 1 387 
6990 00 38 4C 4C 1 387 
6994 18 30 7C 00 1 387 
6998 00 3C 62 0C 1 387 
699C 06 66 3C 00 1 387 
69A0 00 30 30 30 1 387 
69A4 30 34 3E 04 1 387 
69A8 00 7E 60 7E 1 387 
69AC 06 66 3C 00 1 387 
69B0 00 30 60 7C 1 387 
69B4 66 66 3C 00 1 387 
69B8 00 7E 46 0C 1 387 
69BC 18 30 60 00 1 387 
69C0 00 3C 66 3C 1 387 
69C4 66 66 3C 00 1 387 
69C8 00 3C 66 66 1 387 
69CC 3E 06 3C 00 1 387 
69D0 00 00 08 18 1 387 
69D4 00 08 18 00 1 387 
69D8 00 00 04 0C 1 387 
69DC 00 0C 18 30 1 387 
69E0 00 00 04 08 1 387 
69E4 10 08 04 00 1 387 
69E8 00 00 00 3E 1 387 
69EC 00 3E 00 00 1 387 
69F0 00 00 10 08 1 387 
69F4 04 08 10 00 1 387 
69F8 00 3C 42 04 1 387 
69FC 08 00 08 00 1 387 
6A00 00 3C 4A 56 1 387 
6A04 5E 40 3C 00 1 387 
6A08 00 7E 46 46 1 387 
6A0C 7E 46 46 00 1 387 
6A10 00 7C 62 7C 1 387 
6A14 62 62 7C 00 1 387 
6A18 00 7E 66 60 1 387 
6A1C 60 66 7E 00 1 387 
6A20 00 7C 46 46 1 387 
6A24 46 46 7C 00 1 387 
6A28 00 7E 60 7C 1 387 
6A2C 60 60 7E 00 1 387 
6A30 00 7E 60 7C 1 387 
6A34 60 60 60 00 1 387 
6A38 00 3E 62 60 1 387 
6A3C 66 66 3E 00 1 387 
6A40 00 62 62 7E 1 387 
6A44 62 62 62 00 1 387 
6A48 00 18 18 18 1 387 
6A4C 18 18 18 00 1 387 
6A50 00 0C 0C 0C 1 387 
6A54 0C 4C 38 00 1 387 
6A58 00 66 64 68 1 387 
6A5C 7E 46 66 00 1 387 
6A60 00 60 60 60 1 387 
6A64 60 60 7E 00 1 387 
6A68 00 7E 56 56 1 387 
6A6C 56 56 56 00 1 387 
6A70 00 7E 46 46 1 387 
6A74 46 46 46 00 1 387 
6A78 00 7E 62 62 1 387 
6A7C 62 62 7E 00 1 387 
6A80 00 7E 62 62 1 387 
6A84 7E 60 60 00 1 387 
6A88 00 7C 64 64 1 387 
6A8C 64 64 7E 00 1 387 
6A90 00 7C 62 64 1 387 
6A94 7C 46 46 00 1 387 
6A98 00 7E 60 7E 1 387 
6A9C 06 06 7E 00 1 387 
6AA0 00 7E 18 18 1 387 
6AA4 18 18 18 00 1 387 
6AA8 00 62 62 62 1 387 
6AAC 62 62 7E 00 1 387 
6AB0 00 62 62 62 1 387 
6AB4 62 34 18 00 1 387 
6AB8 00 6A 6A 6A 1 387 
6ABC 6A 6A 7E 00 1 387 
6AC0 00 62 62 34 1 387 
6AC4 4E 46 46 00 1 387 
6AC8 00 62 62 7E 1 387 
6ACC 18 18 18 00 1 387 
6AD0 00 7E 06 1C 1 387 
6AD4 38 60 7E 00 1 387 
6AD8 00 0E 08 08 1 387 
6ADC 08 08 0E 00 1 387 
6AE0 00 00 40 20 1 387 
6AE4 10 08 04 00 1 387 
6AE8 00 70 10 10 1 387 
6AEC 10 10 70 00 1 387 
6AF0 00 08 1C 2A 1 387 
6AF4 08 08 08 08 1 387 
6AF8 00 00 00 00 1 387 
6AFC 00 00 00 FF 1 387 
6B00 0C 12 10 38 1 387 
6B04 10 10 3E 00 1 387 
6B08 00 00 3C 06 1 387 
6B0C 7E 46 7E 00 1 387 
6B10 00 60 60 7E 1 387 
6B14 62 62 7E 00 1 387 
6B18 00 00 7E 62 1 387 
6B1C 60 62 7E 00 1 387 
6B20 00 06 06 7E 1 387 
6B24 46 46 7E 00 1 387 
6B28 00 00 7E 46 1 387 
6B2C 7E 60 7E 00 1 387 
6B30 00 1E 30 3C 1 387 
6B34 30 30 30 00 1 387 
6B38 00 00 7E 46 1 387 
6B3C 46 3E 06 3E 1 387 
6B40 00 60 60 7C 1 387 
6B44 66 66 66 00 1 387 
6B48 00 18 00 38 1 387 
6B4C 18 18 3C 00 1 387 
6B50 00 0C 00 0C 1 387 
6B54 0C 0C 4C 38 1 387 
6B58 00 20 2C 38 1 387 
6B5C 38 2C 26 00 1 387 
6B60 00 18 18 18 1 387 
6B64 18 18 0E 00 1 387 
6B68 00 00 6C 56 1 387 
6B6C 56 56 46 00 1 387 
6B70 00 00 7C 46 1 387 
6B74 46 46 46 00 1 387 
6B78 00 00 3C 46 1 387 
6B7C 46 46 3C 00 1 387 
6B80 00 00 7C 66 1 387 
6B84 66 7C 60 60 1 387 
6B88 00 00 3E 46 1 387 
6B8C 46 3E 06 06 1 387 
6B90 00 00 3C 62 1 387 
6B94 60 60 60 00 1 387 
6B98 00 00 3C 60 1 387 
6B9C 3C 06 3C 00 1 387 
6BA0 00 30 78 30 1 387 
6BA4 30 30 1C 00 1 387 
6BA8 00 00 46 46 1 387 
6BAC 46 46 3C 00 1 387 
6BB0 00 00 46 46 1 387 
6BB4 2C 3C 18 00 1 387 
6BB8 00 00 46 56 1 387 
6BBC 56 56 2C 00 1 387 
6BC0 00 00 46 2C 1 387 
6BC4 18 2C 46 00 1 387 
6BC8 00 00 46 46 1 387 
6BCC 46 3E 06 3C 1 387 
6BD0 00 00 7E 0C 1 387 
6BD4 18 30 7E 00 1 387 
6BD8 00 0E 08 30 1 387 
6BDC 08 08 0E 00 1 387 
6BE0 00 08 08 08 1 387 
6BE4 08 2A 1C 08 1 387 
6BE8 00 70 10 0C 1 387 
6BEC 10 10 70 00 1 387 
6BF0 00 14 28 00 1 387 
6BF4 00 00 00 00 1 387 

; File #2: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Main.z80asm

6BF8             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 2 ; Main.z80asm
6BF8             2 3 ; Coded by Antonio Luque
6BF8             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 6 CYAN_COLOR              equ     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6BF8             2 7 RED_COLOR               equ     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6BF8             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 10 ; Entry point of the program - Initialization
6BF8             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 12 Main                    ent     $
6BF8 F3          2 14 di                                  ; disable interrupts
6BF9             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6BF9 21 39 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6BFC FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C00 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C03 FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C06 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C08 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C0A ED 5E       2 24 im      2                           ; set interrupt mode 2
6C0C             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C0C             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C0C             2 28 ; resultant vector address is formed as follows:
6C0C             2 29 ;
6C0C             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C0C             2 31 ; Source: 
6C0C             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
6C0C             2 33 ;
6C0C             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C0C             2 35 ; memory area and it is used by some ROM routines, but it is no longer used by HEX2 program.
6C0C 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C0F AF          2 39 xor     a                           ; A = 0
6C10 D3 FE       2 40 out     ($FE), a                    ; set border color (black)
6C12 CD 8A 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C15             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C15             2 44 ; Start new game
6C15             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C15             2 46 Main_Start
6C15 CD 1F 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C18 CD 2C 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C1B CD 58 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C1E CD 97 77    2 50 call    Screen_Frame                ; draw the screen frame
6C21 CD EF 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C24 CD 0E 78    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C27 CD 51 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C2A FB          2 55 ei                                  ; enable interrupts
6C2B             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C2B             2 58 ; New level
6C2B             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C2B             2 60 Main_New_Level
6C2B 3E 04       2 61 ld      a, 4                        ; maximum level
6C2D 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C30 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C31 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C33 CD 8B 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C36 18 DD       2 66 jr      Main_Start                  ; start a new game
6C38             2 67 Main_Increment_Level
6C38 34          2 68 inc     (hl)                        ; increment game level
6C39 CD 2E 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C3C CD 1D 79    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C3F AF          2 71 xor     a                           ; A = 0
6C40 32 11 62    2 72 ld      (THREE_ROW), a              ; initialize three-in-a-row counter
6C43             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C43             2 75 ; Start new match
6C43             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C43             2 77 Main_Start_Match
6C43             2 78 ; set up timers and clear last messages
6C43 CD CE 76    2 80 call    Timer_Reset                 ; reset timers
6C46 CD B9 76    2 81 call    Timer_Display_All           ; display timers
6C49 CD 41 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C4C 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C4E 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C51 CD 68 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C54             2 87 ; swap players' colors
6C54 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C57 EE 07       2 90 xor     %00000111                   ; swap color
6C59 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C5C CD 24 6F    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C5F             2 94 ; initialize boards
6C5F 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C62 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C65 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C67 01 FF 01    2 99 ld      bc, (256*2)-1               ; length of cyan + red positions areas (-1 already set)
6C6A ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C6C CD A4 6D    2 102 call    Draw_Board                  ; draw an empty hexagons board
6C6F 3E 0A       2 104 ld      a, 10
6C71 32 DA 6D    2 105 ld      (Draw_Token_Delay+1), a     ; set delay duration for animate hexagons
6C74 3E 01       2 106 ld      a, 1
6C76 32 9B 61    2 107 ld      (MOVE_NUMBER), a            ; initialize move number
6C79 32 EB 62    2 108 ld      (TIMER_FLAG), a             ; set cyan timer on
6C7C 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C7E             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C7E             2 112 ; Process players moves - Match loop
6C7E             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C7E             2 114 Main_Match_Loop
6C7E             2 115 ; check player turn
6C7E 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C81 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C84 BE          2 119 cp      (hl)                        ; is player color = current token color?
6C85 28 05       2 120 jr      z, Main_Player_Move         ; yes, process player move
6C87 CD F4 6C    2 121 call    Main_GetSpeccy_Move         ; get the speccy move
6C8A 18 03       2 122 jr      Main_Update_Board           ; update board position
6C8C             2 123 Main_Player_Move
6C8C CD 39 6D    2 124 call    Main_GetPlayer_Move         ; get a legal (empty position) player move 
6C8F             2 125 Main_Update_Board
6C8F             2 126 ; update positions with player/speccy move
6C8F CD 13 71    2 128 call    PathFinder_Friend           ; get player/speccy side
6C92 CD 1D 71    2 129 call    PathFinder_PutToken         ; put token on cyan and red positions
6C95 CD BF 6D    2 130 call    Draw_Token                  ; animate hexagon sprite on the screen
6C98             2 132 ; check win condition
6C98 3A 9E 61    2 134 ld      a, (TOKEN_COLOR)            ; get current token color
6C9B FE 05       2 135 cp      CYAN_COLOR                  ; is token color = cyan?
6C9D 28 05       2 136 jr      z, Main_Cyan_Score          ; yes, get score for cyan player
6C9F CD DC 71    2 137 call    PathFinder_Red_LeftRight    ; get score for red player
6CA2 18 03       2 138 jr      Main_Check_Winner           ; check victory condition
6CA4             2 139 Main_Cyan_Score
6CA4 CD 68 71    2 140 call    PathFinder_Cyan_UpDown      ; get score for cyan player
6CA7             2 141 Main_Check_Winner
6CA7 B7          2 142 or      a                           ; player/speccy won?
6CA8 28 13       2 143 jr      z, Main_Match_End           ; yes, match ends
6CAA 21 9B 61    2 145 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CAD 34          2 146 inc     (hl)                        ; increment move number
6CAE             2 148 ; swap players' timers and token color
6CAE 3A EB 62    2 150 ld      a, (TIMER_FLAG)             ; get current timer flag
6CB1 EE 03       2 151 xor     %00000011                   ; swap timer flag
6CB3 32 EB 62    2 152 ld      (TIMER_FLAG), a             ; save swapped timer flag
6CB6 3A 9E 61    2 154 ld      a, (TOKEN_COLOR)            ; get current token color
6CB9 EE 07       2 155 xor     %00000111                   ; swap token color
6CBB 18 C1       2 156 jr      Main_Match_Loop             ; repeat match loop
6CBD             2 158 ; ----------------------------------------------------------------------------------------------------------------------
6CBD             2 159 ; Current player wins the match
6CBD             2 160 ; ----------------------------------------------------------------------------------------------------------------------
6CBD             2 161 Main_Match_End
6CBD 21 EB 62    2 162 ld      hl, TIMER_FLAG              ; HL points to timer flag address
6CC0 36 00       2 163 ld      (hl), 0                     ; stop timers
6CC2 3E 04       2 164 ld      a, 4
6CC4 32 DA 6D    2 165 ld      (Draw_Token_Delay+1), a     ; set delay duration for animate hexagons
6CC7 CD C3 75    2 166 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CCA 11 3D 62    2 167 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CCD CD 48 6F    2 168 call    Print_Alert                 ; print string
6CD0 3A 9E 61    2 170 ld      a, (TOKEN_COLOR)            ; get current token color
6CD3 21 9F 61    2 171 ld      hl, PLAYER_COLOR            ; get player color
6CD6 BE          2 172 cp      (hl)                        ; is player color = current token color?
6CD7 21 11 62    2 173 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CDA 28 04       2 174 jr      z, Main_ThreeRow_Increment  ; yes, go to increment three-in-a-row counter
6CDC 35          2 175 dec     (hl)                        ; decrement three-in-a-row counter
6CDD F2 E1 6C    2 176 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CE0             2 177 Main_ThreeRow_Increment
6CE0 34          2 178 inc     (hl)                        ; increment three-in-a-row counter
6CE1             2 179 Main_ThreeRow_Show
6CE1 CD 01 79    2 180 call    Screen_ThreeRow             ; show three-in-a-row marks
6CE4 3E FF       2 181 ld      a, 255                      ; set delay duration
6CE6 CD 95 6D    2 182 call    Main_Delay                  ; execute delay
6CE9 3A 11 62    2 183 ld      a, (THREE_ROW)              ; check three row counter
6CEC FE 03       2 184 cp      3                           ; is it 3?
6CEE CA 2B 6C    2 185 jp      z, Main_New_Level           ; yes, start a new level
6CF1 C3 43 6C    2 186 jp      Main_Start_Match            ; start a new match
6CF4             2 188 ; ----------------------------------------------------------------------------------------------------------------------
6CF4             2 189 ; Main_GetSpeccy_Move: get the speccy move
6CF4             2 190 ;
6CF4             2 191 ; Input:    -
6CF4             2 192 ;
6CF4             2 193 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CF4             2 194 ;           HL = CYAN_POSITIONS move address
6CF4             2 195 ;
6CF4             2 196 ; Uses:     MOVE_NUMBER (current move number)
6CF4             2 197 ;           GAME_LEVEL (current game level)
6CF4             2 198 ;           AI_DEPTH (recursion depth level)
6CF4             2 199 ;           STR_MOVE (formatted move string)
6CF4             2 200 ;
6CF4             2 201 ; Destroys: A, DE, IX, IY
6CF4             2 202 ; ----------------------------------------------------------------------------------------------------------------------
6CF4             2 203 Main_GetSpeccy_Move:
6CF4 CD 61 6F    2 204 call    Print_Wait                  ; print "WAIT" message
6CF7 3A 9B 61    2 205 ld      a, (MOVE_NUMBER)            ; get move number
6CFA 3D          2 206 dec     a                           ; is it cyan first move?
6CFB 28 2A       2 207 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CFD DD 21 00 7F 2 209 ld      ix, CANDIDATES              ; IX points to candidates list address
6D01 3A 9D 61    2 210 ld      a, (GAME_LEVEL)             ; get game level
6D04 32 9A 61    2 211 ld      (AI_DEPTH), a               ; save recursion depth level
6D07 CD 13 71    2 212 call    PathFinder_Friend           ; get speccy side
6D0A CD B4 6F    2 213 call    BRAINIAC_best_move          ; get speccy best move
6D0D 6B          2 214 ld      l, e                        ; set node index in L
6D0E             2 215 Main_GetSpeccy_Positions
6D0E 26 7D       2 216 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D10 E5          2 217 push    hl                          ; store CYAN_POSITIONS move address
6D11 CD 84 6D    2 218 call    Main_Board2Indexes          ; convert board position to indexes
6D14 78          2 219 ld      a, b                        ; get 1..7 column
6D15 C6 60       2 220 add     a, $60                      ; adjust to charset ('a'..'g')
6D17 32 18 62    2 221 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D1A 79          2 222 ld      a, c                        ; get 1..7 row
6D1B C6 30       2 223 add     a, $30                      ; adjust to charset ('1'..'7')
6D1D 32 1B 62    2 224 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D20 C5          2 225 push    bc                          ; store hexagon board indexes
6D21 CD 6F 6F    2 226 call    Print_Move                  ; print Speccy move
6D24 C1          2 227 pop     bc                          ; restore hexagon board indexes
6D25 E1          2 228 pop     hl                          ; restore CYAN_POSITIONS move address
6D26 C9          2 229 ret
6D27             2 230 Main_GetSpeccy_Book
6D27 ED 5F       2 231 ld      a, r                        ; get a pseudo-random number (0..127)
6D29 E6 1F       2 232 and     %00011111                   ; number is in range (0..31)
6D2B FE 1B       2 233 cp      27                          ; is it >= 27?
6D2D 30 F8       2 234 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D2F 21 D0 62    2 235 ld      hl, OPENINGS                ; HL points to opening book address
6D32 16 00       2 236 ld      d, 0                        ; set index in DE
6D34 5F          2 237 ld      e, a
6D35 19          2 238 add     hl, de                      ; HL points to move index address
6D36 6E          2 239 ld      l, (hl)                     ; get move from opening book
6D37 18 D5       2 240 jr      Main_GetSpeccy_Positions    ; get speccy move positions
6D39             2 242 ; ----------------------------------------------------------------------------------------------------------------------
6D39             2 243 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D39             2 244 ;
6D39             2 245 ; Input:    -
6D39             2 246 ;
6D39             2 247 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D39             2 248 ;           HL = CYAN_POSITIONS move address
6D39             2 249 ;
6D39             2 250 ; Uses:     STR_MOVE (formatted move string)
6D39             2 251 ;
6D39             2 252 ; Destroys: A, DE, IX
6D39             2 253 ; ----------------------------------------------------------------------------------------------------------------------
6D39             2 254 Main_GetPlayer_Move:
6D39 CD 68 6F    2 255 call    Print_Clear_Move            ; clear player last move
6D3C CD 40 6E    2 256 call    Input_Move                  ; wait for input player move
6D3F 7E          2 257 ld      a, (hl)                     ; get column ('a'..'g') from move
6D40 32 18 62    2 258 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D43 D6 60       2 259 sub     $60                         ; convert to number (1..7)
6D45 47          2 260 ld      b, a                        ; set column index in B
6D46 23          2 261 inc     hl                          ; HL points to move-row address
6D47 7E          2 262 ld      a, (hl)                     ; get row ('1'..'7')
6D48 32 1B 62    2 263 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D4B D6 30       2 264 sub     $30                         ; convert to number (1..7)
6D4D 4F          2 265 ld      c, a                        ; set row index in C
6D4E C5          2 266 push    bc                          ; store board indexes
6D4F CD 6F 6F    2 267 call    Print_Move                  ; print player move
6D52 C1          2 268 pop     bc                          ; restore board indexes
6D53 11 50 62    2 269 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D56 CD 77 6D    2 270 call    Main_Search_Table           ; search board position in board coordinates
6D59 6E          2 271 ld      l, (hl)                     ; set board position of player move
6D5A 26 7D       2 272 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D5C 3E 00       2 273 ld      a, EMPTY                    ; check position
6D5E BE          2 274 cp      (hl)                        ; is position empty?
6D5F C8          2 275 ret     z                           ; yes, return
6D60             2 277 ; illegal player move (position not empty)
6D60 11 31 62    2 279 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D63 CD 48 6F    2 280 call    Print_Alert                 ; print string
6D66 DD 21 F7 64 2 281 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D6A CD E3 76    2 282 call    Sound_FX                    ; play sound fx
6D6D 3E 50       2 283 ld      a, 80                       ; set delay counter
6D6F CD 95 6D    2 284 call    Main_Delay                  ; execute delay
6D72 CD 41 6F    2 285 call    Print_Clear_Alert           ; clear alert message
6D75 18 C2       2 286 jr      Main_GetPlayer_Move         ; repeat player process until move is legal
6D77             2 288 ; ----------------------------------------------------------------------------------------------------------------------
6D77             2 289 ; Main_Search_Table: search an element in a 8x8 bytes table
6D77             2 290 ;
6D77             2 291 ; Input:    BC = element indexes (B = column, C = row)
6D77             2 292 ;           DE = table address in which to search for the element
6D77             2 293 ;
6D77             2 294 ; Output:   DE = address of first element in the C row of the table
6D77             2 295 ;           HL = address of the element in the BC indexes of the table
6D77             2 296 ;
6D77             2 297 ; Destroys: -
6D77             2 298 ; ----------------------------------------------------------------------------------------------------------------------
6D77             2 299 Main_Search_Table:
6D77 26 00       2 300 ld      h, 0                        ; first, get the C row in table
6D79 69          2 301 ld      l, c                        ; set index in HL
6D7A 29          2 302 add     hl, hl                      ; a row is 8 bytes long
6D7B 29          2 303 add     hl, hl
6D7C 29          2 304 add     hl, hl
6D7D 19          2 305 add     hl, de                      ; HL points to the address of C row 
6D7E EB          2 306 ex      de, hl                      ; DE points to the address of C row
6D7F 26 00       2 307 ld      h, 0                        ; go for to the B column
6D81 68          2 308 ld      l, b                        ; set index in HL
6D82 19          2 309 add     hl, de                      ; HL points to the address of BC indexes
6D83 C9          2 310 ret
6D84             2 312 ; ----------------------------------------------------------------------------------------------------------------------
6D84             2 313 ; Main_Board2Indexes: convert a board position into a board indexes
6D84             2 314 ;
6D84             2 315 ; Input:    L  = board position
6D84             2 316 ;
6D84             2 317 ; Output:   BC = board indexes (B = column, C = row)
6D84             2 318 ;
6D84             2 319 ; Destroys: HL
6D84             2 320 ; ----------------------------------------------------------------------------------------------------------------------
6D84             2 321 Main_Board2Indexes:
6D84 7D          2 322 ld      a, l                        ; set board position in A to compare later
6D85 21 90 62    2 324 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D88 0E 07       2 325 ld      c, 7                        ; 7 rows
6D8A             2 326 Board2Indexes_Row
6D8A 06 07       2 327 ld      b, 7                        ; 7 columns
6D8C             2 328 Board2Indexes_Col
6D8C 2B          2 329 dec     hl                          ; move HL to next board position address
6D8D BE          2 330 cp      (hl)                        ; is A the position?
6D8E C8          2 331 ret     z                           ; yes, return board indexes
6D8F 10 FB       2 332 djnz    Board2Indexes_Col           ; repeat for each column
6D91 2B          2 333 dec     hl                          ; skip borders
6D92 0D          2 334 dec     c                           ; decrement row
6D93 18 F5       2 335 jr      Board2Indexes_Row           ; loop until find position
6D95             2 337 ; ----------------------------------------------------------------------------------------------------------------------
6D95             2 338 ; Main_Delay: execute a delay
6D95             2 339 ;
6D95             2 340 ; Input:    A = delay counter
6D95             2 341 ;
6D95             2 342 ; Output:   -
6D95             2 343 ;
6D95             2 344 ; Destroys: A
6D95             2 345 ; ----------------------------------------------------------------------------------------------------------------------
6D95             2 346 Main_Delay:
6D95 C5          2 347 push    bc                          ; store register
6D96             2 348 Main_Delay_Loop
6D96 0E 0A       2 349 ld      c, 10                       ; set outer loop counter
6D98             2 350 Main_Delay_Loop1
6D98 06 00       2 351 ld      b, 0                        ; set inner loop counter (256)
6D9A             2 352 Main_Delay_Loop2
6D9A 10 FE       2 353 djnz    Main_Delay_Loop2            ; repeat until B=0
6D9C 0D          2 354 dec     c                           ; decrement outer loop counter
6D9D 20 F9       2 355 jr      nz, Main_Delay_Loop1        ; repeat until C=0
6D9F 3D          2 356 dec     a                           ; decrement delay counter
6DA0 20 F4       2 357 jr      nz, Main_Delay_Loop         ; repeat until A=0
6DA2 C1          2 358 pop     bc                          ; restore register
6DA3 C9          2 359 ret

; File #3: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Draw.z80asm

6DA4             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6DA4             3 2 ; Draw.z80asm
6DA4             3 3 ; Coded by Antonio Luque
6DA4             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6DA4             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6DA4             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6DA4             3 8 ;
6DA4             3 9 ; Input:    -
6DA4             3 10 ;
6DA4             3 11 ; Output:   -
6DA4             3 12 ;
6DA4             3 13 ; Uses:     TOKEN_COLOR (current token color)
6DA4             3 14 ;
6DA4             3 15 ; Destroys: A, BC, DE, HL, IXL
6DA4             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6DA4             3 17 Draw_Board:
6DA4 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6DA6 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6DA9 0E 07       3 20 ld      c, 7                        ; 7 rows
6DAB             3 21 Draw_Board_Row
6DAB 06 07       3 22 ld      b, 7                        ; 7 columns
6DAD             3 23 Draw_Board_Column
6DAD CD EC 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DB0 CD 24 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DB3 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DB6 CD F6 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DB9 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DBB 0D          3 29 dec     c                           ; decrement row
6DBC 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DBE C9          3 31 ret
6DBF             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DBF             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DBF             3 35 ;
6DBF             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DBF             3 37 ;
6DBF             3 38 ; Output:   -
6DBF             3 39 ;
6DBF             3 40 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
6DBF             3 41 ;
6DBF             3 42 ; Destroys: A, BC, DE, HL, IX
6DBF             3 43 ; ----------------------------------------------------------------------------------------------------------------------
6DBF             3 44 Draw_Token:
6DBF 21 EB 62    3 45 ld      hl, TIMER_FLAG              ; HL points to timer flag address
6DC2 7E          3 46 ld      a, (hl)                     ; save current status
6DC3 36 00       3 47 ld      (hl), 0                     ; stop timer
6DC5 F5          3 48 push    af                          ; store previous timer status
6DC6 CD EC 6D    3 49 call    Draw_GetHex_Screen          ; get hexagon screen address
6DC9 01 04 06    3 50 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DCC 11 9E 65    3 51 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DCF             3 52 Draw_Token_Loop
6DCF E5          3 53 push    hl                          ; store hexagon screen address
6DD0 CD F6 6D    3 54 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DD3 E1          3 55 pop     hl                          ; restore hexagon screen address
6DD4 78          3 56 ld      a, b                        ; check loop counter
6DD5 B9          3 57 cp      c                           ; is it 4?
6DD6 CC 24 6E    3 58 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DD9             3 59 Draw_Token_Delay
6DD9 3E 00       3 60 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DDB CD 95 6D    3 61 call    Main_Delay                  ; execute delay
6DDE 10 EF       3 62 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DE0 DD 21 E7 64 3 63 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6DE4 CD E3 76    3 64 call    Sound_FX                    ; play sound effect
6DE7 F1          3 65 pop     af                          ; restore previous timer status
6DE8 32 EB 62    3 66 ld      (TIMER_FLAG), a             ; restart timer
6DEB C9          3 67 ret
6DEC             3 69 ; ----------------------------------------------------------------------------------------------------------------------
6DEC             3 70 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DEC             3 71 ;
6DEC             3 72 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DEC             3 73 ;
6DEC             3 74 ; Output:   HL = hexagon screen address 
6DEC             3 75 ;
6DEC             3 76 ; Destroys: A, DE
6DEC             3 77 ; ----------------------------------------------------------------------------------------------------------------------
6DEC             3 78 Draw_GetHEX_Screen:
6DEC 11 98 61    3 79 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DEF CD 77 6D    3 80 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DF2 6E          3 81 ld      l, (hl)                     ; set the low byte of the screen address in L
6DF3 1A          3 82 ld      a, (de)                     ; set the high byte of the screen address in H
6DF4 67          3 83 ld      h, a
6DF5 C9          3 84 ret
6DF6             3 86 ; ----------------------------------------------------------------------------------------------------------------------
6DF6             3 87 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DF6             3 88 ;
6DF6             3 89 ; Input:    DE = hexagon sprite address
6DF6             3 90 ;           HL = hexagon screen address
6DF6             3 91 ;
6DF6             3 92 ; Output:   DE = next hexagon sprite address
6DF6             3 93 ;
6DF6             3 94 ; Destroys: A, HL, IXL
6DF6             3 95 ; ----------------------------------------------------------------------------------------------------------------------
6DF6             3 96 Draw_Sprite_Hexagon:
6DF6 DD 2E 10    3 97 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DF9             3 98 Draw_Sprite_HeXLoop
6DF9 1A          3 99 ld      a, (de)                     ; get sprite byte
6DFA 77          3 100 ld      (hl), a                     ; put sprite byte on screen
6DFB 13          3 101 inc     de                          ; move DE to next sprite byte address
6DFC 2C          3 102 inc     l                           ; move HL to next screen column
6DFD 1A          3 103 ld      a, (de)                     ; get sprite byte
6DFE 77          3 104 ld      (hl), a                     ; put sprite byte on screen
6DFF 13          3 105 inc     de                          ; move DE to next sprite byte
6E00 2D          3 106 dec     l                           ; move HL to previous screen column
6E01 CD 15 6E    3 107 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6E04 DD 2D       3 108 dec     ixl                         ; decrement sprite height
6E06 20 F1       3 109 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6E08 C9          3 110 ret
6E09             3 112 ; ----------------------------------------------------------------------------------------------------------------------
6E09             3 113 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6E09             3 114 ;
6E09             3 115 ; Input:    DE = letter/number sprite address
6E09             3 116 ;           HL = letter/number screen address
6E09             3 117 ;
6E09             3 118 ; Output:   DE = next letter/number sprite address
6E09             3 119 ;
6E09             3 120 ; Destroys: A, C, HL
6E09             3 121 ; ----------------------------------------------------------------------------------------------------------------------
6E09             3 122 Draw_Sprite_LetterNum:
6E09 0E 0A       3 123 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6E0B             3 124 Draw_Sprite_Loop
6E0B 1A          3 125 ld      a, (de)                     ; get sprite byte
6E0C 77          3 126 ld      (hl), a                     ; put sprite byte on screen
6E0D 13          3 127 inc     de                          ; move DE to next sprite byte address
6E0E CD 15 6E    3 128 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6E11 0D          3 129 dec     c                           ; decrement sprite height
6E12 20 F7       3 130 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6E14 C9          3 131 ret
6E15             3 133 ; ----------------------------------------------------------------------------------------------------------------------
6E15             3 134 ; Draw_Down_PixelLine: move HL down one pixel-line
6E15             3 135 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6E15             3 136 ;
6E15             3 137 ; The screen address of a pixel-line is encoded as follows:
6E15             3 138 ;
6E15             3 139 ;             H           |           L
6E15             3 140 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E15             3 141 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E15             3 142 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E15             3 143 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6E15             3 144 ;
6E15             3 145 ; where:
6E15             3 146 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E15             3 147 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E15             3 148 ;
6E15             3 149 ; Input:    HL = pixel-line address
6E15             3 150 ;
6E15             3 151 ; Output:   HL = next (down) pixel-line address
6E15             3 152 ;
6E15             3 153 ; Destroys: A
6E15             3 154 ; ----------------------------------------------------------------------------------------------------------------------
6E15             3 155 Draw_Down_PixelLine:
6E15 24          3 156 inc     h                           ; move HL down one pixel-line
6E16 7C          3 157 ld      a, h                        ; get high byte of pixel-line address
6E17 E6 07       3 158 and     %00000111                   ; is pixel-line address inside a character line?
6E19 C0          3 159 ret     nz                          ; yes, return
6E1A 7D          3 160 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6E1B C6 20       3 161 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E1D 6F          3 162 ld      l, a                        ; move HL down one character line
6E1E D8          3 163 ret     c                           ; a third was crossed? yes, return
6E1F 7C          3 164 ld      a, h                        ; get high byte of pixel-line address
6E20 D6 08       3 165 sub     8                           ; clean up the bit from Y6
6E22 67          3 166 ld      h, a                        ; HL points to next (down) pixel-line address
6E23 C9          3 167 ret
6E24             3 169 ; ----------------------------------------------------------------------------------------------------------------------
6E24             3 170 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E24             3 171 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E24             3 172 ;
6E24             3 173 ; This routine converts a screen address (HL) into an attribute address (IX):
6E24             3 174 ;
6E24             3 175 ;             H           |           L
6E24             3 176 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E24             3 177 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E24             3 178 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E24             3 179 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E24             3 180 ;
6E24             3 181 ;            IXH          |          IXL
6E24             3 182 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E24             3 183 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E24             3 184 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E24             3 185 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E24             3 186 ;
6E24             3 187 ; where:
6E24             3 188 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E24             3 189 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E24             3 190 ;
6E24             3 191 ; Input:    HL = screen address of the hexagon
6E24             3 192 ;
6E24             3 193 ; Output:   IX = attribute address of the hexagon
6E24             3 194 ;
6E24             3 195 ; Uses:     TOKEN_COLOR (current token color)
6E24             3 196 ;
6E24             3 197 ; Destroys: A
6E24             3 198 ; ----------------------------------------------------------------------------------------------------------------------
6E24             3 199 Draw_Hexagon_Color:
6E24 7C          3 200 ld      a, h                        ; get high byte of screen address
6E25 F6 87       3 201 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E27 1F          3 202 rra                                 ; shift Y7-Y6 two positions
6E28 1F          3 203 rra
6E29 CB 3F       3 204 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E2B DD 67       3 205 ld      ixh, a                      ; set high byte of attribute address in IXH
6E2D 7D          3 206 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E2E DD 6F       3 207 ld      ixl, a                      ; set low byte of attribute address in IXL
6E30 3A 9E 61    3 208 ld      a, (TOKEN_COLOR)            ; get current token color
6E33 DD 77 00    3 209 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E36 DD 77 01    3 210 ld      (ix+1), a
6E39 DD 77 20    3 211 ld      (ix+32), a
6E3C DD 77 21    3 212 ld      (ix+33), a
6E3F C9          3 213 ret

; File #4: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Input.z80asm

6E40             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E40             4 2 ; Input.z80asm
6E40             4 3 ; Coded by Antonio Luque
6E40             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E40             4 6 MAX_CHARS               equ     2                           ; maximum of input chars
6E40             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E40             4 9 ; Input_Move: wait for input a move from keyboard
6E40             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E40             4 11 ;
6E40             4 12 ; Input:    -
6E40             4 13 ;
6E40             4 14 ; Output:   HL = player move address (PLAYER_MOVE)
6E40             4 15 ;
6E40             4 16 ; Uses:     CHAR_COUNT (number of current characters in input player move)
6E40             4 17 ;           TOKEN_COLOR (current token color)
6E40             4 18 ;
6E40             4 19 ; Destroys: A, A', BC, DE, IX
6E40             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E40             4 21 Input_Move:
6E40 01 0E 62    4 22 ld      bc, PLAYER_MOVE             ; BC points to player move address
6E43 C5          4 23 push    bc                          ; store pointer to player move address
6E44 AF          4 24 xor     a                           ; A = 0
6E45 32 10 62    4 25 ld      (CHAR_COUNT), a             ; initialize char counter
6E48 DD 21 83 5A 4 27 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E4C 21 83 50    4 28 ld      hl, $5083                   ; HL points to screen address of RED input text
6E4F 3A 9E 61    4 29 ld      a, (TOKEN_COLOR)            ; check current player color
6E52 FE 02       4 30 cp      RED_COLOR                   ; is RED the current token color?
6E54 28 07       4 31 jr      z, Input_Start              ; yes, start input
6E56 DD 21 19 59 4 32 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E5A 21 19 48    4 33 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E5D             4 34 Input_Start
6E5D 3E 5F       4 35 ld      a, '_'                      ; text input cursor
6E5F DD 36 00 C7 4 36 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E63 CD 98 6F    4 37 call    Print_Char                  ; print cursor
6E66             4 38 Input_Loop
6E66 CD F8 6E    4 39 call    Input_Key_Scan              ; scan for a key pressed
6E69 FE 0D       4 40 cp      $0D                         ; is it ENTER?
6E6B 28 78       4 41 jr      z, Input_Exit               ; yes, go to the end of routine
6E6D FE 30       4 42 cp      '0'                         ; is it DELETE?
6E6F 28 45       4 43 jr      z, Input_Delete             ; yes, perform delete char
6E71 08          4 44 ex      af, af'                     ; store ASCII code in A'
6E72 3A 10 62    4 45 ld      a, (CHAR_COUNT)             ; A = number of chars inserted
6E75 FE 02       4 46 cp      MAX_CHARS                   ; chars limit reached?
6E77 28 ED       4 47 jr      z, Input_Loop               ; yes, repeat input loop (do not insert char)
6E79 B7          4 48 or      a                           ; is the first char to be inserted? (A = 0)
6E7A 28 24       4 49 jr      z, Input_First_Letter       ; yes, perform input of 1st char (column)
6E7C FE 01       4 50 cp      1                           ; is the secord char to be inserted? (A = 1)
6E7E 28 2B       4 51 jr      z, Input_First_Number       ; yes, perform input of 2nd char (row)
6E80             4 53 ; ----------------------------------------------------------------------------------------------------------------------
6E80             4 54 ; char is valid: 'a'-'g' (1st char) and '1'-'7' (2nd char)
6E80             4 55 ; ----------------------------------------------------------------------------------------------------------------------
6E80             4 56 Input_Char_OK
6E80 02          4 57 ld      (bc), a                     ; set char in ASCII move
6E81 03          4 58 inc     bc                          ; increment ASCII move position
6E82 DD 36 00 47 4 59 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E86 CD 98 6F    4 60 call    Print_Char                  ; print key pressed
6E89 3A 10 62    4 61 ld      a, (CHAR_COUNT)             ; increment char counter
6E8C 3C          4 62 inc     a
6E8D 32 10 62    4 63 ld      (CHAR_COUNT), a
6E90 2C          4 64 inc     l                           ; increment X position of current input screen location
6E91 DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E93 3D          4 66 dec     a                           ; is the first char?
6E94 20 C7       4 67 jr      nz, Input_Start             ; no, get next char
6E96 3E 2D       4 68 ld      a, '-'                      ; yes, print dash
6E98 CD 98 6F    4 69 call    Print_Char                  ; print dash
6E9B 2C          4 70 inc     l                           ; increment X position of current input screen location
6E9C DD 2C       4 71 inc     ixl                         ; increment X position of current input attr location
6E9E 18 BD       4 72 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6EA0             4 74 ; ----------------------------------------------------------------------------------------------------------------------
6EA0             4 75 ; restrict first char to 'a'-'g'
6EA0             4 76 ; ----------------------------------------------------------------------------------------------------------------------
6EA0             4 77 Input_First_Letter
6EA0 08          4 78 ex      af, af'                     ; restore ASCII code
6EA1 FE 61       4 79 cp      'a'                         ; is it < 'a'?
6EA3 38 C1       4 80 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6EA5 FE 68       4 81 cp      'h'                         ; is it >= 'h'?
6EA7 30 BD       4 82 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6EA9 18 D5       4 83 jr      Input_Char_OK               ; char is valid
6EAB             4 85 ; ----------------------------------------------------------------------------------------------------------------------
6EAB             4 86 ; restrict second char to '1'-'7'
6EAB             4 87 ; ----------------------------------------------------------------------------------------------------------------------
6EAB             4 88 Input_First_Number
6EAB 08          4 89 ex      af, af'                     ; restore ASCII code
6EAC FE 31       4 90 cp      '1'                         ; is it < '1'?
6EAE 38 B6       4 91 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6EB0 FE 38       4 92 cp      '8'                         ; is it >= '8'?
6EB2 30 B2       4 93 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6EB4 18 CA       4 94 jr      Input_Char_OK               ; char is valid
6EB6             4 96 ; ----------------------------------------------------------------------------------------------------------------------
6EB6             4 97 ; erase last char, update input screen location and string pointer
6EB6             4 98 ; ----------------------------------------------------------------------------------------------------------------------
6EB6             4 99 Input_Delete
6EB6 3A 10 62    4 100 ld      a, (CHAR_COUNT)             ; get char counter
6EB9 B7          4 101 or      a                           ; is it 0?
6EBA 28 AA       4 102 jr      z, Input_Loop               ; yes, repeat input loop (no chars to delete)
6EBC FE 02       4 103 cp      2                           ; is it 2?
6EBE 20 02       4 104 jr      nz, Input_Delete_Dash       ; no, delete dash
6EC0 18 0C       4 105 jr      Input_Decrement_Chars       ; continue delete
6EC2             4 106 Input_Delete_Dash
6EC2 3E 20       4 107 ld      a, ' '                      ; empty char
6EC4 DD 36 00 47 4 108 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EC8 CD 98 6F    4 109 call    Print_Char                  ; delete char
6ECB 2D          4 110 dec     l                           ; decrement X position of input screen location
6ECC DD 2D       4 111 dec     ixl                         ; decrement X position of input attr location
6ECE             4 112 Input_Decrement_Chars
6ECE 3A 10 62    4 113 ld      a, (CHAR_COUNT)             ; decrement char counter
6ED1 3D          4 114 dec     a
6ED2 32 10 62    4 115 ld      (CHAR_COUNT), a
6ED5 0B          4 116 dec     bc                          ; decrement ASCII move position
6ED6 3E 20       4 117 ld      a, ' '                      ; empty char
6ED8 DD 36 00 47 4 118 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EDC CD 98 6F    4 119 call    Print_Char                  ; delete cursor and last char
6EDF 2D          4 120 dec     l                           ; decrement X position of player input screen location
6EE0 DD 2D       4 121 dec     ixl                         ; decrement X position of player input attr location
6EE2 C3 5D 6E    4 122 jp      Input_Start                 ; get next char
6EE5             4 124 ; ----------------------------------------------------------------------------------------------------------------------
6EE5             4 125 ; player finished move (ENTER pressed)
6EE5             4 126 ; ----------------------------------------------------------------------------------------------------------------------
6EE5             4 127 Input_Exit
6EE5 3A 10 62    4 128 ld      a, (CHAR_COUNT)             ; check char counter  
6EE8 FE 02       4 129 cp      2                           ; is it < 2?
6EEA DA 66 6E    4 130 jp      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EED 3E 20       4 131 ld      a, ' '                      ; empty char
6EEF DD 36 00 47 4 132 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EF3 CD 98 6F    4 133 call    Print_Char                  ; delete cursor
6EF6 E1          4 134 pop     hl                          ; restore pointer to player move address
6EF7 C9          4 135 ret
6EF8             4 137 ; ----------------------------------------------------------------------------------------------------------------------
6EF8             4 138 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EF8             4 139 ;
6EF8             4 140 ;                           Bit
6EF8             4 141 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EF8             4 142 ;  ------+-------+-------+-------+-------+-------+
6EF8             4 143 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EF8             4 144 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EF8             4 145 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EF8             4 146 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EF8             4 147 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EF8             4 148 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EF8             4 149 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EF8             4 150 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EF8             4 151 ;
6EF8             4 152 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EF8             4 153 ;
6EF8             4 154 ; Input:    -
6EF8             4 155 ;
6EF8             4 156 ; Output:   A = ASCII code of key pressed
6EF8             4 157 ;
6EF8             4 158 ; Destroys: DE
6EF8             4 159 ; ----------------------------------------------------------------------------------------------------------------------
6EF8             4 160 Input_Key_Scan:
6EF8 C5          4 161 push    bc                          ; store registers
6EF9 E5          4 162 push    hl
6EFA             4 163 Input_Key_Released
6EFA 01 FE FE    4 164 ld      bc, $FEFE                   ; set keyboard port (see above)
6EFD             4 165 Input_Key_Released_Line
6EFD ED 78       4 166 in      a, (c)                      ; read port
6EFF 2F          4 167 cpl                                 ; invert bits
6F00 E6 1F       4 168 and     %00011111                   ; check 0 to 4 bits
6F02 20 F6       4 169 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6F04 CB 00       4 170 rlc     b                           ; move BC to the next port
6F06 38 F5       4 171 jr      c, Input_Key_Released_Line  ; repeat for each port
6F08 11 05 00    4 172 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6F0B             4 173 Input_Key_Pressed_Begin
6F0B 21 D8 61    4 174 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6F0E             4 175 Input_Key_Pressed_Line
6F0E ED 78       4 176 in      a, (c)                      ; read port
6F10 2F          4 177 cpl                                 ; invert bits
6F11 E6 1F       4 178 and     %00011111                   ; check 0 to 4 bits
6F13 20 08       4 179 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6F15 19          4 180 add     hl, de                      ; HL points to the next KEY_MAP block
6F16 CB 00       4 181 rlc     b                           ; move BC to the next port
6F18 38 F4       4 182 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6F1A 18 EF       4 183 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6F1C             4 184 Input_Key_Next
6F1C 23          4 185 inc     hl                          ; move HL to the next character
6F1D             4 186 Input_Key_Pressed
6F1D 1F          4 187 rra                                 ; rotate bits of port readed
6F1E 30 FC       4 188 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6F20 7E          4 189 ld      a, (hl)                     ; return key pressed (ASCII) in A
6F21 E1          4 190 pop     hl                          ; restore registers
6F22 C1          4 191 pop     bc
6F23 C9          4 192 ret

; File #5: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Print.z80asm

6F24             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6F24             5 2 ; Print.z80asm
6F24             5 3 ; Coded by Antonio Luque
6F24             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6F24             5 6 CHAR_SET                equ     FONT-256                    ; address of character set data, adjusted for ASCII codes
6F24             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6F24             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6F24             5 10 ;
6F24             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6F24             5 12 ;
6F24             5 13 ; Output:   -
6F24             5 14 ;
6F24             5 15 ; Destroys: A, BC, DE, HL
6F24             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6F24             5 17 Print_Players:
6F24 11 24 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6F27 01 1D 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6F2A 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6F2D FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6F2F 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6F31 11 1D 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6F34 01 24 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6F37             5 25 Print_Players_Strings
6F37 CD 8C 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6F3A 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F3B 59          5 28 ld      e, c
6F3C 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F3F 18 4B       5 30 jr      Print_String                ; print "Player" or "Speccy"
6F41             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F41             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F41             5 34 ;
6F41             5 35 ; Input:    -
6F41             5 36 ; Output:   -
6F41             5 37 ; Destroys: A, BC, DE, HL, IX
6F41             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F41             5 39 Print_Clear_Alert:
6F41 11 49 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F44 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F46 18 02       5 42 jr      Print_Alert_XY              ; print (clear) alert string
6F48             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F48             5 45 ; Print_Alert: print an alert message below the current player input move
6F48             5 46 ;
6F48             5 47 ; Input:    DE = alert message string address
6F48             5 48 ;
6F48             5 49 ; Output:   -
6F48             5 50 ;
6F48             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F48             5 52 ;
6F48             5 53 ; Destroys: A, BC, DE, HL, IX
6F48             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F48             5 55 Print_Alert:
6F48 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F4A             5 57 Print_Alert_XY
6F4A DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F4E 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F51 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F54 FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F56 28 31       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F58 DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F5C 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F5F 18 28       5 65 jr      Print_String_Color          ; print alert string with color
6F61             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F61             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F61             5 69 ;
6F61             5 70 ; Input:    -
6F61             5 71 ;
6F61             5 72 ; Output:   -
6F61             5 73 ;
6F61             5 74 ; Destroys: A, BC, DE, HL, IX
6F61             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F61             5 76 Print_Wait:
6F61 11 38 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F64 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F66 18 0C       5 79 jr      Print_Move_XY               ; print wait string
6F68             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F68             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F68             5 83 ;
6F68             5 84 ; Input:    -
6F68             5 85 ;
6F68             5 86 ; Output:   -
6F68             5 87 ;
6F68             5 88 ; Destroys: A, BC, DE, HL, IX
6F68             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F68             5 90 Print_Clear_Move:
6F68 11 44 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F6B 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F6D 18 05       5 93 jr      Print_Move_XY               ; print (clear) move string
6F6F             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F6F             5 96 ; Print_Move: print a formatted move at current player input move location 
6F6F             5 97 ;
6F6F             5 98 ; Input:    -
6F6F             5 99 ;
6F6F             5 100 ; Output:   -
6F6F             5 101 ;
6F6F             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F6F             5 103 ;
6F6F             5 104 ; Destroys: A, BC, DE, HL, IX
6F6F             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F6F             5 106 Print_Move:
6F6F 11 18 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F72 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F74             5 109 Print_Move_XY
6F74 DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F78 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F7B 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F7E FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F80 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F82 DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F86 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F89             5 117 Print_String_Color
6F89 CD 81 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F8C             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F8C             5 120 ; Print_String: print a string on the screen
6F8C             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F8C             5 122 ;
6F8C             5 123 ; Input:    DE = string address (ending with 0)
6F8C             5 124 ;           HL = string screen address
6F8C             5 125 ;
6F8C             5 126 ; Output:   -
6F8C             5 127 ;
6F8C             5 128 ; Destroys: A, DE, HL
6F8C             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F8C             5 130 Print_String:
6F8C 1A          5 131 ld      a, (de)                     ; get string character
6F8D B7          5 132 or      a                           ; is it 0? (end of string)
6F8E C8          5 133 ret     z                           ; yes, return
6F8F D5          5 134 push    de                          ; store pointer to string address
6F90 CD 98 6F    5 135 call    Print_Char                  ; print character
6F93 D1          5 136 pop     de                          ; restore pointer to string address
6F94 13          5 137 inc     de                          ; move DE to next string character
6F95 2C          5 138 inc     l                           ; move HL to next screen column
6F96 18 F4       5 139 jr      Print_String                ; repeat until end of string
6F98             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F98             5 142 ; Print_Char: print a character on the screen
6F98             5 143 ;
6F98             5 144 ; Input:    A  = character to print (ASCII)
6F98             5 145 ;           HL = character screen address
6F98             5 146 ;
6F98             5 147 ; Output:   -
6F98             5 148 ;
6F98             5 149 ; Destroys: A, DE
6F98             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F98             5 151 Print_Char:
6F98 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F9B             5 153 Print_Tile:
6F9B E5          5 154 push    hl                          ; store pointer to character screen address
6F9C 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F9E 6F          5 156 ld      l, a
6F9F 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6FA0 29          5 158 add     hl, hl
6FA1 29          5 159 add     hl, hl
6FA2 19          5 160 add     hl, de                      ; move HL to character/tile address
6FA3 EB          5 161 ex      de, hl                      ; DE points to character/tile address
6FA4 E1          5 162 pop     hl                          ; restore pointer to character screen address
6FA5 C5          5 163 push    bc                          ; store BC register
6FA6 06 08       5 164 ld      b, 8                        ; number of character/tile bytes (loop counter)
6FA8             5 165 Print_Tile_Pixels
6FA8 1A          5 166 ld      a, (de)                     ; get character/tile byte
6FA9 77          5 167 ld      (hl), a                     ; put character/tile byte on screen
6FAA 13          5 168 inc     de                          ; move DE to next character/tile byte
6FAB 24          5 169 inc     h                           ; move HL down one pixel-line
6FAC 10 FA       5 170 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6FAE C1          5 171 pop     bc                          ; restore BC register
6FAF 7C          5 172 ld      a, h                        ; get high byte of character screen address
6FB0 D6 08       5 173 sub     8                           ; subtract number of character/tile bytes
6FB2 67          5 174 ld      h, a                        ; HL points to character screen address
6FB3 C9          5 175 ret

; File #6: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Brainiac.z80asm

6FB4             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6FB4             6 2 ; Brainiac.z80asm
6FB4             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB4             6 4 ;
6FB4             6 5 ; Adapted for Hex game by Einar Saukas
6FB4             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6FB4             6 8 MIN_VALUE               equ     0                           ; alphaBeta pruning minimum value
6FB4             6 9 MAX_VALUE               equ     255                         ; alphaBeta pruning maximum value
6FB4             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6FB4             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6FB4             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6FB4             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6FB4             6 15 ; depth.
6FB4             6 16 ;
6FB4             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB4             6 18 ;
6FB4             6 19 ; Input:    A  = speccy side (FRIEND or ENEMY)
6FB4             6 20 ;           IX = candidates vector address
6FB4             6 21 ;
6FB4             6 22 ; Output:   E  = selected position (speccy move)
6FB4             6 23 ;
6FB4             6 24 ; Uses:     AI_PLAYER (speccy side)
6FB4             6 25 ;           AI_DEPTH (recursion depth level)
6FB4             6 26 ;
6FB4             6 27 ; Destroys: A, BC, D, HL, IX, IY
6FB4             6 28 ; ----------------------------------------------------------------------------------------------------------------------
6FB4             6 29 BRAINIAC_best_move:
6FB4 32 99 61    6 30 ld      (AI_PLAYER), a              ; save speccy side
6FB7 CD A2 74    6 32 call    PathFinder_Score            ; get board score
6FBA CD 4B 75    6 33 call    PathFinder_Candidates       ; get candidates from board potentials
6FBD             6 35 ; BRAINIAC start
6FBD             6 36 AI_First_Candidate
6FBD DD 7E 00    6 37 ld      a, (ix+0)                   ; A is our first candidate
6FC0 5F          6 39 ld      e, a                        ; E = best speccy move (initialization)
6FC1 16 00       6 40 ld      d, MIN_VALUE                ; D = alphaMax
6FC3             6 42 AI_Main_Loop                                                ; for each candidate {
6FC3 D5          6 43 push    de                          ;       store alphaMax and best speccy move
6FC4 26 7D       6 45 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FC6 6F          6 46 ld      l, a
6FC7 E5          6 47 push    hl
6FC8 3A 99 61    6 49 ld      a, (AI_PLAYER)              ;       get speccy side
6FCB CD 1D 71    6 50 call    PathFinder_PutToken         ;       BRAINIAC_play
6FCE 1E FF       6 51 ld      e, MAX_VALUE                ;       E = betaMin
6FD0 CD E8 6F    6 52 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6FD3 E1          6 54 pop     hl                          ;       restore candidate position
6FD4 CD 23 71    6 55 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FD7 D1          6 57 pop     de                          ;       restore alphaMax and best player node
6FD8 BA          6 59 cp      d
6FD9 38 04       6 60 jr      c, AI_Main_Next
6FDB 28 02       6 61 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FDD 57          6 63 ld      d, a                        ;       alphaMax = A
6FDE 5D          6 64 ld      e, l                        ;       best move = E
6FDF             6 66 AI_Main_Next
6FDF DD 2D       6 67 dec     ixl
6FE1 DD 7E 00    6 68 ld      a, (ix+0)                   ;       A is our next candidate
6FE4 B7          6 69 or      a                           ;       repeat until no more candidates
6FE5 20 DC       6 70 jr      nz, AI_Main_Loop            ; }
6FE7 C9          6 71 ret
6FE8             6 73 ; ----------------------------------------------------------------------------------------------------------------------
6FE8             6 74 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FE8             6 75 ; Speccy's score.
6FE8             6 76 ;
6FE8             6 77 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FE8             6 78 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FE8             6 79 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FE8             6 80 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FE8             6 81 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FE8             6 82 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FE8             6 83 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FE8             6 84 ; could be just reproducing the best score from its sibling.
6FE8             6 85 ;
6FE8             6 86 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FE8             6 87 ;
6FE8             6 88 ; Input:    D = alphaMax
6FE8             6 89 ;           E = betaMin
6FE8             6 90 ;
6FE8             6 91 ; Output:   A = "improved" betaMin
6FE8             6 92 ;           D = alphaMax
6FE8             6 93 ;           E = "improved" betaMin
6FE8             6 94 ;
6FE8             6 95 ; Uses:     AI_PLAYER (speccy side)
6FE8             6 96 ;           AI_DEPTH (recursion depth level)
6FE8             6 97 ;
6FE8             6 98 ; Destroys: BC, HL, IX, IY
6FE8             6 99 ; ----------------------------------------------------------------------------------------------------------------------
6FE8             6 100 Alphabeta_Min:
6FE8 D5          6 101 push    de
6FE9             6 103 ; check if last speccy move is a winner one
6FE9 CD A2 74    6 105 call    PathFinder_Score            ; if (speccy won)
6FEC B7          6 106 or      a
6FED 20 07       6 107 jr      nz, Alphabeta_Min_Candidates
6FEF 3A 9A 61    6 108 ld      a, (AI_DEPTH)
6FF2 C6 C0       6 109 add     a, 192                      ;     return 192+depth
6FF4 D1          6 110 pop     de
6FF5 C9          6 111 ret
6FF6             6 113 Alphabeta_Min_Candidates
6FF6 CD 4B 75    6 114 call    PathFinder_Candidates       ; find candidates for next move
6FF9 D1          6 115 pop     de
6FFA DD 7E 00    6 117 ld      a, (ix+0)                   ; A is our first candidate
6FFD 21 9A 61    6 119 ld      hl, AI_DEPTH
7000 35          6 120 dec     (hl)                        ; depth--
7001 28 3B       6 121 jr      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
7003             6 123 Alphabeta_Min_Loop                                          ; for each candidate {
7003 D5          6 124 push    de                          ;       store alphaMax and betaMin
7004 26 7D       6 126 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7006 6F          6 127 ld      l, a
7007 E5          6 128 push    hl
7008 3A 99 61    6 130 ld      a, (AI_PLAYER)              ;       get speccy side
700B EE 7C       6 131 xor     $7C                         ;       switch to player side
700D CD 1D 71    6 132 call    PathFinder_PutToken         ;       BRAINIAC_play
7010 CD 7F 70    6 133 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
7013 E1          6 135 pop     hl                          ;       restore candidate position
7014 CD 23 71    6 136 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7017 D1          6 138 pop     de                          ;       restore alphaMax and betaMin
7018 BB          6 140 cp      e
7019 30 06       6 141 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
701B BA          6 143 cp      d
701C 38 11       6 144 jr      c, Alphabeta_Min_Exit
701E 28 0F       6 145 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
7020 5F          6 147 ld      e, a                        ;       betaMin = A
7021             6 149 Alphabeta_Min_Next
7021 DD 2D       6 150 dec     ixl
7023 DD 7E 00    6 151 ld      a, (ix+0)                   ;       A is our next candidate
7026 B7          6 152 or      a                           ;       repeat until no more candidates
7027 20 DA       6 153 jr      nz, Alphabeta_Min_Loop      ; }
7029 7B          6 155 ld      a, e                        ; return betaMin
702A 21 9A 61    6 157 ld      hl, AI_DEPTH
702D 34          6 158 inc     (hl)                        ; depth++
702E C9          6 159 ret
702F             6 161 Alphabeta_Min_Exit
702F 5F          6 162 ld      e, a                        ; (discard remaining candidates)
7030 AF          6 163 xor     a
7031             6 164 Alphabeta_Min_Skip
7031 DD 2D       6 165 dec     ixl
7033 DD BE 00    6 166 cp      (ix+0)
7036 20 F9       6 167 jr      nz, Alphabeta_Min_Skip
7038 7B          6 168 ld      a, e
7039 21 9A 61    6 170 ld      hl, AI_DEPTH
703C 34          6 171 inc     (hl)                        ; (depth++)
703D C9          6 172 ret
703E             6 174 ; ----------------------------------------------------------------------------------------------------------------------
703E             6 175 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
703E             6 176 ; beta pruning, when it requires MINIMIZING Speccy's score.
703E             6 177 ;
703E             6 178 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
703E             6 179 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
703E             6 180 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
703E             6 181 ; faster.
703E             6 182 ;
703E             6 183 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
703E             6 184 ;
703E             6 185 ; Input:    A = first candidate
703E             6 186 ;           D = alphaMax
703E             6 187 ;           E = betaMin
703E             6 188 ;
703E             6 189 ; Output:   A = "improved" betaMin
703E             6 190 ;           D = alphaMax
703E             6 191 ;           E = "improved" betaMin
703E             6 192 ;
703E             6 193 ; Uses:     AI_PLAYER (speccy side)
703E             6 194 ;           AI_DEPTH (recursion depth level)
703E             6 195 ;
703E             6 196 ; Destroys: BC, HL, IX, IY
703E             6 197 ; ----------------------------------------------------------------------------------------------------------------------
703E             6 198 Heuristic_Min:                                              ; for each candidate {
703E D5          6 199 push    de                          ;       store alphaMax and betaMin
703F 26 7D       6 201 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7041 6F          6 202 ld      l, a
7042 E5          6 203 push    hl
7043 3A 99 61    6 205 ld      a, (AI_PLAYER)              ;       get speccy side
7046 EE 7C       6 206 xor     $7C                         ;       switch to player side
7048 CD 1D 71    6 207 call    PathFinder_PutToken         ;       BRAINIAC_play
704B CD A2 74    6 209 call    PathFinder_Score            ;       if (player won)
704E FE FF       6 210 cp      DEFEAT
7050 20 02       6 211 jr      nz, Heuristic_Min_Continue
7052 3E 40       6 212 ld      a, 64                       ;           A = 64
7054             6 213 Heuristic_Min_Continue
7054 E1          6 214 pop     hl
7055 CD 23 71    6 215 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7058 D1          6 217 pop     de
7059 BB          6 219 cp      e
705A 30 06       6 220 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
705C BA          6 222 cp      d
705D 38 11       6 223 jr      c, Heuristic_Min_Exit
705F 28 0F       6 224 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
7061 5F          6 226 ld      e, a                        ;       betaMin = A
7062             6 228 Heuristic_Min_Next
7062 DD 2D       6 229 dec     ixl
7064 DD 7E 00    6 230 ld      a, (ix+0)                   ;       A is our next candidate
7067 B7          6 231 or      a                           ;       repeat until no more candidates
7068 20 D4       6 232 jr      nz, Heuristic_Min           ; }
706A 7B          6 234 ld      a, e                        ; return betaMin
706B 21 9A 61    6 236 ld      hl, AI_DEPTH
706E 34          6 237 inc     (hl)                        ; depth++
706F C9          6 238 ret
7070             6 240 Heuristic_Min_Exit
7070 5F          6 241 ld      e, a                        ; (discard remaining candidates)
7071 AF          6 242 xor     a
7072             6 243 Heuristic_Min_Skip
7072 DD 2D       6 244 dec     ixl
7074 DD BE 00    6 245 cp      (ix+0)
7077 20 F9       6 246 jr      nz, Heuristic_Min_Skip
7079 7B          6 247 ld      a, e
707A 21 9A 61    6 249 ld      hl, AI_DEPTH
707D 34          6 250 inc     (hl)                        ; (depth++)
707E C9          6 251 ret
707F             6 253 ; ----------------------------------------------------------------------------------------------------------------------
707F             6 254 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
707F             6 255 ; Speccy's score.
707F             6 256 ;
707F             6 257 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
707F             6 258 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
707F             6 259 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
707F             6 260 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
707F             6 261 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
707F             6 262 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
707F             6 263 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
707F             6 264 ; the same score and could be just reproducing the best score from its sibling.
707F             6 265 ;
707F             6 266 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
707F             6 267 ;
707F             6 268 ; Input:    D = alphaMax
707F             6 269 ;           E = betaMin
707F             6 270 ;
707F             6 271 ; Output:   A = "improved" alphaMax
707F             6 272 ;           D = "improved" alphaMax
707F             6 273 ;           E = betaMin
707F             6 274 ;
707F             6 275 ; Uses:     AI_PLAYER (speccy side)
707F             6 276 ;           AI_DEPTH (recursion depth level)
707F             6 277 ;
707F             6 278 ; Destroys: BC, HL, IX, IY
707F             6 279 ; ----------------------------------------------------------------------------------------------------------------------
707F             6 280 Alphabeta_Max:
707F D5          6 281 push    de
7080             6 283 ; check if last player move is a winner one
7080 CD A2 74    6 285 call    PathFinder_Score            ; if (player won)
7083 FE FF       6 286 cp      DEFEAT
7085 20 08       6 287 jr      nz, Alphabeta_Max_Candidates
7087 3A 9A 61    6 288 ld      a, (AI_DEPTH)
708A 2F          6 289 cpl
708B C6 41       6 290 add     a, 64+1                     ;     return 64-depth
708D D1          6 291 pop     de
708E C9          6 292 ret
708F             6 294 Alphabeta_Max_Candidates
708F CD 4B 75    6 295 call    PathFinder_Candidates       ; find candidates for next move
7092 D1          6 296 pop     de
7093 DD 7E 00    6 298 ld      a, (ix+0)                   ; A is our first candidate
7096 21 9A 61    6 300 ld      hl, AI_DEPTH
7099 35          6 301 dec     (hl)                        ; depth--
709A 28 39       6 302 jr      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
709C             6 304 Alphabeta_Max_Loop                                          ; for each candidate {
709C D5          6 305 push    de                          ;       store alphaMax and betaMin
709D 26 7D       6 307 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
709F 6F          6 308 ld      l, a
70A0 E5          6 309 push    hl
70A1 3A 99 61    6 311 ld      a, (AI_PLAYER)              ;       get speccy side
70A4 CD 1D 71    6 312 call    PathFinder_PutToken         ;       BRAINIAC_play
70A7 CD E8 6F    6 313 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
70AA E1          6 315 pop     hl                          ;       restore candidate position
70AB CD 23 71    6 316 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70AE D1          6 318 pop     de                          ;       restore alphaMax and betaMin
70AF BA          6 320 cp      d
70B0 38 06       6 321 jr      c, Alphabeta_Max_Next
70B2 28 04       6 322 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
70B4 BB          6 324 cp      e
70B5 30 0F       6 325 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70B7 57          6 327 ld      d, a                        ;       alphaMax = A
70B8             6 329 Alphabeta_Max_Next
70B8 DD 2D       6 330 dec     ixl
70BA DD 7E 00    6 331 ld      a, (ix+0)                   ;       A is our next candidate
70BD B7          6 332 or      a                           ;       repeat until no more candidates
70BE 20 DC       6 333 jr      nz, Alphabeta_Max_Loop      ; }
70C0 7A          6 335 ld      a, d                        ; return alphaMax
70C1 21 9A 61    6 337 ld      hl, AI_DEPTH
70C4 34          6 338 inc     (hl)                        ; depth++
70C5 C9          6 339 ret
70C6             6 341 Alphabeta_Max_Exit
70C6 57          6 342 ld      d, a                        ; (discard remaining candidates)
70C7 AF          6 343 xor     a
70C8             6 344 Alphabeta_Max_Skip
70C8 DD 2D       6 345 dec     ixl
70CA DD BE 00    6 346 cp      (ix+0)
70CD 20 F9       6 347 jr      nz, Alphabeta_Max_Skip
70CF 7A          6 348 ld      a, d
70D0 21 9A 61    6 350 ld      hl, AI_DEPTH
70D3 34          6 351 inc     (hl)                        ; (depth++)
70D4 C9          6 352 ret
70D5             6 354 ; ----------------------------------------------------------------------------------------------------------------------
70D5             6 355 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70D5             6 356 ; beta pruning, when it requires MAXIMIZING Speccy's score.
70D5             6 357 ;
70D5             6 358 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70D5             6 359 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70D5             6 360 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70D5             6 361 ; faster.
70D5             6 362 ;
70D5             6 363 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70D5             6 364 ;
70D5             6 365 ; Input:    A = first candidate
70D5             6 366 ;           D = alphaMax
70D5             6 367 ;           E = betaMin
70D5             6 368 ;
70D5             6 369 ; Returns:  A = "improved" alphaMax
70D5             6 370 ;           D = "improved" alphaMax
70D5             6 371 ;           E = betaMin
70D5             6 372 ;
70D5             6 373 ; Uses:     AI_PLAYER (speccy side)
70D5             6 374 ;           AI_DEPTH (recursion depth level)
70D5             6 375 ;
70D5             6 376 ; Destroys: BC, HL, IX, IY
70D5             6 377 ; ----------------------------------------------------------------------------------------------------------------------
70D5             6 378 Heuristic_Max:                                              ; for each candidate {
70D5 D5          6 379 push    de                          ;       store alphaMax and betaMin
70D6 26 7D       6 381 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70D8 6F          6 382 ld      l, a
70D9 E5          6 383 push    hl
70DA 3A 99 61    6 385 ld      a, (AI_PLAYER)              ;       get speccy side
70DD CD 1D 71    6 386 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70E0 CD A2 74    6 388 call    PathFinder_Score            ;       if (speccy won)
70E3 B7          6 389 or      a
70E4 20 02       6 390 jr      nz, Heuristic_Max_Continue
70E6 3E C0       6 391 ld      a, 192                      ;           A = 192
70E8             6 392 Heuristic_Max_Continue
70E8 E1          6 393 pop     hl                          ;       restore candidate position
70E9 CD 23 71    6 394 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70EC D1          6 396 pop     de                          ;       restore alphaMax and betaMin
70ED BA          6 398 cp      d
70EE 38 06       6 399 jr      c, Heuristic_Max_Next
70F0 28 04       6 400 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
70F2 BB          6 402 cp      e
70F3 30 0F       6 403 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70F5 57          6 405 ld      d, a                        ;       alphaMax = A
70F6             6 407 Heuristic_Max_Next
70F6 DD 2D       6 408 dec     ixl
70F8 DD 7E 00    6 409 ld      a, (ix+0)                   ;       A is our next candidate
70FB B7          6 410 or      a                           ;       repeat until no more candidates
70FC 20 D7       6 411 jr      nz, Heuristic_Max           ; }
70FE 7A          6 413 ld      a, d                        ; return alphaMax
70FF 21 9A 61    6 415 ld      hl, AI_DEPTH
7102 34          6 416 inc     (hl)                        ; depth++
7103 C9          6 417 ret
7104             6 419 Heuristic_Max_Exit
7104 57          6 420 ld      d, a                        ; (discard remaining candidates)
7105 AF          6 421 xor     a
7106             6 422 Heuristic_Max_Skip
7106 DD 2D       6 423 dec     ixl
7108 DD BE 00    6 424 cp      (ix+0)
710B 20 F9       6 425 jr      nz, Heuristic_Max_Skip
710D 7A          6 426 ld      a, d
710E 21 9A 61    6 428 ld      hl, AI_DEPTH
7111 34          6 429 inc     (hl)                        ; (depth++)
7112 C9          6 430 ret

; File #7: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\PathFinder.z80asm

7113             7 1 ; ----------------------------------------------------------------------------------------------------------------------
7113             7 2 ; PathFinder.z80asm
7113             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
7113             7 4 ;
7113             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
7113             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7113             7 7 ; ----------------------------------------------------------------------------------------------------------------------
7113             7 9 CYAN                    equ     $01                         ; cyan side
7113             7 10 RED                     equ     $02                         ; red side
7113             7 11 WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor
7113             7 12 EMPTY                   equ     $00                         ; empty positions on the board
7113             7 13 SKIPPED                 equ     $01                         ; skipped positions on the board
7113             7 14 FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
7113             7 15 ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
7113             7 16 VICTORY                 equ     $03                         ; internal value if victory
7113             7 17 WINNER                  equ     $00                         ; return value if winner
7113             7 18 DEFEAT                  equ     $FF                         ; return value if defeat
7113             7 20 CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
7113             7 21 RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
7113             7 22 CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates
7113             7 24 ; ----------------------------------------------------------------------------------------------------------------------
7113             7 25 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
7113             7 26 ;
7113             7 27 ; Input:    -
7113             7 28 ;
7113             7 29 ; Output:   A = FRIEND, if current token color is cyan
7113             7 30 ;           A = ENEMY, if current token color is red
7113             7 31 ;
7113             7 32 ; Uses:     TOKEN_COLOR (current token color)
7113             7 33 ;
7113             7 34 ; Destroys: -
7113             7 35 ; ----------------------------------------------------------------------------------------------------------------------
7113             7 36 PathFinder_Friend:
7113 3A 9E 61    7 37 ld      a, (TOKEN_COLOR)            ; get current player color
7116 1F          7 38 rra                                 ; is current player color cyan?
7117 3E 02       7 39 ld      a, FRIEND                   ; set FRIEND in A
7119 D8          7 40 ret     c                           ; yes, return FRIEND 
711A EE 7C       7 41 xor     $7C                         ; no, return ENEMY
711C C9          7 42 ret
711D             7 44 ; ----------------------------------------------------------------------------------------------------------------------
711D             7 45 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
711D             7 46 ;
711D             7 47 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
711D             7 48 ;           HL = CYAN_POSITIONS token address
711D             7 49 ;
711D             7 50 ; Output:   -
711D             7 51 ;
711D             7 52 ; Destroys: -
711D             7 53 ; ----------------------------------------------------------------------------------------------------------------------
711D             7 54 PathFinder_PutToken:
711D 77          7 55 ld      (hl), a                     ; put token at cyan position
711E 24          7 56 inc     h                           ; move HL to red position address
711F EE 7C       7 57 xor     $7C                         ; invert side
7121 77          7 58 ld      (hl), a                     ; put token at red position
7122 C9          7 59 ret
7123             7 61 ; ----------------------------------------------------------------------------------------------------------------------
7123             7 62 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
7123             7 63 ;
7123             7 64 ; Input:    HL = CYAN_POSITIONS token address
7123             7 65 ;
7123             7 66 ; Output:   -
7123             7 67 ;
7123             7 68 ; Destroys: -
7123             7 69 ; ----------------------------------------------------------------------------------------------------------------------
7123             7 70 PathFinder_EraseToken:
7123 36 00       7 71 ld      (hl), EMPTY                 ; erase token at cyan position
7125 24          7 72 inc     h                           ; move HL to red position address
7126 36 00       7 73 ld      (hl), EMPTY                 ; erase token at red position
7128 C9          7 74 ret
7129             7 76 ; ----------------------------------------------------------------------------------------------------------------------
7129             7 77 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
7129             7 78 ;
7129             7 79 ; Input:    DE = cyan or red board address (destiny)
7129             7 80 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
7129             7 81 ;
7129             7 82 ; Output:   -
7129             7 83 ;
7129             7 84 ; Destroys: BC, DE, HL
7129             7 85 ; ----------------------------------------------------------------------------------------------------------------------
7129             7 86 PathFinder_CopyPositions:
7129 01 31 00    7 87 ld      bc, 7*7                     ; number of positions to be copied
712C             7 88 PathFinder_CopyLoop
712C 2C          7 89 inc     l                           ; skip borders on positions
712D 2C          7 90 inc     l
712E 1C          7 91 inc     e                           ; skip borders on board
712F 1C          7 92 inc     e
7130 ED A0       7 93 ldi                                 ; copy a row of 7 positions
7132 ED A0       7 94 ldi
7134 ED A0       7 95 ldi
7136 ED A0       7 96 ldi
7138 ED A0       7 97 ldi
713A ED A0       7 98 ldi
713C ED A0       7 99 ldi
713E EA 2C 71    7 100 jp      pe, PathFinder_CopyLoop     ; repeat for each row
7141 C9          7 101 ret
7142             7 103 ; ----------------------------------------------------------------------------------------------------------------------
7142             7 104 ; PathFinder_Update: update current board position during heuristic function evaluation
7142             7 105 ;
7142             7 106 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
7142             7 107 ; second lowest distance of ps neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
7142             7 108 ; adjacent".
7142             7 109 ;
7142             7 110 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
7142             7 111 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
7142             7 112 ; follows, depending on current content:
7142             7 113 ;
7142             7 114 ; * SKIPPED: 1 + distance of neighbor closest to goal
7142             7 115 ; * FRIEND:  distance of neighbor closest to goal
7142             7 116 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
7142             7 117 ;
7142             7 118 ; Input:    Z  = flag set when (HL) is FRIEND
7142             7 119 ;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
7142             7 120 ;           HL = current position address (on either cyan boards or red boards)
7142             7 121 ;
7142             7 122 ; Output:   -
7142             7 123 ;
7142             7 124 ; Destroys: B, DE
7142             7 125 ; ----------------------------------------------------------------------------------------------------------------------
7142             7 126 PathFinder_Update:
7142 28 12       7 127 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
7144 46          7 128 ld      b, (hl)                     ; check current position
7145 10 1A       7 129 djnz    PathFinder_EMPTY
7147             7 130 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
7147             7 131 PathFinder_Skipped:
7147 71          7 132 ld      (hl), c                     ; save current distance in current position
7148 34          7 133 inc     (hl)                        ; increment distance of current position
7149 CB B6       7 134 res     6, (hl)                     ; reset friendly token flag
714B EB          7 135 ex      de, hl                      ; store current position in DE
714C             7 136 @Queue_Tail
714C 21 00 00    7 137 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
714F 2C          7 138 inc     l                           ; move queue tail down
7150 73          7 139 ld      (hl), e                     ; store position into queue tail
7151 22 4D 71    7 140 ld      (@Queue_Tail+1), hl         ; update queue tail
7154 EB          7 141 ex      de, hl                      ; restore current position
7155 C9          7 142 ret
7156             7 143 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
7156             7 144 PathFinder_Friendly
7156 71          7 145 ld      (hl), c                     ; save current distance in current position
7157 CB F6       7 146 set     6, (hl)                     ; set friendly token flag
7159 45          7 147 ld      b, l                        ; save current position in B
715A D1          7 148 pop     de                          ; preserve RET address
715B E3          7 149 ex      (sp), hl                    ; retrieve queue head
715C 70          7 150 ld      (hl), b                     ; push this position into queue head
715D 2D          7 151 dec     l                           ; move queue head up
715E E3          7 152 ex      (sp), hl                    ; update queue head
715F D5          7 153 push    de                          ; restore RET address
7160 C9          7 154 ret
7161             7 155 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
7161             7 156 PathFinder_EMPTY
7161 CB 71       7 157 bit     6, c                        ; is current distance friendly?
7163 C2 47 71    7 158 jp      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
7166 34          7 159 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
7167 C9          7 160 ret
7168             7 162 ; ----------------------------------------------------------------------------------------------------------------------
7168             7 163 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7168             7 164 ;
7168             7 165 ; Input:    -
7168             7 166 ;
7168             7 167 ; Output:   A = DEFEAT, if down edge couldn't be reached
7168             7 168 ;           A = WINNER, if there is chain of connected cyan tokens between the two edges
7168             7 169 ;           A = X, otherwise
7168             7 170 ;
7168             7 171 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7168             7 172 ;
7168             7 173 ; Destroys: BC, DE, HL, IY
7168             7 174 ; ----------------------------------------------------------------------------------------------------------------------
7168             7 175 PathFinder_Cyan_UpDown:
7168 21 07 7D    7 176 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
716B 11 07 61    7 177 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
716E CD 29 71    7 178 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
7171             7 180 ; entry point for PathFinder_BrightPath
7171             7 181 PathFinder_Cyan_BrightPath:
7171 FD 21 00 09 7 182 ld      iy, $0900                   ; IYH = distance to check edge positions
7175             7 183 ; IYL = initialize return value of 'Path_Finder'
7175 21 00 60    7 184 ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
7178 22 4D 71    7 185 ld      (@Queue_Tail+1), hl         ; initialize cyan queue area
717B E5          7 186 push    hl                          ; store queue tail address
717C             7 188 ; set up cyan board (up-down) start positions distances
717C 21 09 61    7 190 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
717F 0E 43       7 191 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7181 3E 02       7 192 ld      a, FRIEND                   ; set distance to compare with
7183 BE          7 193 cp      (hl)                        ; check 1st start position distance
7184 D4 42 71    7 194 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7187 2C          7 195 inc     l                           ; move HL to next start position address
7188 BE          7 196 cp      (hl)                        ; check 2nd start position distance
7189 D4 42 71    7 197 call    nc, PathFinder_Update       ; (repeat for each start position)
718C 2C          7 198 inc     l
718D BE          7 199 cp      (hl)                        ; check 3rd start position distance
718E D4 42 71    7 200 call    nc, PathFinder_Update
7191 2C          7 201 inc     l
7192 BE          7 202 cp      (hl)                        ; check 4th start position distance
7193 D4 42 71    7 203 call    nc, PathFinder_Update
7196 2C          7 204 inc     l
7197 BE          7 205 cp      (hl)                        ; check 5th start position distance
7198 D4 42 71    7 206 call    nc, PathFinder_Update
719B 2C          7 207 inc     l
719C BE          7 208 cp      (hl)                        ; check 6th start position distance
719D D4 42 71    7 209 call    nc, PathFinder_Update
71A0 2C          7 210 inc     l
71A1 C3 8E 72    7 211 jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)
71A4             7 213 ; ----------------------------------------------------------------------------------------------------------------------
71A4             7 214 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
71A4             7 215 ;
71A4             7 216 ; Input:    -
71A4             7 217 ;
71A4             7 218 ; Output:   A = DEFEAT, if up edge couldn't be reached
71A4             7 219 ;           A = WINNER, if there is chain of connected cyan tokens between the two edges
71A4             7 220 ;           A = X, otherwise
71A4             7 221 ;
71A4             7 222 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71A4             7 223 ;
71A4             7 224 ; Destroys: BC, DE, HL, IY
71A4             7 225 ; ----------------------------------------------------------------------------------------------------------------------
71A4             7 226 PathFinder_Cyan_DownUp:
71A4 21 07 7D    7 227 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
71A7 11 4F 61    7 228 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
71AA CD 29 71    7 229 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
71AD FD 21 00 F7 7 231 ld      iy, $F700                   ; IYH = distance to check edge positions
71B1             7 232 ; IYL = initialize return value of 'Path_Finder'
71B1 2A 4D 71    7 233 ld      hl, (@Queue_Tail+1)         ; initialize cyan queue area
71B4 E5          7 234 push    hl                          ; store Queue Tail
71B5             7 236 ; set up cyan board (down-up) start positions distances
71B5 EB          7 238 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
71B6 2D          7 239 dec     l                           ; move HL to cyan boad down-up address (last position)
71B7 0E 43       7 240 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71B9 3E 02       7 241 ld      a, FRIEND                   ; set distance to compare with
71BB BE          7 242 cp      (hl)                        ; check 1st start position distance
71BC D4 42 71    7 243 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71BF 2D          7 244 dec     l                           ; move HL to next start position address
71C0 BE          7 245 cp      (hl)                        ; check 2nd start position distance
71C1 D4 42 71    7 246 call    nc, PathFinder_Update       ; (repeat for each start position)
71C4 2D          7 247 dec     l
71C5 BE          7 248 cp      (hl)                        ; check 3rd start position distance
71C6 D4 42 71    7 249 call    nc, PathFinder_Update
71C9 2D          7 250 dec     l
71CA BE          7 251 cp      (hl)                        ; check 4th start position distance
71CB D4 42 71    7 252 call    nc, PathFinder_Update
71CE 2D          7 253 dec     l
71CF BE          7 254 cp      (hl)                        ; check 5th start position distance
71D0 D4 42 71    7 255 call    nc, PathFinder_Update
71D3 2D          7 256 dec     l
71D4 BE          7 257 cp      (hl)                        ; check 6th start position distance
71D5 D4 42 71    7 258 call    nc, PathFinder_Update
71D8 2D          7 259 dec     l
71D9 C3 8E 72    7 260 jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)
71DC             7 262 ; ----------------------------------------------------------------------------------------------------------------------
71DC             7 263 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71DC             7 264 ;
71DC             7 265 ; Input:    -
71DC             7 266 ;
71DC             7 267 ; Output:   A = DEFEAT, if right edge couldn't be reached
71DC             7 268 ;           A = WINNER, if there is chain of connected cyan tokens between the two edges
71DC             7 269 ;           A = X, otherwise
71DC             7 270 ;
71DC             7 271 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71DC             7 272 ;
71DC             7 273 ; Destroys: BC, DE, HL, IY
71DC             7 274 ; ----------------------------------------------------------------------------------------------------------------------
71DC             7 275 PathFinder_Red_LeftRight:
71DC 21 07 7E    7 276 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71DF 11 07 64    7 277 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71E2 CD 29 71    7 278 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71E5             7 280 ; entry point for PathFinder_BrightPath
71E5             7 281 PathFinder_Red_BrightPath
71E5 FD 21 00 01 7 282 ld      iy, $0100                   ; IYH = distance to check edge positions
71E9             7 283 ; IYL = initialize return value of 'Path_Finder'
71E9 21 00 63    7 284 ld      hl, RED_QUEUE_AREA          ; initialize red queue area
71EC 22 4D 71    7 285 ld      (@Queue_Tail+1), hl
71EF E5          7 286 push    hl                          ; store Queue Tail
71F0             7 288 ; set up red board (left-right) start positions distances
71F0 21 09 64    7 290 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
71F3 0E 43       7 291 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71F5 3E 02       7 292 ld      a, FRIEND                   ; set distance to compare with
71F7 BE          7 293 cp      (hl)                        ; check 1st start position distance
71F8 D4 42 71    7 294 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71FB 2E 12       7 295 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256 ; move HL to next start position address
71FD BE          7 296 cp      (hl)                        ; check 2nd start position distance
71FE D4 42 71    7 297 call    nc, PathFinder_Update       ; (repeat for each start position)
7201 2E 1B       7 298 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
7203 BE          7 299 cp      (hl)                        ; check 3rd start position distance
7204 D4 42 71    7 300 call    nc, PathFinder_Update
7207 2E 24       7 301 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
7209 BE          7 302 cp      (hl)                        ; check 4th start position distance
720A D4 42 71    7 303 call    nc, PathFinder_Update
720D 2E 2D       7 304 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
720F BE          7 305 cp      (hl)                        ; check 5th start position distance
7210 D4 42 71    7 306 call    nc, PathFinder_Update
7213 2E 36       7 307 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
7215 BE          7 308 cp      (hl)                        ; check 6th start position distance
7216 D4 42 71    7 309 call    nc, PathFinder_Update
7219 2E 3F       7 310 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
721B C3 8E 72    7 311 jp      Path_Finder_First           ; calculate two-distances of red board (left-right)
721E             7 313 ; ----------------------------------------------------------------------------------------------------------------------
721E             7 314 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
721E             7 315 ;
721E             7 316 ; Input:    -
721E             7 317 ;
721E             7 318 ; Output:   A = DEFEAT, if left edge couldn't be reached
721E             7 319 ;           A = WINNER, if there is chain of connected cyan tokens between the two edges
721E             7 320 ;           A = X, otherwise
721E             7 321 ;
721E             7 322 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
721E             7 323 ;
721E             7 324 ; Destroys: BC, DE, HL, IY
721E             7 325 ; ----------------------------------------------------------------------------------------------------------------------
721E             7 326 PathFinder_Red_RightLeft:
721E 21 07 7E    7 327 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
7221 11 4F 64    7 328 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
7224 CD 29 71    7 329 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
7227 FD 21 00 FF 7 331 ld      iy, $FF00                   ; IYH = distance to check edge positions
722B             7 332 ; IYL = initialize return value of 'Path_Finder'
722B 2A 4D 71    7 333 ld      hl, (@Queue_Tail+1)         ; initialize red queue area
722E E5          7 334 push    hl                          ; store queue tail
722F             7 336 ; set up red board (right-left) start positions distances
722F EB          7 338 ex      de, hl                      ; take advantage of last "CopyPositions" execution
7230 2D          7 339 dec     l                           ; move HL to red board right-left address (last position)
7231 0E 43       7 340 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7233 3E 02       7 341 ld      a, FRIEND                   ; set distance to compare with
7235 BE          7 342 cp      (hl)                        ; check 1st start position distance
7236 D4 42 71    7 343 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7239 2E 84       7 344 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256 ; move HL to next start position address
723B BE          7 345 cp      (hl)                        ; check 2nd start position distance
723C D4 42 71    7 346 call    nc, PathFinder_Update       ; (repeat for each start position)
723F 2E 7B       7 347 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
7241 BE          7 348 cp      (hl)                        ; check 3rd start position distance
7242 D4 42 71    7 349 call    nc, PathFinder_Update
7245 2E 72       7 350 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
7247 BE          7 351 cp      (hl)                        ; check 4th start position distance
7248 D4 42 71    7 352 call    nc, PathFinder_Update
724B 2E 69       7 353 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
724D BE          7 354 cp      (hl)                        ; check 5th start position distance
724E D4 42 71    7 355 call    nc, PathFinder_Update
7251 2E 60       7 356 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
7253 BE          7 357 cp      (hl)                        ; check 6th start position distance
7254 D4 42 71    7 358 call    nc, PathFinder_Update
7257 2E 57       7 359 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
7259 C3 8E 72    7 360 jp      Path_Finder_First           ; calculate red two-distance (right-left)
725C             7 362 ; ----------------------------------------------------------------------------------------------------------------------
725C             7 363 ; Path_Finder: calculate two-distance metric for each board position
725C             7 364 ;
725C             7 365 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
725C             7 366 ;
725C             7 367 ; Input:    HL  = cyan or red queue area address
725C             7 368 ;           IYH = distance to check edge positions
725C             7 369 ;           IYL = 0
725C             7 370 ;
725C             7 371 ; Output:   A = DEFEAT, if corresponding edge couldn't be reached
725C             7 372 ;           A = WINNER, if there is chain of connected (color) tokens between the two edges
725C             7 373 ;           A = X, otherwise
725C             7 374 ;
725C             7 375 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
725C             7 376 ;
725C             7 377 ; Destroys: DE, HL, IY
725C             7 378 ; ----------------------------------------------------------------------------------------------------------------------
725C             7 379 Path_Finder:
725C 2C          7 380 inc     l                           ; move queue head down
725D E5          7 381 push    hl                          ; preserve queue head address
725E 6E          7 382 ld      l, (hl)                     ; retrieve next position to be checked
725F 24          7 383 inc     h                           ; move HL to corresponding board address
7260 4E          7 384 ld      c, (hl)                     ; retrieve distance from this position to start
7261 45          7 385 ld      b, l                        ; store current position
7262             7 387 ; look for adjacent positions
7262 7D          7 389 ld      a, l                        ; get current position
7263 FD 84       7 390 add     a, iyh                      ; add distance to check edge positions
7265 6F          7 391 ld      l, a                        ; move HL to calculated position address
7266 CB 7E       7 392 bit     7, (hl)                     ; is it an edge?
7268 20 34       7 393 jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions
726A 3E 02       7 395 ld      a, FRIEND                   ; set distance to compare with
726C             7 396 ; return point from PathFinder_Adjacent
726C             7 397 Path_Finder_Neighbors
726C 68          7 398 ld      l, b                        ; restore current position to be checked
726D 2C          7 399 inc     l                           ; move HL to right neighbor address
726E BE          7 400 cp      (hl)                        ; check right neighbor distance
726F D4 42 71    7 401 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7272 2D          7 402 dec     l                           ; move HL to left neighbor address
7273 2D          7 403 dec     l
7274 BE          7 404 cp      (hl)                        ; check left neighbor distance
7275 D4 42 71    7 405 call    nc, PathFinder_Update       ; (repeat for each neighbor)
7278 11 F8 FF    7 406 ld      de, -WIDTH
727B 19          7 407 add     hl, de
727C BE          7 408 cp      (hl)                        ; check upper-left neighbor distance
727D D4 42 71    7 409 call    nc, PathFinder_Update
7280 2C          7 410 inc     l
7281 BE          7 411 cp      (hl)                        ; check upper-right neighbor distance
7282 D4 42 71    7 412 call    nc, PathFinder_Update
7285 11 10 00    7 413 ld      de, WIDTH*2
7288 19          7 414 add     hl, de
7289 BE          7 415 cp      (hl)                        ; check lower-left neighbor distance
728A D4 42 71    7 416 call    nc, PathFinder_Update
728D 2C          7 417 inc     l
728E             7 418 Path_Finder_First
728E BE          7 419 cp      (hl)                        ; check lower-right neighbor distance
728F D4 42 71    7 420 call    nc, PathFinder_Update
7292 E1          7 421 pop     hl                          ; restore queue tail address
7293 3A 4D 71    7 422 ld      a, (@Queue_Tail+1)          ; check queue
7296 BD          7 423 cp      l                           ; is queue empty?
7297 C2 5C 72    7 424 jp      nz, Path_Finder             ; no, repeat until queue is empty
729A FD 7D       7 426 ld      a, iyl                      ; get last position processed by 'Path_Finder_Adjacent'
729C 3D          7 427 dec     a                           ; return A = DEFEAT, if the edge couldn't be reached
729D C9          7 428 ret
729E             7 430 ; ----------------------------------------------------------------------------------------------------------------------
729E             7 431 ; Check adjacent hexagons.
729E             7 432 ;
729E             7 433 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
729E             7 434 ; "two cells are adjacent if they share a common edge on the board."
729E             7 435 ;
729E             7 436 ; Input:    B  = current position
729E             7 437 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
729E             7 438 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
729E             7 439 ;                edge number)
729E             7 440 ;
729E             7 441 ; Output:   A = WINNER, if there is a chain of connected tokens of the same color between the two edges.
729E             7 442 ;           A = FRIEND, IYL = current position, otherwise.
729E             7 443 ;
729E             7 444 ; Destroys: DE, HL
729E             7 445 ; ----------------------------------------------------------------------------------------------------------------------
729E             7 446 Path_Finder_Adjacent
729E 3E 43       7 447 ld      a, VICTORY+$40              ; set victory distance + friendly flag
72A0 B9          7 448 cp      c                           ; is current distance victory and friendly?
72A1 28 11       7 449 jr      z, Path_Finder_Abort        ; yes, abort path_finder
72A3 7E          7 451 ld      a, (hl)                     ; get current edge position
72A4 E6 07       7 452 and     %00000111                   ; convert to edge number (0..6)
72A6 87          7 453 add     a, a                        ; calculate vector table routine index
72A7 6F          7 454 ld      l, a                        ; set index in L
72A8 24          7 455 inc     h                           ; move HL to (cyan or red) vector table routine address
72A9 5E          7 456 ld      e, (hl)                     ; get low byte of vector table routine address
72AA 2C          7 457 inc     l                           ; move HL to high byte of vector table routine address
72AB 56          7 458 ld      d, (hl)                     ; get high byte of vector table routine address
72AC EB          7 459 ex      de, hl                      ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
72AD 15          7 460 dec     d                           ; move DE to cyan or red board address
72AE 58          7 461 ld      e, b                        ; restore pointer to current position address
72AF FD 68       7 462 ld      iyl, b                      ; store current position
72B1 3E 02       7 463 ld      a, FRIEND                   ; set distance to compare with
72B3 E9          7 464 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
72B4             7 465 Path_Finder_Abort
72B4 E1          7 466 pop     hl                          ; discard queue pointer
72B5 AF          7 467 xor     a                           ; return A = WINNER
72B6 C9          7 468 ret
72B7             7 470 ; ----------------------------------------------------------------------------------------------------------------------
72B7             7 471 ;  Check two-distance of RED adjacents
72B7             7 472 ; ----------------------------------------------------------------------------------------------------------------------
72B7             7 473 PathFinder_RED_Edge_0
72B7 EB          7 474 ex      de, hl                      ; restore pointer to current position address
72B8 11 12 00    7 475 ld      de, 9*2                     ; calculate distance to adjacent #2
72BB 19          7 476 add     hl, de                      ; move HL to adjacent #2 address
72BC BE          7 477 cp      (hl)                        ; check adjacent #2 distance
72BD D4 42 71    7 478 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
72C0 11 09 00    7 479 ld      de, 9                       ; calculate distance to adjacent #3
72C3 19          7 480 add     hl, de                      ; move HL to adjacent #3 address
72C4 BE          7 481 cp      (hl)                        ; check adjacent #3 distance
72C5 D4 42 71    7 482 call    nc, PathFinder_Update       ; (repeat for each adjacent)
72C8 11 09 00    7 483 ld      de, 9
72CB 19          7 484 add     hl, de
72CC BE          7 485 cp      (hl)                        ; check adjacent #4 distance
72CD D4 42 71    7 486 call    nc, PathFinder_Update
72D0 11 09 00    7 487 ld      de, 9
72D3 19          7 488 add     hl, de
72D4 BE          7 489 cp      (hl)                        ; check adjacent #5 distance
72D5 D4 42 71    7 490 call    nc, PathFinder_Update
72D8 11 09 00    7 491 ld      de, 9
72DB 19          7 492 add     hl, de
72DC BE          7 493 cp      (hl)                        ; check adjacent #6 distance
72DD D4 42 71    7 494 call    nc, PathFinder_Update
72E0 FD 45       7 495 ld      b, iyl                      ; restore current position
72E2 C3 6C 72    7 496 jp      Path_Finder_Neighbors       ; continue processing neighbors
72E5             7 498 PathFinder_RED_Edge_1
72E5 EB          7 499 ex      de, hl                      ; restore pointer to current position address
72E6 11 12 00    7 500 ld      de, 9*2
72E9 19          7 501 add     hl, de
72EA BE          7 502 cp      (hl)                        ; check adjacent #3 distance
72EB D4 42 71    7 503 call    nc, PathFinder_Update
72EE 11 09 00    7 504 ld      de, 9
72F1 19          7 505 add     hl, de
72F2 BE          7 506 cp      (hl)                        ; check adjacent #4 distance
72F3 D4 42 71    7 507 call    nc, PathFinder_Update
72F6 11 09 00    7 508 ld      de, 9
72F9 19          7 509 add     hl, de
72FA BE          7 510 cp      (hl)                        ; check adjacent #5 distance
72FB D4 42 71    7 511 call    nc, PathFinder_Update
72FE 11 09 00    7 512 ld      de, 9
7301 19          7 513 add     hl, de
7302 BE          7 514 cp      (hl)                        ; check adjacent #6 distance
7303 D4 42 71    7 515 call    nc, PathFinder_Update
7306 FD 45       7 516 ld      b, iyl                      ; restore current position
7308 C3 6C 72    7 517 jp      Path_Finder_Neighbors       ; continue processing neighbors
730B             7 519 PathFinder_RED_Edge_2
730B EB          7 520 ex      de, hl                      ; restore pointer to current position address
730C 11 12 00    7 521 ld      de, 9*2
730F 19          7 522 add     hl, de
7310 BE          7 523 cp      (hl)                        ; check adjacent #4 distance
7311 D4 42 71    7 524 call    nc, PathFinder_Update
7314 11 09 00    7 525 ld      de, 9
7317 19          7 526 add     hl, de
7318 BE          7 527 cp      (hl)                        ; check adjacent #5 distance
7319 D4 42 71    7 528 call    nc, PathFinder_Update
731C 11 09 00    7 529 ld      de, 9
731F 19          7 530 add     hl, de
7320 BE          7 531 cp      (hl)                        ; check adjacent #6 distance
7321 D4 42 71    7 532 call    nc, PathFinder_Update
7324 11 CA FF    7 533 ld      de, -9*6
7327 19          7 534 add     hl, de
7328 BE          7 535 cp      (hl)                        ; check adjacent #0 distance
7329 D4 42 71    7 536 call    nc, PathFinder_Update
732C FD 45       7 537 ld      b, iyl                      ; restore current position
732E C3 6C 72    7 538 jp      Path_Finder_Neighbors       ; continue processing neighbors
7331             7 540 PathFinder_RED_Edge_3
7331 EB          7 541 ex      de, hl                      ; restore pointer to current position address
7332 11 E5 FF    7 542 ld      de, -9*3
7335 19          7 543 add     hl, de
7336 BE          7 544 cp      (hl)                        ; check adjacent #0 distance
7337 D4 42 71    7 545 call    nc, PathFinder_Update
733A 11 09 00    7 546 ld      de, 9
733D 19          7 547 add     hl, de
733E BE          7 548 cp      (hl)                        ; check adjacent #1 distance
733F D4 42 71    7 549 call    nc, PathFinder_Update
7342 11 24 00    7 550 ld      de, 9*4
7345 19          7 551 add     hl, de
7346 BE          7 552 cp      (hl)                        ; check adjacent #5 distance
7347 D4 42 71    7 553 call    nc, PathFinder_Update
734A 11 09 00    7 554 ld      de, 9
734D 19          7 555 add     hl, de
734E BE          7 556 cp      (hl)                        ; check adjacent #6 distance
734F D4 42 71    7 557 call    nc, PathFinder_Update
7352 FD 45       7 558 ld      b, iyl                      ; restore current position
7354 C3 6C 72    7 559 jp      Path_Finder_Neighbors       ; continue processing neighbors
7357             7 561 PathFinder_RED_Edge_4
7357 EB          7 562 ex      de, hl                      ; restore pointer to current position address
7358 11 12 00    7 563 ld      de, 9*2
735B 19          7 564 add     hl, de
735C BE          7 565 cp      (hl)                        ; check adjacent #6 distance
735D D4 42 71    7 566 call    nc, PathFinder_Update
7360 11 CA FF    7 567 ld      de, -9*6
7363 19          7 568 add     hl, de
7364 BE          7 569 cp      (hl)                        ; check adjacent #0 distance
7365 D4 42 71    7 570 call    nc, PathFinder_Update
7368 11 09 00    7 571 ld      de, 9
736B 19          7 572 add     hl, de
736C BE          7 573 cp      (hl)                        ; check adjacent #1 distance
736D D4 42 71    7 574 call    nc, PathFinder_Update
7370 11 09 00    7 575 ld      de, 9
7373 19          7 576 add     hl, de
7374 BE          7 577 cp      (hl)                        ; check adjacent #2 distance
7375 D4 42 71    7 578 call    nc, PathFinder_Update
7378 FD 45       7 579 ld      b, iyl                      ; restore current position
737A C3 6C 72    7 580 jp      Path_Finder_Neighbors       ; continue processing neighbors
737D             7 582 PathFinder_RED_Edge_5
737D EB          7 583 ex      de, hl                      ; restore pointer to current position address
737E 11 D3 FF    7 584 ld      de, -9*5
7381 19          7 585 add     hl, de
7382 BE          7 586 cp      (hl)                        ; check adjacent #0 distance
7383 D4 42 71    7 587 call    nc, PathFinder_Update
7386 11 09 00    7 588 ld      de, 9
7389 19          7 589 add     hl, de
738A BE          7 590 cp      (hl)                        ; check adjacent #1 distance
738B D4 42 71    7 591 call    nc, PathFinder_Update
738E 11 09 00    7 592 ld      de, 9
7391 19          7 593 add     hl, de
7392 BE          7 594 cp      (hl)                        ; check adjacent #2 distance
7393 D4 42 71    7 595 call    nc, PathFinder_Update
7396 11 09 00    7 596 ld      de, 9
7399 19          7 597 add     hl, de
739A BE          7 598 cp      (hl)                        ; check adjacent #3 distance
739B D4 42 71    7 599 call    nc, PathFinder_Update
739E FD 45       7 600 ld      b, iyl                      ; restore current position
73A0 C3 6C 72    7 601 jp      Path_Finder_Neighbors       ; continue processing neighbors
73A3             7 603 PathFinder_RED_Edge_6
73A3 EB          7 604 ex      de, hl                      ; restore pointer to current position address
73A4 11 CA FF    7 605 ld      de, -9*6
73A7 19          7 606 add     hl, de
73A8 BE          7 607 cp      (hl)                        ; check adjacent #0 distance
73A9 D4 42 71    7 608 call    nc, PathFinder_Update
73AC 11 09 00    7 609 ld      de, 9
73AF 19          7 610 add     hl, de
73B0 BE          7 611 cp      (hl)                        ; check adjacent #1 distance
73B1 D4 42 71    7 612 call    nc, PathFinder_Update
73B4 11 09 00    7 613 ld      de, 9
73B7 19          7 614 add     hl, de
73B8 BE          7 615 cp      (hl)                        ; check adjacent #2 distance
73B9 D4 42 71    7 616 call    nc, PathFinder_Update
73BC 11 09 00    7 617 ld      de, 9
73BF 19          7 618 add     hl, de
73C0 BE          7 619 cp      (hl)                        ; check adjacent #3 distance
73C1 D4 42 71    7 620 call    nc, PathFinder_Update
73C4 11 09 00    7 621 ld      de, 9
73C7 19          7 622 add     hl, de
73C8 BE          7 623 cp      (hl)                        ; check adjacent #4 distance
73C9 D4 42 71    7 624 call    nc, PathFinder_Update
73CC FD 45       7 625 ld      b, iyl                      ; restore current position
73CE C3 6C 72    7 626 jp      Path_Finder_Neighbors       ; continue processing neighbors
73D1             7 628 ; ----------------------------------------------------------------------------------------------------------------------
73D1             7 629 ;  Check two-distance of CYAN adjacents
73D1             7 630 ; ----------------------------------------------------------------------------------------------------------------------
73D1             7 631 PathFinder_CYAN_Edge_0
73D1 EB          7 632 ex      de, hl                      ; restore pointer to current position address
73D2 2C          7 633 inc     l
73D3 2C          7 634 inc     l
73D4 BE          7 635 cp      (hl)                        ; check adjacent #2 distance
73D5 D4 42 71    7 636 call    nc, PathFinder_Update
73D8 2C          7 637 inc     l
73D9 BE          7 638 cp      (hl)                        ; check adjacent #3 distance
73DA D4 42 71    7 639 call    nc, PathFinder_Update
73DD 2C          7 640 inc     l
73DE BE          7 641 cp      (hl)                        ; check adjacent #4 distance
73DF D4 42 71    7 642 call    nc, PathFinder_Update
73E2 2C          7 643 inc     l
73E3 BE          7 644 cp      (hl)                        ; check adjacent of edge number 5
73E4 D4 42 71    7 645 call    nc, PathFinder_Update
73E7 2C          7 646 inc     l
73E8 BE          7 647 cp      (hl)                        ; check adjacent of edge number 6
73E9 D4 42 71    7 648 call    nc, PathFinder_Update
73EC FD 45       7 649 ld      b, iyl                      ; restore current position
73EE C3 6C 72    7 650 jp      Path_Finder_Neighbors       ; continue processing neighbors
73F1             7 652 PathFinder_CYAN_Edge_1
73F1 EB          7 653 ex      de, hl                      ; restore pointer to current position address
73F2 2C          7 654 inc     l
73F3 2C          7 655 inc     l
73F4 BE          7 656 cp      (hl)                        ; check adjacent #3 distance
73F5 D4 42 71    7 657 call    nc, PathFinder_Update
73F8 2C          7 658 inc     l
73F9 BE          7 659 cp      (hl)                        ; check adjacent #4 distance
73FA D4 42 71    7 660 call    nc, PathFinder_Update
73FD 2C          7 661 inc     l
73FE BE          7 662 cp      (hl)                        ; check adjacent #5 distance
73FF D4 42 71    7 663 call    nc, PathFinder_Update
7402 2C          7 664 inc     l
7403 BE          7 665 cp      (hl)                        ; check adjacent #6 distance
7404 D4 42 71    7 666 call    nc, PathFinder_Update
7407 FD 45       7 667 ld      b, iyl                      ; restore current position
7409 C3 6C 72    7 668 jp      Path_Finder_Neighbors       ; continue processing neighbors
740C             7 670 PathFinder_CYAN_Edge_2
740C EB          7 671 ex      de, hl                      ; restore pointer to current position address
740D 2D          7 672 dec     l
740E 2D          7 673 dec     l
740F BE          7 674 cp      (hl)                        ; check adjacent #0 distance
7410 D4 42 71    7 675 call    nc, PathFinder_Update
7413 2C          7 676 inc     l
7414 2C          7 677 inc     l
7415 2C          7 678 inc     l
7416 2C          7 679 inc     l
7417 BE          7 680 cp      (hl)                        ; check adjacent #4 distance
7418 D4 42 71    7 681 call    nc, PathFinder_Update
741B 2C          7 682 inc     l
741C BE          7 683 cp      (hl)                        ; check adjacent #5 distance
741D D4 42 71    7 684 call    nc, PathFinder_Update
7420 2C          7 685 inc     l
7421 BE          7 686 cp      (hl)                        ; check adjacent #6 distance
7422 D4 42 71    7 687 call    nc, PathFinder_Update
7425 FD 45       7 688 ld      b, iyl                      ; restore current position
7427 C3 6C 72    7 689 jp      Path_Finder_Neighbors       ; continue processing neighbors
742A             7 691 PathFinder_CYAN_Edge_3
742A EB          7 692 ex      de, hl                      ; restore pointer to current position address
742B 2D          7 693 dec     l
742C 2D          7 694 dec     l
742D 2D          7 695 dec     l
742E BE          7 696 cp      (hl)                        ; check adjacent #0 distance
742F D4 42 71    7 697 call    nc, PathFinder_Update
7432 2C          7 698 inc     l
7433 BE          7 699 cp      (hl)                        ; check adjacent #1 distance
7434 D4 42 71    7 700 call    nc, PathFinder_Update
7437 2C          7 701 inc     l
7438 2C          7 702 inc     l
7439 2C          7 703 inc     l
743A 2C          7 704 inc     l
743B BE          7 705 cp      (hl)                        ; check adjacent #5 distance
743C D4 42 71    7 706 call    nc, PathFinder_Update
743F 2C          7 707 inc     l
7440 BE          7 708 cp      (hl)                        ; check adjacent #6 distance
7441 D4 42 71    7 709 call    nc, PathFinder_Update
7444 FD 45       7 710 ld      b, iyl                      ; restore current position
7446 C3 6C 72    7 711 jp      Path_Finder_Neighbors       ; continue processing neighbors
7449             7 713 PathFinder_CYAN_Edge_4
7449 EB          7 714 ex      de, hl                      ; restore pointer to current position address
744A 2C          7 715 inc     l
744B 2C          7 716 inc     l
744C BE          7 717 cp      (hl)                        ; check adjacent #6 distance
744D D4 42 71    7 718 call    nc, PathFinder_Update
7450 2D          7 719 dec     l
7451 2D          7 720 dec     l
7452 2D          7 721 dec     l
7453 2D          7 722 dec     l
7454 BE          7 723 cp      (hl)                        ; check adjacent #2 distance
7455 D4 42 71    7 724 call    nc, PathFinder_Update
7458 2D          7 725 dec     l
7459 BE          7 726 cp      (hl)                        ; check adjacent #1 distance
745A D4 42 71    7 727 call    nc, PathFinder_Update
745D 2D          7 728 dec     l
745E BE          7 729 cp      (hl)                        ; check adjacent #0 distance
745F D4 42 71    7 730 call    nc, PathFinder_Update
7462 FD 45       7 731 ld      b, iyl                      ; restore current position
7464 C3 6C 72    7 732 jp      Path_Finder_Neighbors       ; continue processing neighbors
7467             7 734 PathFinder_CYAN_Edge_5
7467 EB          7 735 ex      de, hl                      ; restore pointer to current position address
7468 2D          7 736 dec     l
7469 2D          7 737 dec     l
746A BE          7 738 cp      (hl)                        ; check adjacent #3 distance
746B D4 42 71    7 739 call    nc, PathFinder_Update
746E 2D          7 740 dec     l
746F BE          7 741 cp      (hl)                        ; check adjacent #2 distance
7470 D4 42 71    7 742 call    nc, PathFinder_Update
7473 2D          7 743 dec     l
7474 BE          7 744 cp      (hl)                        ; check adjacent #1 distance
7475 D4 42 71    7 745 call    nc, PathFinder_Update
7478 2D          7 746 dec     l
7479 BE          7 747 cp      (hl)                        ; check adjacent #0 distance
747A D4 42 71    7 748 call    nc, PathFinder_Update
747D FD 45       7 749 ld      b, iyl                      ; restore current position
747F C3 6C 72    7 750 jp      Path_Finder_Neighbors       ; continue processing neighbors
7482             7 752 PathFinder_CYAN_Edge_6
7482 EB          7 753 ex      de, hl                      ; restore pointer to current position address
7483 2D          7 754 dec     l
7484 2D          7 755 dec     l
7485 BE          7 756 cp      (hl)                        ; check adjacent #4 distance
7486 D4 42 71    7 757 call    nc, PathFinder_Update
7489 2D          7 758 dec     l
748A BE          7 759 cp      (hl)                        ; check adjacent #3 distance
748B D4 42 71    7 760 call    nc, PathFinder_Update
748E 2D          7 761 dec     l
748F BE          7 762 cp      (hl)                        ; check adjacent #2 distance
7490 D4 42 71    7 763 call    nc, PathFinder_Update
7493 2D          7 764 dec     l
7494 BE          7 765 cp      (hl)                        ; check adjacent #1 distance
7495 D4 42 71    7 766 call    nc, PathFinder_Update
7498 2D          7 767 dec     l
7499 BE          7 768 cp      (hl)                        ; check adjacent #0 distance
749A D4 42 71    7 769 call    nc, PathFinder_Update
749D FD 45       7 770 ld      b, iyl                      ; restore current position
749F C3 6C 72    7 771 jp      Path_Finder_Neighbors       ; continue processing neighbors
74A2             7 773 ; ----------------------------------------------------------------------------------------------------------------------
74A2             7 774 ; PathFinder_Score: calculate board score depending on speccy color
74A2             7 775 ;
74A2             7 776 ; Input:    -
74A2             7 777 ;
74A2             7 778 ; Output:   A = DEFEAT, if speccy can't reach his opposite edge
74A2             7 779 ;           A = WINNER, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
74A2             7 780 ;           A = speccy heuristic evaluation, otherwise
74A2             7 781 ;
74A2             7 782 ; Uses:     AI_PLAYER (speccy side)
74A2             7 783 ;
74A2             7 784 ; Destroys: A', BC, DE, HL, IY
74A2             7 785 ; ----------------------------------------------------------------------------------------------------------------------
74A2             7 786 PathFinder_Score:
74A2 3A 99 61    7 787 ld      a, (AI_PLAYER)
74A5 FE 02       7 788 cp      FRIEND                      ; if speccy is FRIEND, calculate CYAN score
74A7 28 31       7 789 jr      z, PathFinder_CyanScore
74A9             7 791 ; ----------------------------------------------------------------------------------------------------------------------
74A9             7 792 ; PathFinder_RedScore: calculate red score
74A9             7 793 ;
74A9             7 794 ; Input:    -
74A9             7 795 ;
74A9             7 796 ; Output:   A = DEFEAT, if red can't reach his opposite edge
74A9             7 797 ;           A = WINNER, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
74A9             7 798 ;           A = red heuristic evaluation, otherwise
74A9             7 799 ;
74A9             7 800 ; Uses:     POTENTIALS (board potential and attack mobility)
74A9             7 801 ;
74A9             7 802 ; Destroys: A', BC, DE, HL, IY
74A9             7 803 ; ----------------------------------------------------------------------------------------------------------------------
74A9             7 804 PathFinder_RedScore
74A9 CD DC 71    7 805 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74AC C8          7 806 ret     z                           ; if red has a chain of connected tokens, return A = WINNER
74AD 08          7 807 ex      af, af'                     ; save first result
74AE CD 1E 72    7 808 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74B1 47          7 809 ld      b, a                        ; save second result
74B2 08          7 810 ex      af, af'                     ; restore first result
74B3 90          7 811 sub     b                           ; subtract both results
74B4 78          7 812 ld      a, b                        ; restore second result
74B5 C8          7 813 ret     z                           ; if red can't reach his opposite edge, return A = DEFEAT
74B6 CD 68 71    7 815 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74B9 08          7 816 ex      af, af'                     ; save result
74BA CD A4 71    7 817 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74BD 47          7 818 ld      b, a                        ; save second result
74BE 08          7 819 ex      af, af'                     ; restore first result
74BF 90          7 820 sub     b                           ; subtract both results
74C0 C8          7 821 ret     z                           ; if cyan can't reach his opposite edge, return A = WINNER
74C1 21 09 64    7 823 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74C4 11 51 64    7 824 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74C7 CD 18 75    7 825 call    PathFinder_Potentials       ; calculate RED potentials
74CA ED 43 97 61 7 826 ld      (POTENTIALS), bc            ; store RED potentials
74CE 21 09 61    7 828 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74D1 11 51 61    7 829 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74D4 CD 18 75    7 830 call    PathFinder_Potentials       ; calculate cyan potentials
74D7 C3 08 75    7 831 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74DA             7 833 ; ----------------------------------------------------------------------------------------------------------------------
74DA             7 834 ; PathFinder_CyanScore: calculate cyan score
74DA             7 835 ;
74DA             7 836 ; Input:    -
74DA             7 837 ;
74DA             7 838 ; Output:   A = DEFEAT, if cyan can't reach his opposite edge
74DA             7 839 ;           A = WINNER, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
74DA             7 840 ;           A = cyan heuristic evaluation, otherwise
74DA             7 841 ;
74DA             7 842 ; Uses:     POTENTIALS (board potential and attack mobility)
74DA             7 843 ;
74DA             7 844 ; Destroys: A', BC, DE, HL
74DA             7 845 ; ----------------------------------------------------------------------------------------------------------------------
74DA             7 846 PathFinder_CyanScore
74DA CD 68 71    7 847 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74DD C8          7 848 ret     z                           ; if cyan has a chain of connected tokens, return A = WINNER
74DE 08          7 849 ex      af, af'                     ; save result
74DF CD A4 71    7 850 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74E2 47          7 851 ld      b, a                        ; save second result
74E3 08          7 852 ex      af, af'                     ; restore first result
74E4 90          7 853 sub     b                           ; subtract both results
74E5 78          7 854 ld      a, b                        ; restore second result
74E6 C8          7 855 ret     z                           ; if cyan can't reach his opposite edge, return A = DEFEAT
74E7 CD DC 71    7 857 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74EA 08          7 858 ex      af, af'                     ; save result
74EB CD 1E 72    7 859 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74EE 47          7 860 ld      b, a                        ; save second result
74EF 08          7 861 ex      af, af'                     ; restore first result
74F0 90          7 862 sub     b                           ; subtract both results
74F1 C8          7 863 ret     z                           ; if red can't reach his opposite edge, return A = WINNER
74F2 21 09 61    7 865 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74F5 11 51 61    7 866 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74F8 CD 18 75    7 867 call    PathFinder_Potentials       ; calculate cyan potentials
74FB ED 43 97 61 7 868 ld      (POTENTIALS), bc            ; save cyan potentials
74FF 21 09 64    7 870 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
7502 11 51 64    7 871 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7505 CD 18 75    7 872 call    PathFinder_Potentials       ; calculate red potentials
7508             7 873 ; ----------------------------------------------------------------------------------------------------------------------
7508             7 874 ; PathFinder_Evaluation: calculate heuristic evaluation.
7508             7 875 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
7508             7 876 ;
7508             7 877 ;                                       e = M (pC - pR) - (aC - aR)
7508             7 878 ; where:
7508             7 879 ;   pC = cyan board potential
7508             7 880 ;   pR = red board potential
7508             7 881 ;   aC = cyan attack mobility
7508             7 882 ;   aR = red attack mobility
7508             7 883 ;    M = a large number
7508             7 884 ;
7508             7 885 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
7508             7 886 ;
7508             7 887 ; Input:    B = opponent attack mobility
7508             7 888 ;           C = opponent board potential
7508             7 889 ;
7508             7 890 ; Output:   A = heuristic evaluation
7508             7 891 ;
7508             7 892 ; Destroys: E, HL
7508             7 893 ; ----------------------------------------------------------------------------------------------------------------------
7508             7 894 PathFinder_Evaluation:
7508 21 98 61    7 895 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
750B 78          7 896 ld      a, b                        ; get opponent's attack mobility
750C 96          7 897 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
750D 5F          7 898 ld      e, a                        ; save the result in E
750E 2D          7 899 dec     l                           ; move HL to player's board potential address
750F 79          7 900 ld      a, c                        ; get opponent's board potential
7510 96          7 901 sub     (hl)                        ; subtract potentials -> (pC - pR)
7511 87          7 902 add     a, a                        ; multiply by 8 -> M (pC - pR)
7512 87          7 903 add     a, a
7513 87          7 904 add     a, a
7514 93          7 905 sub     e                           ; subtract result of attack mobilities subtraction
7515             7 906 ; -> M (pC - pR) - (aC - aR)
7515 EE 80       7 907 xor     $80                         ; invert sign for easier further comparative
7517 C9          7 908 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
7518             7 910 ; ----------------------------------------------------------------------------------------------------------------------
7518             7 911 ; PathFinder_Potentials: calculate board potential and attack mobility
7518             7 912 ;
7518             7 913 ; * A cells Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
7518             7 914 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
7518             7 915 ;   the board.
7518             7 916 ; * The attack mobility is defined for each player as the number of cells that realize that players board potential.
7518             7 917 ;
7518             7 918 ; Input:    HL = cyan board or red board address
7518             7 919 ;           DE = cyan board or red board address
7518             7 920 ;
7518             7 921 ; Output:   B = attack mobility
7518             7 922 ;           C = board potential
7518             7 923 ;
7518             7 924 ; Destroys: A, DE, HL, IYL
7518             7 925 ; ----------------------------------------------------------------------------------------------------------------------
7518             7 926 PathFinder_Potentials:
7518 01 FF 00    7 927 ld      bc, $00FF                   ; initialize attack mobility and board potential
751B FD 2E 3D    7 928 ld      iyl, 61                     ; number of cells to be checked (loop counter)
751E             7 929 Potentials_Loop
751E 7E          7 930 ld      a, (hl)                     ; get cell's two-distance pointed by HL
751F FE 40       7 931 cp      $40                         ; is cell occupied or border?
7521 30 16       7 932 jr      nc, Potentials_Next         ; yes, skip to next cell 
7523 FE 04       7 933 cp      $04                         ; cell distance was not updated?
7525 38 1A       7 934 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
7527 1A          7 935 ld      a, (de)                     ; get cell's two-distance pointed by DE
7528 FE 04       7 936 cp      $04                         ; cell distance was not updated?
752A 38 15       7 937 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
752C 86          7 938 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
752D 77          7 939 ld      (hl), a                     ; save potential in the cell pointed by HL
752E B9          7 940 cp      c                           ; is the new potential >= board potential?
752F D2 35 75    7 941 jp      nc, Potentials_Mobility     ; yes, check attack mobility
7532 4F          7 942 ld      c, a                        ; no, board potential = new potential
7533 06 01       7 943 ld      b, 1                        ; restart attack mobility
7535             7 944 Potentials_Mobility
7535 C2 39 75    7 945 jp      nz, Potentials_Next         ; if (potential <> last potential) skip to next cell
7538 04          7 946 inc     b                           ; else, increment attack mobility
7539             7 947 Potentials_Next
7539 1C          7 948 inc     e                           ; move to next cells of each board
753A 2C          7 949 inc     l
753B FD 2D       7 950 dec     iyl                         ; decrement loop counter
753D C2 1E 75    7 951 jp      nz, Potentials_Loop         ; repeat until end of boards
7540 C9          7 952 ret
7541             7 953 Potentials_Infinite
7541 CB FE       7 954 set     7, (hl)                     ; set cell potential as "infinite"
7543 1C          7 955 inc     e                           ; move to next cells of each board
7544 2C          7 956 inc     l
7545 FD 2D       7 957 dec     iyl                         ; decrement loop counter
7547 C2 1E 75    7 958 jp      nz, Potentials_Loop         ; repeat until end of boards
754A C9          7 959 ret
754B             7 961 ; ----------------------------------------------------------------------------------------------------------------------
754B             7 962 ; PathFinder_Candidates: search candidates based on score result and boards potentials
754B             7 963 ;
754B             7 964 ; Input:    A  = DEFEAT, WINNER or heuristic result
754B             7 965 ;           IX = candidates area address
754B             7 966 ;
754B             7 967 ; Output:   IX = first candidate address
754B             7 968 ;
754B             7 969 ; Uses:     AI_PLAYER (speccy side)
754B             7 970 ;
754B             7 971 ; Destroys: A, A', BC, DE, HL
754B             7 972 ; ----------------------------------------------------------------------------------------------------------------------
754B             7 973 PathFinder_Candidates:
754B DD 36 00 00 7 974 ld      (ix+0), 0                   ; set candidates endmarker
754F B7          7 976 or      a                           ; A = WINNER?
7550 28 39       7 977 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
7552 3C          7 978 inc     a                           ; A = DEFEAT?
7553 28 41       7 979 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
7555             7 981 ; if score is not DEFEAT nor WINNER, fill candidates from total potentials
7555 21 09 61    7 983 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7558 11 09 64    7 984 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
755B CD 18 75    7 985 call    PathFinder_Potentials       ; process candidates from total potentials
755E 79          7 987 ld      a, c                        ; set board potential in A
755F 08          7 988 ex      af, af'                     ; save board potential
7560 50          7 989 ld      d, b                        ; store attack mobility
7561 DD 5D       7 990 ld      e, ixl                      ; store candidates position
7563             7 992 ; insert the second best board potentials in candidates area
7563             7 993 Candidates_2nd_Best
7563 2E 09       7 994 ld      l, 9                        ; HL points to board potentials address (1st position)
7565 0C          7 995 inc     c                           ; increment board potential
7566 79          7 996 ld      a, c                        ; A = second best potential
7567 06 3D       7 997 ld      b, 61                       ; number of cells to be checked (loop counter)
7569             7 998 Candidates_2nd_Best_Loop
7569 BE          7 999 cp      (hl)                        ; is current board potential = 2nd best board potential?
756A C2 72 75    7 1000 jp      nz, Candidates_2nd_Best_Next; no, skip to next potential
756D DD 2C       7 1001 inc     ixl                         ; yes, insert candidate
756F DD 75 00    7 1002 ld      (ix+0), l
7572             7 1003 Candidates_2nd_Best_Next
7572 2C          7 1004 inc     l                           ; move HL to next board potential address
7573 10 F4       7 1005 djnz    Candidates_2nd_Best_Loop    ; repeat for each cell
7575 DD 7D       7 1006 ld      a, ixl                      ; A = current candidates position
7577 BB          7 1007 cp      e                           ; new candidates inserted?
7578 28 E9       7 1008 jr      z, Candidates_2nd_Best      ; no, repeat until new candidates inserted
757A 42          7 1010 ld      b, d                        ; restore attack mobility
757B 08          7 1011 ex      af, af'                     ; restore board potential
757C             7 1013 ; insert the best board potentials in candidates area
757C             7 1014 Candidates_Best
757C 2E 08       7 1015 ld      l, 8                        ; HL points to board potential address (1st position -1)
757E             7 1016 Candidates_Best_Loop
757E 2C          7 1017 inc     l                           ; move HL to next board potential address
757F BE          7 1018 cp      (hl)                        ; is current board potential equal to best board potential?
7580 C2 7E 75    7 1019 jp      nz, Candidates_Best_Loop    ; no, next potential
7583 DD 2C       7 1020 inc     ixl                         ; yes, insert candidate
7585 DD 75 00    7 1021 ld      (ix+0), l
7588 10 F4       7 1022 djnz    Candidates_Best_Loop        ; repeat for each cell
758A C9          7 1023 ret
758B             7 1025 ; ----------------------------------------------------------------------------------------------------------------------
758B             7 1026 ; Fill candidates for winner color
758B             7 1027 ; ----------------------------------------------------------------------------------------------------------------------
758B             7 1028 Candidates_Winner
758B 3A 99 61    7 1029 ld      a, (AI_PLAYER)              ; check speccy side
758E FE 02       7 1030 cp      FRIEND                      ; is it friend?
7590 CA A3 75    7 1031 jp      z, Candidates_Cyan_Potential; yes, fill candidates from cyan potentials
7593 C3 B6 75    7 1032 jp      Candidates_Red_Potential    ; no, fill candidates from red potentials
7596             7 1034 ; ----------------------------------------------------------------------------------------------------------------------
7596             7 1035 ; Fill candidates for defeated color
7596             7 1036 ; ----------------------------------------------------------------------------------------------------------------------
7596             7 1037 Candidates_Defeat
7596 3A 99 61    7 1038 ld      a, (AI_PLAYER)              ; check speccy side
7599 FE 02       7 1039 cp      FRIEND                      ; is it friend?
759B 28 13       7 1040 jr      z, Candidates_Red           ; yes, fill candidates from red potentials
759D             7 1042 ; if RED is defeated, candidates are chosen from cyan board potentials
759D CD 68 71    7 1044 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
75A0 CD A4 71    7 1045 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
75A3             7 1046 Candidates_Cyan_Potential
75A3 21 09 61    7 1047 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
75A6 11 51 61    7 1048 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
75A9 CD 18 75    7 1049 call    PathFinder_Potentials       ; calculate cyan potentials
75AC 79          7 1051 ld      a, c                        ; set board potential in A
75AD C3 7C 75    7 1052 jp      Candidates_Best             ; fill only the best candidates
75B0             7 1054 ; if CYAN is defeated, candidates are chosen from red board potentials
75B0             7 1055 Candidates_Red
75B0 CD DC 71    7 1056 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
75B3 CD 1E 72    7 1057 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
75B6             7 1058 Candidates_Red_Potential
75B6 21 09 64    7 1059 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
75B9 11 51 64    7 1060 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
75BC CD 18 75    7 1061 call    PathFinder_Potentials       ; calculate red potentials
75BF 79          7 1063 ld      a, c                        ; set board potential in A
75C0 C3 7C 75    7 1064 jp      Candidates_Best             ; fill only the best candidates
75C3             7 1066 ; ----------------------------------------------------------------------------------------------------------------------
75C3             7 1067 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75C3             7 1068 ;
75C3             7 1069 ; Input:    B = current position
75C3             7 1070 ;
75C3             7 1071 ; Output:   -
75C3             7 1072 ;
75C3             7 1073 ; Uses:     TOKEN_COLOR (current token color)
75C3             7 1074 ;
75C3             7 1075 ; Destroys: A, BC, DE, HL, IY
75C3             7 1076 ; ----------------------------------------------------------------------------------------------------------------------
75C3             7 1077 PathFinder_BrightPath:
75C3 C5          7 1078 push    bc                          ; store current position
75C4 3A 9E 61    7 1080 ld      a, (TOKEN_COLOR)            ; get current player color
75C7 F5          7 1081 push    af                          ; store current player color
75C8 FE 05       7 1082 cp      CYAN_COLOR                  ; check current token color
75CA 28 0B       7 1083 jr      z, BrightPath_Cyan          ; prepare board if it is cyan
75CC 21 45 64    7 1085 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75CF CD 23 76    7 1086 call    PathFinder_PrepareBoard     ; prepare RED board 
75D2 CD E5 71    7 1087 call    PathFinder_Red_BrightPath   ; find RED victory path
75D5 18 09       7 1088 jr      BrightPath_Start            ; start bright path
75D7             7 1089 BrightPath_Cyan
75D7 21 45 61    7 1090 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75DA CD 23 76    7 1091 call    PathFinder_PrepareBoard     ; prepare CYAN board
75DD CD 71 71    7 1092 call    PathFinder_Cyan_BrightPath  ; find CYAN victory path
75E0             7 1093 BrightPath_Start
75E0 F1          7 1094 pop     af                          ; restore current player color
75E1 C6 40       7 1095 add     a, $40                      ; apply bright attribute
75E3 32 9E 61    7 1096 ld      (TOKEN_COLOR), a            ; save color
75E6 C1          7 1098 pop     bc                          ; restore current position
75E7 24          7 1100 inc     h                           ; HL points to the start position of the victory path
75E8 68          7 1101 ld      l, b
75E9 4E          7 1102 ld      c, (hl)                     ; set victory path length in C
75EA 18 1E       7 1103 jr      BrightPath_Position         ; animate and highlight the hexagon position
75EC             7 1104 BrightPath_Neighbor
75EC 2C          7 1105 inc     l                           ; move HL to left neighbor address
75ED BE          7 1106 cp      (hl)                        ; is it the same as victory path length?
75EE 28 1A       7 1107 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F0 2D          7 1108 dec     l
75F1 2D          7 1109 dec     l                           ; right neighbor
75F2 BE          7 1110 cp      (hl)                        ; is it the same as victory path length?
75F3 28 15       7 1111 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F5 7D          7 1112 ld      a, l
75F6 D6 08       7 1113 sub     WIDTH
75F8 6F          7 1114 ld      l, a                        ; move HL to upper-right neighbor address
75F9 79          7 1115 ld      a, c                        ; restore victory path length in A
75FA BE          7 1116 cp      (hl)                        ; is it the same as victory path length?
75FB 28 0D       7 1117 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75FD 2C          7 1118 inc     l                           ; upper-left neighbor
75FE BE          7 1119 cp      (hl)                        ; is it the same as victory path length?
75FF 28 09       7 1120 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7601 7D          7 1121 ld      a, l
7602 C6 10       7 1122 add     a, WIDTH*2
7604 6F          7 1123 ld      l, a                        ; move HL to lower-right neighbor address
7605 79          7 1124 ld      a, c                        ; restore victory path length in A
7606 BE          7 1125 cp      (hl)                        ; is it the same as victory path length?
7607 28 01       7 1126 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7609 2C          7 1127 inc     l                           ; move HL to lower-left neighbor address
760A             7 1128 BrightPath_Position
760A C5          7 1129 push    bc                          ; store victory path length
760B E5          7 1130 push    hl                          ; store current position pointer
760C CD 84 6D    7 1131 call    Main_Board2Indexes          ; convert a board position into a board indexes
760F CD BF 6D    7 1132 call    Draw_Token                  ; draw token
7612 E1          7 1133 pop     hl                          ; restore current position pointer
7613 C1          7 1134 pop     bc                          ; restore victory path length
7614 0D          7 1135 dec     c                           ; decrement victory path length
7615 79          7 1136 ld      a, c                        ; set victory path length in A
7616 FE 03       7 1137 cp      VICTORY                     ; has reached victory path length?
7618 20 D2       7 1138 jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach VICTORY length
761A 3A 9E 61    7 1140 ld      a, (TOKEN_COLOR)            ; restore token color
761D D6 40       7 1141 sub     $40
761F 32 9E 61    7 1142 ld      (TOKEN_COLOR), a
7622 C9          7 1143 ret
7623             7 1145 ; ----------------------------------------------------------------------------------------------------------------------
7623             7 1146 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing WIN_CONDITION to 1, everything else to ENEMY.
7623             7 1147 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
7623             7 1148 ; [color]' again to find a victory path.
7623             7 1149 ;
7623             7 1150 ; Coded by Einar Saukas
7623             7 1151 ;
7623             7 1152 ; Input:    HL = pointer to last position of [color]_BOARD
7623             7 1153 ;
7623             7 1154 ; Output:   -
7623             7 1155 ;
7623             7 1156 ; Destroys: A, BC, HL
7623             7 1157 ; ----------------------------------------------------------------------------------------------------------------------
7623             7 1158 PathFinder_PrepareBoard:
7623 3E 43       7 1159 ld      a, VICTORY+$40              ; set victory distance + friendly flag
7625 0E 07       7 1160 ld      c, 7                        ; 7 rows
7627             7 1161 PrepareBoard_Row
7627 06 07       7 1162 ld      b, 7                        ; 7 columns
7629             7 1163 PrepareBoard_Column
7629 BE          7 1164 cp      (hl)                        ; is it win condition?
762A 36 01       7 1165 ld      (hl), 1                     ; save 1 by default
762C 28 02       7 1166 jr      z, PrepareBoard_Next        ; yes, next position
762E 36 7E       7 1167 ld      (hl), ENEMY                 ; no, save ENEMY
7630             7 1168 PrepareBoard_Next
7630 2D          7 1169 dec     l                           ; HL points to next board position
7631 10 F6       7 1170 djnz    PrepareBoard_Column         ; repeat for each column
7633 2D          7 1172 dec     l                           ; skip borders
7634 2D          7 1173 dec     l
7635 0D          7 1174 dec     c                           ; decrement rows
7636 20 EF       7 1175 jr      nz, PrepareBoard_Row        ; repeat for each row
7638 C9          7 1176 ret

; File #8: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Timer.z80asm

7639             8 1 ; ----------------------------------------------------------------------------------------------------------------------
7639             8 2 ; Timer.z80asm
7639             8 3 ; Coded by Antonio Luque
7639             8 4 ;
7639             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
7639             8 6 ; ----------------------------------------------------------------------------------------------------------------------
7639             8 8 ; ----------------------------------------------------------------------------------------------------------------------
7639             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
7639             8 10 ;
7639             8 11 ; Input:    -
7639             8 12 ;
7639             8 13 ; Output:   -
7639             8 14 ;
7639             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7639             8 16 ;
7639             8 17 ; Destroys: BC', DE', HL'
7639             8 18 ; ----------------------------------------------------------------------------------------------------------------------
7639             8 19 Timer_Interrupt:
7639 F5          8 20 push    af                          ; store AF register
763A D9          8 21 exx                                 ; store BC, DE and HL registers
763B 3A EB 62    8 23 ld      a, (TIMER_FLAG)             ; check timer flag
763E B7          8 24 or      a                           ; is timer stopped?
763F CA 68 76    8 25 jp      z, Timer_Exit               ; yes, exit routine
7642 21 EF 62    8 27 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
7645 3D          8 28 dec     a                           ; is red timer on?
7646 C2 4C 76    8 29 jp      nz, Timer_Counters          ; yes, check interrupt counter 
7649 21 EC 62    8 30 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
764C             8 31 Timer_Counters
764C 35          8 32 dec     (hl)                        ; decrement interrupt counter
764D C2 68 76    8 33 jp      nz, Timer_Exit              ; if not 0, exit routine
7650 36 32       8 35 ld      (hl), 50                    ; restart interrupt counter
7652 23          8 36 inc     hl                          ; move HL to seconds counter address
7653 3E 01       8 37 ld      a, 1                        ; increment seconds counter
7655 86          8 38 add     a, (hl)
7656 27          8 39 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7657 77          8 40 ld      (hl), a                     ; store seconds
7658 FE 60       8 41 cp      $60                         ; 60 seconds reached?
765A C2 65 76    8 42 jp      nz, Timer_Show              ; no, show timer
765D 36 00       8 43 ld      (hl), 0                     ; restart seconds counter
765F 23          8 44 inc     hl                          ; move HL to minutes counter address
7660 3E 01       8 45 ld      a, 1                        ; increment minutes counter
7662 86          8 46 add     a, (hl)
7663 27          8 47 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7664 77          8 48 ld      (hl), a                     ; store minutes
7665             8 49 Timer_Show
7665 CD 6C 76    8 50 call    Timer_Display               ; display timer on the screen
7668             8 51 Timer_Exit
7668 D9          8 52 exx                                 ; restore BC, DE and HL registers
7669 F1          8 53 pop     af                          ; restore AF register
766A FB          8 55 ei                                  ; enable interrupts
766B C9          8 56 ret
766C             8 58 ; ----------------------------------------------------------------------------------------------------------------------
766C             8 59 ; Timer_Display: display a timer on the screen
766C             8 60 ;
766C             8 61 ; Input:    -
766C             8 62 ;
766C             8 63 ; Output:   -
766C             8 64 ;
766C             8 65 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
766C             8 66 ;
766C             8 67 ; Destroys: A, BC, DE, HL
766C             8 68 ; ----------------------------------------------------------------------------------------------------------------------
766C             8 69 Timer_Display:
766C 11 F1 62    8 70 ld      de, RED_TIMER+2             ; DE points to red's minutes counter address
766F 01 E2 48    8 71 ld      bc, $48E2                   ; BC points to red's minutes screen address
7672 3A EB 62    8 72 ld      a, (TIMER_FLAG)             ; check timer flag
7675 3D          8 73 dec     a                           ; is cyan timer on?
7676 C2 7F 76    8 74 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
7679 11 EE 62    8 75 ld      de, CYAN_TIMER+2            ; DE points to cyan's minutes counter address
767C 01 78 40    8 76 ld      bc, $4078                   ; BC points to cyan's minutes screen address
767F             8 77 Timer_Display_Min
767F CD 84 76    8 78 call    Timer_Display_MinSec        ; display minutes counter on screen
7682 1B          8 79 dec     de                          ; DE points to seconds counter address
7683 0C          8 80 inc     c                           ; BC points to seconds screen address
7684             8 81 Timer_Display_MinSec:
7684 1A          8 82 ld      a, (de)                     ; set min/sec counter in A
7685 1F          8 83 rra                                 ; move tens digit to the first 4th bits of A
7686 1F          8 84 rra
7687 1F          8 85 rra
7688 1F          8 86 rra
7689 CD 8D 76    8 87 call    Timer_Display_Digit         ; display tens digit on screen
768C 1A          8 88 ld      a, (de)                     ; set min/sec counter in A 
768D             8 89 Timer_Display_Digit:
768D E6 0F       8 90 and     %00001111                   ; discard the last 4th bits of the digit
768F C5          8 91 push    bc                          ; store digit screen address
7690 21 97 64    8 93 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
7693 87          8 94 add     a, a                        ; a digit is 8 bytes long
7694 87          8 95 add     a, a
7695 87          8 96 add     a, a
7696 85          8 97 add     a, l                        ; set digit index in HL
7697 6F          8 98 ld      l, a
7698 7E          8 100 ld      a, (hl)                     ; get digit tile
7699 02          8 101 ld      (bc), a                     ; put it on screen address
769A 04          8 102 inc     b                           ; move BC to next pixel-line address
769B 2C          8 103 inc     l                           ; move HL to next digit tile address
769C 7E          8 104 ld      a, (hl)                     ; (repeat 7 more times)
769D 02          8 105 ld      (bc), a
769E 04          8 106 inc     b
769F 2C          8 107 inc     l
76A0 7E          8 108 ld      a, (hl)
76A1 02          8 109 ld      (bc), a
76A2 04          8 110 inc     b
76A3 2C          8 111 inc     l
76A4 7E          8 112 ld      a, (hl)
76A5 02          8 113 ld      (bc), a
76A6 04          8 114 inc     b
76A7 2C          8 115 inc     l
76A8 7E          8 116 ld      a, (hl)
76A9 02          8 117 ld      (bc), a
76AA 04          8 118 inc     b
76AB 2C          8 119 inc     l
76AC 7E          8 120 ld      a, (hl)
76AD 02          8 121 ld      (bc), a
76AE 04          8 122 inc     b
76AF 2C          8 123 inc     l
76B0 7E          8 124 ld      a, (hl)
76B1 02          8 125 ld      (bc), a
76B2 04          8 126 inc     b
76B3 2C          8 127 inc     l
76B4 7E          8 128 ld      a, (hl)
76B5 02          8 129 ld      (bc), a
76B6 C1          8 131 pop     bc                          ; restore digit screen address
76B7 0C          8 132 inc     c                           ; move screen address to next column
76B8 C9          8 133 ret
76B9             8 135 ; ----------------------------------------------------------------------------------------------------------------------
76B9             8 136 ; Timer_Display_All: display cyan and red timers
76B9             8 137 ;
76B9             8 138 ; Input:    -
76B9             8 139 ;
76B9             8 140 ; Output:   -
76B9             8 141 ;
76B9             8 142 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
76B9             8 143 ;
76B9             8 144 ; Destroys: BC, DE, HL
76B9             8 145 ; ----------------------------------------------------------------------------------------------------------------------
76B9             8 146 Timer_Display_All:
76B9 3E 01       8 147 ld      a, 1                        ; set cyan timer on
76BB 32 EB 62    8 148 ld      (TIMER_FLAG), a
76BE CD 6C 76    8 149 call    Timer_Display               ; display cyan timer
76C1 3E 02       8 151 ld      a, 2                        ; set red timer on
76C3 32 EB 62    8 152 ld      (TIMER_FLAG), a
76C6 CD 6C 76    8 153 call    Timer_Display               ; display red timer
76C9 AF          8 155 xor     a                           ; stop timers
76CA 32 EB 62    8 156 ld      (TIMER_FLAG), a
76CD C9          8 157 ret
76CE             8 159 ; ----------------------------------------------------------------------------------------------------------------------
76CE             8 160 ; Timer_Reset: initialize cyan and red timers
76CE             8 161 ;
76CE             8 162 ; Input:    -
76CE             8 163 ;
76CE             8 164 ; Output:   -
76CE             8 165 ;
76CE             8 166 ; Destroys: HL
76CE             8 167 ; ----------------------------------------------------------------------------------------------------------------------
76CE             8 168 Timer_Reset:
76CE 21 EC 62    8 169 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76D1 36 32       8 171 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76D3 23          8 172 inc     hl                          ; move HL to cyan's seconds counter address
76D4 36 00       8 173 ld      (hl), 0                     ; reset seconds counter
76D6 23          8 174 inc     hl                          ; move HL to cyan's minutes counter address
76D7 36 00       8 175 ld      (hl), 0                     ; reset minutes counter
76D9 23          8 176 inc     hl                          ; move HL to red's interrupt counter
76DA 36 32       8 178 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76DC 23          8 179 inc     hl                          ; move HL to red's seconds counter address
76DD 36 00       8 180 ld      (hl), 0                     ; reset seconds counter
76DF 23          8 181 inc     hl                          ; move HL to red's minutes counter address
76E0 36 00       8 182 ld      (hl), 0                     ; reset minutes counter
76E2 C9          8 183 ret

; File #9: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Sound.z80asm

76E3             9 1 ; ----------------------------------------------------------------------------------------------------------------------
76E3             9 2 ; Sound.z80asm
76E3             9 3 ; Coded with BeepFX player tool by Shiru: https://opengameart.org/content/zx-spectrum-beeper-sound-effects
76E3             9 4 ;
76E3             9 5 ; Adapted for Hex game by Antonio Luque
76E3             9 6 ; ----------------------------------------------------------------------------------------------------------------------
76E3             9 8 ; ----------------------------------------------------------------------------------------------------------------------
76E3             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
76E3             9 10 ; 
76E3             9 11 ; Input:    IX = tone parameters address
76E3             9 12 ;
76E3             9 13 ; Output:   -
76E3             9 14 ;
76E3             9 15 ; Destroys: A, BC, DE, HL, IY
76E3             9 16 ; ----------------------------------------------------------------------------------------------------------------------
76E3             9 17 Sound_FX:
76E3 F3          9 18 di                                  ; disable interrupts
76E4 DD 4E 00    9 19 ld      c, (ix+0)                   ; BC = frames
76E7 DD 46 01    9 20 ld      b, (ix+1)
76EA DD 5E 02    9 21 ld      e, (ix+2)                   ; DE = frame length
76ED DD 56 03    9 22 ld      d, (ix+3)
76F0 D5          9 23 push    de                          ; (simulate 'ld iy,de')
76F1 FD E1       9 24 pop     iy                          ; store frame length in IY
76F3 DD 5E 04    9 25 ld      e, (ix+4)                   ; DE = pitch
76F6 DD 56 05    9 26 ld      d, (ix+5)
76F9 21 00 00    9 27 ld      hl, 0                       ; reset HL
76FC             9 28 Sound_FX_Frames
76FC C5          9 29 push    bc                          ; store frames
76FD FD E5       9 30 push    iy                          ; (simulate 'ld bc,iy')
76FF C1          9 31 pop     bc                          ; restore frame length in BC
7700             9 32 Sound_FX_FrameLength
7700 19          9 33 add     hl, de                      ; HL = incremented pitch
7701 7C          9 34 ld      a, h                        ; set high-byte in A
7702 FE 80       9 35 cp      128                         ; compares with duty cycle, the timbre of the tone
7704             9 36 ; (128 for 50% square wave)
7704 9F          9 37 sbc     a, a                        ; subtract with carry
7705 E6 10       9 38 and     16                          ; mask result
7707 D3 FE       9 39 out     (254), a                    ; play sound
7709 0B          9 40 dec     bc                          ; decrement frame length
770A 78          9 41 ld      a, b
770B B1          9 42 or      c                           ; frame length = 0?
770C 20 F2       9 43 jr      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times
770E DD 4E 06    9 44 ld      c, (ix+6)                   ; BC = pitch slide
7711 DD 46 07    9 45 ld      b, (ix+7)
7714 EB          9 46 ex      de, hl                      ; HL = pitch
7715 09          9 47 add     hl, bc                      ; add pitch slide
7716 EB          9 48 ex      de, hl                      ; DE = incremented pitch
7717 C1          9 49 pop     bc                          ; restore frames
7718 0B          9 50 dec     bc                          ; decrement frames
7719 78          9 51 ld      a, b
771A B1          9 52 or      c                           ; frames = 0?
771B 20 DF       9 53 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
771D FB          9 54 ei                                  ; enable interrupts
771E C9          9 55 ret

; File #10: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Screen.z80asm

771F             10 1 ; ----------------------------------------------------------------------------------------------------------------------
771F             10 2 ; Screen.z80asm
771F             10 3 ; Coded by Antonio Luque
771F             10 4 ; ----------------------------------------------------------------------------------------------------------------------
771F             10 6 BLUE_INK                equ     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
771F             10 7 BLUE_PAPER              equ     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
771F             10 8 WHITE_PAPER             equ     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
771F             10 9 WHITE                   equ     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
771F             10 10 BRIGHT                  equ     %01000000                   ; mask to apply bright to attributes
771F             10 11 FLASH                   equ     %10000000                   ; mask to apply flash to attributes
771F             10 12 WHITE_FLASH0            equ     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
771F             10 13 WHITE_FLASH1            equ     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
771F             10 15 ; ----------------------------------------------------------------------------------------------------------------------
771F             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
771F             10 17 ;
771F             10 18 ; Input:    -
771F             10 19 ;
771F             10 20 ; Output:   -
771F             10 21 ;
771F             10 22 ; Destroys: BC, DE, HL
771F             10 23 ; ----------------------------------------------------------------------------------------------------------------------
771F             10 24 Screen_Clear:
771F 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
7722 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
7725 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
7726 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
7729 ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
772B C9          10 30 ret
772C             10 32 ; ----------------------------------------------------------------------------------------------------------------------
772C             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
772C             10 34 ;
772C             10 35 ; Input:    -
772C             10 36 ;
772C             10 37 ; Output:   -
772C             10 38 ;
772C             10 39 ; Destroys: A, BC, DE, HL, IX
772C             10 40 ; ----------------------------------------------------------------------------------------------------------------------
772C             10 41 Screen_Letters:
772C 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
772F DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
7733 CD 3D 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
7736 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
7739 DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
773D             10 47 Screen_Letters_Row:
773D 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
7740 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
7742             10 50 Screen_Letter_Loop
7742 E5          10 51 push    hl                          ; store letter screen address
7743 CD 09 6E    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
7746 E1          10 53 pop     hl                          ; restore letter screen address
7747 2C          10 54 inc     l                           ; move HL to next screen address
7748 2C          10 55 inc     l
7749 DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
774D DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
7751 DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
7753 DD 2C       10 59 inc     ixl
7755 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
7757 C9          10 61 ret
7758             10 63 ; ----------------------------------------------------------------------------------------------------------------------
7758             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
7758             10 65 ;
7758             10 66 ; Input:    -
7758             10 67 ;
7758             10 68 ; Output:   -
7758             10 69 ;
7758             10 70 ; Destroys: A, BC, DE, HL, IX, IY
7758             10 71 ; ----------------------------------------------------------------------------------------------------------------------
7758             10 72 Screen_Numbers:
7758 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
775B FD 21 F2 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
775F DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
7763 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
7765             10 77 Screen_Number_Loop
7765 FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
7768 FD 66 01    10 79 ld      h, (iy+1)
776B E5          10 80 push    hl                          ; store pointer to number screen address
776C D5          10 81 push    de                          ; store pointer to sprite address
776D CD 09 6E    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
7770 D1          10 83 pop     de                          ; restore pointer to sprite address
7771 E1          10 84 pop     hl                          ; restore pointer to number screen address
7772 DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7776 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
777A 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
777B C6 0F       10 88 add     a, 15
777D 6F          10 89 ld      l, a
777E CD 09 6E    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
7781 DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
7785 DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
7789 78          10 93 ld      a, b                        ; save loop counter
778A 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
778D DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
778F FD 23       10 96 inc     iy                          ; move IY to next number screen address
7791 FD 23       10 97 inc     iy
7793 47          10 98 ld      b, a                        ; restore loop counter
7794 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
7796 C9          10 100 ret
7797             10 102 ; ----------------------------------------------------------------------------------------------------------------------
7797             10 103 ; Screen_Frame: draw the screen frame on the screen
7797             10 104 ;
7797             10 105 ; Input:    -
7797             10 106 ;
7797             10 107 ; Output:   -
7797             10 108 ;
7797             10 109 ; Destroys: A, BC, DE, HL, IX
7797             10 110 ; ----------------------------------------------------------------------------------------------------------------------
7797             10 111 Screen_Frame:
7797 11 2B 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
779A 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
779D CD 8C 6F    10 114 call    Print_String                ; print "Level"
77A0 CD DC 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
77A3 01 90 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
77A6 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
77A9 CD AF 77    10 119 call    Screen_Frame_Border         ; draw up-border
77AC 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
77AF             10 121 Screen_Frame_Border:
77AF DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
77B2             10 123 Screen_Frame_Loop
77B2 0A          10 124 ld      a, (bc)                     ; get tile index
77B3 FE FF       10 125 cp      -1                          ; is it -1?
77B5 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
77B7 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
77BA CD 9B 6F    10 128 call    Print_Tile                  ; print frame tile
77BD             10 129 Screen_Frame_Next
77BD 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77BE 03          10 131 inc     bc                          ; BC points to the next tile index
77BF DD 2D       10 132 dec     ixl                         ; decrement loop counter
77C1 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77C3 DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77C7 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77CB DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77CF DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77D3 DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77D7 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77DB C9          10 141 ret
77DC             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77DC             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77DC             10 145 ;
77DC             10 146 ; Input:    -
77DC             10 147 ;
77DC             10 148 ; Output:   -
77DC             10 149 ;
77DC             10 150 ; Destroys: A, BC, HL
77DC             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77DC             10 152 Screen_Vertical_Bars:
77DC 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
77DF CD E5 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
77E2 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
77E5             10 156 Screen_Vertical_Bar:
77E5 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
77E7             10 158 Screen_Vertical_Loop
77E7 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
77E9 CD 15 6E    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
77EC 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
77EE C9          10 162 ret
77EF             10 164 ; ----------------------------------------------------------------------------------------------------------------------
77EF             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
77EF             10 166 ;
77EF             10 167 ; Input:    -
77EF             10 168 ;
77EF             10 169 ; Output:   -
77EF             10 170 ;
77EF             10 171 ; Uses:     TOKEN_COLOR (current token color)
77EF             10 172 ;
77EF             10 173 ; Destroys: A, BC, DE, HL, IX
77EF             10 174 ; ----------------------------------------------------------------------------------------------------------------------
77EF             10 175 Screen_Tokens:
77EF 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
77F1 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
77F4 CD FC 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
77F7 3E 02       10 180 ld      a, RED_COLOR                ; set token color
77F9 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
77FC             10 182 Screen_Tokens_Draw:
77FC 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77FF CD 24 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
7802 DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
7805 DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
7808 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
780B C3 F6 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
780E             10 190 ; ----------------------------------------------------------------------------------------------------------------------
780E             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
780E             10 192 ;
780E             10 193 ; Input:    -
780E             10 194 ;
780E             10 195 ; Output:   -
780E             10 196 ;
780E             10 197 ; Destroys: IX
780E             10 198 ; ----------------------------------------------------------------------------------------------------------------------
780E             10 199 Screen_Timer_Quotes:
780E DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
7812 DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7816 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
781A DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
781C DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7820 DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7824 DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
7827 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
782B DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
782F DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
7833 DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7837 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
783B DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
783D DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7841 DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7845 DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
7848 DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
784C DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
7850 C9          10 219 ret
7851             10 221 ; ----------------------------------------------------------------------------------------------------------------------
7851             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
7851             10 223 ;
7851             10 224 ; Input:    -
7851             10 225 ;
7851             10 226 ; Output:   -
7851             10 227 ;
7851             10 228 ; Destroys: BC, IX
7851             10 229 ; ----------------------------------------------------------------------------------------------------------------------
7851             10 230 Screen_Color_Statics:
7851 DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
7855 0E 07       10 232 ld      c, WHITE                    ; set color in C
7857 CD 81 78    10 233 call    Screen_Apply_Color          ; apply color
785A DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
785D 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
785F CD 81 78    10 236 call    Screen_Apply_Color          ; apply color
7862 DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7866 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
7868 CD 81 78    10 239 call    Screen_Apply_Color          ; apply color
786B DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
786E 0E 07       10 241 ld      c, WHITE                    ; set color in C
7870 CD 81 78    10 242 call    Screen_Apply_Color          ; apply color
7873 DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7877 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
7879 CD 81 78    10 245 call    Screen_Apply_Color          ; apply color
787C DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
787F 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
7881             10 248 Screen_Apply_Color:
7881 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
7883             10 250 Screen_Apply_Color_Loop:
7883 DD 71 00    10 251 ld      (ix+0), c                   ; apply color
7886 DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
7888 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
788A C9          10 254 ret
788B             10 256 ; ----------------------------------------------------------------------------------------------------------------------
788B             10 257 ; Screen_Last_Level: show last level screen and input game level
788B             10 258 ;
788B             10 259 ; Input:    -
788B             10 260 ;
788B             10 261 ; Output:   -
788B             10 262 ;
788B             10 263 ; Uses:     GAME_LEVEL (current game level)
788B             10 264 ;
788B             10 265 ; Destroys: A, BC, DE, HL, IX, IY
788B             10 266 ; ----------------------------------------------------------------------------------------------------------------------
788B             10 267 Screen_Last_Level:
788B 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
788E 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
7891 CD 8C 6F    10 270 call    Print_String                ; print "Press any key"
7894 DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
7898 01 38 0D    10 272 ld      bc, (13*256)+WHITE_PAPER    ; B = string length (loop counter), C = color attributes
789B CD 83 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
789E CD F8 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
78A1 CD 1F 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
78A4 CD 64 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
78A7 DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
78AB 01 C7 11    10 279 ld      bc, (17*256)+WHITE_FLASH1   ; B = string length (loop counter), C = color attributes
78AE CD 83 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
78B1 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
78B4 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
78B7 CD 8C 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
78BA DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78BE CD E3 76    10 285 call    Sound_FX                    ; play sound fx
78C1 F3          10 287 di                                  ; disable interrupts
78C2 DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78C6 01 07 1C    10 289 ld      bc, (28*256)+WHITE          ; B = string length (loop counter), C = color attributes
78C9 CD 83 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78CC 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78CF 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78D2 CD 8C 6F    10 293 call    Print_String                ; print "Well done!..."
78D5 DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78D8 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78DA CD 83 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78DD DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
78E1 DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
78E5 DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
78E9 13          10 300 inc     de                          ; move DE to next string address
78EA 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
78EC CD 8C 6F    10 302 call    Print_String                ; print "Choose..."
78EF             10 303 Screen_Choose_Level
78EF CD F8 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
78F2 FE 31       10 305 cp      '1'                         ; is it < '1' ?
78F4 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
78F6 FE 35       10 307 cp      '5'                         ; is it >= '5' ?
78F8 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
78FA D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
78FC 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
78FF 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
7900 C9          10 312 ret
7901             10 314 ; ----------------------------------------------------------------------------------------------------------------------
7901             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
7901             10 316 ;
7901             10 317 ; Input:    -
7901             10 318 ;
7901             10 319 ; Output:   -
7901             10 320 ;
7901             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
7901             10 322 ;           THREE_ROW (three-in-a-row counter)
7901             10 323 ;
7901             10 324 ; Destroys: A, C, HL, IX
7901             10 325 ; ----------------------------------------------------------------------------------------------------------------------
7901             10 326 Screen_ThreeRow:
7901 21 9C 61    10 327 ld      hl, LEVEL_COLOR             ; HL points to level color address
7904 4E          10 328 ld      c, (hl)                     ; save level color in C
7905 CD 1D 79    10 329 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7908 3A 11 62    10 330 ld      a, (THREE_ROW)              ; A = three-in-a-row counter
790B B7          10 331 or      a                           ; is it 0?
790C C8          10 332 ret     z                           ; yes, return
790D 3D          10 333 dec     a                           ; is it 1?
790E 28 09       10 334 jr      z, Screen_ThreeRow_1        ; yes, color first mark
7910 3D          10 335 dec     a                           ; is it 2?
7911 28 03       10 336 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
7913 DD 71 00    10 337 ld      (ix+0), c                   ; color 3rd mark
7916             10 338 Screen_ThreeRow_2
7916 DD 71 01    10 339 ld      (ix+1), c                   ; color 2nd mark
7919             10 340 Screen_ThreeRow_1
7919 DD 71 02    10 341 ld      (ix+2), c                   ; color 1st mark
791C C9          10 342 ret
791D             10 344 ; ----------------------------------------------------------------------------------------------------------------------
791D             10 345 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
791D             10 346 ;
791D             10 347 ; Input:    -
791D             10 348 ;
791D             10 349 ; Output:   IX = three-in-a-row marks attribute address
791D             10 350 ;
791D             10 351 ; Destroys: -
791D             10 352 ; ----------------------------------------------------------------------------------------------------------------------
791D             10 353 Screen_Clear_ThreeRow:
791D DD 21 F2 5A 10 354 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
7921 DD 36 00 01 10 355 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
7925 DD 36 01 01 10 356 ld      (ix+1), BLUE_INK
7929 DD 36 02 01 10 357 ld      (ix+2), BLUE_INK
792D C9          10 358 ret
792E             10 360 ; ----------------------------------------------------------------------------------------------------------------------
792E             10 361 ; Screen_Frame_Color: set up frame color and print level number depending on current level
792E             10 362 ;
792E             10 363 ; Input:    HL = game level address
792E             10 364 ;
792E             10 365 ; Output:   -
792E             10 366 ;
792E             10 367 ; Uses:     LEVEL_COLOR (current level color for frame border)
792E             10 368 ;
792E             10 369 ; Destroys: A, BC, DE, HL
792E             10 370 ; ----------------------------------------------------------------------------------------------------------------------
792E             10 371 Screen_Frame_Color:
792E 06 00       10 372 ld      b, 0                        ; set game level in BC
7930 4E          10 373 ld      c, (hl)
7931 3E 30       10 374 ld      a, $30                      ; convert game level number to game level character
7933 81          10 375 add     a, c
7934 21 0F 40    10 376 ld      hl, $400F                   ; HL points to screen address of game level
7937 CD 98 6F    10 377 call    Print_Char                  ; print game level
793A 21 11 62    10 378 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
793D 09          10 379 add     hl, bc                      ; use BC as index for color map address
793E 7E          10 380 ld      a, (hl)                     ; A = level color
793F CD 54 79    10 381 call    Screen_Tiles_Color          ; color the frame according to the current level
7942 E6 07       10 382 and     %00000111                   ; mask color
7944 32 9C 61    10 383 ld      (LEVEL_COLOR), a            ; save masked color
7947 17          10 384 rla                                 ; rotate to text level color
7948 17          10 385 rla
7949 17          10 386 rla
794A 21 08 58    10 387 ld      hl, $5808                   ; HL points to attribute address of level text
794D 06 09       10 388 ld      b, 9                        ; length of level text (loop counter)
794F             10 389 Screen_Level_Loop
794F 77          10 390 ld      (hl), a                     ; apply color to level text
7950 2C          10 391 inc     l                           ; HL points to attr address of next character of level text
7951 10 FC       10 392 djnz    Screen_Level_Loop           ; repeat for each character of level text
7953 C9          10 393 ret
7954             10 395 ; ----------------------------------------------------------------------------------------------------------------------
7954             10 396 ; Screen_Tiles_Color: apply color to the frame tiles
7954             10 397 ;
7954             10 398 ; Input:    A = color to apply
7954             10 399 ;
7954             10 400 ; Output:   -
7954             10 401 ;
7954             10 402 ; Destroys: BC, DE, HL
7954             10 403 ; ----------------------------------------------------------------------------------------------------------------------
7954             10 404 Screen_Tiles_Color:
7954             10 405 ; color up row
7954 21 01 58    10 407 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
7957 06 06       10 408 ld      b, 6                        ; number of tiles (loop counter)
7959             10 409 Screen_Tiles_URow1
7959 77          10 410 ld      (hl), a                     ; apply color
795A 2C          10 411 inc     l                           ; move HL to the next attribute address
795B 10 FC       10 412 djnz    Screen_Tiles_URow1          ; repeat for each tile
795D 2E 12       10 413 ld      l, $12                      ; move HL to the next attribute address
795F 06 0D       10 414 ld      b, 13                       ; number of tiles (loop counter)
7961             10 415 Screen_Tiles_URow2
7961 77          10 416 ld      (hl), a                     ; apply color
7962 2C          10 417 inc     l                           ; move HL to the next attribute address
7963 10 FC       10 418 djnz    Screen_Tiles_URow2          ; repeat for each tile
7965             10 420 ; color vertical bars
7965 2E 00       10 422 ld      l, 0                        ; move HL to the next attribute address
7967 11 1F 00    10 423 ld      de, 31                      ; attribute address displacement (for each bar)
796A 0E 03       10 424 ld      c, 3                        ; number of screen thirds (outer loop counter)
796C             10 425 Screen_Tiles_VBar1
796C 06 08       10 426 ld      b, 8                        ; number of tiles (inner loop counter)
796E             10 427 Screen_Tiles_VBar2
796E 77          10 428 ld      (hl), a                     ; apply color
796F 19          10 429 add     hl, de                      ; move HL to the right column
7970 77          10 430 ld      (hl), a                     ; apply color
7971 2C          10 431 inc     l                           ; move HL to the next attribute address
7972 10 FA       10 432 djnz    Screen_Tiles_VBar2          ; repeat for each tile
7974 24          10 433 inc     h                           ; move HL to the next screen third
7975 0D          10 434 dec     c                           ; decrement number of thirds
7976 20 F4       10 435 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
7978             10 437 ; color bottom row
7978 21 E1 5A    10 439 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
797B 06 10       10 440 ld      b, 16                       ; number of tiles (loop counter)
797D             10 441 Screen_Tiles_BRow1
797D 77          10 442 ld      (hl), a                     ; apply color
797E 2C          10 443 inc     l                           ; move HL to the next attribute address
797F 10 FC       10 444 djnz    Screen_Tiles_BRow1          ; repeat for each tile
7981 2E F6       10 445 ld      l, $F6                      ; move HL to the next attribute address
7983 06 09       10 446 ld      b, 9                        ; number of tiles (loop counter)
7985             10 447 Screen_Tiles_BRow2
7985 77          10 448 ld      (hl), a                     ; apply color
7986 2C          10 449 inc     l                           ; move HL to the next attribute address
7987 10 FC       10 450 djnz    Screen_Tiles_BRow2          ; repeat for each tile
7989 C9          10 451 ret
798A             10 453 ; ----------------------------------------------------------------------------------------------------------------------
798A             10 454 ; Screen_Menu: show main menu and wait for an option
798A             10 455 ;
798A             10 456 ; Input:    -
798A             10 457 ;
798A             10 458 ; Output:   -
798A             10 459 ;
798A             10 460 ; Uses:     GAME_LEVEL (current game level)
798A             10 461 ;
798A             10 462 ; Destroys: A, BC, DE, HL, IX, IY
798A             10 463 ; ----------------------------------------------------------------------------------------------------------------------
798A             10 464 Screen_Menu:
798A CD 1F 77    10 465 call    Screen_Clear                ; fill in black the whole screen area and attributes area
798D CD 64 7C    10 466 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7990             10 467 Screen_Menu_Strings
7990 21 80 59    10 468 ld      hl, $5980                   ; HL points to menu text area attributes address
7993 11 81 59    10 469 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
7996 36 00       10 470 ld      (hl), 0                     ; set first attribute text area in black
7998 01 7F 01    10 471 ld      bc, (32*12)-1               ; length of text area attributes (-1 already set)
799B ED B0       10 472 ldir                                ; set the rest of text area attributes in black
799D DD 21 CA 59 10 474 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
79A1 DD 36 FF 78 10 475 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79A5 01 47 0D    10 476 ld      bc, (13*256)+WHITE_FLASH0   ; B = string length-1 (loop counter), C = color attributes
79A8 CD 83 78    10 477 call    Screen_Apply_Color_Loop     ; apply color to string area
79AB 11 80 67    10 478 ld      de, STR_OPTIONS             ; DE points to string address
79AE 21 C9 48    10 479 ld      hl, $48C9                   ; HL points to string screen address
79B1 CD 8C 6F    10 480 call    Print_String                ; print "Start new game"
79B4 DD 21 2A 5A 10 481 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
79B8 DD 36 FF 78 10 482 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79BC 06 0A       10 483 ld      b, 10                       ; string length-1 (loop counter)
79BE CD 83 78    10 484 call    Screen_Apply_Color_Loop     ; apply color to string area
79C1 13          10 485 inc     de                          ; move DE to "How to play" string address
79C2 21 29 50    10 486 ld      hl, $5029                   ; HL points to string screen address
79C5 CD 8C 6F    10 487 call    Print_String                ; print "How to play"
79C8 DD 2E 8A    10 488 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79CB DD 36 FF 78 10 489 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79CF CD 81 78    10 490 call    Screen_Apply_Color          ; apply color to string area
79D2 13          10 491 inc     de                          ; move DE to "Credits" string address
79D3 2E 89       10 492 ld      l, $89                      ; HL points to string screen address
79D5 CD 8C 6F    10 493 call    Print_String                ; print "Credits"
79D8             10 494 Screen_Menu_Options
79D8 CD F8 6E    10 495 call    Input_Key_Scan              ; wait for a key pressed
79DB FE 73       10 496 cp      's'                         ; is it 's'?
79DD C8          10 497 ret     z                           ; yes, return
79DE FE 63       10 498 cp      'c'                         ; is it 'c'?
79E0 CA F4 7B    10 499 jp      z, Screen_Menu_Credits      ; yes, show credits
79E3 FE 68       10 500 cp      'h'                         ; is it 'h'?
79E5 20 F1       10 501 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
79E7             10 503 ; ----------------------------------------------------------------------------------------------------------------------
79E7             10 504 ; Show "How to play" pages
79E7             10 505 ; ----------------------------------------------------------------------------------------------------------------------
79E7             10 506 Screen_Menu_How2Play
79E7 CD 1F 77    10 507 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79EA CD 2C 77    10 508 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
79ED CD 58 77    10 509 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
79F0 CD 97 77    10 510 call    Screen_Frame                ; draw the screen frame
79F3 21 9D 61    10 512 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
79F6 34          10 513 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
79F7 CD 2E 79    10 514 call    Screen_Frame_Color          ; set up frame color depending on current level
79FA CD 1D 79    10 515 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
79FD 11 4A 68    10 517 ld      de, STR_BUTTONS             ; DE points to "Next" string address
7A00 21 DB 50    10 518 ld      hl, $50DB                   ; HL points to string screen address
7A03 CD 8C 6F    10 519 call    Print_String                ; print "Next"
7A06 13          10 520 inc     de                          ; move DE to "Back" string address
7A07 21 C1 50    10 521 ld      hl, $50C1                   ; HL points to string screen address
7A0A CD 8C 6F    10 522 call    Print_String                ; print "Back"
7A0D             10 524 Screen_How2Play_RED
7A0D 21 5E 58    10 525 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7A10 CD 9E 7C    10 526 call    Screen_Clear_Text           ; clear text area attributes
7A13 CD A4 6D    10 527 call    Draw_Board                  ; draw an empty hexagons board
7A16             10 529 ; text for RED
7A16 DD 21 01 5A 10 531 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
7A1A 01 07 07    10 532 ld      bc, (7*256)+WHITE           ; B = string length (loop counter), C = color attributes
7A1D CD 83 78    10 533 call    Screen_Apply_Color_Loop     ; apply color to string area
7A20 11 5D 68    10 534 ld      de, STR_HELP1               ; DE points to string address
7A23 21 01 50    10 535 ld      hl, $5001                   ; HL points to string screen address
7A26 CD 8C 6F    10 536 call    Print_String                ; print "Connect"
7A29 DD 2E 21    10 537 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A2C 06 08       10 538 ld      b, 8                        ; string length (loop counter)
7A2E CD 83 78    10 539 call    Screen_Apply_Color_Loop     ; apply color to string area
7A31 13          10 540 inc     de                          ; move DE to "left and" string address
7A32 2E 21       10 541 ld      l, $21                      ; HL points to string screen address
7A34 CD 8C 6F    10 542 call    Print_String                ; print "left and"
7A37 DD 2E 41    10 543 ld      ixl, $41                    ; IX points to "right" string attributes address
7A3A 06 05       10 544 ld      b, 5                        ; set string length (loop counter)
7A3C CD 83 78    10 545 call    Screen_Apply_Color_Loop     ; apply color to string area
7A3F 11 75 68    10 546 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A42 2E 41       10 547 ld      l, $41                      ; HL points to string screen address
7A44 CD 8C 6F    10 548 call    Print_String                ; print "right"
7A47 DD 2E 61    10 549 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A4A 06 07       10 550 ld      b, 7                        ; set string length (loop counter)
7A4C CD 83 78    10 551 call    Screen_Apply_Color_Loop     ; apply color to string area
7A4F 11 80 68    10 552 ld      de, STR_HELP4               ; DE points to "borders" string address
7A52 2E 61       10 553 ld      l, $61                      ; HL points to string screen address
7A54 CD 8C 6F    10 554 call    Print_String                ; print "borders"
7A57 DD 2E 81    10 555 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A5A CD 81 78    10 556 call    Screen_Apply_Color          ; apply color to string area
7A5D 13          10 557 inc     de                          ; move DE to "to win" string address
7A5E 2E 81       10 558 ld      l, $81                      ; HL points to string screen address
7A60 CD 8C 6F    10 559 call    Print_String                ; print "to win"
7A63 DD 21 E3 59 10 560 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A67 01 42 03    10 561 ld      bc, (3*256)+RED_COLOR+BRIGHT; B = string length (loop counter), C = color attributes
7A6A CD 83 78    10 562 call    Screen_Apply_Color_Loop     ; apply color to string area
7A6D 11 54 68    10 563 ld      de, STR_RED                 ; DE points to "RED" string address
7A70 21 E3 48    10 564 ld      hl, $48E3                   ; HL points to string screen address
7A73 CD 8C 6F    10 565 call    Print_String                ; print "RED"
7A76             10 567 ; draw RED sample board
7A76 FD 21 3A 67 10 569 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A7A 11 3E 66    10 570 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A7D 06 07       10 571 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A7F 3E 42       10 572 ld      a, RED_COLOR+BRIGHT         ; set token color
7A81 32 9E 61    10 573 ld      (TOKEN_COLOR), a            ; save token color
7A84 CD 89 7C    10 574 call    Screen_Hexagons_Loop        ; draw tokens
7A87 06 02       10 575 ld      b, 2                        ; number of red tokens (loop counter)
7A89 3E 02       10 576 ld      a, RED_COLOR                ; set token color
7A8B 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7A8E CD 89 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7A91 06 09       10 579 ld      b, 9                        ; number of cyan tokens (loop counter)
7A93 3E 05       10 580 ld      a, CYAN_COLOR               ; set token color
7A95 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7A98 CD 89 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7A9B             10 584 ; wait for "Next" option pressed
7A9B DD 21 C1 5A 10 586 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A9F 01 00 04    10 587 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7AA2 CD 83 78    10 588 call    Screen_Apply_Color_Loop     ; hide "Back" string
7AA5 DD 2E DC    10 589 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7AA8 DD 36 FF 78 10 590 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7AAC 01 47 03    10 591 ld      bc, (3*256)+WHITE_FLASH0    ; B = string length-1 (loop counter), C = color attributes
7AAF CD 83 78    10 592 call    Screen_Apply_Color_Loop     ; apply color to string area
7AB2             10 593 Screen_How2PlayRED_End
7AB2 CD F8 6E    10 594 call    Input_Key_Scan              ; wait for a key pressed
7AB5 FE 6E       10 595 cp      'n'                         ; is it 'n'?
7AB7 20 F9       10 596 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7AB9             10 598 Screen_How2Play_CYAN
7AB9 21 0F 58    10 599 ld      hl, $580F                   ; HL points to level number attribute address
7ABC CB BE       10 600 res     7, (hl)                     ; reset flash attribute
7ABE 26 40       10 601 ld      h, $40                      ; HL points to level number screen address
7AC0 3E 31       10 602 ld      a, '1'                      ; set level number (char)
7AC2 CD 98 6F    10 603 call    Print_Char                  ; print '1'
7AC5 CD 1D 79    10 604 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7AC8 21 C9 59    10 606 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7ACB CD 9E 7C    10 607 call    Screen_Clear_Text           ; clear text area attributes
7ACE CD A4 6D    10 608 call    Draw_Board                  ; draw an empty hexagons board
7AD1             10 610 ; text for CYAN
7AD1 DD 21 98 58 10 612 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7AD5 01 07 07    10 613 ld      bc, (7*256)+WHITE           ; B = string length (loop counter), C = color attributes
7AD8 CD 83 78    10 614 call    Screen_Apply_Color_Loop     ; apply color to string area
7ADB 11 5D 68    10 615 ld      de, STR_HELP1               ; DE points to "Connect" string address
7ADE 21 98 40    10 616 ld      hl, $4098                   ; HL points to string screen address
7AE1 CD 8C 6F    10 617 call    Print_String                ; print "Connect"
7AE4 DD 2E B9    10 618 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7AE7 CD 81 78    10 619 call    Screen_Apply_Color          ; apply color to string area
7AEA 11 6E 68    10 620 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7AED 2E B9       10 621 ld      l, $B9                      ; HL points to string screen address
7AEF CD 8C 6F    10 622 call    Print_String                ; print "up and"
7AF2 DD 2E DB    10 623 ld      ixl, $DB                    ; IX points to "down" string attributes address
7AF5 06 04       10 624 ld      b, 4                        ; string length (loop counter)
7AF7 CD 83 78    10 625 call    Screen_Apply_Color_Loop     ; apply color to string area
7AFA 11 7B 68    10 626 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7AFD 2E DB       10 627 ld      l, $DB                      ; HL points to string screen address
7AFF CD 8C 6F    10 628 call    Print_String                ; print "down"
7B02 DD 2E F8    10 629 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7B05 06 07       10 630 ld      b, 7                        ; string length (loop counter)
7B07 CD 83 78    10 631 call    Screen_Apply_Color_Loop     ; apply color to string area
7B0A 13          10 632 inc     de                          ; move DE to "borders" string address
7B0B 2E F8       10 633 ld      l, $F8                      ; HL points to string screen address
7B0D CD 8C 6F    10 634 call    Print_String                ; print "borders"
7B10 DD 21 19 59 10 635 ld      ix, $5919                   ; IX points to "to win" string attributes address
7B14 CD 81 78    10 636 call    Screen_Apply_Color          ; apply color to string area
7B17 13          10 637 inc     de                          ; move DE to "to win" string address
7B18 21 19 48    10 638 ld      hl, $4819                   ; HL points to string screen address
7B1B CD 8C 6F    10 639 call    Print_String                ; print "to win"
7B1E DD 21 7A 58 10 640 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B22 01 45 04    10 641 ld      bc, $0445                   ; B = string length (loop counter)
7B25             10 642 ; C = color attributes (cyan+bright)
7B25 CD 83 78    10 643 call    Screen_Apply_Color_Loop     ; apply color to string area
7B28 11 58 68    10 644 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B2B 21 7A 40    10 645 ld      hl, $407A                   ; HL points to string screen address
7B2E CD 8C 6F    10 646 call    Print_String                ; print "CYAN"
7B31             10 648 ; draw CYAN sample board
7B31 FD 21 5E 67 10 650 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B35 11 3E 66    10 651 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B38 06 07       10 652 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B3A 3E 45       10 653 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B3C 32 9E 61    10 654 ld      (TOKEN_COLOR), a            ; save token color
7B3F CD 89 7C    10 655 call    Screen_Hexagons_Loop        ; draw tokens
7B42 06 02       10 656 ld      b, 2                        ; number of cyan tokens (loop counter)
7B44 3E 05       10 657 ld      a, CYAN_COLOR               ; set token color
7B46 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B49 CD 89 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B4C 06 08       10 660 ld      b, 8                        ; number of red tokens (loop counter)
7B4E 3E 02       10 661 ld      a, RED_COLOR                ; set token color
7B50 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B53 CD 89 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B56             10 665 ; wait for "Next" or "Back" options pressed
7B56 DD 21 C2 5A 10 667 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B5A DD 36 FF 78 10 668 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B5E 01 47 03    10 669 ld      bc, (3*256)+WHITE_FLASH0    ; B = string length (-1), C = color attributes
7B61 CD 83 78    10 670 call    Screen_Apply_Color_Loop     ; apply color to string area
7B64             10 671 Screen_How2PlayCYAN_End
7B64 CD F8 6E    10 672 call    Input_Key_Scan              ; wait for a key pressed
7B67 FE 62       10 673 cp      'b'                         ; is it 'b'?
7B69 CA 0D 7A    10 674 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B6C FE 6E       10 675 cp      'n'                         ; is it 'n'?
7B6E 20 F4       10 676 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B70             10 678 Screen_How2Play_LevelUp
7B70 21 5E 58    10 679 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B73 CD 9E 7C    10 680 call    Screen_Clear_Text           ; clear text area attributes
7B76             10 682 ; text for Level Up
7B76 DD 21 21 5A 10 684 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B7A 01 07 09    10 685 ld      bc, (9*256)+WHITE           ; B = string length (loop counter), C = color attributes
7B7D CD 83 78    10 686 call    Screen_Apply_Color_Loop     ; apply color to string area
7B80 11 8F 68    10 687 ld      de, STR_HELP                ; DE points to "Win three" string address
7B83 21 21 50    10 688 ld      hl, $5021                   ; HL points to string screen address
7B86 CD 8C 6F    10 689 call    Print_String                ; print "Win three"
7B89 DD 2E 41    10 690 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B8C 06 08       10 691 ld      b, 8                        ; string length (loop counter)
7B8E CD 83 78    10 692 call    Screen_Apply_Color_Loop     ; apply color to string area
7B91 13          10 693 inc     de                          ; move DE to "times in" string address
7B92 2E 41       10 694 ld      l, $41                      ; HL points to string screen address
7B94 CD 8C 6F    10 695 call    Print_String                ; print "times in"
7B97 DD 2E 61    10 696 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B9A 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7B9C CD 83 78    10 698 call    Screen_Apply_Color_Loop     ; apply color to string area
7B9F 13          10 699 inc     de                          ; move DE to "a row to" string address
7BA0 2E 61       10 700 ld      l, $61                      ; HL points to string screen address
7BA2 CD 8C 6F    10 701 call    Print_String                ; print "a row to"
7BA5 DD 2E 81    10 702 ld      ixl, $81                    ; IX points to "level up" string attributes address
7BA8 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7BAA CD 83 78    10 704 call    Screen_Apply_Color_Loop     ; apply color to string area
7BAD 13          10 705 inc     de                          ; move DE to "level up" string address
7BAE 2E 81       10 706 ld      l, $81                      ; HL points to string screen address
7BB0 CD 8C 6F    10 707 call    Print_String                ; print "level up"
7BB3             10 709 ; reset bright of cyan tokens
7BB3 FD 21 5E 67 10 711 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7BB7 11 3E 66    10 712 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7BBA 06 07       10 713 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7BBC 3E 05       10 714 ld      a, CYAN_COLOR               ; set new token color
7BBE 32 9E 61    10 715 ld      (TOKEN_COLOR), a            ; save color
7BC1 CD 89 7C    10 716 call    Screen_Hexagons_Loop        ; draw tokens
7BC4             10 718 ; set flash attribute of level number and three-in-a-row marks
7BC4 21 0F 58    10 720 ld      hl, $580F                   ; HL points to level number attribute address
7BC7 CB FE       10 721 set     7, (hl)                     ; set flash attribute
7BC9 21 0F 40    10 722 ld      hl, $400F                   ; HL points to level number screen address
7BCC 3E 32       10 723 ld      a, '2'                      ; set new level
7BCE CD 98 6F    10 724 call    Print_Char                  ; print new level
7BD1 DD 21 F2 5A 10 725 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BD5 DD 36 00 B8 10 726 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BD9 DD 36 01 B8 10 727 ld      (ix+1), WHITE_PAPER+FLASH
7BDD DD 36 02 B8 10 728 ld      (ix+2), WHITE_PAPER+FLASH
7BE1             10 730 ; wait for "Next" or "Back" options pressed
7BE1             10 732 Screen_How2Play_End
7BE1 CD F8 6E    10 733 call    Input_Key_Scan              ; wait for a key pressed
7BE4 FE 62       10 734 cp      'b'                         ; is it 'b'?
7BE6 CA B9 7A    10 735 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7BE9 FE 6E       10 736 cp      'n'                         ; is it 'n'?
7BEB 20 F4       10 737 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7BED 21 9D 61    10 739 ld      hl, GAME_LEVEL              ; HL points to game level address
7BF0 35          10 740 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7BF1 C3 8A 79    10 741 jp      Screen_Menu                 ; return to main menu
7BF4             10 743 ; ----------------------------------------------------------------------------------------------------------------------
7BF4             10 744 ; Show credits
7BF4             10 745 ; ----------------------------------------------------------------------------------------------------------------------
7BF4             10 746 Screen_Menu_Credits
7BF4 DD 21 84 59 10 747 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7BF8 01 47 19    10 748 ld      bc, (25*256)+WHITE_FLASH0   ; B = string length (loop counter), C = color attributes
7BFB CD 83 78    10 749 call    Screen_Apply_Color_Loop     ; apply color to string area
7BFE 11 A3 67    10 750 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7C01 21 84 48    10 751 ld      hl, $4884                   ; HL points to string screen address
7C04 CD 8C 6F    10 752 call    Print_String                ; print "Design..."
7C07 DD 2E C4    10 753 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7C0A 06 19       10 754 ld      b, 25                       ; string length (loop counter)
7C0C CD 83 78    10 755 call    Screen_Apply_Color_Loop     ; apply color to string area
7C0F 13          10 756 inc     de                          ; move DE to to "Code..." string address
7C10 2E C4       10 757 ld      l, $C4                      ; HL points to string screen address
7C12 CD 8C 6F    10 758 call    Print_String                ; print "Code..."
7C15 DD 2E E4    10 759 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7C18 06 18       10 760 ld      b, 24                       ; string length (loop counter)
7C1A CD 83 78    10 761 call    Screen_Apply_Color_Loop     ; apply color to string area
7C1D 13          10 762 inc     de                          ; move DE to "Einar Saukas" string address
7C1E 2E E4       10 763 ld      l, $E4                      ; HL points to string screen address
7C20 CD 8C 6F    10 764 call    Print_String                ; print "Einar Saukas"
7C23 DD 21 24 5A 10 765 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C27 06 18       10 766 ld      b, 24                       ; string length (loop counter)
7C29 CD 83 78    10 767 call    Screen_Apply_Color_Loop     ; apply color to string area
7C2C 13          10 768 inc     de                          ; move DE to "Font..." string address
7C2D 21 24 50    10 769 ld      hl, $5024                   ; HL points to string screen address
7C30 CD 8C 6F    10 770 call    Print_String                ; print "Font..."
7C33 DD 2E 64    10 771 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C36 06 18       10 772 ld      b, 24                       ; string length (loop counter)
7C38 CD 83 78    10 773 call    Screen_Apply_Color_Loop     ; apply color to string area
7C3B 13          10 774 inc     de                          ; move DE to "Graphics..." string address
7C3C 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7C3E CD 8C 6F    10 776 call    Print_String                ; print "Graphics..."
7C41 DD 2E 84    10 777 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C44 06 19       10 778 ld      b, 25                       ; string length (loop counter)
7C46 CD 83 78    10 779 call    Screen_Apply_Color_Loop     ; apply color to string area
7C49 13          10 780 inc     de                          ; move DE to "Antonio Luque" string address
7C4A 2E 84       10 781 ld      l, $84                      ; HL points to string screen address
7C4C CD 8C 6F    10 782 call    Print_String                ; print "Antonio Luque"
7C4F DD 2E E9    10 783 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C52 01 38 0D    10 784 ld      bc, (13*256)+WHITE_PAPER    ; B = string length (loop counter), C = color attributes
7C55 CD 83 78    10 785 call    Screen_Apply_Color_Loop     ; apply color to string area
7C58 13          10 786 inc     de                          ; move DE to "Press any key" string address
7C59 2E E9       10 787 ld      l, $E9                      ; HL points to string screen address
7C5B CD 8C 6F    10 788 call    Print_String                ; print "Press any key"
7C5E CD F8 6E    10 789 call    Input_Key_Scan              ; wait for a key pressed
7C61 C3 90 79    10 790 jp      Screen_Menu_Strings         ; return to main menu
7C64             10 792 ; ----------------------------------------------------------------------------------------------------------------------
7C64             10 793 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C64             10 794 ;
7C64             10 795 ; Input:    -
7C64             10 796 ;
7C64             10 797 ; Output:   -
7C64             10 798 ;
7C64             10 799 ; Uses:     TOKEN_COLOR (current token color)
7C64             10 800 ;
7C64             10 801 ; Destroys: A, BC, DE, HL, IX, IY
7C64             10 802 ; ----------------------------------------------------------------------------------------------------------------------
7C64             10 803 Screen_Hexagons:
7C64 FD 21 EA 66 10 804 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C68 3E 07       10 805 ld      a, WHITE                    ; set hexagon color
7C6A 32 9E 61    10 806 ld      (TOKEN_COLOR), a            ; save hexagon color
7C6D 11 7E 65    10 807 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C70 06 1C       10 808 ld      b, 28                       ; number of empty hexagons (loop counter)
7C72 CD 89 7C    10 809 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C75 3E 05       10 810 ld      a, CYAN_COLOR               ; set token color
7C77 32 9E 61    10 811 ld      (TOKEN_COLOR), a            ; save hexagon color
7C7A 11 3E 66    10 812 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C7D 06 06       10 813 ld      b, 6                        ; number of cyan tokens (loop counter)
7C7F CD 89 7C    10 814 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C82 3E 02       10 815 ld      a, RED_COLOR                ; set token color
7C84 32 9E 61    10 816 ld      (TOKEN_COLOR), a            ; save hexagon color
7C87 06 06       10 817 ld      b, 6                        ; number of red tokens (loop counter)
7C89             10 818 Screen_Hexagons_Loop:
7C89 FD 6E 00    10 819 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C8C FD 66 01    10 820 ld      h, (iy+1)
7C8F CD 24 6E    10 821 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C92 D5          10 822 push    de                          ; store hexagon/token sprite address
7C93 CD F6 6D    10 823 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C96 D1          10 824 pop     de                          ; restore hexagon/token sprite address
7C97 FD 23       10 825 inc     iy                          ; move IY to next hexagon/token screen address
7C99 FD 23       10 826 inc     iy
7C9B 10 EC       10 827 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C9D C9          10 828 ret
7C9E             10 830 ; ----------------------------------------------------------------------------------------------------------------------
7C9E             10 831 ; Screen_Clear_Text: clean a text attributes area
7C9E             10 832 ;
7C9E             10 833 ; Input:    HL = text area attributes address
7C9E             10 834 ;
7C9E             10 835 ; Output:   -
7C9E             10 836 ;
7C9E             10 837 ; Destroys: BC, DE, HL
7C9E             10 838 ; ----------------------------------------------------------------------------------------------------------------------
7C9E             10 839 Screen_Clear_Text:
7C9E 01 30 00    10 840 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7CA1             10 841 Screen_ClearText_Loop
7CA1 11 18 00    10 842 ld      de, 24                      ; displacement for each text row
7CA4 19          10 843 add     hl, de                      ; add displacement to text area attributes address
7CA5 54          10 844 ld      d, h                        ; DE points to text area attributes address
7CA6 5D          10 845 ld      e, l
7CA7 36 00       10 846 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7CA9 13          10 847 inc     de                          ; move DE to next byte attribute address
7CAA ED A0       10 848 ldi                                 ; set attributes color for the rest of bytes of current row
7CAC ED A0       10 849 ldi
7CAE ED A0       10 850 ldi
7CB0 ED A0       10 851 ldi
7CB2 ED A0       10 852 ldi
7CB4 ED A0       10 853 ldi
7CB6 ED A0       10 854 ldi
7CB8 ED A0       10 855 ldi
7CBA EA A1 7C    10 856 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7CBD C9          10 857 ret

; File #0: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Hex2.z80asm

7CBE             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CBE             0 20 ; Credits and acknowledgements:
7CBE             0 21 ;
7CBE             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CBE             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CBE             0 24 ;   "King+" font and TOKEN graphics.
7CBE             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CBE             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CBE             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CBE             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CBE             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CBE             0 30 ;
7CBE             0 31 ; - Special thanks to my wife Sonia.
7CBE             0 32 ; ----------------------------------------------------------------------------------------------------------------------
