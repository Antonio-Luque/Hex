
; File #0: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   org     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         defs    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 defb                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 defb    0                           ; board potential
6198 00          1 51 defb    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               defb    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                defb    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             defb    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             defb    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              defb    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             defb    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            defb    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 defb    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 defb    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 defb    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 defb    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 defb    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 defb    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 defb    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 defm    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;org     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 A2 73       1 85 defw    PathFinder_CYAN_Edge_0
6202 C2 73       1 86 defw    PathFinder_CYAN_Edge_1
6204 DD 73       1 87 defw    PathFinder_CYAN_Edge_2
6206 FB 73       1 88 defw    PathFinder_CYAN_Edge_3
6208 1A 74       1 89 defw    PathFinder_CYAN_Edge_4
620A 38 74       1 90 defw    PathFinder_CYAN_Edge_5
620C 53 74       1 91 defw    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 96 PLAYER_MOVE:                                                ; player move in ASCII format
620E 00          1 97 defb    0                           ; column ('a'..'g')
620F 00          1 98 defb    0                           ; row ('1'..'7')
6210 00          1 99 CHAR_COUNT              defb    0                           ; number of current characters in input player move
6211 00          1 100 THREE_ROW               defb    0                           ; three-in-a-row counter
6212 0F 0E 0C 0B 1 101 ROW_COLOR_MAP           defb    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6216 0D 0A       1 101 
6218 00 2D 30 00 1 102 STR_MOVE                defb    0, '-', '0', 0, '\0'        ; formatted move string
621C 00          1 102 
621D 53 70 65 63 1 103 STR_SPECCY              defm    "Speccy\0"
6221 63 79 00    1 103 
6224 50 6C 61 79 1 104 STR_PLAYER              defm    "Player\0"
6228 65 72 00    1 104 
622B 4C 65 76 65 1 105 STR_LEVELTEXT           defm    "Level\0"
622F 6C 00       1 105 
6231 46 49 4C 4C 1 106 STR_FILLED              defm    "FILLED\0"
6235 45 44 00    1 106 
6238 57 41 49 54 1 107 STR_WAIT                defm    "WAIT\0"
623C 00          1 107 
623D 20 57 49 4E 1 108 STR_WINNER              defm    " WINS \0"
6241 53 20 00    1 108 
6244 20 20 20 20 1 109 STR_EMPTY4              defm    "    \0"
6248 00          1 109 
6249 20 20 20 20 1 110 STR_EMPTY6              defm    "      \0"
624D 20 20 00    1 110 
6250             1 112 ; ----------------------------------------------------------------------------------------------------------------------
6250             1 113 ; Conversion table: from position to XY board indexes
6250             1 114 ; ----------------------------------------------------------------------------------------------------------------------
6250             1 115 BOARD_COORDINATES:
6250 00 00 00 00 1 116 defb    $00, $00, $00, $00, $00, $00, $00, $00
6254 00 00 00 00 1 116 
6258 00 09 0A 0B 1 117 defb    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
625C 0C 0D 0E 0F 1 117 
6260 00 12 13 14 1 118 defb    $00, $12, $13, $14, $15, $16, $17, $18
6264 15 16 17 18 1 118 
6268 00 1B 1C 1D 1 119 defb    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
626C 1E 1F 20 21 1 119 
6270 00 24 25 26 1 120 defb    $00, $24, $25, $26, $27, $28, $29, $2A
6274 27 28 29 2A 1 120 
6278 00 2D 2E 2F 1 121 defb    $00, $2D, $2E, $2F, $30, $31, $32, $33
627C 30 31 32 33 1 121 
6280 00 36 37 38 1 122 defb    $00, $36, $37, $38, $39, $3A, $3B, $3C
6284 39 3A 3B 3C 1 122 
6288 00 3F 40 41 1 123 defb    $00, $3F, $40, $41, $42, $43, $44, $45
628C 42 43 44 45 1 123 
6290             1 125 ; ----------------------------------------------------------------------------------------------------------------------
6290             1 126 ; Graphics map indexes for the frame tiles
6290             1 127 ; ----------------------------------------------------------------------------------------------------------------------
6290             1 128 FRAME_MAP:
6290 00 01 01 01 1 129 defb      0,   1,   1,   1,   1,   1,   2,   3
6294 01 01 02 03 1 129 
6298 04 FF FF FF 1 130 defb      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
629C FF FF FF FF 1 130 
62A0 05 06 07 01 1 131 defb      5,   6,   7,   1,   1,   1,   1,   1
62A4 01 01 01 01 1 131 
62A8 01 01 01 01 1 132 defb      1,   1,   1,   1,   1,   1,   1,   8
62AC 01 01 01 08 1 132 
62B0 09 01 01 01 1 133 defb      9,   1,   1,   1,   1,   1,   1,   1
62B4 01 01 01 01 1 133 
62B8 01 01 01 01 1 134 defb      1,   1,   1,   1,   1,   1,   1,   1
62BC 01 01 01 01 1 134 
62C0 0A 06 0D 0D 1 135 defb     10,   6,  13,  13,  13,   3,  11,   1
62C4 0D 03 0B 01 1 135 
62C8 01 01 01 01 1 136 defb      1,   1,   1,   1,   1,   1,   1,  12
62CC 01 01 01 0C 1 136 
62D0             1 138 ; ----------------------------------------------------------------------------------------------------------------------
62D0             1 139 ; Definition of a small "Opening Book" for speccy first move
62D0             1 140 ; ----------------------------------------------------------------------------------------------------------------------
62D0             1 141 OPENINGS:
62D0 0F 14 16 17 1 142 defb    $0F, $14, $16, $17, $18, $1C, $1D
62D4 18 1C 1D    1 142 
62D7 1E 1F 20 24 1 143 defb    $1E, $1F, $20, $24, $25, $26, $27
62DB 25 26 27    1 143 
62DE 28 29 2A 2E 1 144 defb    $28, $29, $2A, $2E, $2F, $30, $31
62E2 2F 30 31    1 144 
62E5 32 36 37 38 1 145 defb    $32, $36, $37, $38, $3A, $3F
62E9 3A 3F       1 145 
62EB             1 147 ; ----------------------------------------------------------------------------------------------------------------------
62EB             1 148 ; Timer variables
62EB             1 149 ; ----------------------------------------------------------------------------------------------------------------------
62EB 00          1 150 TIMER_FLAG              defb    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62EC             1 151 ; for each timer:
62EC             1 152 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62EC             1 153 ;   2nd byte = seconds counter
62EC             1 154 ;   3th byte = minutes counter
62EC 32 00 00    1 155 CYAN_TIMER              defb    50, 0, 0
62EF 32 00 00    1 156 RED_TIMER               defb    50, 0, 0
62F2             1 158 ; ----------------------------------------------------------------------------------------------------------------------
62F2             1 159 ; Screen addresses look-up array for board numbers
62F2             1 160 ; ----------------------------------------------------------------------------------------------------------------------
62F2             1 161 NUMBER_SCREEN:
62F2 A5 43 E6 43 1 162 defw    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F6 27 4B 68 4B 1 162 
62FA A9 4B EA 4B 1 162 
62FE 2B 53       1 162 
6300             1 164 ;org     $6300
6300             1 165 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 166 ; Circular queue
6300             1 167 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 168 RED_QUEUE_AREA          defs    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 168 
6308 00 00 00 00 1 168 
630C 00 00 00 00 1 168 
6310 00 00 00 00 1 168 
6314 00 00 00 00 1 168 
6318 00 00 00 00 1 168 
631C 00 00 00 00 1 168 
6320 00 00 00 00 1 168 
6324 00 00 00 00 1 168 
6328 00 00 00 00 1 168 
632C 00 00 00 00 1 168 
6330 00 00 00 00 1 168 
6334 00 00 00 00 1 168 
6338 00 00 00 00 1 168 
633C 00 00 00 00 1 168 
6340 00 00 00 00 1 168 
6344 00 00 00 00 1 168 
6348 00 00 00 00 1 168 
634C 00 00 00 00 1 168 
6350 00 00 00 00 1 168 
6354 00 00 00 00 1 168 
6358 00 00 00 00 1 168 
635C 00 00 00 00 1 168 
6360 00 00 00 00 1 168 
6364 00 00 00 00 1 168 
6368 00 00 00 00 1 168 
636C 00 00 00 00 1 168 
6370 00 00 00 00 1 168 
6374 00 00 00 00 1 168 
6378 00 00 00 00 1 168 
637C 00 00 00 00 1 168 
6380 00 00 00 00 1 168 
6384 00 00 00 00 1 168 
6388 00 00 00 00 1 168 
638C 00 00 00 00 1 168 
6390 00 00 00 00 1 168 
6394 00 00 00 00 1 168 
6398 00 00 00 00 1 168 
639C 00 00 00 00 1 168 
63A0 00 00 00 00 1 168 
63A4 00 00 00 00 1 168 
63A8 00 00 00 00 1 168 
63AC 00 00 00 00 1 168 
63B0 00 00 00 00 1 168 
63B4 00 00 00 00 1 168 
63B8 00 00 00 00 1 168 
63BC 00 00 00 00 1 168 
63C0 00 00 00 00 1 168 
63C4 00 00 00 00 1 168 
63C8 00 00 00 00 1 168 
63CC 00 00 00 00 1 168 
63D0 00 00 00 00 1 168 
63D4 00 00 00 00 1 168 
63D8 00 00 00 00 1 168 
63DC 00 00 00 00 1 168 
63E0 00 00 00 00 1 168 
63E4 00 00 00 00 1 168 
63E8 00 00 00 00 1 168 
63EC 00 00 00 00 1 168 
63F0 00 00 00 00 1 168 
63F4 00 00 00 00 1 168 
63F8 00 00 00 00 1 168 
63FC 00 00 00 00 1 168 
6400             1 170 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 171 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 172 ; 
6400             1 173 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 174 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 175 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 176 ; 
6400             1 177 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 178 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 179 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 180 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 181 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 182 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 182 
6408 7F 00 00 00 1 183 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 183 
6410 80          1 183 
6411 7F 00 00 00 1 184 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 184 
6419 81          1 184 
641A 7F 00 00 00 1 185 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 185 
6422 82          1 185 
6423 7F 00 00 00 1 186 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 186 
642B 83          1 186 
642C 7F 00 00 00 1 187 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 187 
6434 84          1 187 
6435 7F 00 00 00 1 188 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 188 
643D 85          1 188 
643E 7F 00 00 00 1 189 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 189 
6446 86          1 189 
6447 7F 7F 7F 7F 1 190 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 190 
644F 7F          1 190 
6450             1 191 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 192 defb    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 192 
6458 7F          1 192 
6459 81 00 00 00 1 193 defb       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 193 
6461 7F          1 193 
6462 82 00 00 00 1 194 defb          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 194 
646A 7F          1 194 
646B 83 00 00 00 1 195 defb             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 195 
6473 7F          1 195 
6474 84 00 00 00 1 196 defb                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 196 
647C 7F          1 196 
647D 85 00 00 00 1 197 defb                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 197 
6485 7F          1 197 
6486 86 00 00 00 1 198 defb                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 198 
648E 7F          1 198 
648F 7F 7F 7F 7F 1 199 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 199 
6497             1 201 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 202 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 203 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 204 TIMER_DIGITS:
6497 00 0F 0B 0B 1 205 defb    $00, $0F, $0B, $0B, $0B, $0F, $00, $00
649B 0B 0F 00 00 1 205 
649F 00 06 0E 06 1 206 defb    $00, $06, $0E, $06, $06, $06, $00, $00
64A3 06 06 00 00 1 206 
64A7 00 0F 03 0F 1 207 defb    $00, $0F, $03, $0F, $08, $0F, $00, $00
64AB 08 0F 00 00 1 207 
64AF 00 0F 03 07 1 208 defb    $00, $0F, $03, $07, $03, $0F, $00, $00
64B3 03 0F 00 00 1 208 
64B7 00 0B 0B 0F 1 209 defb    $00, $0B, $0B, $0F, $03, $03, $00, $00
64BB 03 03 00 00 1 209 
64BF 00 0F 08 0F 1 210 defb    $00, $0F, $08, $0F, $03, $0F, $00, $00
64C3 03 0F 00 00 1 210 
64C7 00 0F 0C 0F 1 211 defb    $00, $0F, $0C, $0F, $0D, $0F, $00, $00
64CB 0D 0F 00 00 1 211 
64CF 00 0F 03 03 1 212 defb    $00, $0F, $03, $03, $03, $03, $00, $00
64D3 03 03 00 00 1 212 
64D7 00 0F 0B 0F 1 213 defb    $00, $0F, $0B, $0F, $0B, $0F, $00, $00
64DB 0B 0F 00 00 1 213 
64DF 00 0F 0B 0F 1 214 defb    $00, $0F, $0B, $0F, $03, $0F, $00, $00
64E3 03 0F 00 00 1 214 
64E7             1 216 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 217 ; Tone parameters for sound effects
64E7             1 218 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 219 ; for each tone (from left to right):
64E7             1 220 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 221 ;   - length of a frame (1..65536)
64E7             1 222 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 223 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 224 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 225 TOKEN_FX                defw       1, 1000, 1400,   0
64EB 78 05 00 00 1 225 
64EF 05 00 88 13 1 226 WINNER_FX               defw       5, 5000,  200, 100
64F3 C8 00 64 00 1 226 
64F7 E8 03 0A 00 1 227 FILLED_FX               defw    1000,   10,  100,   0
64FB 64 00 00 00 1 227 
64FF FF          1 229 FILLER                  defb    $FF                         ; filler to align next block (not used)
6500             1 231 ;org     $6500
6500             1 232 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 233 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 234 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 235 RED_VECTOR_TABLE:
6500 88 72       1 236 defw    PathFinder_RED_Edge_0
6502 B6 72       1 237 defw    PathFinder_RED_Edge_1
6504 DC 72       1 238 defw    PathFinder_RED_Edge_2
6506 02 73       1 239 defw    PathFinder_RED_Edge_3
6508 28 73       1 240 defw    PathFinder_RED_Edge_4
650A 4E 73       1 241 defw    PathFinder_RED_Edge_5
650C 74 73       1 242 defw    PathFinder_RED_Edge_6
650E             1 244 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 245 ; Graphics for the screen frame
650E             1 246 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 247 FRAME_TILES:
650E 00 00 1F 3F 1 248 defb    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C
6512 3F 3F 3C 3C 1 248 
6516 00 00 FF FF 1 249 defb    $00, $00, $FF, $FF, $FF, $FF, $00, $00
651A FF FF 00 00 1 249 
651E 00 00 FF FE 1 250 defb    $00, $00, $FF, $FE, $FE, $FF, $00, $00
6522 FE FF 00 00 1 250 
6526 03 07 0F 0F 1 251 defb    $03, $07, $0F, $0F, $0F, $0F, $07, $03
652A 0F 0F 07 03 1 251 
652E FF FE FC FC 1 252 defb    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF
6532 FC FC FE FF 1 252 
6536 FF 7F 3F 3F 1 253 defb    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF
653A 3F 3F 7F FF 1 253 
653E C0 E0 F0 F0 1 254 defb    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0
6542 F0 F0 E0 C0 1 254 
6546 00 00 FF 7F 1 255 defb    $00, $00, $FF, $7F, $7F, $FF, $00, $00
654A 7F FF 00 00 1 255 
654E 00 00 F8 FC 1 256 defb    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C
6552 FC FC 3C 3C 1 256 
6556 3C 3C 3F 3F 1 257 defb    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00
655A 3F 1F 00 00 1 257 
655E 00 00 FE FF 1 258 defb    $00, $00, $FE, $FF, $FF, $FE, $00, $00
6562 FF FE 00 00 1 258 
6566 00 00 7F FF 1 259 defb    $00, $00, $7F, $FF, $FF, $7F, $00, $00
656A FF 7F 00 00 1 259 
656E 3C 3C FC FC 1 260 defb    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00
6572 FC F8 00 00 1 260 
6576 00 00 38 7C 1 261 defb    $00, $00, $38, $7C, $7C, $38, $00, $00
657A 7C 38 00 00 1 261 
657E             1 263 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 264 ; Hexagon sprites
657E             1 265 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 266 HEXAGON_EMPTY:
657E 07 E0 18 18 1 267 defb    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 267 
6586 48 02 48 02 1 268 defb    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 268 
658E 40 02 40 02 1 269 defb    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 269 
6596 20 24 20 04 1 270 defb    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 270 
659E             1 271 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 272 defb    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 272 
65A6 24 04 24 04 1 273 defb    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 273 
65AE 20 04 20 04 1 274 defb    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 274 
65B6 10 48 10 08 1 275 defb    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 275 
65BE 01 80 02 40 1 277 defb    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 277 
65C6 0A 10 0A 10 1 278 defb    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 278 
65CE 08 10 08 10 1 279 defb    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 279 
65D6 08 90 04 20 1 280 defb    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 280 
65DE 00 80 00 80 1 282 defb    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 282 
65E6 00 80 00 80 1 283 defb    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 283 
65EE 00 80 00 80 1 284 defb    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 284 
65F6 00 80 00 80 1 285 defb    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 285 
65FE 01 80 02 40 1 287 defb    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 287 
6606 0B D0 0B D0 1 288 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 288 
660E 0B D0 0B D0 1 289 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 289 
6616 0B D0 05 A0 1 290 defb    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 290 
661E 03 C0 0C 30 1 292 defb    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 292 
6626 2F F4 2F F4 1 293 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 293 
662E 2F F4 2F F4 1 294 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 294 
6636 17 E8 13 C8 1 295 defb    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 295 
663E             1 296 HEXAGON_TOKEN:
663E 07 E0 18 18 1 297 defb    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 297 
6646 5F FA 5F FA 1 298 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 298 
664E 5F FA 5F FA 1 299 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 299 
6656 2F F4 27 E4 1 300 defb    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 300 
665E             1 302 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 303 ; Board letter sprites
665E             1 304 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 305 LETTER_SPRITES:
665E 3C 7E FF C3 1 306 defb    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C
6662 F3 C3 D3 C3 1 306 
6666 7E 3C       1 306 
6668 3C 7E CF CF 1 307 defb    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C
666C C3 CB CB C3 1 307 
6670 7E 3C       1 307 
6672 3C 7E FF E3 1 308 defb    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C
6676 CF CF CF E3 1 308 
667A 7E 3C       1 308 
667C 3C 7E F3 F3 1 309 defb    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C
6680 C3 D3 D3 C3 1 309 
6684 7E 3C       1 309 
6686 3C 7E FF E3 1 310 defb    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C
668A CB C3 CF E3 1 310 
668E 7E 3C       1 310 
6690 3C 7E E3 CF 1 311 defb    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C
6694 C7 CF CF CF 1 311 
6698 7E 3C       1 311 
669A 3C 7E FF E3 1 312 defb    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C
669E D3 D3 E3 F3 1 312 
66A2 46 3C       1 312 
66A4             1 314 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 315 ; Board number sprites
66A4             1 316 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 317 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 318 defb    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C
66A8 E7 E7 E7 E7 1 318 
66AC 7E 3C       1 318 
66AE 3C 7E E7 D3 1 319 defb    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C
66B2 F3 E7 CF C3 1 319 
66B6 7E 3C       1 319 
66B8 3C 7E C7 F3 1 320 defb    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C
66BC E3 F3 F3 C7 1 320 
66C0 7E 3C       1 320 
66C2 3C 7E D3 D3 1 321 defb    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C
66C6 C3 F3 F3 F3 1 321 
66CA 7E 3C       1 321 
66CC 3C 7E C3 CF 1 322 defb    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C
66D0 C7 F3 F3 C7 1 322 
66D4 7E 3C       1 322 
66D6 3C 7E E3 CF 1 323 defb    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C
66DA C3 CB CB C3 1 323 
66DE 7E 3C       1 323 
66E0 3C 7E C3 F3 1 324 defb    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C
66E4 F3 E7 E7 E7 1 324 
66E8 7E 3C       1 324 
66EA             1 326 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 327 ; Screen addresses for menu hexagons
66EA             1 328 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 329 MENU_HEXAGONS:
66EA 01 40 05 40 1 330 defw    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 330 
66F2 0F 40 13 40 1 330 
66F6 1A 40       1 330 
66F8 45 40 48 40 1 331 defw    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 331 
6700 81 40 83 40 1 331 
6704 85 40       1 331 
6706 88 40 8A 40 1 332 defw    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 332 
670E C1 40 D0 40 1 332 
6712 D9 40       1 332 
6714 05 48 08 48 1 333 defw    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 333 
671C 19 48 1B 48 1 333 
6720 1D 48       1 333 
6722 0A 40 59 40 1 334 defw    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 334 
672A D2 40 0C 48 1 334 
672E 1C 40       1 334 
6730 41 40 50 40 1 335 defw    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 335 
6738 0F 48       1 335 
673A             1 336 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 337 defw    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 337 
6742 EF 40 F1 40 1 337 
6746 B2 40       1 337 
6748 E9 40 6F 48 1 338 defw    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 338 
6750 AA 48 AC 40 1 338 
6754 EF 48       1 338 
6756 2A 48 6D 48 1 339 defw    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 339 
675E             1 340 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 341 defw    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 341 
6766 AE 48 EF 48 1 341 
676A 2E 50       1 341 
676C AC 48 B4 48 1 342 defw    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 342 
6774 2E 48 F1 40 1 342 
6778 F3 40       1 342 
677A 73 48 B2 48 1 343 defw    $4873, $48B2, $5030
677E 30 50       1 343 
6780             1 345 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 346 ; Strings
6780             1 347 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 348 STR_OPTIONS:
6780 53 74 61 72 1 349 defm    "Start new game\0"
6784 74 20 6E 65 1 349 
6788 77 20 67 61 1 349 
678C 6D 65 00    1 349 
678F 48 6F 77 20 1 350 defm    "How to play\0"
6793 74 6F 20 70 1 350 
6797 6C 61 79 00 1 350 
679B 43 72 65 64 1 351 defm    "Credits\0"
679F 69 74 73 00 1 351 
67A3             1 352 STR_CREDITS:
67A3 44 65 73 69 1 353 defm    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 353 
67AB 20 20 20 20 1 353 
67AF 41 6E 74 6F 1 353 
67B3 6E 69 6F 20 1 353 
67B7 4C 75 71 75 1 353 
67BB 65 00       1 353 
67BD 43 6F 64 65 1 354 defm    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 354 
67C5 20 20 20 20 1 354 
67C9 41 6E 74 6F 1 354 
67CD 6E 69 6F 20 1 354 
67D1 4C 75 71 75 1 354 
67D5 65 00       1 354 
67D7 20 20 20 20 1 355 defm    "            Einar Saukas\0"
67DB 20 20 20 20 1 355 
67DF 20 20 20 20 1 355 
67E3 45 69 6E 61 1 355 
67E7 72 20 53 61 1 355 
67EB 75 6B 61 73 1 355 
67EF 00          1 355 
67F0 46 6F 6E 74 1 356 defm    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 356 
67F8 20 20 20 20 1 356 
67FC 45 69 6E 61 1 356 
6800 72 20 53 61 1 356 
6804 75 6B 61 73 1 356 
6808 00          1 356 
6809 47 72 61 70 1 357 defm    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 357 
6811 3A 20 20 20 1 357 
6815 45 69 6E 61 1 357 
6819 72 20 53 61 1 357 
681D 75 6B 61 73 1 357 
6821 00          1 357 
6822 20 20 20 20 1 358 defm    "            Antonio Luque\0"
6826 20 20 20 20 1 358 
682A 20 20 20 20 1 358 
682E 41 6E 74 6F 1 358 
6832 6E 69 6F 20 1 358 
6836 4C 75 71 75 1 358 
683A 65 00       1 358 
683C 50 72 65 73 1 359 STR_PRESSKEY            defm    "Press any key\0"
6840 73 20 61 6E 1 359 
6844 79 20 6B 65 1 359 
6848 79 00       1 359 
684A             1 360 STR_BUTTONS:
684A 4E 65 78 74 1 361 defm    "Next\0"
684E 00          1 361 
684F 42 61 63 6B 1 362 defm    "Back\0"
6853 00          1 362 
6854 52 45 44 00 1 363 STR_RED                 defm    "RED\0"
6858 43 59 41 4E 1 364 STR_CYAN                defm    "CYAN\0"
685C 00          1 364 
685D 43 6F 6E 6E 1 365 STR_HELP1               defm    "Connect\0"
6861 65 63 74 00 1 365 
6865 6C 65 66 74 1 366 STR_HELP2_RED           defm    "left and\0"
6869 20 61 6E 64 1 366 
686D 00          1 366 
686E 75 70 20 61 1 367 STR_HELP2_CYAN          defm    "up and\0"
6872 6E 64 00    1 367 
6875 72 69 67 68 1 368 STR_HELP3_RED           defm    "right\0"
6879 74 00       1 368 
687B 64 6F 77 6E 1 369 STR_HELP3_CYAN          defm    "down\0"
687F 00          1 369 
6880 62 6F 72 64 1 370 STR_HELP4               defm    "borders\0"
6884 65 72 73 00 1 370 
6888 74 6F 20 77 1 371 STR_HELP5               defm    "to win\0"
688C 69 6E 00    1 371 
688F             1 372 STR_HELP:
688F 57 69 6E 20 1 373 defm    "Win three\0"
6893 74 68 72 65 1 373 
6897 65 00       1 373 
6899 74 69 6D 65 1 374 defm    "times in\0"
689D 73 20 69 6E 1 374 
68A1 00          1 374 
68A2 61 20 72 6F 1 375 defm    "a row to\0"
68A6 77 20 74 6F 1 375 
68AA 00          1 375 
68AB 6C 65 76 65 1 376 defm    "level up\0"
68AF 6C 20 75 70 1 376 
68B3 00          1 376 
68B4 20 43 4F 4E 1 377 STR_CONGRATS            defm    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 377 
68BC 55 4C 41 54 1 377 
68C0 49 4F 4E 53 1 377 
68C4 20 00       1 377 
68C6             1 378 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 379 defm    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 379 
68CE 65 21 20 4C 1 379 
68D2 61 73 74 20 1 379 
68D6 6C 65 76 65 1 379 
68DA 6C 20 70 61 1 379 
68DE 73 73 65 64 1 379 
68E2 00          1 379 
68E3 43 68 6F 6F 1 380 defm    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 380 
68EB 65 76 65 6C 1 380 
68EF 20 74 6F 20 1 380 
68F3 72 65 73 74 1 380 
68F7 61 72 74 2C 1 380 
68FB 20 31 2D 34 1 380 
68FF 00          1 380 
6900             1 382 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 383 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 384 ; this font was designed by Einar Saukas for Hex game
6900             1 385 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 386 FONT:
6900 00 00 00 00 1 387 includebin "King+.bin"
6904 00 00 00 00 1 387 
6908 00 18 18 18 1 387 
690C 00 18 18 00 1 387 
6910 00 24 24 00 1 387 
6914 00 00 00 00 1 387 
6918 00 24 7E 24 1 387 
691C 24 7E 24 00 1 387 
6920 00 08 3E 28 1 387 
6924 3E 0A 3E 08 1 387 
6928 00 62 64 08 1 387 
692C 10 26 46 00 1 387 
6930 00 10 28 10 1 387 
6934 2A 44 3A 00 1 387 
6938 00 18 30 00 1 387 
693C 00 00 00 00 1 387 
6940 06 0C 08 08 1 387 
6944 08 0C 06 00 1 387 
6948 60 30 10 10 1 387 
694C 10 30 60 00 1 387 
6950 00 00 14 08 1 387 
6954 3E 08 14 00 1 387 
6958 00 00 08 08 1 387 
695C 3E 08 08 00 1 387 
6960 00 00 00 00 1 387 
6964 00 0C 18 30 1 387 
6968 00 00 00 7E 1 387 
696C 7E 00 00 00 1 387 
6970 00 00 00 00 1 387 
6974 30 70 70 00 1 387 
6978 02 06 0C 18 1 387 
697C 30 60 40 00 1 387 
6980 00 7E 62 62 1 387 
6984 62 62 7E 00 1 387 
6988 00 18 38 18 1 387 
698C 18 18 3C 00 1 387 
6990 00 38 4C 4C 1 387 
6994 18 30 7C 00 1 387 
6998 00 3C 62 0C 1 387 
699C 06 66 3C 00 1 387 
69A0 00 30 30 30 1 387 
69A4 30 34 3E 04 1 387 
69A8 00 7E 60 7E 1 387 
69AC 06 66 3C 00 1 387 
69B0 00 30 60 7C 1 387 
69B4 66 66 3C 00 1 387 
69B8 00 7E 46 0C 1 387 
69BC 18 30 60 00 1 387 
69C0 00 3C 66 3C 1 387 
69C4 66 66 3C 00 1 387 
69C8 00 3C 66 66 1 387 
69CC 3E 06 3C 00 1 387 
69D0 00 00 08 18 1 387 
69D4 00 08 18 00 1 387 
69D8 00 00 04 0C 1 387 
69DC 00 0C 18 30 1 387 
69E0 00 00 04 08 1 387 
69E4 10 08 04 00 1 387 
69E8 00 00 00 3E 1 387 
69EC 00 3E 00 00 1 387 
69F0 00 00 10 08 1 387 
69F4 04 08 10 00 1 387 
69F8 00 3C 42 04 1 387 
69FC 08 00 08 00 1 387 
6A00 00 3C 4A 56 1 387 
6A04 5E 40 3C 00 1 387 
6A08 00 7E 46 46 1 387 
6A0C 7E 46 46 00 1 387 
6A10 00 7C 62 7C 1 387 
6A14 62 62 7C 00 1 387 
6A18 00 7E 66 60 1 387 
6A1C 60 66 7E 00 1 387 
6A20 00 7C 46 46 1 387 
6A24 46 46 7C 00 1 387 
6A28 00 7E 60 7C 1 387 
6A2C 60 60 7E 00 1 387 
6A30 00 7E 60 7C 1 387 
6A34 60 60 60 00 1 387 
6A38 00 3E 62 60 1 387 
6A3C 66 66 3E 00 1 387 
6A40 00 62 62 7E 1 387 
6A44 62 62 62 00 1 387 
6A48 00 18 18 18 1 387 
6A4C 18 18 18 00 1 387 
6A50 00 0C 0C 0C 1 387 
6A54 0C 4C 38 00 1 387 
6A58 00 66 64 68 1 387 
6A5C 7E 46 66 00 1 387 
6A60 00 60 60 60 1 387 
6A64 60 60 7E 00 1 387 
6A68 00 7E 56 56 1 387 
6A6C 56 56 56 00 1 387 
6A70 00 7E 46 46 1 387 
6A74 46 46 46 00 1 387 
6A78 00 7E 62 62 1 387 
6A7C 62 62 7E 00 1 387 
6A80 00 7E 62 62 1 387 
6A84 7E 60 60 00 1 387 
6A88 00 7C 64 64 1 387 
6A8C 64 64 7E 00 1 387 
6A90 00 7C 62 64 1 387 
6A94 7C 46 46 00 1 387 
6A98 00 7E 60 7E 1 387 
6A9C 06 06 7E 00 1 387 
6AA0 00 7E 18 18 1 387 
6AA4 18 18 18 00 1 387 
6AA8 00 62 62 62 1 387 
6AAC 62 62 7E 00 1 387 
6AB0 00 62 62 62 1 387 
6AB4 62 34 18 00 1 387 
6AB8 00 6A 6A 6A 1 387 
6ABC 6A 6A 7E 00 1 387 
6AC0 00 62 62 34 1 387 
6AC4 4E 46 46 00 1 387 
6AC8 00 62 62 7E 1 387 
6ACC 18 18 18 00 1 387 
6AD0 00 7E 06 1C 1 387 
6AD4 38 60 7E 00 1 387 
6AD8 00 0E 08 08 1 387 
6ADC 08 08 0E 00 1 387 
6AE0 00 00 40 20 1 387 
6AE4 10 08 04 00 1 387 
6AE8 00 70 10 10 1 387 
6AEC 10 10 70 00 1 387 
6AF0 00 08 1C 2A 1 387 
6AF4 08 08 08 08 1 387 
6AF8 00 00 00 00 1 387 
6AFC 00 00 00 FF 1 387 
6B00 0C 12 10 38 1 387 
6B04 10 10 3E 00 1 387 
6B08 00 00 3C 06 1 387 
6B0C 7E 46 7E 00 1 387 
6B10 00 60 60 7E 1 387 
6B14 62 62 7E 00 1 387 
6B18 00 00 7E 62 1 387 
6B1C 60 62 7E 00 1 387 
6B20 00 06 06 7E 1 387 
6B24 46 46 7E 00 1 387 
6B28 00 00 7E 46 1 387 
6B2C 7E 60 7E 00 1 387 
6B30 00 1E 30 3C 1 387 
6B34 30 30 30 00 1 387 
6B38 00 00 7E 46 1 387 
6B3C 46 3E 06 3E 1 387 
6B40 00 60 60 7C 1 387 
6B44 66 66 66 00 1 387 
6B48 00 18 00 38 1 387 
6B4C 18 18 3C 00 1 387 
6B50 00 0C 00 0C 1 387 
6B54 0C 0C 4C 38 1 387 
6B58 00 20 2C 38 1 387 
6B5C 38 2C 26 00 1 387 
6B60 00 18 18 18 1 387 
6B64 18 18 0E 00 1 387 
6B68 00 00 6C 56 1 387 
6B6C 56 56 46 00 1 387 
6B70 00 00 7C 46 1 387 
6B74 46 46 46 00 1 387 
6B78 00 00 3C 46 1 387 
6B7C 46 46 3C 00 1 387 
6B80 00 00 7C 66 1 387 
6B84 66 7C 60 60 1 387 
6B88 00 00 3E 46 1 387 
6B8C 46 3E 06 06 1 387 
6B90 00 00 3C 62 1 387 
6B94 60 60 60 00 1 387 
6B98 00 00 3C 60 1 387 
6B9C 3C 06 3C 00 1 387 
6BA0 00 30 78 30 1 387 
6BA4 30 30 1C 00 1 387 
6BA8 00 00 46 46 1 387 
6BAC 46 46 3C 00 1 387 
6BB0 00 00 46 46 1 387 
6BB4 2C 3C 18 00 1 387 
6BB8 00 00 46 56 1 387 
6BBC 56 56 2C 00 1 387 
6BC0 00 00 46 2C 1 387 
6BC4 18 2C 46 00 1 387 
6BC8 00 00 46 46 1 387 
6BCC 46 3E 06 3C 1 387 
6BD0 00 00 7E 0C 1 387 
6BD4 18 30 7E 00 1 387 
6BD8 00 0E 08 30 1 387 
6BDC 08 08 0E 00 1 387 
6BE0 00 08 08 08 1 387 
6BE4 08 2A 1C 08 1 387 
6BE8 00 70 10 0C 1 387 
6BEC 10 10 70 00 1 387 
6BF0 00 14 28 00 1 387 
6BF4 00 00 00 00 1 387 

; File #2: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Main.z80asm

6BF8             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 2 ; Main.z80asm
6BF8             2 3 ; Coded by Antonio Luque
6BF8             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 6 CYAN_COLOR              equ     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6BF8             2 7 RED_COLOR               equ     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6BF8             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 10 ; Entry point of the program - Initialization
6BF8             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 12 Main                    ent     $
6BF8 F3          2 14 di                                  ; disable interrupts
6BF9             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6BF9 21 15 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6BFC FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C00 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C03 FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C06 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C08 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C0A ED 5E       2 24 im      2                           ; set interrupt mode 2
6C0C             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C0C             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C0C             2 28 ; resultant vector address is formed as follows:
6C0C             2 29 ;
6C0C             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C0C             2 31 ; Source: 
6C0C             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
6C0C             2 33 ;
6C0C             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C0C             2 35 ; memory area and it is used by some ROM routines, but none of them are called by HEX2 program.
6C0C 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C0F AF          2 39 xor     a                           ; A = 0
6C10 D3 FE       2 40 out     ($FE), a                    ; set border color (black)
6C12 CD 6C 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C15             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C15             2 44 ; Start new game
6C15             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C15             2 46 Main_Start
6C15 CD 01 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C18 CD 0E 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C1B CD 3A 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C1E CD 79 77    2 50 call    Screen_Frame                ; draw the screen frame
6C21 CD D1 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C24 CD F0 77    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C27 CD 33 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C2A FB          2 55 ei                                  ; enable interrupts
6C2B             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C2B             2 58 ; New level
6C2B             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C2B             2 60 Main_New_Level
6C2B 3E 04       2 61 ld      a, 4                        ; maximum level
6C2D 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C30 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C31 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C33 CD 6D 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C36 18 DD       2 66 jr      Main_Start                  ; start a new game
6C38             2 67 Main_Increment_Level
6C38 34          2 68 inc     (hl)                        ; increment game level
6C39 CD 10 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C3C CD FF 78    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C3F AF          2 71 xor     a                           ; A = 0
6C40 32 11 62    2 72 ld      (THREE_ROW), a              ; initialize three-in-a-row counter
6C43             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C43             2 75 ; Start new match
6C43             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C43             2 77 Main_Start_Match
6C43             2 78 ; set up timers and clear last messages
6C43 CD AA 76    2 80 call    Timer_Reset                 ; reset timers
6C46 CD 95 76    2 81 call    Timer_Display_All           ; display timers
6C49 CD 06 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C4C 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C4E 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C51 CD 2D 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C54             2 87 ; swap players' colors
6C54 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C57 EE 07       2 90 xor     %00000111                   ; swap color
6C59 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C5C CD E9 6E    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C5F             2 94 ; initialize positions and draw empty board
6C5F 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C62 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C65 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C67 01 FF 01    2 99 ld      bc, 256*2-1                 ; length of cyan + red positions areas (-1 already set)
6C6A ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C6C CD 99 6D    2 101 call    Draw_Board                  ; draw an empty hexagons board
6C6F             2 103 ; initialize draw token delay, move number and token color
6C6F 3E 0A       2 105 ld      a, 10                       ; set delay duration for animate hexagons
6C71 32 C8 6D    2 106 ld      (Draw_Token_Delay+1), a
6C74 3E 01       2 107 ld      a, 1                        ; initialize move number
6C76 32 9B 61    2 108 ld      (MOVE_NUMBER), a
6C79 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C7B             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C7B             2 112 ; Process players moves - Match loop
6C7B             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C7B             2 114 Main_Match_Loop
6C7B             2 115 ; check player turn
6C7B 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C7E 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C81 BE          2 119 cp      (hl)                        ; is player color = current token color?
6C82 28 05       2 120 jr      z, Main_Player_Move         ; yes, process player move
6C84 CD E4 6C    2 122 call    Main_GetSpeccy_Move         ; get the speccy move
6C87 18 03       2 123 jr      Main_Update_Board           ; update board position
6C89             2 124 Main_Player_Move
6C89 CD 2E 6D    2 125 call    Main_GetPlayer_Move         ; get a legal (empty position) player move 
6C8C             2 126 Main_Update_Board
6C8C             2 127 ; update positions with player/speccy move
6C8C CD E5 70    2 129 call    PathFinder_Friend           ; get player/speccy side
6C8F CD EF 70    2 130 call    PathFinder_PutToken         ; put token on cyan and red positions
6C92             2 132 ; draw token on the board
6C92 AF          2 134 xor     a                           ; stop timers
6C93 32 EB 62    2 135 ld      (TIMER_FLAG), a
6C96 CD B4 6D    2 136 call    Draw_Token                  ; animate hexagon sprite on the screen
6C99 DD 21 E7 64 2 137 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6C9D CD BF 76    2 138 call    Sound_FX                    ; play sound effect
6CA0             2 140 ; check for a winner
6CA0 CD 98 75    2 142 call    PathFinder_VictoryPath      ; check current player victory path
6CA3 3C          2 143 inc     a                           ; is there a victory path?
6CA4 20 0B       2 144 jr      nz, Main_Match_End          ; yes, match ends
6CA6 21 9B 61    2 146 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CA9 34          2 147 inc     (hl)                        ; increment move number
6CAA             2 149 ; swap players' token color
6CAA 3A 9E 61    2 151 ld      a, (TOKEN_COLOR)            ; get current token color
6CAD EE 07       2 152 xor     %00000111                   ; swap token color
6CAF 18 CA       2 153 jr      Main_Match_Loop             ; repeat match loop
6CB1             2 155 ; ----------------------------------------------------------------------------------------------------------------------
6CB1             2 156 ; Current player wins the match
6CB1             2 157 ; ----------------------------------------------------------------------------------------------------------------------
6CB1             2 158 Main_Match_End
6CB1 47          2 159 ld      b, a                        ; set start position of victory path in B
6CB2 3E 04       2 160 ld      a, 4                        ; set delay duration for animate hexagons
6CB4 32 C8 6D    2 161 ld      (Draw_Token_Delay+1), a
6CB7 CD CD 75    2 163 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CBA 11 3D 62    2 165 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CBD CD 0D 6F    2 166 call    Print_Alert                 ; print string
6CC0 3A 9E 61    2 168 ld      a, (TOKEN_COLOR)            ; get current token color
6CC3 21 9F 61    2 169 ld      hl, PLAYER_COLOR            ; get player color
6CC6 BE          2 170 cp      (hl)                        ; is player color = current token color?
6CC7 21 11 62    2 171 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CCA 28 04       2 172 jr      z, Main_ThreeRow_Increment  ; yes, go to increment three-in-a-row counter
6CCC 35          2 173 dec     (hl)                        ; decrement three-in-a-row counter
6CCD F2 D1 6C    2 174 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CD0             2 175 Main_ThreeRow_Increment
6CD0 34          2 176 inc     (hl)                        ; increment three-in-a-row counter
6CD1             2 177 Main_ThreeRow_Show
6CD1 CD E3 78    2 178 call    Screen_ThreeRow             ; show three-in-a-row marks
6CD4 3E FF       2 179 ld      a, 255                      ; set delay duration
6CD6 CD 8A 6D    2 180 call    Main_Delay                  ; execute delay
6CD9 3A 11 62    2 181 ld      a, (THREE_ROW)              ; check three row counter
6CDC FE 03       2 182 cp      3                           ; is it 3?
6CDE CA 2B 6C    2 183 jp      z, Main_New_Level           ; yes, start a new level
6CE1 C3 43 6C    2 184 jp      Main_Start_Match            ; start a new match
6CE4             2 186 ; ----------------------------------------------------------------------------------------------------------------------
6CE4             2 187 ; Main_GetSpeccy_Move: get the speccy move
6CE4             2 188 ;
6CE4             2 189 ; Input:     A = current token color
6CE4             2 190 ;
6CE4             2 191 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CE4             2 192 ;           HL = CYAN_POSITIONS move address
6CE4             2 193 ;
6CE4             2 194 ; Uses:     MOVE_NUMBER (current move number)
6CE4             2 195 ;           GAME_LEVEL (current game level)
6CE4             2 196 ;           AI_DEPTH (recursion depth level)
6CE4             2 197 ;           STR_MOVE (formatted move string)
6CE4             2 198 ;
6CE4             2 199 ; Destroys: A, DE, IX, IY
6CE4             2 200 ; ----------------------------------------------------------------------------------------------------------------------
6CE4             2 201 Main_GetSpeccy_Move:
6CE4 E6 03       2 202 and     %00000011                   ; calculate speccy's timer flag based on current token color
6CE6 32 EB 62    2 203 ld      (TIMER_FLAG), a             ; (re)start speccy timer
6CE9 CD 26 6F    2 205 call    Print_Wait                  ; print "WAIT" message
6CEC 3A 9B 61    2 206 ld      a, (MOVE_NUMBER)            ; get move number
6CEF 3D          2 207 dec     a                           ; is it cyan first move?
6CF0 28 2A       2 208 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CF2 DD 21 00 7F 2 210 ld      ix, CANDIDATES              ; IX points to candidates list address
6CF6 3A 9D 61    2 211 ld      a, (GAME_LEVEL)             ; get game level
6CF9 32 9A 61    2 212 ld      (AI_DEPTH), a               ; save recursion depth level
6CFC CD E5 70    2 214 call    PathFinder_Friend           ; get speccy side
6CFF CD 77 6F    2 215 call    BRAINIAC_best_move          ; get speccy best move
6D02 6B          2 216 ld      l, e                        ; set node index in L
6D03             2 217 Main_GetSpeccy_Positions
6D03 26 7D       2 218 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D05 E5          2 219 push    hl                          ; store CYAN_POSITIONS move address
6D06 CD 79 6D    2 220 call    Main_Board2Indexes          ; convert board position to indexes
6D09 78          2 221 ld      a, b                        ; get 1..7 column
6D0A C6 60       2 222 add     a, $60                      ; adjust to charset ('a'..'g')
6D0C 32 18 62    2 223 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D0F 79          2 224 ld      a, c                        ; get 1..7 row
6D10 C6 30       2 225 add     a, $30                      ; adjust to charset ('1'..'7')
6D12 32 1B 62    2 226 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D15 C5          2 227 push    bc                          ; store hexagon board indexes
6D16 CD 34 6F    2 228 call    Print_Move                  ; print Speccy move
6D19 C1          2 229 pop     bc                          ; restore hexagon board indexes
6D1A E1          2 230 pop     hl                          ; restore CYAN_POSITIONS move address
6D1B C9          2 231 ret
6D1C             2 232 Main_GetSpeccy_Book
6D1C ED 5F       2 233 ld      a, r                        ; get a pseudo-random number (0..127)
6D1E E6 1F       2 234 and     %00011111                   ; number is in range (0..31)
6D20 FE 1B       2 235 cp      27                          ; is it >= 27?
6D22 30 F8       2 236 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D24 21 D0 62    2 237 ld      hl, OPENINGS                ; HL points to opening book address
6D27 16 00       2 238 ld      d, 0                        ; set index in DE
6D29 5F          2 239 ld      e, a
6D2A 19          2 240 add     hl, de                      ; HL points to move index address
6D2B 6E          2 241 ld      l, (hl)                     ; get move from opening book
6D2C 18 D5       2 242 jr      Main_GetSpeccy_Positions    ; get speccy move positions
6D2E             2 244 ; ----------------------------------------------------------------------------------------------------------------------
6D2E             2 245 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D2E             2 246 ;
6D2E             2 247 ; Input:     A = current token color
6D2E             2 248 ;
6D2E             2 249 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D2E             2 250 ;           HL = CYAN_POSITIONS move address
6D2E             2 251 ;
6D2E             2 252 ; Uses:     STR_MOVE (formatted move string)
6D2E             2 253 ;
6D2E             2 254 ; Destroys: A, DE, IX
6D2E             2 255 ; ----------------------------------------------------------------------------------------------------------------------
6D2E             2 256 Main_GetPlayer_Move:
6D2E E6 03       2 257 and     %00000011                   ; calculate player's timer flag based on current token color
6D30 32 EB 62    2 258 ld      (TIMER_FLAG), a             ; (re)start player timer
6D33             2 259 Main_GetPlayer_Input
6D33 CD 2D 6F    2 260 call    Print_Clear_Move            ; clear player last move
6D36 CD 23 6E    2 261 call    Input_Move                  ; wait for input player move
6D39 CD 34 6F    2 262 call    Print_Move                  ; print player move
6D3C 3A 18 62    2 264 ld      a, (STR_MOVE+0)             ; get column ('a'..'g')
6D3F D6 60       2 265 sub     $60                         ; convert to number (1..7)
6D41 47          2 266 ld      b, a                        ; set column index in B
6D42 3A 1B 62    2 267 ld      a, (STR_MOVE+3)             ; get row ('1'..'7')
6D45 D6 30       2 268 sub     $30                         ; convert to number (1..7)
6D47 4F          2 269 ld      c, a                        ; set row index in C
6D48 11 50 62    2 270 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D4B CD 6C 6D    2 271 call    Main_Search_Table           ; search board position in board coordinates
6D4E 6E          2 272 ld      l, (hl)                     ; set board position of player move
6D4F 26 7D       2 273 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D51 3E 00       2 274 ld      a, EMPTY                    ; check position
6D53 BE          2 275 cp      (hl)                        ; is position empty?
6D54 C8          2 276 ret     z                           ; yes, return
6D55             2 278 ; illegal player move (position not empty)
6D55 11 31 62    2 280 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D58 CD 0D 6F    2 281 call    Print_Alert                 ; print string
6D5B DD 21 F7 64 2 282 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D5F CD BF 76    2 283 call    Sound_FX                    ; play sound fx
6D62 3E 50       2 284 ld      a, 80                       ; set delay counter
6D64 CD 8A 6D    2 285 call    Main_Delay                  ; execute delay
6D67 CD 06 6F    2 286 call    Print_Clear_Alert           ; clear alert message
6D6A 18 C7       2 287 jr      Main_GetPlayer_Input        ; repeat player input until move is legal
6D6C             2 289 ; ----------------------------------------------------------------------------------------------------------------------
6D6C             2 290 ; Main_Search_Table: search an element in a 8x8 bytes table
6D6C             2 291 ;
6D6C             2 292 ; Input:    BC = element indexes (B = column, C = row)
6D6C             2 293 ;           DE = table address in which to search for the element
6D6C             2 294 ;
6D6C             2 295 ; Output:   DE = address of first element in the C row of the table
6D6C             2 296 ;           HL = address of the element in the BC indexes of the table
6D6C             2 297 ;
6D6C             2 298 ; Destroys: -
6D6C             2 299 ; ----------------------------------------------------------------------------------------------------------------------
6D6C             2 300 Main_Search_Table:
6D6C 26 00       2 301 ld      h, 0                        ; first, get the C row in table
6D6E 69          2 302 ld      l, c                        ; set index in HL
6D6F 29          2 303 add     hl, hl                      ; a row is 8 bytes long
6D70 29          2 304 add     hl, hl
6D71 29          2 305 add     hl, hl
6D72 19          2 306 add     hl, de                      ; HL points to the address of C row 
6D73 EB          2 307 ex      de, hl                      ; DE points to the address of C row
6D74 26 00       2 308 ld      h, 0                        ; go for to the B column
6D76 68          2 309 ld      l, b                        ; set index in HL
6D77 19          2 310 add     hl, de                      ; HL points to the address of BC indexes
6D78 C9          2 311 ret
6D79             2 313 ; ----------------------------------------------------------------------------------------------------------------------
6D79             2 314 ; Main_Board2Indexes: convert a board position into a board indexes
6D79             2 315 ;
6D79             2 316 ; Input:    L  = board position
6D79             2 317 ;
6D79             2 318 ; Output:   BC = board indexes (B = column, C = row)
6D79             2 319 ;
6D79             2 320 ; Destroys: HL
6D79             2 321 ; ----------------------------------------------------------------------------------------------------------------------
6D79             2 322 Main_Board2Indexes:
6D79 7D          2 323 ld      a, l                        ; set board position in A to compare later
6D7A 21 90 62    2 325 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D7D 0E 07       2 326 ld      c, 7                        ; 7 rows
6D7F             2 327 Main_Board2Indexes_Row
6D7F 06 07       2 328 ld      b, 7                        ; 7 columns
6D81             2 329 Main_Board2Indexes_Col
6D81 2B          2 330 dec     hl                          ; move HL to next board position address
6D82 BE          2 331 cp      (hl)                        ; is A the position?
6D83 C8          2 332 ret     z                           ; yes, return board indexes
6D84 10 FB       2 333 djnz    Main_Board2Indexes_Col      ; repeat for each column
6D86 2B          2 334 dec     hl                          ; skip borders
6D87 0D          2 335 dec     c                           ; decrement row
6D88 18 F5       2 336 jr      Main_Board2Indexes_Row      ; loop until find position
6D8A             2 338 ; ----------------------------------------------------------------------------------------------------------------------
6D8A             2 339 ; Main_Delay: execute a delay
6D8A             2 340 ;
6D8A             2 341 ; Input:    A = delay counter
6D8A             2 342 ;
6D8A             2 343 ; Output:   -
6D8A             2 344 ;
6D8A             2 345 ; Destroys: A
6D8A             2 346 ; ----------------------------------------------------------------------------------------------------------------------
6D8A             2 347 Main_Delay:
6D8A C5          2 348 push    bc                          ; store register
6D8B             2 349 Main_Delay_Loop
6D8B 0E 0A       2 350 ld      c, 10                       ; set outer loop counter
6D8D             2 351 Main_Delay_Loop1
6D8D 06 00       2 352 ld      b, 0                        ; set inner loop counter (256)
6D8F             2 353 Main_Delay_Loop2
6D8F 10 FE       2 354 djnz    Main_Delay_Loop2            ; repeat until B=0
6D91 0D          2 355 dec     c                           ; decrement outer loop counter
6D92 20 F9       2 356 jr      nz, Main_Delay_Loop1        ; repeat until C=0
6D94 3D          2 357 dec     a                           ; decrement delay counter
6D95 20 F4       2 358 jr      nz, Main_Delay_Loop         ; repeat until A=0
6D97 C1          2 359 pop     bc                          ; restore register
6D98 C9          2 360 ret

; File #3: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Draw.z80asm

6D99             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6D99             3 2 ; Draw.z80asm
6D99             3 3 ; Coded by Antonio Luque
6D99             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6D99             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6D99             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6D99             3 8 ;
6D99             3 9 ; Input:    -
6D99             3 10 ;
6D99             3 11 ; Output:   -
6D99             3 12 ;
6D99             3 13 ; Uses:     TOKEN_COLOR (current token color)
6D99             3 14 ;
6D99             3 15 ; Destroys: A, BC, DE, HL, IXL
6D99             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6D99             3 17 Draw_Board:
6D99 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6D9B 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6D9E 0E 07       3 20 ld      c, 7                        ; 7 rows
6DA0             3 21 Draw_Board_Row
6DA0 06 07       3 22 ld      b, 7                        ; 7 columns
6DA2             3 23 Draw_Board_Column
6DA2 CD CF 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DA5 CD 07 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DA8 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DAB CD D9 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DAE 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DB0 0D          3 29 dec     c                           ; decrement row
6DB1 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DB3 C9          3 31 ret
6DB4             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DB4             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DB4             3 35 ;
6DB4             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DB4             3 37 ;
6DB4             3 38 ; Output:   -
6DB4             3 39 ;
6DB4             3 40 ; Destroys: A, BC, DE, HL, IXL
6DB4             3 41 ; ----------------------------------------------------------------------------------------------------------------------
6DB4             3 42 Draw_Token:
6DB4 CD CF 6D    3 43 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DB7 01 04 06    3 44 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DBA 11 9E 65    3 45 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DBD             3 46 Draw_Token_Loop
6DBD E5          3 47 push    hl                          ; store hexagon screen address
6DBE CD D9 6D    3 48 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DC1 E1          3 49 pop     hl                          ; restore hexagon screen address
6DC2 78          3 50 ld      a, b                        ; check loop counter
6DC3 B9          3 51 cp      c                           ; is it 4?
6DC4 CC 07 6E    3 52 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DC7             3 53 Draw_Token_Delay
6DC7 3E 00       3 54 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DC9 CD 8A 6D    3 55 call    Main_Delay                  ; execute delay
6DCC 10 EF       3 56 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DCE C9          3 57 ret
6DCF             3 59 ; ----------------------------------------------------------------------------------------------------------------------
6DCF             3 60 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DCF             3 61 ;
6DCF             3 62 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DCF             3 63 ;
6DCF             3 64 ; Output:   HL = hexagon screen address 
6DCF             3 65 ;
6DCF             3 66 ; Destroys: A, DE
6DCF             3 67 ; ----------------------------------------------------------------------------------------------------------------------
6DCF             3 68 Draw_GetHEX_Screen:
6DCF 11 98 61    3 69 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DD2 CD 6C 6D    3 70 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DD5 6E          3 71 ld      l, (hl)                     ; set the low byte of the screen address in L
6DD6 1A          3 72 ld      a, (de)                     ; set the high byte of the screen address in H
6DD7 67          3 73 ld      h, a
6DD8 C9          3 74 ret
6DD9             3 76 ; ----------------------------------------------------------------------------------------------------------------------
6DD9             3 77 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DD9             3 78 ;
6DD9             3 79 ; Input:    DE = hexagon sprite address
6DD9             3 80 ;           HL = hexagon screen address
6DD9             3 81 ;
6DD9             3 82 ; Output:   DE = next hexagon sprite address
6DD9             3 83 ;
6DD9             3 84 ; Destroys: A, HL, IXL
6DD9             3 85 ; ----------------------------------------------------------------------------------------------------------------------
6DD9             3 86 Draw_Sprite_Hexagon:
6DD9 DD 2E 10    3 87 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DDC             3 88 Draw_Sprite_HexLoop
6DDC 1A          3 89 ld      a, (de)                     ; get sprite byte
6DDD 77          3 90 ld      (hl), a                     ; put sprite byte on screen
6DDE 13          3 91 inc     de                          ; move DE to next sprite byte address
6DDF 2C          3 92 inc     l                           ; move HL to next screen column
6DE0 1A          3 93 ld      a, (de)                     ; get sprite byte
6DE1 77          3 94 ld      (hl), a                     ; put sprite byte on screen
6DE2 13          3 95 inc     de                          ; move DE to next sprite byte
6DE3 2D          3 96 dec     l                           ; move HL to previous screen column
6DE4 CD F8 6D    3 97 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DE7 DD 2D       3 98 dec     ixl                         ; decrement sprite height
6DE9 20 F1       3 99 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6DEB C9          3 100 ret
6DEC             3 102 ; ----------------------------------------------------------------------------------------------------------------------
6DEC             3 103 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6DEC             3 104 ;
6DEC             3 105 ; Input:    DE = letter/number sprite address
6DEC             3 106 ;           HL = letter/number screen address
6DEC             3 107 ;
6DEC             3 108 ; Output:   DE = next letter/number sprite address
6DEC             3 109 ;
6DEC             3 110 ; Destroys: A, C, HL
6DEC             3 111 ; ----------------------------------------------------------------------------------------------------------------------
6DEC             3 112 Draw_Sprite_LetterNum:
6DEC 0E 0A       3 113 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6DEE             3 114 Draw_Sprite_Loop
6DEE 1A          3 115 ld      a, (de)                     ; get sprite byte
6DEF 77          3 116 ld      (hl), a                     ; put sprite byte on screen
6DF0 13          3 117 inc     de                          ; move DE to next sprite byte address
6DF1 CD F8 6D    3 118 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DF4 0D          3 119 dec     c                           ; decrement sprite height
6DF5 20 F7       3 120 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6DF7 C9          3 121 ret
6DF8             3 123 ; ----------------------------------------------------------------------------------------------------------------------
6DF8             3 124 ; Draw_Down_PixelLine: move HL down one pixel-line
6DF8             3 125 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6DF8             3 126 ;
6DF8             3 127 ; The screen address of a pixel-line is encoded as follows:
6DF8             3 128 ;
6DF8             3 129 ;             H           |           L
6DF8             3 130 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DF8             3 131 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6DF8             3 132 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DF8             3 133 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6DF8             3 134 ;
6DF8             3 135 ; where:
6DF8             3 136 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6DF8             3 137 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6DF8             3 138 ;
6DF8             3 139 ; Input:    HL = pixel-line address
6DF8             3 140 ;
6DF8             3 141 ; Output:   HL = next (down) pixel-line address
6DF8             3 142 ;
6DF8             3 143 ; Destroys: A
6DF8             3 144 ; ----------------------------------------------------------------------------------------------------------------------
6DF8             3 145 Draw_Down_PixelLine:
6DF8 24          3 146 inc     h                           ; move HL down one pixel-line
6DF9 7C          3 147 ld      a, h                        ; get high byte of pixel-line address
6DFA E6 07       3 148 and     %00000111                   ; is pixel-line address inside a character line?
6DFC C0          3 149 ret     nz                          ; yes, return
6DFD 7D          3 150 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6DFE C6 20       3 151 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E00 6F          3 152 ld      l, a                        ; move HL down one character line
6E01 D8          3 153 ret     c                           ; a third was crossed? yes, return
6E02 7C          3 154 ld      a, h                        ; get high byte of pixel-line address
6E03 D6 08       3 155 sub     8                           ; clean up the bit from Y6
6E05 67          3 156 ld      h, a                        ; HL points to next (down) pixel-line address
6E06 C9          3 157 ret
6E07             3 159 ; ----------------------------------------------------------------------------------------------------------------------
6E07             3 160 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E07             3 161 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E07             3 162 ;
6E07             3 163 ; This routine converts a screen address (HL) into an attribute address (IX):
6E07             3 164 ;
6E07             3 165 ;             H           |           L
6E07             3 166 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E07             3 167 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E07             3 168 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E07             3 169 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E07             3 170 ;
6E07             3 171 ;            IXH          |          IXL
6E07             3 172 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E07             3 173 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E07             3 174 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E07             3 175 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E07             3 176 ;
6E07             3 177 ; where:
6E07             3 178 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E07             3 179 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E07             3 180 ;
6E07             3 181 ; Input:    HL = screen address of the hexagon
6E07             3 182 ;
6E07             3 183 ; Output:   IX = attribute address of the hexagon
6E07             3 184 ;
6E07             3 185 ; Uses:     TOKEN_COLOR (current token color)
6E07             3 186 ;
6E07             3 187 ; Destroys: A
6E07             3 188 ; ----------------------------------------------------------------------------------------------------------------------
6E07             3 189 Draw_Hexagon_Color:
6E07 7C          3 190 ld      a, h                        ; get high byte of screen address
6E08 F6 87       3 191 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E0A 1F          3 192 rra                                 ; shift Y7-Y6 two positions
6E0B 1F          3 193 rra
6E0C CB 3F       3 194 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E0E DD 67       3 195 ld      ixh, a                      ; set high byte of attribute address in IXH
6E10 7D          3 196 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E11 DD 6F       3 197 ld      ixl, a                      ; set low byte of attribute address in IXL
6E13 3A 9E 61    3 198 ld      a, (TOKEN_COLOR)            ; get current token color
6E16 DD 77 00    3 199 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E19 DD 77 01    3 200 ld      (ix+1), a
6E1C DD 77 20    3 201 ld      (ix+32), a
6E1F DD 77 21    3 202 ld      (ix+33), a
6E22 C9          3 203 ret

; File #4: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Input.z80asm

6E23             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E23             4 2 ; Input.z80asm
6E23             4 3 ; Coded by Antonio Luque
6E23             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E23             4 6 MAX_CHARS               equ     2                           ; maximum of input chars
6E23             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E23             4 9 ; Input_Move: wait for input a move from keyboard
6E23             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E23             4 11 ;
6E23             4 12 ; Input:    -
6E23             4 13 ;
6E23             4 14 ; Output:   -
6E23             4 15 ;
6E23             4 16 ; Uses:     TOKEN_COLOR (current token color)
6E23             4 17 ;           STR_MOVE (formatted move string)
6E23             4 18 ;
6E23             4 19 ; Destroys: A, A', BC, DE, HL, IX
6E23             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E23             4 21 Input_Move:
6E23 01 00 02    4 22 ld      bc, MAX_CHARS*256           ; B = maximum of input chars, C = chars counter
6E26 DD 21 83 5A 4 24 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E2A 21 83 50    4 25 ld      hl, $5083                   ; HL points to screen address of RED input text
6E2D 3A 9E 61    4 26 ld      a, (TOKEN_COLOR)            ; check current player color
6E30 FE 02       4 27 cp      RED_COLOR                   ; is RED the current token color?
6E32 28 07       4 28 jr      z, Input_Start              ; yes, start input
6E34 DD 21 19 59 4 29 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E38 21 19 48    4 30 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E3B             4 31 Input_Start
6E3B DD 36 00 C7 4 32 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E3F 3E 5F       4 33 ld      a, '_'                      ; text input cursor
6E41 CD 5D 6F    4 34 call    Print_Char                  ; print cursor
6E44             4 35 Input_Loop
6E44 CD BD 6E    4 36 call    Input_Key_Scan              ; scan for a key pressed
6E47 FE 0D       4 38 cp      $0D                         ; is it ENTER?
6E49 28 64       4 39 jr      z, Input_Enter              ; yes, perform enter pressed
6E4B FE 30       4 40 cp      '0'                         ; is it "delete"? (char '0' acts as delete, without Shift)
6E4D 28 42       4 41 jr      z, Input_Delete             ; yes, perform delete char
6E4F 08          4 42 ex      af, af'                     ; store char in A'
6E50 79          4 43 ld      a, c                        ; check number of chars inserted
6E51 B8          4 44 cp      b                           ; chars limit reached?
6E52 28 F0       4 45 jr      z, Input_Loop               ; yes, repeat input loop
6E54 B7          4 47 or      a                           ; is it the first char?
6E55 20 21       4 48 jr      nz, Input_Numbers           ; no, perform input of 2nd char
6E57             4 50 ; restrict first char to 'a'-'g'
6E57 08          4 52 ex      af, af'                     ; restore char
6E58 FE 61       4 53 cp      'a'                         ; is it < 'a'?
6E5A 38 E8       4 54 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E5C FE 68       4 55 cp      'h'                         ; is it >= 'g'?
6E5E 30 E4       4 56 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E60             4 58 ; char is valid as column
6E60 32 18 62    4 60 ld      (STR_MOVE+0), a             ; save char in player move
6E63 DD 36 00 47 4 61 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E67 CD 5D 6F    4 62 call    Print_Char                  ; print key pressed
6E6A 0C          4 63 inc     c                           ; increment chars counter
6E6B 2C          4 64 inc     l                           ; increment X position of current input screen location
6E6C DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E6E 3E 2D       4 66 ld      a, '-'                      ; set dash char
6E70 CD 5D 6F    4 67 call    Print_Char                  ; print key pressed
6E73 2C          4 68 inc     l                           ; increment X position of current input screen location
6E74 DD 2C       4 69 inc     ixl                         ; increment X position of current input attr location
6E76 18 C3       4 70 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E78             4 71 Input_Numbers
6E78             4 72 ; restrict second char to '1'-'7'
6E78 08          4 74 ex      af, af'                     ; restore char
6E79 FE 31       4 75 cp      '1'                         ; is it < '1'?
6E7B 38 C7       4 76 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E7D FE 38       4 77 cp      '8'                         ; is it >= '8'?
6E7F 30 C3       4 78 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E81             4 80 ; char is valid as row
6E81 32 1B 62    4 82 ld      (STR_MOVE+3), a             ; save char in player move
6E84 DD 36 00 47 4 83 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E88 CD 5D 6F    4 84 call    Print_Char                  ; print key pressed
6E8B 0C          4 85 inc     c                           ; increment chars counter
6E8C 2C          4 86 inc     l                           ; increment X position of current input screen location
6E8D DD 2C       4 87 inc     ixl                         ; increment X position of current input attr location
6E8F 18 AA       4 88 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E91             4 90 ; player pressed "delete" (char '0')
6E91             4 91 Input_Delete
6E91 79          4 92 ld      a, c                        ; get char counter
6E92 B7          4 93 or      a                           ; is it 0?
6E93 28 AF       4 94 jr      z, Input_Loop               ; repeat input loop (no chars to delete)
6E95 DD 36 00 47 4 96 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E99 B8          4 97 cp      b                           ; is it the first char?
6E9A 28 08       4 98 jr      z, Input_Delete_Char        ; yes, continue delete
6E9C 3E 20       4 99 ld      a, ' '                      ; empty char
6E9E CD 5D 6F    4 100 call    Print_Char                  ; delete cursor and last char
6EA1 2D          4 101 dec     l                           ; decrement X position of input screen location
6EA2 DD 2D       4 102 dec     ixl                         ; decrement X position of input attr location
6EA4             4 103 Input_Delete_Char
6EA4 0D          4 104 dec     c                           ; decrement char counter
6EA5 3E 20       4 105 ld      a, ' '                      ; empty char
6EA7 CD 5D 6F    4 106 call    Print_Char                  ; delete cursor and last char
6EAA 2D          4 107 dec     l                           ; decrement X position of player input screen location
6EAB DD 2D       4 108 dec     ixl                         ; decrement X position of player input attr location
6EAD 18 8C       4 109 jr      Input_Start                 ; get next char
6EAF             4 111 ; player pressed ENTER
6EAF             4 112 Input_Enter
6EAF 79          4 113 ld      a, c                        ; check char counter  
6EB0 B8          4 114 cp      b                           ; is it < MAX_CHARS?
6EB1 38 91       4 115 jr      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EB3 DD 36 00 47 4 117 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EB7 3E 20       4 118 ld      a, ' '                      ; empty char
6EB9 CD 5D 6F    4 119 call    Print_Char                  ; delete cursor
6EBC C9          4 120 ret
6EBD             4 122 ; ----------------------------------------------------------------------------------------------------------------------
6EBD             4 123 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EBD             4 124 ;
6EBD             4 125 ;                           Bit
6EBD             4 126 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EBD             4 127 ;  ------+-------+-------+-------+-------+-------+
6EBD             4 128 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EBD             4 129 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EBD             4 130 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EBD             4 131 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EBD             4 132 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EBD             4 133 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EBD             4 134 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EBD             4 135 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EBD             4 136 ;
6EBD             4 137 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EBD             4 138 ;
6EBD             4 139 ; Input:    -
6EBD             4 140 ;
6EBD             4 141 ; Output:   A = ASCII code of key pressed
6EBD             4 142 ;
6EBD             4 143 ; Destroys: DE
6EBD             4 144 ; ----------------------------------------------------------------------------------------------------------------------
6EBD             4 145 Input_Key_Scan:
6EBD C5          4 146 push    bc                          ; store registers
6EBE E5          4 147 push    hl
6EBF             4 148 Input_Key_Released
6EBF 01 FE FE    4 149 ld      bc, $FEFE                   ; set keyboard port (see above)
6EC2             4 150 Input_Key_Released_Line
6EC2 ED 78       4 151 in      a, (c)                      ; read port
6EC4 2F          4 152 cpl                                 ; invert bits
6EC5 E6 1F       4 153 and     %00011111                   ; check 0 to 4 bits
6EC7 20 F6       4 154 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6EC9 CB 00       4 155 rlc     b                           ; move BC to the next port
6ECB 38 F5       4 156 jr      c, Input_Key_Released_Line  ; repeat for each port
6ECD 11 05 00    4 157 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6ED0             4 158 Input_Key_Pressed_Begin
6ED0 21 D8 61    4 159 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6ED3             4 160 Input_Key_Pressed_Line
6ED3 ED 78       4 161 in      a, (c)                      ; read port
6ED5 2F          4 162 cpl                                 ; invert bits
6ED6 E6 1F       4 163 and     %00011111                   ; check 0 to 4 bits
6ED8 20 08       4 164 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6EDA 19          4 165 add     hl, de                      ; HL points to the next KEY_MAP block
6EDB CB 00       4 166 rlc     b                           ; move BC to the next port
6EDD 38 F4       4 167 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6EDF 18 EF       4 168 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6EE1             4 169 Input_Key_Next
6EE1 23          4 170 inc     hl                          ; move HL to the next character
6EE2             4 171 Input_Key_Pressed
6EE2 1F          4 172 rra                                 ; rotate bits of port readed
6EE3 30 FC       4 173 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6EE5 7E          4 174 ld      a, (hl)                     ; return key pressed (ASCII) in A
6EE6 E1          4 175 pop     hl                          ; restore registers
6EE7 C1          4 176 pop     bc
6EE8 C9          4 177 ret

; File #5: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Print.z80asm

6EE9             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6EE9             5 2 ; Print.z80asm
6EE9             5 3 ; Coded by Antonio Luque
6EE9             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6EE9             5 6 CHAR_SET                equ     FONT-256                    ; address of character set data, adjusted for ASCII codes
6EE9             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6EE9             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6EE9             5 10 ;
6EE9             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6EE9             5 12 ;
6EE9             5 13 ; Output:   -
6EE9             5 14 ;
6EE9             5 15 ; Destroys: A, BC, DE, HL
6EE9             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6EE9             5 17 Print_Players:
6EE9 11 24 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6EEC 01 1D 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6EEF 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6EF2 FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6EF4 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6EF6 11 1D 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6EF9 01 24 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6EFC             5 25 Print_Players_Strings
6EFC CD 51 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6EFF 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F00 59          5 28 ld      e, c
6F01 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F04 18 4B       5 30 jr      Print_String                ; print "Player" or "Speccy"
6F06             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F06             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F06             5 34 ;
6F06             5 35 ; Input:    -
6F06             5 36 ; Output:   -
6F06             5 37 ; Destroys: A, BC, DE, HL, IX
6F06             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F06             5 39 Print_Clear_Alert:
6F06 11 49 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F09 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F0B 18 02       5 42 jr      Print_Alert_XY              ; print (clear) alert string
6F0D             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F0D             5 45 ; Print_Alert: print an alert message below the current player input move
6F0D             5 46 ;
6F0D             5 47 ; Input:    DE = alert message string address
6F0D             5 48 ;
6F0D             5 49 ; Output:   -
6F0D             5 50 ;
6F0D             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F0D             5 52 ;
6F0D             5 53 ; Destroys: A, BC, DE, HL, IX
6F0D             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F0D             5 55 Print_Alert:
6F0D 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F0F             5 57 Print_Alert_XY
6F0F DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F13 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F16 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F19 FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F1B 28 31       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F1D DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F21 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F24 18 28       5 65 jr      Print_String_Color          ; print alert string with color
6F26             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F26             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F26             5 69 ;
6F26             5 70 ; Input:    -
6F26             5 71 ;
6F26             5 72 ; Output:   -
6F26             5 73 ;
6F26             5 74 ; Destroys: A, BC, DE, HL, IX
6F26             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F26             5 76 Print_Wait:
6F26 11 38 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F29 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F2B 18 0C       5 79 jr      Print_Move_XY               ; print wait string
6F2D             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F2D             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F2D             5 83 ;
6F2D             5 84 ; Input:    -
6F2D             5 85 ;
6F2D             5 86 ; Output:   -
6F2D             5 87 ;
6F2D             5 88 ; Destroys: A, BC, DE, HL, IX
6F2D             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F2D             5 90 Print_Clear_Move:
6F2D 11 44 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F30 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F32 18 05       5 93 jr      Print_Move_XY               ; print (clear) move string
6F34             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F34             5 96 ; Print_Move: print a formatted move at current player input move location 
6F34             5 97 ;
6F34             5 98 ; Input:    -
6F34             5 99 ;
6F34             5 100 ; Output:   -
6F34             5 101 ;
6F34             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F34             5 103 ;
6F34             5 104 ; Destroys: A, BC, DE, HL, IX
6F34             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F34             5 106 Print_Move:
6F34 11 18 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F37 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F39             5 109 Print_Move_XY
6F39 DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F3D 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F40 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F43 FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F45 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F47 DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F4B 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F4E             5 117 Print_String_Color
6F4E CD 63 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F51             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F51             5 120 ; Print_String: print a string on the screen
6F51             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F51             5 122 ;
6F51             5 123 ; Input:    DE = string address (ending with 0)
6F51             5 124 ;           HL = string screen address
6F51             5 125 ;
6F51             5 126 ; Output:   -
6F51             5 127 ;
6F51             5 128 ; Destroys: A, DE, HL
6F51             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F51             5 130 Print_String:
6F51 1A          5 131 ld      a, (de)                     ; get string character
6F52 B7          5 132 or      a                           ; is it 0? (end of string)
6F53 C8          5 133 ret     z                           ; yes, return
6F54 D5          5 134 push    de                          ; store pointer to string address
6F55 CD 5D 6F    5 135 call    Print_Char                  ; print character
6F58 D1          5 136 pop     de                          ; restore pointer to string address
6F59 13          5 137 inc     de                          ; move DE to next string character
6F5A 2C          5 138 inc     l                           ; move HL to next screen column
6F5B 18 F4       5 139 jr      Print_String                ; repeat until end of string
6F5D             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F5D             5 142 ; Print_Char: print a character on the screen
6F5D             5 143 ;
6F5D             5 144 ; Input:    A  = character to print (ASCII)
6F5D             5 145 ;           HL = character screen address
6F5D             5 146 ;
6F5D             5 147 ; Output:   -
6F5D             5 148 ;
6F5D             5 149 ; Destroys: A, DE
6F5D             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F5D             5 151 Print_Char:
6F5D 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F60             5 153 Print_Tile:
6F60 E5          5 154 push    hl                          ; store pointer to character/tile screen address
6F61 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F63 6F          5 156 ld      l, a
6F64 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6F65 29          5 158 add     hl, hl
6F66 29          5 159 add     hl, hl
6F67 19          5 160 add     hl, de                      ; move HL to character/tile address
6F68 EB          5 161 ex      de, hl                      ; DE points to character/tile address
6F69 E1          5 162 pop     hl                          ; restore pointer to character/tile screen address
6F6A C5          5 163 push    bc                          ; store BC register
6F6B 4C          5 164 ld      c, h                        ; save high byte of character/tile screen address
6F6C 06 08       5 165 ld      b, 8                        ; number of character/tile bytes (loop counter)
6F6E             5 166 Print_Tile_Pixels
6F6E 1A          5 167 ld      a, (de)                     ; get character/tile byte
6F6F 77          5 168 ld      (hl), a                     ; put character/tile byte on screen
6F70 13          5 169 inc     de                          ; move DE to next character/tile byte
6F71 24          5 170 inc     h                           ; move HL down one pixel-line
6F72 10 FA       5 171 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6F74 61          5 172 ld      h, c                        ; restore high byte of character/tile screen address
6F75 C1          5 173 pop     bc                          ; restore BC register
6F76 C9          5 174 ret

; File #6: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Brainiac.z80asm

6F77             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6F77             6 2 ; Brainiac.z80asm
6F77             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F77             6 4 ;
6F77             6 5 ; Adapted for Hex game by Einar Saukas
6F77             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6F77             6 8 MIN_VALUE               equ     0                           ; alphaBeta pruning minimum value
6F77             6 9 MAX_VALUE               equ     255                         ; alphaBeta pruning maximum value
6F77             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6F77             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6F77             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6F77             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6F77             6 15 ; depth.
6F77             6 16 ;
6F77             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F77             6 18 ;
6F77             6 19 ; Input:    A  = speccy side (FRIEND or ENEMY)
6F77             6 20 ;           IX = candidates vector address
6F77             6 21 ;
6F77             6 22 ; Output:   E  = selected position (speccy move)
6F77             6 23 ;
6F77             6 24 ; Uses:     AI_PLAYER (speccy side)
6F77             6 25 ;           AI_DEPTH (recursion depth level)
6F77             6 26 ;
6F77             6 27 ; Destroys: A, A', BC, D, HL, IX, IY
6F77             6 28 ; ----------------------------------------------------------------------------------------------------------------------
6F77             6 29 BRAINIAC_best_move:
6F77 32 99 61    6 30 ld      (AI_PLAYER), a              ; save speccy side
6F7A CD 73 74    6 32 call    PathFinder_Score            ; get board score
6F7D CD 1C 75    6 33 call    PathFinder_Candidates       ; get candidates from board potentials
6F80             6 35 ; BRAINIAC start
6F80             6 36 AI_First_Candidate
6F80 DD 7E 00    6 37 ld      a, (ix+0)                   ; A is our first candidate
6F83 5F          6 39 ld      e, a                        ; E = best speccy move (initialization)
6F84 16 00       6 40 ld      d, MIN_VALUE                ; D = alphaMax
6F86             6 42 AI_Main_Loop                                                ; for each candidate {
6F86 D5          6 43 push    de                          ;       store alphaMax and best speccy move
6F87 26 7D       6 45 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F89 6F          6 46 ld      l, a
6F8A E5          6 47 push    hl
6F8B 3A 99 61    6 49 ld      a, (AI_PLAYER)              ;       get speccy side
6F8E CD EF 70    6 50 call    PathFinder_PutToken         ;       BRAINIAC_play
6F91 1E FF       6 51 ld      e, MAX_VALUE                ;       E = betaMin
6F93 CD AC 6F    6 52 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6F96 E1          6 54 pop     hl                          ;       restore candidate position
6F97 CD F5 70    6 55 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6F9A D1          6 57 pop     de                          ;       restore alphaMax and best player node
6F9B BA          6 59 cp      d
6F9C 38 04       6 60 jr      c, AI_Main_Next
6F9E 28 02       6 61 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FA0 57          6 63 ld      d, a                        ;       alphaMax = A
6FA1 5D          6 64 ld      e, l                        ;       best move = E
6FA2             6 66 AI_Main_Next
6FA2 DD 2D       6 67 dec     ixl
6FA4 DD 7E 00    6 68 ld      a, (ix+0)                   ;       A is our next candidate
6FA7 B7          6 69 or      a                           ;       repeat until no more candidates
6FA8 C2 86 6F    6 70 jp      nz, AI_Main_Loop            ; }
6FAB C9          6 71 ret
6FAC             6 73 ; ----------------------------------------------------------------------------------------------------------------------
6FAC             6 74 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FAC             6 75 ; Speccy's score.
6FAC             6 76 ;
6FAC             6 77 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FAC             6 78 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FAC             6 79 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FAC             6 80 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FAC             6 81 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FAC             6 82 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FAC             6 83 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FAC             6 84 ; could be just reproducing the best score from its sibling.
6FAC             6 85 ;
6FAC             6 86 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FAC             6 87 ;
6FAC             6 88 ; Input:    D = alphaMax
6FAC             6 89 ;           E = betaMin
6FAC             6 90 ;
6FAC             6 91 ; Output:   A = "improved" betaMin
6FAC             6 92 ;           D = alphaMax
6FAC             6 93 ;           E = "improved" betaMin
6FAC             6 94 ;
6FAC             6 95 ; Uses:     AI_PLAYER (speccy side)
6FAC             6 96 ;           AI_DEPTH (recursion depth level)
6FAC             6 97 ;
6FAC             6 98 ; Destroys: BC, HL, IX, IY
6FAC             6 99 ; ----------------------------------------------------------------------------------------------------------------------
6FAC             6 100 Alphabeta_Min:
6FAC D5          6 101 push    de
6FAD             6 103 ; check if last speccy move is a winner one
6FAD CD 73 74    6 105 call    PathFinder_Score            ; if (speccy won)
6FB0 B7          6 106 or      a
6FB1 C2 BB 6F    6 107 jp      nz, Alphabeta_Min_Candidates
6FB4 3A 9A 61    6 108 ld      a, (AI_DEPTH)
6FB7 C6 C0       6 109 add     a, 192                      ;     return 192+depth
6FB9 D1          6 110 pop     de
6FBA C9          6 111 ret
6FBB             6 113 Alphabeta_Min_Candidates
6FBB CD 1C 75    6 114 call    PathFinder_Candidates       ; find candidates for next move
6FBE D1          6 115 pop     de
6FBF DD 7E 00    6 117 ld      a, (ix+0)                   ; A is our first candidate
6FC2 21 9A 61    6 119 ld      hl, AI_DEPTH
6FC5 35          6 120 dec     (hl)                        ; depth--
6FC6 CA 06 70    6 121 jp      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
6FC9             6 123 Alphabeta_Min_Loop                                          ; for each candidate {
6FC9 D5          6 124 push    de                          ;       store alphaMax and betaMin
6FCA 26 7D       6 126 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FCC 6F          6 127 ld      l, a
6FCD E5          6 128 push    hl
6FCE 3A 99 61    6 130 ld      a, (AI_PLAYER)              ;       get speccy side
6FD1 EE 7C       6 131 xor     $7C                         ;       switch to player side
6FD3 CD EF 70    6 132 call    PathFinder_PutToken         ;       BRAINIAC_play
6FD6 CD 4A 70    6 133 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
6FD9 E1          6 135 pop     hl                          ;       restore candidate position
6FDA CD F5 70    6 136 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FDD D1          6 138 pop     de                          ;       restore alphaMax and betaMin
6FDE BB          6 140 cp      e
6FDF 30 06       6 141 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
6FE1 BA          6 143 cp      d
6FE2 38 12       6 144 jr      c, Alphabeta_Min_Exit
6FE4 28 10       6 145 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FE6 5F          6 147 ld      e, a                        ;       betaMin = A
6FE7             6 149 Alphabeta_Min_Next
6FE7 DD 2D       6 150 dec     ixl
6FE9 DD 7E 00    6 151 ld      a, (ix+0)                   ;       A is our next candidate
6FEC B7          6 152 or      a                           ;       repeat until no more candidates
6FED C2 C9 6F    6 153 jp      nz, Alphabeta_Min_Loop      ; }
6FF0 7B          6 155 ld      a, e                        ; return betaMin
6FF1 21 9A 61    6 157 ld      hl, AI_DEPTH
6FF4 34          6 158 inc     (hl)                        ; depth++
6FF5 C9          6 159 ret
6FF6             6 161 Alphabeta_Min_Exit
6FF6 5F          6 162 ld      e, a                        ; (discard remaining candidates)
6FF7 AF          6 163 xor     a
6FF8             6 164 Alphabeta_Min_Skip
6FF8 DD 2D       6 165 dec     ixl
6FFA DD BE 00    6 166 cp      (ix+0)
6FFD C2 F8 6F    6 167 jp      nz, Alphabeta_Min_Skip
7000 7B          6 168 ld      a, e
7001 21 9A 61    6 170 ld      hl, AI_DEPTH
7004 34          6 171 inc     (hl)                        ; (depth++)
7005 C9          6 172 ret
7006             6 174 ; ----------------------------------------------------------------------------------------------------------------------
7006             6 175 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
7006             6 176 ; beta pruning, when it requires MINIMIZING Speccy's score.
7006             6 177 ;
7006             6 178 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
7006             6 179 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
7006             6 180 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
7006             6 181 ; faster.
7006             6 182 ;
7006             6 183 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7006             6 184 ;
7006             6 185 ; Input:    A = first candidate
7006             6 186 ;           D = alphaMax
7006             6 187 ;           E = betaMin
7006             6 188 ;
7006             6 189 ; Output:   A = "improved" betaMin
7006             6 190 ;           D = alphaMax
7006             6 191 ;           E = "improved" betaMin
7006             6 192 ;
7006             6 193 ; Uses:     AI_PLAYER (speccy side)
7006             6 194 ;           AI_DEPTH (recursion depth level)
7006             6 195 ;
7006             6 196 ; Destroys: BC, HL, IX, IY
7006             6 197 ; ----------------------------------------------------------------------------------------------------------------------
7006             6 198 Heuristic_Min:                                              ; for each candidate {
7006 D5          6 199 push    de                          ;       store alphaMax and betaMin
7007 26 7D       6 201 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7009 6F          6 202 ld      l, a
700A E5          6 203 push    hl
700B 3A 99 61    6 205 ld      a, (AI_PLAYER)              ;       get speccy side
700E EE 7C       6 206 xor     $7C                         ;       switch to player side
7010 CD EF 70    6 207 call    PathFinder_PutToken         ;       BRAINIAC_play
7013 CD 73 74    6 209 call    PathFinder_Score            ;       if (player won)
7016 FE FF       6 210 cp      -1
7018 C2 1D 70    6 211 jp      nz, Heuristic_Min_Continue
701B 3E 40       6 212 ld      a, 64                       ;           A = 64
701D             6 213 Heuristic_Min_Continue
701D E1          6 214 pop     hl
701E CD F5 70    6 215 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7021 D1          6 217 pop     de
7022 BB          6 219 cp      e
7023 30 06       6 220 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
7025 BA          6 222 cp      d
7026 38 12       6 223 jr      c, Heuristic_Min_Exit
7028 28 10       6 224 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
702A 5F          6 226 ld      e, a                        ;       betaMin = A
702B             6 228 Heuristic_Min_Next
702B DD 2D       6 229 dec     ixl
702D DD 7E 00    6 230 ld      a, (ix+0)                   ;       A is our next candidate
7030 B7          6 231 or      a                           ;       repeat until no more candidates
7031 C2 06 70    6 232 jp      nz, Heuristic_Min           ; }
7034 7B          6 234 ld      a, e                        ; return betaMin
7035 21 9A 61    6 236 ld      hl, AI_DEPTH
7038 34          6 237 inc     (hl)                        ; depth++
7039 C9          6 238 ret
703A             6 240 Heuristic_Min_Exit
703A 5F          6 241 ld      e, a                        ; (discard remaining candidates)
703B AF          6 242 xor     a
703C             6 243 Heuristic_Min_Skip
703C DD 2D       6 244 dec     ixl
703E DD BE 00    6 245 cp      (ix+0)
7041 C2 3C 70    6 246 jp      nz, Heuristic_Min_Skip
7044 7B          6 247 ld      a, e
7045 21 9A 61    6 249 ld      hl, AI_DEPTH
7048 34          6 250 inc     (hl)                        ; (depth++)
7049 C9          6 251 ret
704A             6 253 ; ----------------------------------------------------------------------------------------------------------------------
704A             6 254 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
704A             6 255 ; Speccy's score.
704A             6 256 ;
704A             6 257 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
704A             6 258 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
704A             6 259 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
704A             6 260 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
704A             6 261 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
704A             6 262 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
704A             6 263 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
704A             6 264 ; the same score and could be just reproducing the best score from its sibling.
704A             6 265 ;
704A             6 266 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
704A             6 267 ;
704A             6 268 ; Input:    D = alphaMax
704A             6 269 ;           E = betaMin
704A             6 270 ;
704A             6 271 ; Output:   A = "improved" alphaMax
704A             6 272 ;           D = "improved" alphaMax
704A             6 273 ;           E = betaMin
704A             6 274 ;
704A             6 275 ; Uses:     AI_PLAYER (speccy side)
704A             6 276 ;           AI_DEPTH (recursion depth level)
704A             6 277 ;
704A             6 278 ; Destroys: BC, HL, IX, IY
704A             6 279 ; ----------------------------------------------------------------------------------------------------------------------
704A             6 280 Alphabeta_Max:
704A D5          6 281 push    de
704B             6 283 ; check if last player move is a winner one
704B CD 73 74    6 285 call    PathFinder_Score            ; if (player won)
704E FE FF       6 286 cp      -1
7050 C2 5B 70    6 287 jp      nz, Alphabeta_Max_Candidates
7053 3A 9A 61    6 288 ld      a, (AI_DEPTH)
7056 2F          6 289 cpl
7057 C6 41       6 290 add     a, 64+1                     ;     return 64-depth
7059 D1          6 291 pop     de
705A C9          6 292 ret
705B             6 294 Alphabeta_Max_Candidates
705B CD 1C 75    6 295 call    PathFinder_Candidates       ; find candidates for next move
705E D1          6 296 pop     de
705F DD 7E 00    6 298 ld      a, (ix+0)                   ; A is our first candidate
7062 21 9A 61    6 300 ld      hl, AI_DEPTH
7065 35          6 301 dec     (hl)                        ; depth--
7066 CA A4 70    6 302 jp      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
7069             6 304 Alphabeta_Max_Loop                                          ; for each candidate {
7069 D5          6 305 push    de                          ;       store alphaMax and betaMin
706A 26 7D       6 307 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
706C 6F          6 308 ld      l, a
706D E5          6 309 push    hl
706E 3A 99 61    6 311 ld      a, (AI_PLAYER)              ;       get speccy side
7071 CD EF 70    6 312 call    PathFinder_PutToken         ;       BRAINIAC_play
7074 CD AC 6F    6 313 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
7077 E1          6 315 pop     hl                          ;       restore candidate position
7078 CD F5 70    6 316 call    PathFinder_EraseToken       ;       BRAINIAC_undo
707B D1          6 318 pop     de                          ;       restore alphaMax and betaMin
707C BA          6 320 cp      d
707D 38 06       6 321 jr      c, Alphabeta_Max_Next
707F 28 04       6 322 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
7081 BB          6 324 cp      e
7082 30 10       6 325 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
7084 57          6 327 ld      d, a                        ;       alphaMax = A
7085             6 329 Alphabeta_Max_Next
7085 DD 2D       6 330 dec     ixl
7087 DD 7E 00    6 331 ld      a, (ix+0)                   ;       A is our next candidate
708A B7          6 332 or      a                           ;       repeat until no more candidates
708B C2 69 70    6 333 jp      nz, Alphabeta_Max_Loop      ; }
708E 7A          6 335 ld      a, d                        ; return alphaMax
708F 21 9A 61    6 337 ld      hl, AI_DEPTH
7092 34          6 338 inc     (hl)                        ; depth++
7093 C9          6 339 ret
7094             6 341 Alphabeta_Max_Exit
7094 57          6 342 ld      d, a                        ; (discard remaining candidates)
7095 AF          6 343 xor     a
7096             6 344 Alphabeta_Max_Skip
7096 DD 2D       6 345 dec     ixl
7098 DD BE 00    6 346 cp      (ix+0)
709B C2 96 70    6 347 jp      nz, Alphabeta_Max_Skip
709E 7A          6 348 ld      a, d
709F 21 9A 61    6 350 ld      hl, AI_DEPTH
70A2 34          6 351 inc     (hl)                        ; (depth++)
70A3 C9          6 352 ret
70A4             6 354 ; ----------------------------------------------------------------------------------------------------------------------
70A4             6 355 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70A4             6 356 ; beta pruning, when it requires MAXIMIZING Speccy's score.
70A4             6 357 ;
70A4             6 358 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70A4             6 359 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70A4             6 360 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70A4             6 361 ; faster.
70A4             6 362 ;
70A4             6 363 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70A4             6 364 ;
70A4             6 365 ; Input:    A = first candidate
70A4             6 366 ;           D = alphaMax
70A4             6 367 ;           E = betaMin
70A4             6 368 ;
70A4             6 369 ; Returns:  A = "improved" alphaMax
70A4             6 370 ;           D = "improved" alphaMax
70A4             6 371 ;           E = betaMin
70A4             6 372 ;
70A4             6 373 ; Uses:     AI_PLAYER (speccy side)
70A4             6 374 ;           AI_DEPTH (recursion depth level)
70A4             6 375 ;
70A4             6 376 ; Destroys: BC, HL, IX, IY
70A4             6 377 ; ----------------------------------------------------------------------------------------------------------------------
70A4             6 378 Heuristic_Max:                                              ; for each candidate {
70A4 D5          6 379 push    de                          ;       store alphaMax and betaMin
70A5 26 7D       6 381 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70A7 6F          6 382 ld      l, a
70A8 E5          6 383 push    hl
70A9 3A 99 61    6 385 ld      a, (AI_PLAYER)              ;       get speccy side
70AC CD EF 70    6 386 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70AF CD 73 74    6 388 call    PathFinder_Score            ;       if (speccy won)
70B2 B7          6 389 or      a
70B3 C2 B8 70    6 390 jp      nz, Heuristic_Max_Continue
70B6 3E C0       6 391 ld      a, 192                      ;           A = 192
70B8             6 392 Heuristic_Max_Continue
70B8 E1          6 393 pop     hl                          ;       restore candidate position
70B9 CD F5 70    6 394 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70BC D1          6 396 pop     de                          ;       restore alphaMax and betaMin
70BD BA          6 398 cp      d
70BE 38 06       6 399 jr      c, Heuristic_Max_Next
70C0 28 04       6 400 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
70C2 BB          6 402 cp      e
70C3 30 10       6 403 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70C5 57          6 405 ld      d, a                        ;       alphaMax = A
70C6             6 407 Heuristic_Max_Next
70C6 DD 2D       6 408 dec     ixl
70C8 DD 7E 00    6 409 ld      a, (ix+0)                   ;       A is our next candidate
70CB B7          6 410 or      a                           ;       repeat until no more candidates
70CC C2 A4 70    6 411 jp      nz, Heuristic_Max           ; }
70CF 7A          6 413 ld      a, d                        ; return alphaMax
70D0 21 9A 61    6 415 ld      hl, AI_DEPTH
70D3 34          6 416 inc     (hl)                        ; depth++
70D4 C9          6 417 ret
70D5             6 419 Heuristic_Max_Exit
70D5 57          6 420 ld      d, a                        ; (discard remaining candidates)
70D6 AF          6 421 xor     a
70D7             6 422 Heuristic_Max_Skip
70D7 DD 2D       6 423 dec     ixl
70D9 DD BE 00    6 424 cp      (ix+0)
70DC C2 D7 70    6 425 jp      nz, Heuristic_Max_Skip
70DF 7A          6 426 ld      a, d
70E0 21 9A 61    6 428 ld      hl, AI_DEPTH
70E3 34          6 429 inc     (hl)                        ; (depth++)
70E4 C9          6 430 ret

; File #7: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\PathFinder.z80asm

70E5             7 1 ; ----------------------------------------------------------------------------------------------------------------------
70E5             7 2 ; PathFinder.z80asm
70E5             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
70E5             7 4 ;
70E5             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
70E5             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
70E5             7 7 ; ----------------------------------------------------------------------------------------------------------------------
70E5             7 9 CYAN                    equ     $01                         ; cyan side
70E5             7 10 RED                     equ     $02                         ; red side
70E5             7 11 WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor
70E5             7 12 EMPTY                   equ     $00                         ; empty positions on the board
70E5             7 13 SKIPPED                 equ     $01                         ; skipped positions on the board
70E5             7 14 FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
70E5             7 15 VICTORY                 equ     $03                         ; internal value if victory
70E5             7 16 ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
70E5             7 18 CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
70E5             7 19 RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
70E5             7 20 CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates
70E5             7 22 ; ----------------------------------------------------------------------------------------------------------------------
70E5             7 23 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
70E5             7 24 ;
70E5             7 25 ; Input:    -
70E5             7 26 ;
70E5             7 27 ; Output:   A = FRIEND, if current token color is cyan
70E5             7 28 ;           A = ENEMY, if current token color is red
70E5             7 29 ;
70E5             7 30 ; Uses:     TOKEN_COLOR (current token color)
70E5             7 31 ;
70E5             7 32 ; Destroys: -
70E5             7 33 ; ----------------------------------------------------------------------------------------------------------------------
70E5             7 34 PathFinder_Friend:
70E5 3A 9E 61    7 35 ld      a, (TOKEN_COLOR)            ; get current player color
70E8 1F          7 36 rra                                 ; is current player color cyan?
70E9 3E 02       7 37 ld      a, FRIEND                   ; set FRIEND in A
70EB D8          7 38 ret     c                           ; yes, return FRIEND 
70EC EE 7C       7 39 xor     $7C                         ; no, return ENEMY
70EE C9          7 40 ret
70EF             7 42 ; ----------------------------------------------------------------------------------------------------------------------
70EF             7 43 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
70EF             7 44 ;
70EF             7 45 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
70EF             7 46 ;           HL = CYAN_POSITIONS token address
70EF             7 47 ;
70EF             7 48 ; Output:   -
70EF             7 49 ;
70EF             7 50 ; Destroys: -
70EF             7 51 ; ----------------------------------------------------------------------------------------------------------------------
70EF             7 52 PathFinder_PutToken:
70EF 77          7 53 ld      (hl), a                     ; put token at cyan position
70F0 24          7 54 inc     h                           ; move HL to red position address
70F1 EE 7C       7 55 xor     $7C                         ; invert side
70F3 77          7 56 ld      (hl), a                     ; put token at red position
70F4 C9          7 57 ret
70F5             7 59 ; ----------------------------------------------------------------------------------------------------------------------
70F5             7 60 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
70F5             7 61 ;
70F5             7 62 ; Input:    HL = CYAN_POSITIONS token address
70F5             7 63 ;
70F5             7 64 ; Output:   -
70F5             7 65 ;
70F5             7 66 ; Destroys: -
70F5             7 67 ; ----------------------------------------------------------------------------------------------------------------------
70F5             7 68 PathFinder_EraseToken:
70F5 36 00       7 69 ld      (hl), EMPTY                 ; erase token at cyan position
70F7 24          7 70 inc     h                           ; move HL to red position address
70F8 36 00       7 71 ld      (hl), EMPTY                 ; erase token at red position
70FA C9          7 72 ret
70FB             7 74 ; ----------------------------------------------------------------------------------------------------------------------
70FB             7 75 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
70FB             7 76 ;
70FB             7 77 ; Input:    DE = cyan or red board address (destiny)
70FB             7 78 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
70FB             7 79 ;
70FB             7 80 ; Output:   -
70FB             7 81 ;
70FB             7 82 ; Destroys: BC, DE, HL
70FB             7 83 ; ----------------------------------------------------------------------------------------------------------------------
70FB             7 84 PathFinder_CopyPositions:
70FB 01 31 00    7 85 ld      bc, 7*7                     ; number of positions to be copied
70FE             7 86 PathFinder_CopyLoop
70FE 2C          7 87 inc     l                           ; skip borders on positions
70FF 2C          7 88 inc     l
7100 1C          7 89 inc     e                           ; skip borders on board
7101 1C          7 90 inc     e
7102 ED A0       7 91 ldi                                 ; copy a row of 7 positions
7104 ED A0       7 92 ldi
7106 ED A0       7 93 ldi
7108 ED A0       7 94 ldi
710A ED A0       7 95 ldi
710C ED A0       7 96 ldi
710E ED A0       7 97 ldi
7110 EA FE 70    7 98 jp      pe, PathFinder_CopyLoop     ; repeat for each row
7113 C9          7 99 ret
7114             7 101 ; ----------------------------------------------------------------------------------------------------------------------
7114             7 102 ; PathFinder_Update: update current board position during heuristic function evaluation
7114             7 103 ;
7114             7 104 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
7114             7 105 ; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
7114             7 106 ; adjacent".
7114             7 107 ;
7114             7 108 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
7114             7 109 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
7114             7 110 ; follows, depending on current content:
7114             7 111 ;
7114             7 112 ; * SKIPPED: 1 + distance of neighbor closest to goal
7114             7 113 ; * FRIEND:  distance of neighbor closest to goal
7114             7 114 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
7114             7 115 ;
7114             7 116 ; Input:    Z  = flag set when (HL) is FRIEND
7114             7 117 ;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
7114             7 118 ;           HL = current position address (on either cyan boards or red boards)
7114             7 119 ;
7114             7 120 ; Output:   -
7114             7 121 ;
7114             7 122 ; Destroys: B, DE
7114             7 123 ; ----------------------------------------------------------------------------------------------------------------------
7114             7 124 PathFinder_Update:
7114 28 12       7 125 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
7116 46          7 126 ld      b, (hl)                     ; check current position
7117 10 1A       7 127 djnz    PathFinder_EMPTY
7119             7 128 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
7119             7 129 PathFinder_Skipped:
7119 71          7 130 ld      (hl), c                     ; save current distance in current position
711A 34          7 131 inc     (hl)                        ; increment distance of current position
711B CB B6       7 132 res     6, (hl)                     ; reset friendly token flag
711D EB          7 133 ex      de, hl                      ; store current position in DE
711E             7 134 @Queue_Tail
711E 21 00 00    7 135 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
7121 2C          7 136 inc     l                           ; move queue tail down
7122 73          7 137 ld      (hl), e                     ; store position into queue tail
7123 22 1F 71    7 138 ld      (@Queue_Tail+1), hl         ; update queue tail
7126 EB          7 139 ex      de, hl                      ; restore current position
7127 C9          7 140 ret
7128             7 141 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
7128             7 142 PathFinder_Friendly
7128 71          7 143 ld      (hl), c                     ; save current distance in current position
7129 CB F6       7 144 set     6, (hl)                     ; set friendly token flag
712B 45          7 145 ld      b, l                        ; save current position in B
712C D1          7 146 pop     de                          ; preserve RET address
712D E3          7 147 ex      (sp), hl                    ; retrieve queue head
712E 70          7 148 ld      (hl), b                     ; push this position into queue head
712F 2D          7 149 dec     l                           ; move queue head up
7130 E3          7 150 ex      (sp), hl                    ; update queue head
7131 D5          7 151 push    de                          ; restore RET address
7132 C9          7 152 ret
7133             7 153 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
7133             7 154 PathFinder_EMPTY
7133 CB 71       7 155 bit     6, c                        ; is current distance friendly?
7135 20 E2       7 156 jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
7137 34          7 157 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
7138 C9          7 158 ret
7139             7 160 ; ----------------------------------------------------------------------------------------------------------------------
7139             7 161 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7139             7 162 ;
7139             7 163 ; Input:    -
7139             7 164 ;
7139             7 165 ; Output:   A = -1, if down edge couldn't be reached
7139             7 166 ;           A =  0, if there is chain of connected cyan tokens between the two edges
7139             7 167 ;           A = last edge position visited (-1), otherwise
7139             7 168 ;
7139             7 169 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7139             7 170 ;
7139             7 171 ; Destroys: BC, DE, HL, IY
7139             7 172 ; ----------------------------------------------------------------------------------------------------------------------
7139             7 173 PathFinder_Cyan_UpDown:
7139 21 07 7D    7 174 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
713C 11 07 61    7 175 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
713F CD FB 70    7 176 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
7142             7 178 ; entry point for PathFinder_VictoryPath
7142             7 179 PathFinder_Cyan_CheckPath:
7142 FD 21 00 09 7 180 ld      iy, $0900                   ; IYH = distance to check edge positions
7146             7 181 ; IYL = last edge position visited
7146 21 00 60    7 182 ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
7149 22 1F 71    7 183 ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
714C E5          7 184 push    hl                          ; store cyan queue head
714D             7 186 ; set up cyan board (up-down) start positions distances
714D 21 09 61    7 188 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7150 0E 43       7 189 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7152 3E 02       7 190 ld      a, FRIEND                   ; set distance to compare with
7154 BE          7 191 cp      (hl)                        ; check 1st start position distance
7155 D4 14 71    7 192 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7158 2C          7 193 inc     l                           ; move HL to next start position address
7159 BE          7 194 cp      (hl)                        ; check 2nd start position distance
715A D4 14 71    7 195 call    nc, PathFinder_Update       ; (repeat for each start position)
715D 2C          7 196 inc     l
715E BE          7 197 cp      (hl)                        ; check 3rd start position distance
715F D4 14 71    7 198 call    nc, PathFinder_Update
7162 2C          7 199 inc     l
7163 BE          7 200 cp      (hl)                        ; check 4th start position distance
7164 D4 14 71    7 201 call    nc, PathFinder_Update
7167 2C          7 202 inc     l
7168 BE          7 203 cp      (hl)                        ; check 5th start position distance
7169 D4 14 71    7 204 call    nc, PathFinder_Update
716C 2C          7 205 inc     l
716D BE          7 206 cp      (hl)                        ; check 6th start position distance
716E D4 14 71    7 207 call    nc, PathFinder_Update
7171 2C          7 208 inc     l
7172 C3 5F 72    7 209 jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)
7175             7 211 ; ----------------------------------------------------------------------------------------------------------------------
7175             7 212 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
7175             7 213 ;
7175             7 214 ; Input:    -
7175             7 215 ;
7175             7 216 ; Output:   A = -1, if up edge couldn't be reached
7175             7 217 ;           A =  0, if there is chain of connected cyan tokens between the two edges
7175             7 218 ;           A = last edge position visited (-1), otherwise
7175             7 219 ;
7175             7 220 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7175             7 221 ;
7175             7 222 ; Destroys: BC, DE, HL, IY
7175             7 223 ; ----------------------------------------------------------------------------------------------------------------------
7175             7 224 PathFinder_Cyan_DownUp:
7175 21 07 7D    7 225 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7178 11 4F 61    7 226 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
717B CD FB 70    7 227 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
717E FD 21 00 F7 7 229 ld      iy, $F700                   ; IYH = distance to check edge positions
7182             7 230 ; IYL = last edge position visited
7182 2A 1F 71    7 231 ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
7185 E5          7 232 push    hl                          ; initialize cyan queue head
7186             7 234 ; set up cyan board (down-up) start positions distances
7186 EB          7 236 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
7187 2D          7 237 dec     l                           ; move HL to cyan boad down-up address (last position)
7188 0E 43       7 238 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
718A 3E 02       7 239 ld      a, FRIEND                   ; set distance to compare with
718C BE          7 240 cp      (hl)                        ; check 1st start position distance
718D D4 14 71    7 241 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7190 2D          7 242 dec     l                           ; move HL to next start position address
7191 BE          7 243 cp      (hl)                        ; check 2nd start position distance
7192 D4 14 71    7 244 call    nc, PathFinder_Update       ; (repeat for each start position)
7195 2D          7 245 dec     l
7196 BE          7 246 cp      (hl)                        ; check 3rd start position distance
7197 D4 14 71    7 247 call    nc, PathFinder_Update
719A 2D          7 248 dec     l
719B BE          7 249 cp      (hl)                        ; check 4th start position distance
719C D4 14 71    7 250 call    nc, PathFinder_Update
719F 2D          7 251 dec     l
71A0 BE          7 252 cp      (hl)                        ; check 5th start position distance
71A1 D4 14 71    7 253 call    nc, PathFinder_Update
71A4 2D          7 254 dec     l
71A5 BE          7 255 cp      (hl)                        ; check 6th start position distance
71A6 D4 14 71    7 256 call    nc, PathFinder_Update
71A9 2D          7 257 dec     l
71AA C3 5F 72    7 258 jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)
71AD             7 260 ; ----------------------------------------------------------------------------------------------------------------------
71AD             7 261 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71AD             7 262 ;
71AD             7 263 ; Input:    -
71AD             7 264 ;
71AD             7 265 ; Output:   A = -1, if right edge couldn't be reached
71AD             7 266 ;           A =  0, if there is chain of connected cyan tokens between the two edges
71AD             7 267 ;           A = last edge position visited (-1), otherwise
71AD             7 268 ;
71AD             7 269 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71AD             7 270 ;
71AD             7 271 ; Destroys: BC, DE, HL, IY
71AD             7 272 ; ----------------------------------------------------------------------------------------------------------------------
71AD             7 273 PathFinder_Red_LeftRight:
71AD 21 07 7E    7 274 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71B0 11 07 64    7 275 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71B3 CD FB 70    7 276 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71B6             7 278 ; entry point for PathFinder_VictoryPath
71B6             7 279 PathFinder_Red_CheckPath
71B6 FD 21 00 01 7 280 ld      iy, $0100                   ; IYH = distance to check edge positions
71BA             7 281 ; IYL = last edge position visited
71BA 21 00 63    7 282 ld      hl, RED_QUEUE_AREA          ; HL points to red queue area address
71BD 22 1F 71    7 283 ld      (@Queue_Tail+1), hl         ; initialize red queue tail
71C0 E5          7 284 push    hl                          ; store red queue head
71C1             7 286 ; set up red board (left-right) start positions distances
71C1 21 09 64    7 288 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
71C4 0E 43       7 289 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71C6 3E 02       7 290 ld      a, FRIEND                   ; set distance to compare with
71C8 BE          7 291 cp      (hl)                        ; check 1st start position distance
71C9 D4 14 71    7 292 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71CC 2E 12       7 293 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
71CE BE          7 294 cp      (hl)                        ; check 2nd start position distance
71CF D4 14 71    7 295 call    nc, PathFinder_Update       ; (repeat for each start position)
71D2 2E 1B       7 296 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
71D4 BE          7 297 cp      (hl)                        ; check 3rd start position distance
71D5 D4 14 71    7 298 call    nc, PathFinder_Update
71D8 2E 24       7 299 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
71DA BE          7 300 cp      (hl)                        ; check 4th start position distance
71DB D4 14 71    7 301 call    nc, PathFinder_Update
71DE 2E 2D       7 302 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
71E0 BE          7 303 cp      (hl)                        ; check 5th start position distance
71E1 D4 14 71    7 304 call    nc, PathFinder_Update
71E4 2E 36       7 305 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
71E6 BE          7 306 cp      (hl)                        ; check 6th start position distance
71E7 D4 14 71    7 307 call    nc, PathFinder_Update
71EA 2E 3F       7 308 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
71EC C3 5F 72    7 309 jp      Path_Finder_First           ; calculate two-distances of red board (left-right)
71EF             7 311 ; ----------------------------------------------------------------------------------------------------------------------
71EF             7 312 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
71EF             7 313 ;
71EF             7 314 ; Input:    -
71EF             7 315 ;
71EF             7 316 ; Output:   A = -1, if left edge couldn't be reached
71EF             7 317 ;           A =  0, if there is chain of connected cyan tokens between the two edges
71EF             7 318 ;           A = last edge position visited (-1), otherwise
71EF             7 319 ;
71EF             7 320 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71EF             7 321 ;
71EF             7 322 ; Destroys: BC, DE, HL, IY
71EF             7 323 ; ----------------------------------------------------------------------------------------------------------------------
71EF             7 324 PathFinder_Red_RightLeft:
71EF 21 07 7E    7 325 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71F2 11 4F 64    7 326 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
71F5 CD FB 70    7 327 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
71F8 FD 21 00 FF 7 329 ld      iy, $FF00                   ; IYH = distance to check edge positions
71FC             7 330 ; IYL = last edge position visited
71FC 2A 1F 71    7 331 ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
71FF E5          7 332 push    hl                          ; initialize red queue head
7200             7 334 ; set up red board (right-left) start positions distances
7200 EB          7 336 ex      de, hl                      ; take advantage of last "CopyPositions" execution
7201 2D          7 337 dec     l                           ; move HL to red board right-left address (last position)
7202 0E 43       7 338 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7204 3E 02       7 339 ld      a, FRIEND                   ; set distance to compare with
7206 BE          7 340 cp      (hl)                        ; check 1st start position distance
7207 D4 14 71    7 341 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
720A 2E 84       7 342 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
720C BE          7 343 cp      (hl)                        ; check 2nd start position distance
720D D4 14 71    7 344 call    nc, PathFinder_Update       ; (repeat for each start position)
7210 2E 7B       7 345 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
7212 BE          7 346 cp      (hl)                        ; check 3rd start position distance
7213 D4 14 71    7 347 call    nc, PathFinder_Update
7216 2E 72       7 348 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
7218 BE          7 349 cp      (hl)                        ; check 4th start position distance
7219 D4 14 71    7 350 call    nc, PathFinder_Update
721C 2E 69       7 351 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
721E BE          7 352 cp      (hl)                        ; check 5th start position distance
721F D4 14 71    7 353 call    nc, PathFinder_Update
7222 2E 60       7 354 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
7224 BE          7 355 cp      (hl)                        ; check 6th start position distance
7225 D4 14 71    7 356 call    nc, PathFinder_Update
7228 2E 57       7 357 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
722A C3 5F 72    7 358 jp      Path_Finder_First           ; calculate red two-distance (right-left)
722D             7 360 ; ----------------------------------------------------------------------------------------------------------------------
722D             7 361 ; Path_Finder: calculate two-distance metric for each board position
722D             7 362 ;
722D             7 363 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
722D             7 364 ;
722D             7 365 ; Input:    HL  = cyan or red queue area address
722D             7 366 ;           IYH = distance to check edge positions
722D             7 367 ;           IYL = 0
722D             7 368 ;
722D             7 369 ; Output:   A = -1, if corresponding edge couldn't be reached
722D             7 370 ;           A =  0, if there is chain of connected (color) tokens between the two edges
722D             7 371 ;           A = last edge position visited (-1), otherwise
722D             7 372 ;
722D             7 373 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
722D             7 374 ;
722D             7 375 ; Destroys: DE, HL, IY
722D             7 376 ; ----------------------------------------------------------------------------------------------------------------------
722D             7 377 Path_Finder:
722D 2C          7 378 inc     l                           ; move queue head down
722E E5          7 379 push    hl                          ; preserve queue head address
722F 6E          7 380 ld      l, (hl)                     ; retrieve next position to be checked
7230 24          7 381 inc     h                           ; move HL to corresponding board address
7231 4E          7 382 ld      c, (hl)                     ; retrieve distance from this position to start
7232 45          7 383 ld      b, l                        ; store current position
7233             7 385 ; look for adjacent positions
7233 7D          7 387 ld      a, l                        ; get current position
7234 FD 84       7 388 add     a, iyh                      ; add distance to check edge positions
7236 6F          7 389 ld      l, a                        ; move HL to calculated position address
7237 CB 7E       7 390 bit     7, (hl)                     ; is it an edge?
7239 20 34       7 391 jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions
723B 3E 02       7 393 ld      a, FRIEND                   ; set distance to compare with
723D             7 394 ; return point from PathFinder_Adjacent
723D             7 395 Path_Finder_Neighbors
723D 68          7 396 ld      l, b                        ; restore current position to be checked
723E 2C          7 397 inc     l                           ; move HL to right neighbor address
723F BE          7 398 cp      (hl)                        ; check right neighbor distance
7240 D4 14 71    7 399 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7243 2D          7 400 dec     l                           ; move HL to left neighbor address
7244 2D          7 401 dec     l
7245 BE          7 402 cp      (hl)                        ; check left neighbor distance
7246 D4 14 71    7 403 call    nc, PathFinder_Update       ; (repeat for each neighbor)
7249 11 F8 FF    7 404 ld      de, -WIDTH
724C 19          7 405 add     hl, de
724D BE          7 406 cp      (hl)                        ; check upper-left neighbor distance
724E D4 14 71    7 407 call    nc, PathFinder_Update
7251 2C          7 408 inc     l
7252 BE          7 409 cp      (hl)                        ; check upper-right neighbor distance
7253 D4 14 71    7 410 call    nc, PathFinder_Update
7256 11 10 00    7 411 ld      de, WIDTH*2
7259 19          7 412 add     hl, de
725A BE          7 413 cp      (hl)                        ; check lower-left neighbor distance
725B D4 14 71    7 414 call    nc, PathFinder_Update
725E 2C          7 415 inc     l
725F             7 416 Path_Finder_First
725F BE          7 417 cp      (hl)                        ; check lower-right neighbor distance
7260 D4 14 71    7 418 call    nc, PathFinder_Update
7263 E1          7 419 pop     hl                          ; retreive queue head address
7264 3A 1F 71    7 420 ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
7267 BD          7 421 cp      l                           ; is queue empty?
7268 C2 2D 72    7 422 jp      nz, Path_Finder             ; no, repeat until queue is empty
726B FD 7D       7 424 ld      a, iyl                      ; get last edge position visited
726D 3D          7 425 dec     a                           ; return A = -1, if the edge couldn't be reached
726E C9          7 426 ret
726F             7 428 ; ----------------------------------------------------------------------------------------------------------------------
726F             7 429 ; Check adjacent hexagons.
726F             7 430 ;
726F             7 431 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
726F             7 432 ; "two cells are adjacent if they share a common edge on the board."
726F             7 433 ;
726F             7 434 ; Input:    B  = current position
726F             7 435 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
726F             7 436 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
726F             7 437 ;                edge number)
726F             7 438 ;
726F             7 439 ; Output:   A = 0, if there is a chain of connected tokens of the same color between the two edges.
726F             7 440 ;           A = FRIEND, IYL = current position, otherwise.
726F             7 441 ;
726F             7 442 ; Destroys: DE, HL
726F             7 443 ; ----------------------------------------------------------------------------------------------------------------------
726F             7 444 Path_Finder_Adjacent
726F 3E 43       7 445 ld      a, VICTORY+$40              ; set victory distance + friendly flag
7271 B9          7 446 cp      c                           ; is current distance victory and friendly?
7272 28 11       7 447 jr      z, Path_Finder_Abort        ; yes, abort path_finder
7274 7E          7 449 ld      a, (hl)                     ; get current edge position
7275 E6 07       7 450 and     %00000111                   ; convert to edge number (0..6)
7277 87          7 451 add     a, a                        ; calculate vector table routine index
7278 6F          7 452 ld      l, a                        ; set index in L
7279 24          7 453 inc     h                           ; move HL to (cyan or red) vector table routine address
727A 5E          7 454 ld      e, (hl)                     ; get low byte of vector table routine address
727B 2C          7 455 inc     l                           ; move HL to high byte of vector table routine address
727C 56          7 456 ld      d, (hl)                     ; get high byte of vector table routine address
727D EB          7 457 ex      de, hl                      ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
727E 15          7 458 dec     d                           ; move DE to cyan or red board address
727F 58          7 459 ld      e, b                        ; restore pointer to current position
7280 FD 68       7 460 ld      iyl, b                      ; last edge position visited = current position
7282 3E 02       7 461 ld      a, FRIEND                   ; set distance to compare with
7284 E9          7 462 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
7285             7 463 Path_Finder_Abort
7285 E1          7 464 pop     hl                          ; restore queue head address
7286 AF          7 465 xor     a                           ; return A = 0
7287 C9          7 466 ret
7288             7 468 ; ----------------------------------------------------------------------------------------------------------------------
7288             7 469 ;  Check two-distance of RED adjacents
7288             7 470 ; ----------------------------------------------------------------------------------------------------------------------
7288             7 471 PathFinder_RED_Edge_0
7288 EB          7 472 ex      de, hl                      ; restore pointer to current position address
7289 11 12 00    7 473 ld      de, 9*2                     ; calculate distance to adjacent #2
728C 19          7 474 add     hl, de                      ; move HL to adjacent #2 address
728D BE          7 475 cp      (hl)                        ; check adjacent #2 distance
728E D4 14 71    7 476 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
7291 11 09 00    7 477 ld      de, 9                       ; calculate distance to adjacent #3
7294 19          7 478 add     hl, de                      ; move HL to adjacent #3 address
7295 BE          7 479 cp      (hl)                        ; check adjacent #3 distance
7296 D4 14 71    7 480 call    nc, PathFinder_Update       ; (repeat for each adjacent)
7299 11 09 00    7 481 ld      de, 9
729C 19          7 482 add     hl, de
729D BE          7 483 cp      (hl)                        ; check adjacent #4 distance
729E D4 14 71    7 484 call    nc, PathFinder_Update
72A1 11 09 00    7 485 ld      de, 9
72A4 19          7 486 add     hl, de
72A5 BE          7 487 cp      (hl)                        ; check adjacent #5 distance
72A6 D4 14 71    7 488 call    nc, PathFinder_Update
72A9 11 09 00    7 489 ld      de, 9
72AC 19          7 490 add     hl, de
72AD BE          7 491 cp      (hl)                        ; check adjacent #6 distance
72AE D4 14 71    7 492 call    nc, PathFinder_Update
72B1 FD 45       7 493 ld      b, iyl                      ; restore current position
72B3 C3 3D 72    7 494 jp      Path_Finder_Neighbors       ; continue processing neighbors
72B6             7 496 PathFinder_RED_Edge_1
72B6 EB          7 497 ex      de, hl                      ; restore pointer to current position address
72B7 11 12 00    7 498 ld      de, 9*2
72BA 19          7 499 add     hl, de
72BB BE          7 500 cp      (hl)                        ; check adjacent #3 distance
72BC D4 14 71    7 501 call    nc, PathFinder_Update
72BF 11 09 00    7 502 ld      de, 9
72C2 19          7 503 add     hl, de
72C3 BE          7 504 cp      (hl)                        ; check adjacent #4 distance
72C4 D4 14 71    7 505 call    nc, PathFinder_Update
72C7 11 09 00    7 506 ld      de, 9
72CA 19          7 507 add     hl, de
72CB BE          7 508 cp      (hl)                        ; check adjacent #5 distance
72CC D4 14 71    7 509 call    nc, PathFinder_Update
72CF 11 09 00    7 510 ld      de, 9
72D2 19          7 511 add     hl, de
72D3 BE          7 512 cp      (hl)                        ; check adjacent #6 distance
72D4 D4 14 71    7 513 call    nc, PathFinder_Update
72D7 FD 45       7 514 ld      b, iyl                      ; restore current position
72D9 C3 3D 72    7 515 jp      Path_Finder_Neighbors       ; continue processing neighbors
72DC             7 517 PathFinder_RED_Edge_2
72DC EB          7 518 ex      de, hl                      ; restore pointer to current position address
72DD 11 12 00    7 519 ld      de, 9*2
72E0 19          7 520 add     hl, de
72E1 BE          7 521 cp      (hl)                        ; check adjacent #4 distance
72E2 D4 14 71    7 522 call    nc, PathFinder_Update
72E5 11 09 00    7 523 ld      de, 9
72E8 19          7 524 add     hl, de
72E9 BE          7 525 cp      (hl)                        ; check adjacent #5 distance
72EA D4 14 71    7 526 call    nc, PathFinder_Update
72ED 11 09 00    7 527 ld      de, 9
72F0 19          7 528 add     hl, de
72F1 BE          7 529 cp      (hl)                        ; check adjacent #6 distance
72F2 D4 14 71    7 530 call    nc, PathFinder_Update
72F5 11 CA FF    7 531 ld      de, -9*6
72F8 19          7 532 add     hl, de
72F9 BE          7 533 cp      (hl)                        ; check adjacent #0 distance
72FA D4 14 71    7 534 call    nc, PathFinder_Update
72FD FD 45       7 535 ld      b, iyl                      ; restore current position
72FF C3 3D 72    7 536 jp      Path_Finder_Neighbors       ; continue processing neighbors
7302             7 538 PathFinder_RED_Edge_3
7302 EB          7 539 ex      de, hl                      ; restore pointer to current position address
7303 11 E5 FF    7 540 ld      de, -9*3
7306 19          7 541 add     hl, de
7307 BE          7 542 cp      (hl)                        ; check adjacent #0 distance
7308 D4 14 71    7 543 call    nc, PathFinder_Update
730B 11 09 00    7 544 ld      de, 9
730E 19          7 545 add     hl, de
730F BE          7 546 cp      (hl)                        ; check adjacent #1 distance
7310 D4 14 71    7 547 call    nc, PathFinder_Update
7313 11 24 00    7 548 ld      de, 9*4
7316 19          7 549 add     hl, de
7317 BE          7 550 cp      (hl)                        ; check adjacent #5 distance
7318 D4 14 71    7 551 call    nc, PathFinder_Update
731B 11 09 00    7 552 ld      de, 9
731E 19          7 553 add     hl, de
731F BE          7 554 cp      (hl)                        ; check adjacent #6 distance
7320 D4 14 71    7 555 call    nc, PathFinder_Update
7323 FD 45       7 556 ld      b, iyl                      ; restore current position
7325 C3 3D 72    7 557 jp      Path_Finder_Neighbors       ; continue processing neighbors
7328             7 559 PathFinder_RED_Edge_4
7328 EB          7 560 ex      de, hl                      ; restore pointer to current position address
7329 11 12 00    7 561 ld      de, 9*2
732C 19          7 562 add     hl, de
732D BE          7 563 cp      (hl)                        ; check adjacent #6 distance
732E D4 14 71    7 564 call    nc, PathFinder_Update
7331 11 CA FF    7 565 ld      de, -9*6
7334 19          7 566 add     hl, de
7335 BE          7 567 cp      (hl)                        ; check adjacent #0 distance
7336 D4 14 71    7 568 call    nc, PathFinder_Update
7339 11 09 00    7 569 ld      de, 9
733C 19          7 570 add     hl, de
733D BE          7 571 cp      (hl)                        ; check adjacent #1 distance
733E D4 14 71    7 572 call    nc, PathFinder_Update
7341 11 09 00    7 573 ld      de, 9
7344 19          7 574 add     hl, de
7345 BE          7 575 cp      (hl)                        ; check adjacent #2 distance
7346 D4 14 71    7 576 call    nc, PathFinder_Update
7349 FD 45       7 577 ld      b, iyl                      ; restore current position
734B C3 3D 72    7 578 jp      Path_Finder_Neighbors       ; continue processing neighbors
734E             7 580 PathFinder_RED_Edge_5
734E EB          7 581 ex      de, hl                      ; restore pointer to current position address
734F 11 D3 FF    7 582 ld      de, -9*5
7352 19          7 583 add     hl, de
7353 BE          7 584 cp      (hl)                        ; check adjacent #0 distance
7354 D4 14 71    7 585 call    nc, PathFinder_Update
7357 11 09 00    7 586 ld      de, 9
735A 19          7 587 add     hl, de
735B BE          7 588 cp      (hl)                        ; check adjacent #1 distance
735C D4 14 71    7 589 call    nc, PathFinder_Update
735F 11 09 00    7 590 ld      de, 9
7362 19          7 591 add     hl, de
7363 BE          7 592 cp      (hl)                        ; check adjacent #2 distance
7364 D4 14 71    7 593 call    nc, PathFinder_Update
7367 11 09 00    7 594 ld      de, 9
736A 19          7 595 add     hl, de
736B BE          7 596 cp      (hl)                        ; check adjacent #3 distance
736C D4 14 71    7 597 call    nc, PathFinder_Update
736F FD 45       7 598 ld      b, iyl                      ; restore current position
7371 C3 3D 72    7 599 jp      Path_Finder_Neighbors       ; continue processing neighbors
7374             7 601 PathFinder_RED_Edge_6
7374 EB          7 602 ex      de, hl                      ; restore pointer to current position address
7375 11 CA FF    7 603 ld      de, -9*6
7378 19          7 604 add     hl, de
7379 BE          7 605 cp      (hl)                        ; check adjacent #0 distance
737A D4 14 71    7 606 call    nc, PathFinder_Update
737D 11 09 00    7 607 ld      de, 9
7380 19          7 608 add     hl, de
7381 BE          7 609 cp      (hl)                        ; check adjacent #1 distance
7382 D4 14 71    7 610 call    nc, PathFinder_Update
7385 11 09 00    7 611 ld      de, 9
7388 19          7 612 add     hl, de
7389 BE          7 613 cp      (hl)                        ; check adjacent #2 distance
738A D4 14 71    7 614 call    nc, PathFinder_Update
738D 11 09 00    7 615 ld      de, 9
7390 19          7 616 add     hl, de
7391 BE          7 617 cp      (hl)                        ; check adjacent #3 distance
7392 D4 14 71    7 618 call    nc, PathFinder_Update
7395 11 09 00    7 619 ld      de, 9
7398 19          7 620 add     hl, de
7399 BE          7 621 cp      (hl)                        ; check adjacent #4 distance
739A D4 14 71    7 622 call    nc, PathFinder_Update
739D FD 45       7 623 ld      b, iyl                      ; restore current position
739F C3 3D 72    7 624 jp      Path_Finder_Neighbors       ; continue processing neighbors
73A2             7 626 ; ----------------------------------------------------------------------------------------------------------------------
73A2             7 627 ;  Check two-distance of CYAN adjacents
73A2             7 628 ; ----------------------------------------------------------------------------------------------------------------------
73A2             7 629 PathFinder_CYAN_Edge_0
73A2 EB          7 630 ex      de, hl                      ; restore pointer to current position address
73A3 2C          7 631 inc     l
73A4 2C          7 632 inc     l
73A5 BE          7 633 cp      (hl)                        ; check adjacent #2 distance
73A6 D4 14 71    7 634 call    nc, PathFinder_Update
73A9 2C          7 635 inc     l
73AA BE          7 636 cp      (hl)                        ; check adjacent #3 distance
73AB D4 14 71    7 637 call    nc, PathFinder_Update
73AE 2C          7 638 inc     l
73AF BE          7 639 cp      (hl)                        ; check adjacent #4 distance
73B0 D4 14 71    7 640 call    nc, PathFinder_Update
73B3 2C          7 641 inc     l
73B4 BE          7 642 cp      (hl)                        ; check adjacent of edge number 5
73B5 D4 14 71    7 643 call    nc, PathFinder_Update
73B8 2C          7 644 inc     l
73B9 BE          7 645 cp      (hl)                        ; check adjacent of edge number 6
73BA D4 14 71    7 646 call    nc, PathFinder_Update
73BD FD 45       7 647 ld      b, iyl                      ; restore current position
73BF C3 3D 72    7 648 jp      Path_Finder_Neighbors       ; continue processing neighbors
73C2             7 650 PathFinder_CYAN_Edge_1
73C2 EB          7 651 ex      de, hl                      ; restore pointer to current position address
73C3 2C          7 652 inc     l
73C4 2C          7 653 inc     l
73C5 BE          7 654 cp      (hl)                        ; check adjacent #3 distance
73C6 D4 14 71    7 655 call    nc, PathFinder_Update
73C9 2C          7 656 inc     l
73CA BE          7 657 cp      (hl)                        ; check adjacent #4 distance
73CB D4 14 71    7 658 call    nc, PathFinder_Update
73CE 2C          7 659 inc     l
73CF BE          7 660 cp      (hl)                        ; check adjacent #5 distance
73D0 D4 14 71    7 661 call    nc, PathFinder_Update
73D3 2C          7 662 inc     l
73D4 BE          7 663 cp      (hl)                        ; check adjacent #6 distance
73D5 D4 14 71    7 664 call    nc, PathFinder_Update
73D8 FD 45       7 665 ld      b, iyl                      ; restore current position
73DA C3 3D 72    7 666 jp      Path_Finder_Neighbors       ; continue processing neighbors
73DD             7 668 PathFinder_CYAN_Edge_2
73DD EB          7 669 ex      de, hl                      ; restore pointer to current position address
73DE 2D          7 670 dec     l
73DF 2D          7 671 dec     l
73E0 BE          7 672 cp      (hl)                        ; check adjacent #0 distance
73E1 D4 14 71    7 673 call    nc, PathFinder_Update
73E4 2C          7 674 inc     l
73E5 2C          7 675 inc     l
73E6 2C          7 676 inc     l
73E7 2C          7 677 inc     l
73E8 BE          7 678 cp      (hl)                        ; check adjacent #4 distance
73E9 D4 14 71    7 679 call    nc, PathFinder_Update
73EC 2C          7 680 inc     l
73ED BE          7 681 cp      (hl)                        ; check adjacent #5 distance
73EE D4 14 71    7 682 call    nc, PathFinder_Update
73F1 2C          7 683 inc     l
73F2 BE          7 684 cp      (hl)                        ; check adjacent #6 distance
73F3 D4 14 71    7 685 call    nc, PathFinder_Update
73F6 FD 45       7 686 ld      b, iyl                      ; restore current position
73F8 C3 3D 72    7 687 jp      Path_Finder_Neighbors       ; continue processing neighbors
73FB             7 689 PathFinder_CYAN_Edge_3
73FB EB          7 690 ex      de, hl                      ; restore pointer to current position address
73FC 2D          7 691 dec     l
73FD 2D          7 692 dec     l
73FE 2D          7 693 dec     l
73FF BE          7 694 cp      (hl)                        ; check adjacent #0 distance
7400 D4 14 71    7 695 call    nc, PathFinder_Update
7403 2C          7 696 inc     l
7404 BE          7 697 cp      (hl)                        ; check adjacent #1 distance
7405 D4 14 71    7 698 call    nc, PathFinder_Update
7408 2C          7 699 inc     l
7409 2C          7 700 inc     l
740A 2C          7 701 inc     l
740B 2C          7 702 inc     l
740C BE          7 703 cp      (hl)                        ; check adjacent #5 distance
740D D4 14 71    7 704 call    nc, PathFinder_Update
7410 2C          7 705 inc     l
7411 BE          7 706 cp      (hl)                        ; check adjacent #6 distance
7412 D4 14 71    7 707 call    nc, PathFinder_Update
7415 FD 45       7 708 ld      b, iyl                      ; restore current position
7417 C3 3D 72    7 709 jp      Path_Finder_Neighbors       ; continue processing neighbors
741A             7 711 PathFinder_CYAN_Edge_4
741A EB          7 712 ex      de, hl                      ; restore pointer to current position address
741B 2C          7 713 inc     l
741C 2C          7 714 inc     l
741D BE          7 715 cp      (hl)                        ; check adjacent #6 distance
741E D4 14 71    7 716 call    nc, PathFinder_Update
7421 2D          7 717 dec     l
7422 2D          7 718 dec     l
7423 2D          7 719 dec     l
7424 2D          7 720 dec     l
7425 BE          7 721 cp      (hl)                        ; check adjacent #2 distance
7426 D4 14 71    7 722 call    nc, PathFinder_Update
7429 2D          7 723 dec     l
742A BE          7 724 cp      (hl)                        ; check adjacent #1 distance
742B D4 14 71    7 725 call    nc, PathFinder_Update
742E 2D          7 726 dec     l
742F BE          7 727 cp      (hl)                        ; check adjacent #0 distance
7430 D4 14 71    7 728 call    nc, PathFinder_Update
7433 FD 45       7 729 ld      b, iyl                      ; restore current position
7435 C3 3D 72    7 730 jp      Path_Finder_Neighbors       ; continue processing neighbors
7438             7 732 PathFinder_CYAN_Edge_5
7438 EB          7 733 ex      de, hl                      ; restore pointer to current position address
7439 2D          7 734 dec     l
743A 2D          7 735 dec     l
743B BE          7 736 cp      (hl)                        ; check adjacent #3 distance
743C D4 14 71    7 737 call    nc, PathFinder_Update
743F 2D          7 738 dec     l
7440 BE          7 739 cp      (hl)                        ; check adjacent #2 distance
7441 D4 14 71    7 740 call    nc, PathFinder_Update
7444 2D          7 741 dec     l
7445 BE          7 742 cp      (hl)                        ; check adjacent #1 distance
7446 D4 14 71    7 743 call    nc, PathFinder_Update
7449 2D          7 744 dec     l
744A BE          7 745 cp      (hl)                        ; check adjacent #0 distance
744B D4 14 71    7 746 call    nc, PathFinder_Update
744E FD 45       7 747 ld      b, iyl                      ; restore current position
7450 C3 3D 72    7 748 jp      Path_Finder_Neighbors       ; continue processing neighbors
7453             7 750 PathFinder_CYAN_Edge_6
7453 EB          7 751 ex      de, hl                      ; restore pointer to current position address
7454 2D          7 752 dec     l
7455 2D          7 753 dec     l
7456 BE          7 754 cp      (hl)                        ; check adjacent #4 distance
7457 D4 14 71    7 755 call    nc, PathFinder_Update
745A 2D          7 756 dec     l
745B BE          7 757 cp      (hl)                        ; check adjacent #3 distance
745C D4 14 71    7 758 call    nc, PathFinder_Update
745F 2D          7 759 dec     l
7460 BE          7 760 cp      (hl)                        ; check adjacent #2 distance
7461 D4 14 71    7 761 call    nc, PathFinder_Update
7464 2D          7 762 dec     l
7465 BE          7 763 cp      (hl)                        ; check adjacent #1 distance
7466 D4 14 71    7 764 call    nc, PathFinder_Update
7469 2D          7 765 dec     l
746A BE          7 766 cp      (hl)                        ; check adjacent #0 distance
746B D4 14 71    7 767 call    nc, PathFinder_Update
746E FD 45       7 768 ld      b, iyl                      ; restore current position
7470 C3 3D 72    7 769 jp      Path_Finder_Neighbors       ; continue processing neighbors
7473             7 771 ; ----------------------------------------------------------------------------------------------------------------------
7473             7 772 ; PathFinder_Score: calculate board score depending on speccy color
7473             7 773 ;
7473             7 774 ; Input:    -
7473             7 775 ;
7473             7 776 ; Output:   A = -1, if speccy can't reach his opposite edge
7473             7 777 ;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
7473             7 778 ;           A = speccy heuristic evaluation, otherwise
7473             7 779 ;
7473             7 780 ; Uses:     AI_PLAYER (speccy side)
7473             7 781 ;
7473             7 782 ; Destroys: A', BC, DE, HL, IY
7473             7 783 ; ----------------------------------------------------------------------------------------------------------------------
7473             7 784 PathFinder_Score:
7473 3A 99 61    7 785 ld      a, (AI_PLAYER)              ; get speecy side
7476 FE 02       7 786 cp      FRIEND                      ; is it FRIEND?
7478 28 31       7 787 jr      z, PathFinder_CyanScore     ; yes, calculate CYAN score
747A             7 789 ; ----------------------------------------------------------------------------------------------------------------------
747A             7 790 ; PathFinder_RedScore: calculate red score
747A             7 791 ;
747A             7 792 ; Input:    -
747A             7 793 ;
747A             7 794 ; Output:   A = -1, if red can't reach his opposite edge
747A             7 795 ;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
747A             7 796 ;           A = red heuristic evaluation, otherwise
747A             7 797 ;
747A             7 798 ; Uses:     POTENTIALS (board potential and attack mobility)
747A             7 799 ;
747A             7 800 ; Destroys: A', BC, DE, HL, IY
747A             7 801 ; ----------------------------------------------------------------------------------------------------------------------
747A             7 802 PathFinder_RedScore
747A CD AD 71    7 803 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
747D C8          7 804 ret     z                           ; if red has a chain of connected tokens, return A = 0
747E 08          7 805 ex      af, af'                     ; save first result
747F CD EF 71    7 806 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
7482 47          7 807 ld      b, a                        ; save second result
7483 08          7 808 ex      af, af'                     ; restore first result
7484 90          7 809 sub     b                           ; subtract both results
7485 78          7 810 ld      a, b                        ; restore second result
7486 C8          7 811 ret     z                           ; if red can't reach his opposite edge, return A = -1
7487 CD 39 71    7 813 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
748A 08          7 814 ex      af, af'                     ; save result
748B CD 75 71    7 815 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
748E 47          7 816 ld      b, a                        ; save second result
748F 08          7 817 ex      af, af'                     ; restore first result
7490 90          7 818 sub     b                           ; subtract both results
7491 C8          7 819 ret     z                           ; if cyan can't reach his opposite edge, return A = 0
7492 21 09 64    7 821 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
7495 11 51 64    7 822 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7498 CD E9 74    7 823 call    PathFinder_Potentials       ; calculate RED potentials
749B ED 43 97 61 7 824 ld      (POTENTIALS), bc            ; store RED potentials
749F 21 09 61    7 826 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74A2 11 51 61    7 827 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74A5 CD E9 74    7 828 call    PathFinder_Potentials       ; calculate cyan potentials
74A8 C3 D9 74    7 829 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74AB             7 831 ; ----------------------------------------------------------------------------------------------------------------------
74AB             7 832 ; PathFinder_CyanScore: calculate cyan score
74AB             7 833 ;
74AB             7 834 ; Input:    -
74AB             7 835 ;
74AB             7 836 ; Output:   A = -1, if cyan can't reach his opposite edge
74AB             7 837 ;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
74AB             7 838 ;           A = cyan heuristic evaluation, otherwise
74AB             7 839 ;
74AB             7 840 ; Uses:     POTENTIALS (board potential and attack mobility)
74AB             7 841 ;
74AB             7 842 ; Destroys: A', BC, DE, HL
74AB             7 843 ; ----------------------------------------------------------------------------------------------------------------------
74AB             7 844 PathFinder_CyanScore
74AB CD 39 71    7 845 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74AE C8          7 846 ret     z                           ; if cyan has a chain of connected tokens, return A = 0
74AF 08          7 847 ex      af, af'                     ; save result
74B0 CD 75 71    7 848 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74B3 47          7 849 ld      b, a                        ; save second result
74B4 08          7 850 ex      af, af'                     ; restore first result
74B5 90          7 851 sub     b                           ; subtract both results
74B6 78          7 852 ld      a, b                        ; restore second result
74B7 C8          7 853 ret     z                           ; if cyan can't reach his opposite edge, return A = -1
74B8 CD AD 71    7 855 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74BB 08          7 856 ex      af, af'                     ; save result
74BC CD EF 71    7 857 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74BF 47          7 858 ld      b, a                        ; save second result
74C0 08          7 859 ex      af, af'                     ; restore first result
74C1 90          7 860 sub     b                           ; subtract both results
74C2 C8          7 861 ret     z                           ; if red can't reach his opposite edge, return A = 0
74C3 21 09 61    7 863 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74C6 11 51 61    7 864 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74C9 CD E9 74    7 865 call    PathFinder_Potentials       ; calculate cyan potentials
74CC ED 43 97 61 7 866 ld      (POTENTIALS), bc            ; save cyan potentials
74D0 21 09 64    7 868 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74D3 11 51 64    7 869 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74D6 CD E9 74    7 870 call    PathFinder_Potentials       ; calculate red potentials
74D9             7 871 ; ----------------------------------------------------------------------------------------------------------------------
74D9             7 872 ; PathFinder_Evaluation: calculate heuristic evaluation.
74D9             7 873 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
74D9             7 874 ;
74D9             7 875 ;                                       e = M (pC - pR) - (aC - aR)
74D9             7 876 ; where:
74D9             7 877 ;   pC = cyan board potential
74D9             7 878 ;   pR = red board potential
74D9             7 879 ;   aC = cyan attack mobility
74D9             7 880 ;   aR = red attack mobility
74D9             7 881 ;    M = a large number
74D9             7 882 ;
74D9             7 883 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
74D9             7 884 ;
74D9             7 885 ; Input:    B = opponent attack mobility
74D9             7 886 ;           C = opponent board potential
74D9             7 887 ;
74D9             7 888 ; Output:   A = heuristic evaluation
74D9             7 889 ;
74D9             7 890 ; Destroys: E, HL
74D9             7 891 ; ----------------------------------------------------------------------------------------------------------------------
74D9             7 892 PathFinder_Evaluation:
74D9 21 98 61    7 893 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
74DC 78          7 894 ld      a, b                        ; get opponent's attack mobility
74DD 96          7 895 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
74DE 5F          7 896 ld      e, a                        ; save the result in E
74DF 2D          7 897 dec     l                           ; move HL to player's board potential address
74E0 79          7 898 ld      a, c                        ; get opponent's board potential
74E1 96          7 899 sub     (hl)                        ; subtract potentials -> (pC - pR)
74E2 87          7 900 add     a, a                        ; multiply by 8 -> M (pC - pR)
74E3 87          7 901 add     a, a
74E4 87          7 902 add     a, a
74E5 93          7 903 sub     e                           ; subtract result of attack mobilities subtraction
74E6             7 904 ; -> M (pC - pR) - (aC - aR)
74E6 EE 80       7 905 xor     $80                         ; invert sign for easier further comparative
74E8 C9          7 906 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
74E9             7 908 ; ----------------------------------------------------------------------------------------------------------------------
74E9             7 909 ; PathFinder_Potentials: calculate board potential and attack mobility
74E9             7 910 ;
74E9             7 911 ; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
74E9             7 912 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
74E9             7 913 ;   the board.
74E9             7 914 ; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
74E9             7 915 ;
74E9             7 916 ; Input:    HL = cyan board or red board address
74E9             7 917 ;           DE = cyan board or red board address
74E9             7 918 ;
74E9             7 919 ; Output:   B = attack mobility
74E9             7 920 ;           C = board potential
74E9             7 921 ;
74E9             7 922 ; Destroys: A, DE, HL, IYL
74E9             7 923 ; ----------------------------------------------------------------------------------------------------------------------
74E9             7 924 PathFinder_Potentials:
74E9 01 FF 00    7 925 ld      bc, $00FF                   ; initialize attack mobility and board potential
74EC FD 2E 3D    7 926 ld      iyl, 61                     ; number of cells to be checked (loop counter)
74EF             7 927 Potentials_Loop
74EF 7E          7 928 ld      a, (hl)                     ; get cell's two-distance pointed by HL
74F0 FE 40       7 929 cp      $40                         ; is cell occupied or border?
74F2 30 16       7 930 jr      nc, Potentials_Next         ; yes, skip to next cell
74F4 FE 04       7 931 cp      $04                         ; cell distance was not updated?
74F6 38 1A       7 932 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
74F8 1A          7 933 ld      a, (de)                     ; get cell's two-distance pointed by DE
74F9 FE 04       7 934 cp      $04                         ; cell distance was not updated?
74FB 38 15       7 935 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
74FD 86          7 936 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
74FE 77          7 937 ld      (hl), a                     ; save potential in the cell pointed by HL
74FF B9          7 938 cp      c                           ; is the new potential >= board potential?
7500 D2 06 75    7 939 jp      nc, Potentials_Mobility     ; yes, check attack mobility
7503 4F          7 940 ld      c, a                        ; no, board potential = new potential
7504 06 01       7 941 ld      b, 1                        ; restart attack mobility
7506             7 942 Potentials_Mobility
7506 C2 0A 75    7 943 jp      nz, Potentials_Next         ; if (potential <> last potential) skip to next cell
7509 04          7 944 inc     b                           ; else, increment attack mobility
750A             7 945 Potentials_Next
750A 1C          7 946 inc     e                           ; move to next cell of each board
750B 2C          7 947 inc     l
750C FD 2D       7 948 dec     iyl                         ; decrement loop counter
750E C2 EF 74    7 949 jp      nz, Potentials_Loop         ; repeat until end of boards
7511 C9          7 950 ret
7512             7 951 Potentials_Infinite
7512 CB FE       7 952 set     7, (hl)                     ; set cell potential as "infinite"
7514 1C          7 953 inc     e                           ; move to next cell of each board
7515 2C          7 954 inc     l
7516 FD 2D       7 955 dec     iyl                         ; decrement loop counter
7518 C2 EF 74    7 956 jp      nz, Potentials_Loop         ; repeat until end of boards
751B C9          7 957 ret
751C             7 959 ; ----------------------------------------------------------------------------------------------------------------------
751C             7 960 ; PathFinder_Candidates: search candidates based on score result and boards potentials
751C             7 961 ;
751C             7 962 ; Input:    A  = -1, 0 or heuristic result
751C             7 963 ;           IX = candidates area address
751C             7 964 ;
751C             7 965 ; Output:   IX = first candidate address
751C             7 966 ;
751C             7 967 ; Uses:     AI_PLAYER (speccy side)
751C             7 968 ;
751C             7 969 ; Destroys: A, A', BC, DE, HL
751C             7 970 ; ----------------------------------------------------------------------------------------------------------------------
751C             7 971 PathFinder_Candidates:
751C DD 36 00 00 7 972 ld      (ix+0), 0                   ; set candidates endmarker
7520 B7          7 974 or      a                           ; A = 0?
7521 28 3D       7 975 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
7523 3C          7 976 inc     a                           ; A = -1?
7524 28 45       7 977 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
7526             7 979 ; if score is not -1 nor 0, fill candidates from total potentials
7526 21 09 61    7 981 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7529 11 09 64    7 982 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
752C CD E9 74    7 983 call    PathFinder_Potentials       ; process candidates from total potentials
752F 79          7 985 ld      a, c                        ; set board potential in A
7530 08          7 986 ex      af, af'                     ; save board potential
7531 50          7 987 ld      d, b                        ; store attack mobility
7532 DD 5D       7 988 ld      e, ixl                      ; store candidates position
7534             7 990 ; insert the second best board potentials in candidates area
7534             7 991 Candidates_2ndBest
7534 2E 09       7 992 ld      l, 9                        ; HL points to board potentials address (1st position)
7536 0C          7 993 inc     c                           ; increment board potential
7537 79          7 994 ld      a, c                        ; A = second best potential
7538 FE 20       7 995 cp      $20                         ; is potential >= $20? (2nd best max potential)
753A 30 13       7 996 jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential
753C 06 3D       7 997 ld      b, 61                       ; number of cells to be checked (loop counter)
753E             7 998 Candidates_2ndBest_Loop
753E BE          7 999 cp      (hl)                        ; is current board potential = 2nd best board potential?
753F C2 47 75    7 1000 jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
7542 DD 2C       7 1001 inc     ixl                         ; yes, insert candidate
7544 DD 75 00    7 1002 ld      (ix+0), l
7547             7 1003 Candidates_2ndBest_Next
7547 2C          7 1004 inc     l                           ; move HL to next board potential address
7548 10 F4       7 1005 djnz    Candidates_2ndBest_Loop     ; repeat for each cell
754A DD 7D       7 1006 ld      a, ixl                      ; A = current candidates position
754C BB          7 1007 cp      e                           ; new candidates inserted?
754D 28 E5       7 1008 jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted
754F             7 1009 Candidates_2ndBest_Exit
754F 42          7 1010 ld      b, d                        ; restore attack mobility
7550 08          7 1011 ex      af, af'                     ; restore board potential
7551             7 1013 ; insert the best board potentials in candidates area
7551             7 1014 Candidates_Best
7551 2E 08       7 1015 ld      l, 8                        ; HL points to board potential address (1st position -1)
7553             7 1016 Candidates_Best_Loop
7553 2C          7 1017 inc     l                           ; move HL to next board potential address
7554 BE          7 1018 cp      (hl)                        ; is current board potential equal to best board potential?
7555 C2 53 75    7 1019 jp      nz, Candidates_Best_Loop    ; no, next potential
7558 DD 2C       7 1020 inc     ixl                         ; yes, insert candidate
755A DD 75 00    7 1021 ld      (ix+0), l
755D 10 F4       7 1022 djnz    Candidates_Best_Loop        ; repeat for each cell
755F C9          7 1023 ret
7560             7 1025 ; ----------------------------------------------------------------------------------------------------------------------
7560             7 1026 ; Fill candidates for winner color
7560             7 1027 ; ----------------------------------------------------------------------------------------------------------------------
7560             7 1028 Candidates_Winner
7560 3A 99 61    7 1029 ld      a, (AI_PLAYER)              ; check speccy side
7563 FE 02       7 1030 cp      FRIEND                      ; is it friend?
7565 CA 78 75    7 1031 jp      z, Candidates_Cyan_Potential; yes, fill candidates from cyan potentials
7568 C3 8B 75    7 1032 jp      Candidates_Red_Potential    ; no, fill candidates from red potentials
756B             7 1034 ; ----------------------------------------------------------------------------------------------------------------------
756B             7 1035 ; Fill candidates for defeated color
756B             7 1036 ; ----------------------------------------------------------------------------------------------------------------------
756B             7 1037 Candidates_Defeat
756B 3A 99 61    7 1038 ld      a, (AI_PLAYER)              ; check speccy side
756E FE 02       7 1039 cp      FRIEND                      ; is it friend?
7570 28 13       7 1040 jr      z, Candidates_Red           ; yes, fill candidates from red potentials
7572             7 1042 ; if RED is defeated, candidates are chosen from cyan board potentials
7572 CD 39 71    7 1044 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
7575 CD 75 71    7 1045 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
7578             7 1046 Candidates_Cyan_Potential
7578 21 09 61    7 1047 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
757B 11 51 61    7 1048 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
757E CD E9 74    7 1049 call    PathFinder_Potentials       ; calculate cyan potentials
7581 79          7 1051 ld      a, c                        ; set board potential in A
7582 C3 51 75    7 1052 jp      Candidates_Best             ; fill only the best candidates
7585             7 1054 ; if CYAN is defeated, candidates are chosen from red board potentials
7585             7 1055 Candidates_Red
7585 CD AD 71    7 1056 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
7588 CD EF 71    7 1057 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
758B             7 1058 Candidates_Red_Potential
758B 21 09 64    7 1059 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
758E 11 51 64    7 1060 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7591 CD E9 74    7 1061 call    PathFinder_Potentials       ; calculate red potentials
7594 79          7 1063 ld      a, c                        ; set board potential in A
7595 C3 51 75    7 1064 jp      Candidates_Best             ; fill only the best candidates
7598             7 1066 ; ----------------------------------------------------------------------------------------------------------------------
7598             7 1067 ; PathFinder_VictoryPath: calculate current player victory path
7598             7 1068 ;
7598             7 1069 ; Input:    -
7598             7 1070 ;
7598             7 1071 ; Output:   A = -1, if there isn't a victory path
7598             7 1072 ;           A = start position (-1) of the victory path, otherwise
7598             7 1073 ;
7598             7 1074 ; Uses:     TOKEN_COLOR (current token color)
7598             7 1075 ;
7598             7 1076 ; Destroys: BC, DE, HL, IY
7598             7 1077 ; ----------------------------------------------------------------------------------------------------------------------
7598             7 1078 PathFinder_VictoryPath:
7598 3A 9E 61    7 1079 ld      a, (TOKEN_COLOR)            ; get current token color
759B FE 05       7 1080 cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
759D 28 0C       7 1081 jr      z, PathFinder_VictoryPath_Cyan
759F CD AD 71    7 1083 call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
75A2 21 45 64    7 1084 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75A5 CD B7 75    7 1085 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75A8 C3 B6 71    7 1086 jp      PathFinder_Red_CheckPath    ; calculate RED victory path
75AB             7 1088 PathFinder_VictoryPath_Cyan
75AB CD 39 71    7 1089 call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
75AE 21 45 61    7 1090 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75B1 CD B7 75    7 1091 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75B4 C3 42 71    7 1092 jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path
75B7             7 1094 ; ----------------------------------------------------------------------------------------------------------------------
75B7             7 1095 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to 1, everything else to ENEMY.
75B7             7 1096 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
75B7             7 1097 ; [color]' again to find a victory path.
75B7             7 1098 ;
75B7             7 1099 ; Coded by Einar Saukas
75B7             7 1100 ;
75B7             7 1101 ; Input:    HL = pointer to last position of [color]_BOARD
75B7             7 1102 ;
75B7             7 1103 ; Output:   -
75B7             7 1104 ;
75B7             7 1105 ; Destroys: A, BC, HL
75B7             7 1106 ; ----------------------------------------------------------------------------------------------------------------------
75B7             7 1107 PathFinder_PrepareBoard:
75B7 3E 43       7 1108 ld      a, VICTORY+$40              ; set victory distance + friendly flag
75B9 0E 07       7 1109 ld      c, 7                        ; 7 rows
75BB             7 1110 PrepareBoard_Row
75BB 06 07       7 1111 ld      b, 7                        ; 7 columns
75BD             7 1112 PrepareBoard_Column
75BD BE          7 1113 cp      (hl)                        ; is it win condition?
75BE 36 01       7 1114 ld      (hl), 1                     ; save 1 by default
75C0 28 02       7 1115 jr      z, PrepareBoard_Next        ; yes, next position
75C2 36 7E       7 1116 ld      (hl), ENEMY                 ; no, save ENEMY
75C4             7 1117 PrepareBoard_Next
75C4 2D          7 1118 dec     l                           ; HL points to next board position
75C5 10 F6       7 1119 djnz    PrepareBoard_Column         ; repeat for each column
75C7 2D          7 1121 dec     l                           ; skip borders
75C8 2D          7 1122 dec     l
75C9 0D          7 1123 dec     c                           ; decrement rows
75CA 20 EF       7 1124 jr      nz, PrepareBoard_Row        ; repeat for each row
75CC C9          7 1125 ret
75CD             7 1127 ; ----------------------------------------------------------------------------------------------------------------------
75CD             7 1128 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75CD             7 1129 ;
75CD             7 1130 ; Input:    B  = start position of the victory path
75CD             7 1131 ;           HL = [color]_QUEUE_AREA address
75CD             7 1132 ;
75CD             7 1133 ; Output:   -
75CD             7 1134 ;
75CD             7 1135 ; Uses:     TOKEN_COLOR (current token color)
75CD             7 1136 ;
75CD             7 1137 ; Destroys: A, BC, DE, HL, IX
75CD             7 1138 ; ----------------------------------------------------------------------------------------------------------------------
75CD             7 1139 PathFinder_BrightPath:
75CD 3A 9E 61    7 1140 ld      a, (TOKEN_COLOR)            ; get current token color
75D0 F5          7 1141 push    af                          ; store current token color
75D1 C6 40       7 1142 add     a, $40                      ; apply bright attribute
75D3 32 9E 61    7 1143 ld      (TOKEN_COLOR), a            ; save color
75D6 24          7 1145 inc     h                           ; move HL to the start position of the victory path
75D7 68          7 1146 ld      l, b
75D8 4E          7 1147 ld      c, (hl)                     ; set victory path length in C
75D9 18 1E       7 1148 jr      BrightPath_Position         ; animate and highlight the hexagon position
75DB             7 1149 BrightPath_Neighbor
75DB 2C          7 1150 inc     l                           ; move HL to left neighbor address
75DC BE          7 1151 cp      (hl)                        ; is it the same as victory path length?
75DD 28 1A       7 1152 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75DF 2D          7 1153 dec     l
75E0 2D          7 1154 dec     l                           ; right neighbor
75E1 BE          7 1155 cp      (hl)                        ; is it the same as victory path length?
75E2 28 15       7 1156 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75E4 7D          7 1157 ld      a, l
75E5 D6 08       7 1158 sub     WIDTH
75E7 6F          7 1159 ld      l, a                        ; move HL to upper-right neighbor address
75E8 79          7 1160 ld      a, c                        ; restore victory path length in A
75E9 BE          7 1161 cp      (hl)                        ; is it the same as victory path length?
75EA 28 0D       7 1162 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75EC 2C          7 1163 inc     l                           ; upper-left neighbor
75ED BE          7 1164 cp      (hl)                        ; is it the same as victory path length?
75EE 28 09       7 1165 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F0 7D          7 1166 ld      a, l
75F1 C6 10       7 1167 add     a, WIDTH*2
75F3 6F          7 1168 ld      l, a                        ; move HL to lower-right neighbor address
75F4 79          7 1169 ld      a, c                        ; restore victory path length in A
75F5 BE          7 1170 cp      (hl)                        ; is it the same as victory path length?
75F6 28 01       7 1171 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F8 2C          7 1172 inc     l                           ; move HL to lower-left neighbor address
75F9             7 1173 BrightPath_Position
75F9 C5          7 1174 push    bc                          ; store victory path length
75FA E5          7 1175 push    hl                          ; store current position pointer
75FB CD 79 6D    7 1176 call    Main_Board2Indexes          ; convert a board position into a board indexes
75FE CD B4 6D    7 1177 call    Draw_Token                  ; animate hexagon sprite on the screen
7601 DD 21 E7 64 7 1178 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
7605 CD BF 76    7 1179 call    Sound_FX                    ; play sound effect
7608 E1          7 1180 pop     hl                          ; restore current position pointer
7609 C1          7 1181 pop     bc                          ; restore victory path length
760A 0D          7 1182 dec     c                           ; decrement victory path length
760B 79          7 1183 ld      a, c                        ; set victory path length in A
760C FE 03       7 1184 cp      VICTORY                     ; has reached victory path length?
760E 20 CB       7 1185 jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach VICTORY length
7610 F1          7 1187 pop     af                          ; restore current token color
7611 32 9E 61    7 1188 ld      (TOKEN_COLOR), a
7614 C9          7 1189 ret

; File #8: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Timer.z80asm

7615             8 1 ; ----------------------------------------------------------------------------------------------------------------------
7615             8 2 ; Timer.z80asm
7615             8 3 ; Coded by Antonio Luque
7615             8 4 ;
7615             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
7615             8 6 ; ----------------------------------------------------------------------------------------------------------------------
7615             8 8 ; ----------------------------------------------------------------------------------------------------------------------
7615             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
7615             8 10 ;
7615             8 11 ; Input:    -
7615             8 12 ;
7615             8 13 ; Output:   -
7615             8 14 ;
7615             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7615             8 16 ;
7615             8 17 ; Destroys: BC', DE', HL'
7615             8 18 ; ----------------------------------------------------------------------------------------------------------------------
7615             8 19 Timer_Interrupt:
7615 F5          8 20 push    af                          ; store AF register
7616 D9          8 21 exx                                 ; store BC, DE and HL registers
7617 3A EB 62    8 23 ld      a, (TIMER_FLAG)             ; check timer flag
761A B7          8 24 or      a                           ; is timer stopped?
761B CA 44 76    8 25 jp      z, Timer_Exit               ; yes, exit routine
761E 21 EF 62    8 27 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
7621 3D          8 28 dec     a                           ; is red timer on?
7622 C2 28 76    8 29 jp      nz, Timer_Counters          ; yes, check interrupt counter 
7625 21 EC 62    8 30 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
7628             8 31 Timer_Counters
7628 35          8 32 dec     (hl)                        ; decrement interrupt counter
7629 C2 44 76    8 33 jp      nz, Timer_Exit              ; if not 0, exit routine
762C 36 32       8 35 ld      (hl), 50                    ; restart interrupt counter
762E 23          8 36 inc     hl                          ; move HL to seconds counter address
762F 3E 01       8 37 ld      a, 1                        ; increment seconds counter
7631 86          8 38 add     a, (hl)
7632 27          8 39 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7633 77          8 40 ld      (hl), a                     ; store seconds
7634 FE 60       8 41 cp      $60                         ; 60 seconds reached?
7636 C2 41 76    8 42 jp      nz, Timer_Show              ; no, show timer
7639 36 00       8 43 ld      (hl), 0                     ; restart seconds counter
763B 23          8 44 inc     hl                          ; move HL to minutes counter address
763C 3E 01       8 45 ld      a, 1                        ; increment minutes counter
763E 86          8 46 add     a, (hl)
763F 27          8 47 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7640 77          8 48 ld      (hl), a                     ; store minutes
7641             8 49 Timer_Show
7641 CD 48 76    8 50 call    Timer_Display               ; display timer on the screen
7644             8 51 Timer_Exit
7644 D9          8 52 exx                                 ; restore BC, DE and HL registers
7645 F1          8 53 pop     af                          ; restore AF register
7646 FB          8 55 ei                                  ; enable interrupts
7647 C9          8 56 ret
7648             8 58 ; ----------------------------------------------------------------------------------------------------------------------
7648             8 59 ; Timer_Display: display a timer on the screen
7648             8 60 ;
7648             8 61 ; Input:    -
7648             8 62 ;
7648             8 63 ; Output:   -
7648             8 64 ;
7648             8 65 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7648             8 66 ;
7648             8 67 ; Destroys: A, BC, DE, HL
7648             8 68 ; ----------------------------------------------------------------------------------------------------------------------
7648             8 69 Timer_Display:
7648 11 F1 62    8 70 ld      de, RED_TIMER+2             ; DE points to red's minutes counter address
764B 01 E2 48    8 71 ld      bc, $48E2                   ; BC points to red's minutes screen address
764E 3A EB 62    8 72 ld      a, (TIMER_FLAG)             ; check timer flag
7651 3D          8 73 dec     a                           ; is cyan timer on?
7652 C2 5B 76    8 74 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
7655 11 EE 62    8 75 ld      de, CYAN_TIMER+2            ; DE points to cyan's minutes counter address
7658 01 78 40    8 76 ld      bc, $4078                   ; BC points to cyan's minutes screen address
765B             8 77 Timer_Display_Min
765B CD 60 76    8 78 call    Timer_Display_MinSec        ; display minutes counter on screen
765E 1B          8 79 dec     de                          ; DE points to seconds counter address
765F 0C          8 80 inc     c                           ; BC points to seconds screen address
7660             8 81 Timer_Display_MinSec:
7660 1A          8 82 ld      a, (de)                     ; set min/sec counter in A
7661 1F          8 83 rra                                 ; move tens digit to the first 4th bits of A
7662 1F          8 84 rra
7663 1F          8 85 rra
7664 1F          8 86 rra
7665 CD 69 76    8 87 call    Timer_Display_Digit         ; display tens digit on screen
7668 1A          8 88 ld      a, (de)                     ; set min/sec counter in A 
7669             8 89 Timer_Display_Digit:
7669 E6 0F       8 90 and     %00001111                   ; discard the last 4th bits of the digit
766B C5          8 91 push    bc                          ; store digit screen address
766C 21 97 64    8 93 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
766F 87          8 94 add     a, a                        ; a digit is 8 bytes long
7670 87          8 95 add     a, a
7671 87          8 96 add     a, a
7672 85          8 97 add     a, l                        ; set digit index in HL
7673 6F          8 98 ld      l, a
7674 7E          8 100 ld      a, (hl)                     ; get digit tile
7675 02          8 101 ld      (bc), a                     ; put it on screen address
7676 04          8 102 inc     b                           ; move BC to next pixel-line address
7677 2C          8 103 inc     l                           ; move HL to next digit tile address
7678 7E          8 104 ld      a, (hl)                     ; (repeat 7 more times)
7679 02          8 105 ld      (bc), a
767A 04          8 106 inc     b
767B 2C          8 107 inc     l
767C 7E          8 108 ld      a, (hl)
767D 02          8 109 ld      (bc), a
767E 04          8 110 inc     b
767F 2C          8 111 inc     l
7680 7E          8 112 ld      a, (hl)
7681 02          8 113 ld      (bc), a
7682 04          8 114 inc     b
7683 2C          8 115 inc     l
7684 7E          8 116 ld      a, (hl)
7685 02          8 117 ld      (bc), a
7686 04          8 118 inc     b
7687 2C          8 119 inc     l
7688 7E          8 120 ld      a, (hl)
7689 02          8 121 ld      (bc), a
768A 04          8 122 inc     b
768B 2C          8 123 inc     l
768C 7E          8 124 ld      a, (hl)
768D 02          8 125 ld      (bc), a
768E 04          8 126 inc     b
768F 2C          8 127 inc     l
7690 7E          8 128 ld      a, (hl)
7691 02          8 129 ld      (bc), a
7692 C1          8 131 pop     bc                          ; restore digit screen address
7693 0C          8 132 inc     c                           ; move screen address to next column
7694 C9          8 133 ret
7695             8 135 ; ----------------------------------------------------------------------------------------------------------------------
7695             8 136 ; Timer_Display_All: display cyan and red timers
7695             8 137 ;
7695             8 138 ; Input:    -
7695             8 139 ;
7695             8 140 ; Output:   -
7695             8 141 ;
7695             8 142 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7695             8 143 ;
7695             8 144 ; Destroys: BC, DE, HL
7695             8 145 ; ----------------------------------------------------------------------------------------------------------------------
7695             8 146 Timer_Display_All:
7695 3E 01       8 147 ld      a, 1                        ; set cyan timer on
7697 32 EB 62    8 148 ld      (TIMER_FLAG), a
769A CD 48 76    8 149 call    Timer_Display               ; display cyan timer
769D 3E 02       8 151 ld      a, 2                        ; set red timer on
769F 32 EB 62    8 152 ld      (TIMER_FLAG), a
76A2 CD 48 76    8 153 call    Timer_Display               ; display red timer
76A5 AF          8 155 xor     a                           ; stop timers
76A6 32 EB 62    8 156 ld      (TIMER_FLAG), a
76A9 C9          8 157 ret
76AA             8 159 ; ----------------------------------------------------------------------------------------------------------------------
76AA             8 160 ; Timer_Reset: initialize cyan and red timers
76AA             8 161 ;
76AA             8 162 ; Input:    -
76AA             8 163 ;
76AA             8 164 ; Output:   -
76AA             8 165 ;
76AA             8 166 ; Destroys: HL
76AA             8 167 ; ----------------------------------------------------------------------------------------------------------------------
76AA             8 168 Timer_Reset:
76AA 21 EC 62    8 169 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76AD 36 32       8 171 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76AF 23          8 172 inc     hl                          ; move HL to cyan's seconds counter address
76B0 36 00       8 173 ld      (hl), 0                     ; reset seconds counter
76B2 23          8 174 inc     hl                          ; move HL to cyan's minutes counter address
76B3 36 00       8 175 ld      (hl), 0                     ; reset minutes counter
76B5 23          8 176 inc     hl                          ; move HL to red's interrupt counter
76B6 36 32       8 178 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76B8 23          8 179 inc     hl                          ; move HL to red's seconds counter address
76B9 36 00       8 180 ld      (hl), 0                     ; reset seconds counter
76BB 23          8 181 inc     hl                          ; move HL to red's minutes counter address
76BC 36 00       8 182 ld      (hl), 0                     ; reset minutes counter
76BE C9          8 183 ret

; File #9: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Sound.z80asm

76BF             9 1 ; ----------------------------------------------------------------------------------------------------------------------
76BF             9 2 ; Sound.z80asm
76BF             9 3 ; Coded with BeepFX player tool by Shiru: https://shiru.untergrund.net/software.shtml
76BF             9 4 ;
76BF             9 5 ; Adapted for Hex game by Antonio Luque
76BF             9 6 ; ----------------------------------------------------------------------------------------------------------------------
76BF             9 8 ; ----------------------------------------------------------------------------------------------------------------------
76BF             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
76BF             9 10 ; 
76BF             9 11 ; Input:    IX = tone parameters address
76BF             9 12 ;
76BF             9 13 ; Output:   -
76BF             9 14 ;
76BF             9 15 ; Destroys: A, BC, DE, HL, IY
76BF             9 16 ; ----------------------------------------------------------------------------------------------------------------------
76BF             9 17 Sound_FX:
76BF F3          9 18 di                                  ; disable interrupts
76C0 DD 4E 00    9 20 ld      c, (ix+0)                   ; BC = frames
76C3 DD 46 01    9 21 ld      b, (ix+1)
76C6 DD 5E 02    9 22 ld      e, (ix+2)                   ; DE = frame length
76C9 DD 56 03    9 23 ld      d, (ix+3)
76CC D5          9 24 push    de                          ; store frame length in IY
76CD FD E1       9 25 pop     iy
76CF DD 5E 04    9 26 ld      e, (ix+4)                   ; DE = pitch
76D2 DD 56 05    9 27 ld      d, (ix+5)
76D5 21 00 00    9 28 ld      hl, 0                       ; reset HL
76D8             9 30 Sound_FX_Frames
76D8 C5          9 31 push    bc                          ; store frames
76D9 FD E5       9 32 push    iy                          ; restore frame length in BC
76DB C1          9 33 pop     bc
76DC             9 34 Sound_FX_FrameLength
76DC 19          9 35 add     hl, de                      ; HL = incremented pitch
76DD 7C          9 36 ld      a, h                        ; compares with fixed duty cycle ($80 for 50% square wave)
76DE FE 80       9 37 cp      $80                         ; if (incremented pitch < duty cycle)
76E0 9F          9 38 sbc     a, a                        ;    { A = %11111111 } else { A = %00000000 }
76E1 E6 10       9 39 and     %00010000                   ; toggling bit 4 controls the internal speaker
76E3 F6 00       9 40 or      0                           ; keep border unchanged, dummy (7t)
76E5 D3 FE       9 41 out     ($FE), a                    ; send bit to internal speaker
76E7 3A 00 00    9 42 ld      a, (0)                      ; dummy (13t)
76EA 0B          9 43 dec     bc                          ; decrement frame length
76EB 78          9 44 ld      a, b                        ; check frame length
76EC B1          9 45 or      c                           ; frame length = 0?
76ED C2 DC 76    9 46 jp      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times (loop = 88t)
76F0 DD 4E 06    9 48 ld      c, (ix+6)                   ; BC = pitch slide
76F3 DD 46 07    9 49 ld      b, (ix+7)
76F6 EB          9 50 ex      de, hl                      ; HL = current pitch
76F7 09          9 51 add     hl, bc                      ; increment pitch with pitch slide
76F8 EB          9 52 ex      de, hl                      ; DE = new pitch
76F9 C1          9 54 pop     bc                          ; restore frames
76FA 0B          9 55 dec     bc                          ; decrement frames
76FB 78          9 56 ld      a, b                        ; check frames
76FC B1          9 57 or      c                           ; frames = 0?
76FD 20 D9       9 58 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
76FF FB          9 60 ei                                  ; enable interrupts
7700 C9          9 61 ret

; File #10: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Screen.z80asm

7701             10 1 ; ----------------------------------------------------------------------------------------------------------------------
7701             10 2 ; Screen.z80asm
7701             10 3 ; Coded by Antonio Luque
7701             10 4 ; ----------------------------------------------------------------------------------------------------------------------
7701             10 6 BLUE_INK                equ     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
7701             10 7 BLUE_PAPER              equ     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
7701             10 8 WHITE_PAPER             equ     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
7701             10 9 WHITE                   equ     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
7701             10 10 BRIGHT                  equ     %01000000                   ; mask to apply bright to attributes
7701             10 11 FLASH                   equ     %10000000                   ; mask to apply flash to attributes
7701             10 12 WHITE_FLASH0            equ     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
7701             10 13 WHITE_FLASH1            equ     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
7701             10 15 ; ----------------------------------------------------------------------------------------------------------------------
7701             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
7701             10 17 ;
7701             10 18 ; Input:    -
7701             10 19 ;
7701             10 20 ; Output:   -
7701             10 21 ;
7701             10 22 ; Destroys: BC, DE, HL
7701             10 23 ; ----------------------------------------------------------------------------------------------------------------------
7701             10 24 Screen_Clear:
7701 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
7704 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
7707 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
7708 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
770B ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
770D C9          10 30 ret
770E             10 32 ; ----------------------------------------------------------------------------------------------------------------------
770E             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
770E             10 34 ;
770E             10 35 ; Input:    -
770E             10 36 ;
770E             10 37 ; Output:   -
770E             10 38 ;
770E             10 39 ; Destroys: A, BC, DE, HL, IX
770E             10 40 ; ----------------------------------------------------------------------------------------------------------------------
770E             10 41 Screen_Letters:
770E 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
7711 DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
7715 CD 1F 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
7718 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
771B DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
771F             10 47 Screen_Letters_Row:
771F 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
7722 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
7724             10 50 Screen_Letter_Loop
7724 E5          10 51 push    hl                          ; store letter screen address
7725 CD EC 6D    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
7728 E1          10 53 pop     hl                          ; restore letter screen address
7729 2C          10 54 inc     l                           ; move HL to next screen address
772A 2C          10 55 inc     l
772B DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
772F DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
7733 DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
7735 DD 2C       10 59 inc     ixl
7737 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
7739 C9          10 61 ret
773A             10 63 ; ----------------------------------------------------------------------------------------------------------------------
773A             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
773A             10 65 ;
773A             10 66 ; Input:    -
773A             10 67 ;
773A             10 68 ; Output:   -
773A             10 69 ;
773A             10 70 ; Destroys: A, BC, DE, HL, IX, IY
773A             10 71 ; ----------------------------------------------------------------------------------------------------------------------
773A             10 72 Screen_Numbers:
773A 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
773D FD 21 F2 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
7741 DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
7745 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
7747             10 77 Screen_Number_Loop
7747 FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
774A FD 66 01    10 79 ld      h, (iy+1)
774D E5          10 80 push    hl                          ; store pointer to number screen address
774E D5          10 81 push    de                          ; store pointer to sprite address
774F CD EC 6D    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
7752 D1          10 83 pop     de                          ; restore pointer to sprite address
7753 E1          10 84 pop     hl                          ; restore pointer to number screen address
7754 DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7758 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
775C 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
775D C6 0F       10 88 add     a, 15
775F 6F          10 89 ld      l, a
7760 CD EC 6D    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
7763 DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
7767 DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
776B 78          10 93 ld      a, b                        ; save loop counter
776C 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
776F DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
7771 FD 23       10 96 inc     iy                          ; move IY to next number screen address
7773 FD 23       10 97 inc     iy
7775 47          10 98 ld      b, a                        ; restore loop counter
7776 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
7778 C9          10 100 ret
7779             10 102 ; ----------------------------------------------------------------------------------------------------------------------
7779             10 103 ; Screen_Frame: draw the screen frame on the screen
7779             10 104 ;
7779             10 105 ; Input:    -
7779             10 106 ;
7779             10 107 ; Output:   -
7779             10 108 ;
7779             10 109 ; Destroys: A, BC, DE, HL, IX
7779             10 110 ; ----------------------------------------------------------------------------------------------------------------------
7779             10 111 Screen_Frame:
7779 11 2B 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
777C 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
777F CD 51 6F    10 114 call    Print_String                ; print "Level"
7782 CD BE 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
7785 01 90 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
7788 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
778B CD 91 77    10 119 call    Screen_Frame_Border         ; draw up-border
778E 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
7791             10 121 Screen_Frame_Border:
7791 DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
7794             10 123 Screen_Frame_Loop
7794 0A          10 124 ld      a, (bc)                     ; get tile index
7795 FE FF       10 125 cp      -1                          ; is it -1?
7797 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
7799 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
779C CD 60 6F    10 128 call    Print_Tile                  ; print frame tile
779F             10 129 Screen_Frame_Next
779F 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77A0 03          10 131 inc     bc                          ; BC points to the next tile index
77A1 DD 2D       10 132 dec     ixl                         ; decrement loop counter
77A3 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77A5 DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77A9 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77AD DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77B1 DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77B5 DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77B9 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77BD C9          10 141 ret
77BE             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77BE             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77BE             10 145 ;
77BE             10 146 ; Input:    -
77BE             10 147 ;
77BE             10 148 ; Output:   -
77BE             10 149 ;
77BE             10 150 ; Destroys: A, BC, HL
77BE             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77BE             10 152 Screen_Vertical_Bars:
77BE 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
77C1 CD C7 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
77C4 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
77C7             10 156 Screen_Vertical_Bar:
77C7 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
77C9             10 158 Screen_Vertical_Loop
77C9 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
77CB CD F8 6D    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
77CE 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
77D0 C9          10 162 ret
77D1             10 164 ; ----------------------------------------------------------------------------------------------------------------------
77D1             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
77D1             10 166 ;
77D1             10 167 ; Input:    -
77D1             10 168 ;
77D1             10 169 ; Output:   -
77D1             10 170 ;
77D1             10 171 ; Uses:     TOKEN_COLOR (current token color)
77D1             10 172 ;
77D1             10 173 ; Destroys: A, BC, DE, HL, IX
77D1             10 174 ; ----------------------------------------------------------------------------------------------------------------------
77D1             10 175 Screen_Tokens:
77D1 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
77D3 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
77D6 CD DE 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
77D9 3E 02       10 180 ld      a, RED_COLOR                ; set token color
77DB 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
77DE             10 182 Screen_Tokens_Draw:
77DE 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77E1 CD 07 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
77E4 DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
77E7 DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
77EA 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
77ED C3 D9 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
77F0             10 190 ; ----------------------------------------------------------------------------------------------------------------------
77F0             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
77F0             10 192 ;
77F0             10 193 ; Input:    -
77F0             10 194 ;
77F0             10 195 ; Output:   -
77F0             10 196 ;
77F0             10 197 ; Destroys: IX
77F0             10 198 ; ----------------------------------------------------------------------------------------------------------------------
77F0             10 199 Screen_Timer_Quotes:
77F0 DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
77F4 DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
77F8 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
77FC DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
77FE DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7802 DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7806 DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
7809 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
780D DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
7811 DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
7815 DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7819 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
781D DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
781F DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7823 DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7827 DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
782A DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
782E DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
7832 C9          10 219 ret
7833             10 221 ; ----------------------------------------------------------------------------------------------------------------------
7833             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
7833             10 223 ;
7833             10 224 ; Input:    -
7833             10 225 ;
7833             10 226 ; Output:   -
7833             10 227 ;
7833             10 228 ; Destroys: BC, IX
7833             10 229 ; ----------------------------------------------------------------------------------------------------------------------
7833             10 230 Screen_Color_Statics:
7833 DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
7837 0E 07       10 232 ld      c, WHITE                    ; set color in C
7839 CD 63 78    10 233 call    Screen_Apply_Color          ; apply color
783C DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
783F 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
7841 CD 63 78    10 236 call    Screen_Apply_Color          ; apply color
7844 DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7848 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
784A CD 63 78    10 239 call    Screen_Apply_Color          ; apply color
784D DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
7850 0E 07       10 241 ld      c, WHITE                    ; set color in C
7852 CD 63 78    10 242 call    Screen_Apply_Color          ; apply color
7855 DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7859 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
785B CD 63 78    10 245 call    Screen_Apply_Color          ; apply color
785E DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
7861 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
7863             10 248 Screen_Apply_Color:
7863 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
7865             10 250 Screen_Apply_Color_Loop:
7865 DD 71 00    10 251 ld      (ix+0), c                   ; apply color
7868 DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
786A 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
786C C9          10 254 ret
786D             10 256 ; ----------------------------------------------------------------------------------------------------------------------
786D             10 257 ; Screen_Last_Level: show last level screen and input game level
786D             10 258 ;
786D             10 259 ; Input:    -
786D             10 260 ;
786D             10 261 ; Output:   -
786D             10 262 ;
786D             10 263 ; Uses:     GAME_LEVEL (current game level)
786D             10 264 ;
786D             10 265 ; Destroys: A, BC, DE, HL, IX, IY
786D             10 266 ; ----------------------------------------------------------------------------------------------------------------------
786D             10 267 Screen_Last_Level:
786D 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
7870 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
7873 CD 51 6F    10 270 call    Print_String                ; print "Press any key"
7876 DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
787A 01 38 0D    10 272 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
787D CD 65 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
7880 CD BD 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
7883 CD 01 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7886 CD 46 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7889 DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
788D 01 C7 11    10 279 ld      bc, 17*256+WHITE_FLASH1     ; B = string length (loop counter), C = color attributes
7890 CD 65 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
7893 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
7896 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
7899 CD 51 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
789C DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78A0 CD BF 76    10 285 call    Sound_FX                    ; play sound fx
78A3 F3          10 287 di                                  ; disable interrupts
78A4 DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78A8 01 07 1C    10 289 ld      bc, 28*256+WHITE            ; B = string length (loop counter), C = color attributes
78AB CD 65 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78AE 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78B1 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78B4 CD 51 6F    10 293 call    Print_String                ; print "Well done!..."
78B7 DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78BA 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78BC CD 65 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78BF DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
78C3 DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
78C7 DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
78CB 13          10 300 inc     de                          ; move DE to next string address
78CC 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
78CE CD 51 6F    10 302 call    Print_String                ; print "Choose..."
78D1             10 303 Screen_Choose_Level
78D1 CD BD 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
78D4 FE 31       10 305 cp      '1'                         ; is it < '1' ?
78D6 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
78D8 FE 35       10 307 cp      '5'                         ; is it >= '5' ?
78DA 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
78DC D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
78DE 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
78E1 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
78E2 C9          10 312 ret
78E3             10 314 ; ----------------------------------------------------------------------------------------------------------------------
78E3             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
78E3             10 316 ;
78E3             10 317 ; Input:    -
78E3             10 318 ;
78E3             10 319 ; Output:   -
78E3             10 320 ;
78E3             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
78E3             10 322 ;           THREE_ROW (three-in-a-row counter)
78E3             10 323 ;
78E3             10 324 ; Destroys: A, C, HL, IX
78E3             10 325 ; ----------------------------------------------------------------------------------------------------------------------
78E3             10 326 Screen_ThreeRow:
78E3 21 9C 61    10 327 ld      hl, LEVEL_COLOR             ; HL points to level color address
78E6 4E          10 328 ld      c, (hl)                     ; save level color in C
78E7 CD FF 78    10 329 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
78EA 3A 11 62    10 330 ld      a, (THREE_ROW)              ; A = three-in-a-row counter
78ED B7          10 331 or      a                           ; is it 0?
78EE C8          10 332 ret     z                           ; yes, return
78EF 3D          10 333 dec     a                           ; is it 1?
78F0 28 09       10 334 jr      z, Screen_ThreeRow_1        ; yes, color first mark
78F2 3D          10 335 dec     a                           ; is it 2?
78F3 28 03       10 336 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
78F5 DD 71 00    10 337 ld      (ix+0), c                   ; color 3rd mark
78F8             10 338 Screen_ThreeRow_2
78F8 DD 71 01    10 339 ld      (ix+1), c                   ; color 2nd mark
78FB             10 340 Screen_ThreeRow_1
78FB DD 71 02    10 341 ld      (ix+2), c                   ; color 1st mark
78FE C9          10 342 ret
78FF             10 344 ; ----------------------------------------------------------------------------------------------------------------------
78FF             10 345 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
78FF             10 346 ;
78FF             10 347 ; Input:    -
78FF             10 348 ;
78FF             10 349 ; Output:   IX = three-in-a-row marks attribute address
78FF             10 350 ;
78FF             10 351 ; Destroys: -
78FF             10 352 ; ----------------------------------------------------------------------------------------------------------------------
78FF             10 353 Screen_Clear_ThreeRow:
78FF DD 21 F2 5A 10 354 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
7903 DD 36 00 01 10 355 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
7907 DD 36 01 01 10 356 ld      (ix+1), BLUE_INK
790B DD 36 02 01 10 357 ld      (ix+2), BLUE_INK
790F C9          10 358 ret
7910             10 360 ; ----------------------------------------------------------------------------------------------------------------------
7910             10 361 ; Screen_Frame_Color: set up frame color and print level number depending on current level
7910             10 362 ;
7910             10 363 ; Input:    HL = game level address
7910             10 364 ;
7910             10 365 ; Output:   -
7910             10 366 ;
7910             10 367 ; Uses:     LEVEL_COLOR (current level color for frame border)
7910             10 368 ;
7910             10 369 ; Destroys: A, BC, DE, HL
7910             10 370 ; ----------------------------------------------------------------------------------------------------------------------
7910             10 371 Screen_Frame_Color:
7910 06 00       10 372 ld      b, 0                        ; set game level in BC
7912 4E          10 373 ld      c, (hl)
7913 3E 30       10 374 ld      a, $30                      ; convert game level number to game level character
7915 81          10 375 add     a, c
7916 21 0F 40    10 376 ld      hl, $400F                   ; HL points to screen address of game level
7919 CD 5D 6F    10 377 call    Print_Char                  ; print game level
791C 21 11 62    10 378 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
791F 09          10 379 add     hl, bc                      ; use BC as index for color map address
7920 7E          10 380 ld      a, (hl)                     ; A = level color
7921 CD 36 79    10 381 call    Screen_Tiles_Color          ; color the frame according to the current level
7924 E6 07       10 382 and     %00000111                   ; mask color
7926 32 9C 61    10 383 ld      (LEVEL_COLOR), a            ; save masked color
7929 17          10 384 rla                                 ; rotate to text level color
792A 17          10 385 rla
792B 17          10 386 rla
792C 21 08 58    10 387 ld      hl, $5808                   ; HL points to attribute address of level text
792F 06 09       10 388 ld      b, 9                        ; length of level text (loop counter)
7931             10 389 Screen_Level_Loop
7931 77          10 390 ld      (hl), a                     ; apply color to level text
7932 2C          10 391 inc     l                           ; HL points to attr address of next character of level text
7933 10 FC       10 392 djnz    Screen_Level_Loop           ; repeat for each character of level text
7935 C9          10 393 ret
7936             10 395 ; ----------------------------------------------------------------------------------------------------------------------
7936             10 396 ; Screen_Tiles_Color: apply color to the frame tiles
7936             10 397 ;
7936             10 398 ; Input:    A = color to apply
7936             10 399 ;
7936             10 400 ; Output:   -
7936             10 401 ;
7936             10 402 ; Destroys: BC, DE, HL
7936             10 403 ; ----------------------------------------------------------------------------------------------------------------------
7936             10 404 Screen_Tiles_Color:
7936             10 405 ; color up row
7936 21 01 58    10 407 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
7939 06 06       10 408 ld      b, 6                        ; number of tiles (loop counter)
793B             10 409 Screen_Tiles_URow1
793B 77          10 410 ld      (hl), a                     ; apply color
793C 2C          10 411 inc     l                           ; move HL to the next attribute address
793D 10 FC       10 412 djnz    Screen_Tiles_URow1          ; repeat for each tile
793F 2E 12       10 413 ld      l, $12                      ; move HL to the next attribute address
7941 06 0D       10 414 ld      b, 13                       ; number of tiles (loop counter)
7943             10 415 Screen_Tiles_URow2
7943 77          10 416 ld      (hl), a                     ; apply color
7944 2C          10 417 inc     l                           ; move HL to the next attribute address
7945 10 FC       10 418 djnz    Screen_Tiles_URow2          ; repeat for each tile
7947             10 420 ; color vertical bars
7947 2E 00       10 422 ld      l, 0                        ; move HL to the next attribute address
7949 11 1F 00    10 423 ld      de, 31                      ; attribute address displacement (for each bar)
794C 0E 03       10 424 ld      c, 3                        ; number of screen thirds (outer loop counter)
794E             10 425 Screen_Tiles_VBar1
794E 06 08       10 426 ld      b, 8                        ; number of tiles (inner loop counter)
7950             10 427 Screen_Tiles_VBar2
7950 77          10 428 ld      (hl), a                     ; apply color
7951 19          10 429 add     hl, de                      ; move HL to the right column
7952 77          10 430 ld      (hl), a                     ; apply color
7953 2C          10 431 inc     l                           ; move HL to the next attribute address
7954 10 FA       10 432 djnz    Screen_Tiles_VBar2          ; repeat for each tile
7956 24          10 433 inc     h                           ; move HL to the next screen third
7957 0D          10 434 dec     c                           ; decrement number of thirds
7958 20 F4       10 435 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
795A             10 437 ; color bottom row
795A 21 E1 5A    10 439 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
795D 06 10       10 440 ld      b, 16                       ; number of tiles (loop counter)
795F             10 441 Screen_Tiles_BRow1
795F 77          10 442 ld      (hl), a                     ; apply color
7960 2C          10 443 inc     l                           ; move HL to the next attribute address
7961 10 FC       10 444 djnz    Screen_Tiles_BRow1          ; repeat for each tile
7963 2E F6       10 445 ld      l, $F6                      ; move HL to the next attribute address
7965 06 09       10 446 ld      b, 9                        ; number of tiles (loop counter)
7967             10 447 Screen_Tiles_BRow2
7967 77          10 448 ld      (hl), a                     ; apply color
7968 2C          10 449 inc     l                           ; move HL to the next attribute address
7969 10 FC       10 450 djnz    Screen_Tiles_BRow2          ; repeat for each tile
796B C9          10 451 ret
796C             10 453 ; ----------------------------------------------------------------------------------------------------------------------
796C             10 454 ; Screen_Menu: show main menu and wait for an option
796C             10 455 ;
796C             10 456 ; Input:    -
796C             10 457 ;
796C             10 458 ; Output:   -
796C             10 459 ;
796C             10 460 ; Uses:     GAME_LEVEL (current game level)
796C             10 461 ;
796C             10 462 ; Destroys: A, BC, DE, HL, IX, IY
796C             10 463 ; ----------------------------------------------------------------------------------------------------------------------
796C             10 464 Screen_Menu:
796C CD 01 77    10 465 call    Screen_Clear                ; fill in black the whole screen area and attributes area
796F CD 46 7C    10 466 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7972             10 467 Screen_Menu_Strings
7972 21 80 59    10 468 ld      hl, $5980                   ; HL points to menu text area attributes address
7975 11 81 59    10 469 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
7978 36 00       10 470 ld      (hl), 0                     ; set first attribute text area in black
797A 01 7F 01    10 471 ld      bc, 32*12-1                 ; length of text area attributes (-1 already set)
797D ED B0       10 472 ldir                                ; set the rest of text area attributes in black
797F DD 21 CA 59 10 474 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
7983 DD 36 FF 78 10 475 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7987 01 47 0D    10 476 ld      bc, 13*256+WHITE_FLASH0     ; B = string length-1 (loop counter), C = color attributes
798A CD 65 78    10 477 call    Screen_Apply_Color_Loop     ; apply color to string area
798D 11 80 67    10 478 ld      de, STR_OPTIONS             ; DE points to string address
7990 21 C9 48    10 479 ld      hl, $48C9                   ; HL points to string screen address
7993 CD 51 6F    10 480 call    Print_String                ; print "Start new game"
7996 DD 21 2A 5A 10 481 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
799A DD 36 FF 78 10 482 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
799E 06 0A       10 483 ld      b, 10                       ; string length-1 (loop counter)
79A0 CD 65 78    10 484 call    Screen_Apply_Color_Loop     ; apply color to string area
79A3 13          10 485 inc     de                          ; move DE to "How to play" string address
79A4 21 29 50    10 486 ld      hl, $5029                   ; HL points to string screen address
79A7 CD 51 6F    10 487 call    Print_String                ; print "How to play"
79AA DD 2E 8A    10 488 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79AD DD 36 FF 78 10 489 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79B1 CD 63 78    10 490 call    Screen_Apply_Color          ; apply color to string area
79B4 13          10 491 inc     de                          ; move DE to "Credits" string address
79B5 2E 89       10 492 ld      l, $89                      ; HL points to string screen address
79B7 CD 51 6F    10 493 call    Print_String                ; print "Credits"
79BA             10 494 Screen_Menu_Options
79BA CD BD 6E    10 495 call    Input_Key_Scan              ; wait for a key pressed
79BD FE 73       10 496 cp      's'                         ; is it 's'?
79BF C8          10 497 ret     z                           ; yes, return
79C0 FE 63       10 498 cp      'c'                         ; is it 'c'?
79C2 CA D6 7B    10 499 jp      z, Screen_Menu_Credits      ; yes, show credits
79C5 FE 68       10 500 cp      'h'                         ; is it 'h'?
79C7 20 F1       10 501 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
79C9             10 503 ; ----------------------------------------------------------------------------------------------------------------------
79C9             10 504 ; Show "How to play" pages
79C9             10 505 ; ----------------------------------------------------------------------------------------------------------------------
79C9             10 506 Screen_Menu_How2Play
79C9 CD 01 77    10 507 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79CC CD 0E 77    10 508 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
79CF CD 3A 77    10 509 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
79D2 CD 79 77    10 510 call    Screen_Frame                ; draw the screen frame
79D5 21 9D 61    10 512 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
79D8 34          10 513 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
79D9 CD 10 79    10 514 call    Screen_Frame_Color          ; set up frame color depending on current level
79DC CD FF 78    10 515 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
79DF 11 4A 68    10 517 ld      de, STR_BUTTONS             ; DE points to "Next" string address
79E2 21 DB 50    10 518 ld      hl, $50DB                   ; HL points to string screen address
79E5 CD 51 6F    10 519 call    Print_String                ; print "Next"
79E8 13          10 520 inc     de                          ; move DE to "Back" string address
79E9 21 C1 50    10 521 ld      hl, $50C1                   ; HL points to string screen address
79EC CD 51 6F    10 522 call    Print_String                ; print "Back"
79EF             10 524 Screen_How2Play_RED
79EF 21 5E 58    10 525 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
79F2 CD 80 7C    10 526 call    Screen_Clear_Text           ; clear text area attributes
79F5 CD 99 6D    10 527 call    Draw_Board                  ; draw an empty hexagons board
79F8             10 529 ; text for RED
79F8 DD 21 01 5A 10 531 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
79FC 01 07 07    10 532 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
79FF CD 65 78    10 533 call    Screen_Apply_Color_Loop     ; apply color to string area
7A02 11 5D 68    10 534 ld      de, STR_HELP1               ; DE points to string address
7A05 21 01 50    10 535 ld      hl, $5001                   ; HL points to string screen address
7A08 CD 51 6F    10 536 call    Print_String                ; print "Connect"
7A0B DD 2E 21    10 537 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A0E 06 08       10 538 ld      b, 8                        ; string length (loop counter)
7A10 CD 65 78    10 539 call    Screen_Apply_Color_Loop     ; apply color to string area
7A13 13          10 540 inc     de                          ; move DE to "left and" string address
7A14 2E 21       10 541 ld      l, $21                      ; HL points to string screen address
7A16 CD 51 6F    10 542 call    Print_String                ; print "left and"
7A19 DD 2E 41    10 543 ld      ixl, $41                    ; IX points to "right" string attributes address
7A1C 06 05       10 544 ld      b, 5                        ; set string length (loop counter)
7A1E CD 65 78    10 545 call    Screen_Apply_Color_Loop     ; apply color to string area
7A21 11 75 68    10 546 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A24 2E 41       10 547 ld      l, $41                      ; HL points to string screen address
7A26 CD 51 6F    10 548 call    Print_String                ; print "right"
7A29 DD 2E 61    10 549 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A2C 06 07       10 550 ld      b, 7                        ; set string length (loop counter)
7A2E CD 65 78    10 551 call    Screen_Apply_Color_Loop     ; apply color to string area
7A31 11 80 68    10 552 ld      de, STR_HELP4               ; DE points to "borders" string address
7A34 2E 61       10 553 ld      l, $61                      ; HL points to string screen address
7A36 CD 51 6F    10 554 call    Print_String                ; print "borders"
7A39 DD 2E 81    10 555 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A3C CD 63 78    10 556 call    Screen_Apply_Color          ; apply color to string area
7A3F 13          10 557 inc     de                          ; move DE to "to win" string address
7A40 2E 81       10 558 ld      l, $81                      ; HL points to string screen address
7A42 CD 51 6F    10 559 call    Print_String                ; print "to win"
7A45 DD 21 E3 59 10 560 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A49 01 42 03    10 561 ld      bc, 3*256+RED_COLOR+BRIGHT  ; B = string length (loop counter), C = color attributes
7A4C CD 65 78    10 562 call    Screen_Apply_Color_Loop     ; apply color to string area
7A4F 11 54 68    10 563 ld      de, STR_RED                 ; DE points to "RED" string address
7A52 21 E3 48    10 564 ld      hl, $48E3                   ; HL points to string screen address
7A55 CD 51 6F    10 565 call    Print_String                ; print "RED"
7A58             10 567 ; draw RED sample board
7A58 FD 21 3A 67 10 569 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A5C 11 3E 66    10 570 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A5F 06 07       10 571 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A61 3E 42       10 572 ld      a, RED_COLOR+BRIGHT         ; set token color
7A63 32 9E 61    10 573 ld      (TOKEN_COLOR), a            ; save token color
7A66 CD 6B 7C    10 574 call    Screen_Hexagons_Loop        ; draw tokens
7A69 06 02       10 575 ld      b, 2                        ; number of red tokens (loop counter)
7A6B 3E 02       10 576 ld      a, RED_COLOR                ; set token color
7A6D 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7A70 CD 6B 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7A73 06 09       10 579 ld      b, 9                        ; number of cyan tokens (loop counter)
7A75 3E 05       10 580 ld      a, CYAN_COLOR               ; set token color
7A77 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7A7A CD 6B 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7A7D             10 584 ; wait for "Next" option pressed
7A7D DD 21 C1 5A 10 586 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A81 01 00 04    10 587 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7A84 CD 65 78    10 588 call    Screen_Apply_Color_Loop     ; hide "Back" string
7A87 DD 2E DC    10 589 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7A8A DD 36 FF 78 10 590 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7A8E 01 47 03    10 591 ld      bc, 3*256+WHITE_FLASH0      ; B = string length-1 (loop counter), C = color attributes
7A91 CD 65 78    10 592 call    Screen_Apply_Color_Loop     ; apply color to string area
7A94             10 593 Screen_How2PlayRED_End
7A94 CD BD 6E    10 594 call    Input_Key_Scan              ; wait for a key pressed
7A97 FE 6E       10 595 cp      'n'                         ; is it 'n'?
7A99 20 F9       10 596 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7A9B             10 598 Screen_How2Play_CYAN
7A9B 21 0F 58    10 599 ld      hl, $580F                   ; HL points to level number attribute address
7A9E CB BE       10 600 res     7, (hl)                     ; reset flash attribute
7AA0 26 40       10 601 ld      h, $40                      ; HL points to level number screen address
7AA2 3E 31       10 602 ld      a, '1'                      ; set level number (char)
7AA4 CD 5D 6F    10 603 call    Print_Char                  ; print '1'
7AA7 CD FF 78    10 604 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7AAA 21 C9 59    10 606 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7AAD CD 80 7C    10 607 call    Screen_Clear_Text           ; clear text area attributes
7AB0 CD 99 6D    10 608 call    Draw_Board                  ; draw an empty hexagons board
7AB3             10 610 ; text for CYAN
7AB3 DD 21 98 58 10 612 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7AB7 01 07 07    10 613 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7ABA CD 65 78    10 614 call    Screen_Apply_Color_Loop     ; apply color to string area
7ABD 11 5D 68    10 615 ld      de, STR_HELP1               ; DE points to "Connect" string address
7AC0 21 98 40    10 616 ld      hl, $4098                   ; HL points to string screen address
7AC3 CD 51 6F    10 617 call    Print_String                ; print "Connect"
7AC6 DD 2E B9    10 618 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7AC9 CD 63 78    10 619 call    Screen_Apply_Color          ; apply color to string area
7ACC 11 6E 68    10 620 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7ACF 2E B9       10 621 ld      l, $B9                      ; HL points to string screen address
7AD1 CD 51 6F    10 622 call    Print_String                ; print "up and"
7AD4 DD 2E DB    10 623 ld      ixl, $DB                    ; IX points to "down" string attributes address
7AD7 06 04       10 624 ld      b, 4                        ; string length (loop counter)
7AD9 CD 65 78    10 625 call    Screen_Apply_Color_Loop     ; apply color to string area
7ADC 11 7B 68    10 626 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7ADF 2E DB       10 627 ld      l, $DB                      ; HL points to string screen address
7AE1 CD 51 6F    10 628 call    Print_String                ; print "down"
7AE4 DD 2E F8    10 629 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7AE7 06 07       10 630 ld      b, 7                        ; string length (loop counter)
7AE9 CD 65 78    10 631 call    Screen_Apply_Color_Loop     ; apply color to string area
7AEC 13          10 632 inc     de                          ; move DE to "borders" string address
7AED 2E F8       10 633 ld      l, $F8                      ; HL points to string screen address
7AEF CD 51 6F    10 634 call    Print_String                ; print "borders"
7AF2 DD 21 19 59 10 635 ld      ix, $5919                   ; IX points to "to win" string attributes address
7AF6 CD 63 78    10 636 call    Screen_Apply_Color          ; apply color to string area
7AF9 13          10 637 inc     de                          ; move DE to "to win" string address
7AFA 21 19 48    10 638 ld      hl, $4819                   ; HL points to string screen address
7AFD CD 51 6F    10 639 call    Print_String                ; print "to win"
7B00 DD 21 7A 58 10 640 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B04 01 45 04    10 641 ld      bc, $0445                   ; B = string length (loop counter)
7B07             10 642 ; C = color attributes (cyan+bright)
7B07 CD 65 78    10 643 call    Screen_Apply_Color_Loop     ; apply color to string area
7B0A 11 58 68    10 644 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B0D 21 7A 40    10 645 ld      hl, $407A                   ; HL points to string screen address
7B10 CD 51 6F    10 646 call    Print_String                ; print "CYAN"
7B13             10 648 ; draw CYAN sample board
7B13 FD 21 5E 67 10 650 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B17 11 3E 66    10 651 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B1A 06 07       10 652 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B1C 3E 45       10 653 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B1E 32 9E 61    10 654 ld      (TOKEN_COLOR), a            ; save token color
7B21 CD 6B 7C    10 655 call    Screen_Hexagons_Loop        ; draw tokens
7B24 06 02       10 656 ld      b, 2                        ; number of cyan tokens (loop counter)
7B26 3E 05       10 657 ld      a, CYAN_COLOR               ; set token color
7B28 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B2B CD 6B 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B2E 06 08       10 660 ld      b, 8                        ; number of red tokens (loop counter)
7B30 3E 02       10 661 ld      a, RED_COLOR                ; set token color
7B32 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B35 CD 6B 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B38             10 665 ; wait for "Next" or "Back" options pressed
7B38 DD 21 C2 5A 10 667 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B3C DD 36 FF 78 10 668 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B40 01 47 03    10 669 ld      bc, 3*256+WHITE_FLASH0      ; B = string length (-1), C = color attributes
7B43 CD 65 78    10 670 call    Screen_Apply_Color_Loop     ; apply color to string area
7B46             10 671 Screen_How2PlayCYAN_End
7B46 CD BD 6E    10 672 call    Input_Key_Scan              ; wait for a key pressed
7B49 FE 62       10 673 cp      'b'                         ; is it 'b'?
7B4B CA EF 79    10 674 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B4E FE 6E       10 675 cp      'n'                         ; is it 'n'?
7B50 20 F4       10 676 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B52             10 678 Screen_How2Play_LevelUp
7B52 21 5E 58    10 679 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B55 CD 80 7C    10 680 call    Screen_Clear_Text           ; clear text area attributes
7B58             10 682 ; text for Level Up
7B58 DD 21 21 5A 10 684 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B5C 01 07 09    10 685 ld      bc, 9*256+WHITE             ; B = string length (loop counter), C = color attributes
7B5F CD 65 78    10 686 call    Screen_Apply_Color_Loop     ; apply color to string area
7B62 11 8F 68    10 687 ld      de, STR_HELP                ; DE points to "Win three" string address
7B65 21 21 50    10 688 ld      hl, $5021                   ; HL points to string screen address
7B68 CD 51 6F    10 689 call    Print_String                ; print "Win three"
7B6B DD 2E 41    10 690 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B6E 06 08       10 691 ld      b, 8                        ; string length (loop counter)
7B70 CD 65 78    10 692 call    Screen_Apply_Color_Loop     ; apply color to string area
7B73 13          10 693 inc     de                          ; move DE to "times in" string address
7B74 2E 41       10 694 ld      l, $41                      ; HL points to string screen address
7B76 CD 51 6F    10 695 call    Print_String                ; print "times in"
7B79 DD 2E 61    10 696 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B7C 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7B7E CD 65 78    10 698 call    Screen_Apply_Color_Loop     ; apply color to string area
7B81 13          10 699 inc     de                          ; move DE to "a row to" string address
7B82 2E 61       10 700 ld      l, $61                      ; HL points to string screen address
7B84 CD 51 6F    10 701 call    Print_String                ; print "a row to"
7B87 DD 2E 81    10 702 ld      ixl, $81                    ; IX points to "level up" string attributes address
7B8A 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7B8C CD 65 78    10 704 call    Screen_Apply_Color_Loop     ; apply color to string area
7B8F 13          10 705 inc     de                          ; move DE to "level up" string address
7B90 2E 81       10 706 ld      l, $81                      ; HL points to string screen address
7B92 CD 51 6F    10 707 call    Print_String                ; print "level up"
7B95             10 709 ; reset bright of cyan tokens
7B95 FD 21 5E 67 10 711 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B99 11 3E 66    10 712 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B9C 06 07       10 713 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B9E 3E 05       10 714 ld      a, CYAN_COLOR               ; set new token color
7BA0 32 9E 61    10 715 ld      (TOKEN_COLOR), a            ; save color
7BA3 CD 6B 7C    10 716 call    Screen_Hexagons_Loop        ; draw tokens
7BA6             10 718 ; set flash attribute of level number and three-in-a-row marks
7BA6 21 0F 58    10 720 ld      hl, $580F                   ; HL points to level number attribute address
7BA9 CB FE       10 721 set     7, (hl)                     ; set flash attribute
7BAB 21 0F 40    10 722 ld      hl, $400F                   ; HL points to level number screen address
7BAE 3E 32       10 723 ld      a, '2'                      ; set new level
7BB0 CD 5D 6F    10 724 call    Print_Char                  ; print new level
7BB3 DD 21 F2 5A 10 725 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BB7 DD 36 00 B8 10 726 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BBB DD 36 01 B8 10 727 ld      (ix+1), WHITE_PAPER+FLASH
7BBF DD 36 02 B8 10 728 ld      (ix+2), WHITE_PAPER+FLASH
7BC3             10 730 ; wait for "Next" or "Back" options pressed
7BC3             10 732 Screen_How2Play_End
7BC3 CD BD 6E    10 733 call    Input_Key_Scan              ; wait for a key pressed
7BC6 FE 62       10 734 cp      'b'                         ; is it 'b'?
7BC8 CA 9B 7A    10 735 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7BCB FE 6E       10 736 cp      'n'                         ; is it 'n'?
7BCD 20 F4       10 737 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7BCF 21 9D 61    10 739 ld      hl, GAME_LEVEL              ; HL points to game level address
7BD2 35          10 740 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7BD3 C3 6C 79    10 741 jp      Screen_Menu                 ; return to main menu
7BD6             10 743 ; ----------------------------------------------------------------------------------------------------------------------
7BD6             10 744 ; Show credits
7BD6             10 745 ; ----------------------------------------------------------------------------------------------------------------------
7BD6             10 746 Screen_Menu_Credits
7BD6 DD 21 84 59 10 747 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7BDA 01 47 19    10 748 ld      bc, 25*256+WHITE_FLASH0     ; B = string length (loop counter), C = color attributes
7BDD CD 65 78    10 749 call    Screen_Apply_Color_Loop     ; apply color to string area
7BE0 11 A3 67    10 750 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7BE3 21 84 48    10 751 ld      hl, $4884                   ; HL points to string screen address
7BE6 CD 51 6F    10 752 call    Print_String                ; print "Design..."
7BE9 DD 2E C4    10 753 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7BEC 06 19       10 754 ld      b, 25                       ; string length (loop counter)
7BEE CD 65 78    10 755 call    Screen_Apply_Color_Loop     ; apply color to string area
7BF1 13          10 756 inc     de                          ; move DE to to "Code..." string address
7BF2 2E C4       10 757 ld      l, $C4                      ; HL points to string screen address
7BF4 CD 51 6F    10 758 call    Print_String                ; print "Code..."
7BF7 DD 2E E4    10 759 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7BFA 06 18       10 760 ld      b, 24                       ; string length (loop counter)
7BFC CD 65 78    10 761 call    Screen_Apply_Color_Loop     ; apply color to string area
7BFF 13          10 762 inc     de                          ; move DE to "Einar Saukas" string address
7C00 2E E4       10 763 ld      l, $E4                      ; HL points to string screen address
7C02 CD 51 6F    10 764 call    Print_String                ; print "Einar Saukas"
7C05 DD 21 24 5A 10 765 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C09 06 18       10 766 ld      b, 24                       ; string length (loop counter)
7C0B CD 65 78    10 767 call    Screen_Apply_Color_Loop     ; apply color to string area
7C0E 13          10 768 inc     de                          ; move DE to "Font..." string address
7C0F 21 24 50    10 769 ld      hl, $5024                   ; HL points to string screen address
7C12 CD 51 6F    10 770 call    Print_String                ; print "Font..."
7C15 DD 2E 64    10 771 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C18 06 18       10 772 ld      b, 24                       ; string length (loop counter)
7C1A CD 65 78    10 773 call    Screen_Apply_Color_Loop     ; apply color to string area
7C1D 13          10 774 inc     de                          ; move DE to "Graphics..." string address
7C1E 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7C20 CD 51 6F    10 776 call    Print_String                ; print "Graphics..."
7C23 DD 2E 84    10 777 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C26 06 19       10 778 ld      b, 25                       ; string length (loop counter)
7C28 CD 65 78    10 779 call    Screen_Apply_Color_Loop     ; apply color to string area
7C2B 13          10 780 inc     de                          ; move DE to "Antonio Luque" string address
7C2C 2E 84       10 781 ld      l, $84                      ; HL points to string screen address
7C2E CD 51 6F    10 782 call    Print_String                ; print "Antonio Luque"
7C31 DD 2E E9    10 783 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C34 01 38 0D    10 784 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7C37 CD 65 78    10 785 call    Screen_Apply_Color_Loop     ; apply color to string area
7C3A 13          10 786 inc     de                          ; move DE to "Press any key" string address
7C3B 2E E9       10 787 ld      l, $E9                      ; HL points to string screen address
7C3D CD 51 6F    10 788 call    Print_String                ; print "Press any key"
7C40 CD BD 6E    10 789 call    Input_Key_Scan              ; wait for a key pressed
7C43 C3 72 79    10 790 jp      Screen_Menu_Strings         ; return to main menu
7C46             10 792 ; ----------------------------------------------------------------------------------------------------------------------
7C46             10 793 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C46             10 794 ;
7C46             10 795 ; Input:    -
7C46             10 796 ;
7C46             10 797 ; Output:   -
7C46             10 798 ;
7C46             10 799 ; Uses:     TOKEN_COLOR (current token color)
7C46             10 800 ;
7C46             10 801 ; Destroys: A, BC, DE, HL, IX, IY
7C46             10 802 ; ----------------------------------------------------------------------------------------------------------------------
7C46             10 803 Screen_Hexagons:
7C46 FD 21 EA 66 10 804 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C4A 3E 07       10 805 ld      a, WHITE                    ; set hexagon color
7C4C 32 9E 61    10 806 ld      (TOKEN_COLOR), a            ; save hexagon color
7C4F 11 7E 65    10 807 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C52 06 1C       10 808 ld      b, 28                       ; number of empty hexagons (loop counter)
7C54 CD 6B 7C    10 809 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C57 3E 05       10 810 ld      a, CYAN_COLOR               ; set token color
7C59 32 9E 61    10 811 ld      (TOKEN_COLOR), a            ; save hexagon color
7C5C 11 3E 66    10 812 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C5F 06 06       10 813 ld      b, 6                        ; number of cyan tokens (loop counter)
7C61 CD 6B 7C    10 814 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C64 3E 02       10 815 ld      a, RED_COLOR                ; set token color
7C66 32 9E 61    10 816 ld      (TOKEN_COLOR), a            ; save hexagon color
7C69 06 06       10 817 ld      b, 6                        ; number of red tokens (loop counter)
7C6B             10 818 Screen_Hexagons_Loop:
7C6B FD 6E 00    10 819 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C6E FD 66 01    10 820 ld      h, (iy+1)
7C71 CD 07 6E    10 821 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C74 D5          10 822 push    de                          ; store hexagon/token sprite address
7C75 CD D9 6D    10 823 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C78 D1          10 824 pop     de                          ; restore hexagon/token sprite address
7C79 FD 23       10 825 inc     iy                          ; move IY to next hexagon/token screen address
7C7B FD 23       10 826 inc     iy
7C7D 10 EC       10 827 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C7F C9          10 828 ret
7C80             10 830 ; ----------------------------------------------------------------------------------------------------------------------
7C80             10 831 ; Screen_Clear_Text: clean a text attributes area
7C80             10 832 ;
7C80             10 833 ; Input:    HL = text area attributes address
7C80             10 834 ;
7C80             10 835 ; Output:   -
7C80             10 836 ;
7C80             10 837 ; Destroys: BC, DE, HL
7C80             10 838 ; ----------------------------------------------------------------------------------------------------------------------
7C80             10 839 Screen_Clear_Text:
7C80 01 30 00    10 840 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7C83             10 841 Screen_ClearText_Loop
7C83 11 18 00    10 842 ld      de, 24                      ; displacement for each text row
7C86 19          10 843 add     hl, de                      ; add displacement to text area attributes address
7C87 54          10 844 ld      d, h                        ; DE points to text area attributes address
7C88 5D          10 845 ld      e, l
7C89 36 00       10 846 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7C8B 13          10 847 inc     de                          ; move DE to next byte attribute address
7C8C ED A0       10 848 ldi                                 ; set attributes color for the rest of bytes of current row
7C8E ED A0       10 849 ldi
7C90 ED A0       10 850 ldi
7C92 ED A0       10 851 ldi
7C94 ED A0       10 852 ldi
7C96 ED A0       10 853 ldi
7C98 ED A0       10 854 ldi
7C9A ED A0       10 855 ldi
7C9C EA 83 7C    10 856 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7C9F C9          10 857 ret

; File #0: C:\Users\Antonio Luque\source\Repos\Hex\Z80CodeFiles\Hex2.z80asm

7CA0             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CA0             0 20 ; Credits and acknowledgements:
7CA0             0 21 ;
7CA0             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CA0             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CA0             0 24 ;   "King+" font and TOKEN graphics.
7CA0             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CA0             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CA0             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CA0             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CA0             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CA0             0 30 ;
7CA0             0 31 ; - Special thanks to my wife Sonia.
7CA0             0 32 ; ----------------------------------------------------------------------------------------------------------------------
