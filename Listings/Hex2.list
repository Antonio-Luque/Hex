
; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   ORG     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         DEFS    256
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 DEFB      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 DEFB                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 DEFB    0                           ; speccy board potential
6198 00          1 51 DEFB    0                           ; speccy attack mobility
6199 00          1 52 GAME_LEVEL              DEFB    0                           ; current game level (1-4)
619A 00          1 53 AI_DEPTH                DEFB    0                           ; recursion depth level (1-4)
619B 00          1 54 AI_PLAYER               DEFB    0                           ; speccy side (FRIEND or ENEMY)
619C 00          1 55 LEVEL_COLOR             DEFB    0                           ; current level color for frame border
619D 00          1 56 MOVE_NUMBER             DEFB    0                           ; current move number
619E 00          1 57 TOKEN_COLOR             DEFB    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            DEFB    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 DEFB    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 DEFB    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 DEFB    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 DEFB    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 DEFB    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 DEFB    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 DEFB    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 DEFM    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;ORG     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 65 73       1 85 DEFW    PathFinder_CYAN_Edge_0
6202 85 73       1 86 DEFW    PathFinder_CYAN_Edge_1
6204 A0 73       1 87 DEFW    PathFinder_CYAN_Edge_2
6206 BE 73       1 88 DEFW    PathFinder_CYAN_Edge_3
6208 DD 73       1 89 DEFW    PathFinder_CYAN_Edge_4
620A FB 73       1 90 DEFW    PathFinder_CYAN_Edge_5
620C 16 74       1 91 DEFW    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E 00          1 96 THREE_ROW               DEFB    0                           ; three-in-a-row counter
620F 0F 0E 0C 0B 1 97 ROW_COLOR_MAP           DEFB    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6213 0D 0A       1 97 
6215 00 2D 30 00 1 98 STR_MOVE                DEFB    0, '-', '0', 0, '\0'        ; formatted move string
6219 00          1 98 
621A 53 70 65 63 1 99 STR_SPECCY              DEFM    "Speccy\0"
621E 63 79 00    1 99 
6221 50 6C 61 79 1 100 STR_PLAYER              DEFM    "Player\0"
6225 65 72 00    1 100 
6228 4C 65 76 65 1 101 STR_LEVELTEXT           DEFM    "Level\0"
622C 6C 00       1 101 
622E 46 49 4C 4C 1 102 STR_FILLED              DEFM    "FILLED\0"
6232 45 44 00    1 102 
6235 57 41 49 54 1 103 STR_WAIT                DEFM    "WAIT\0"
6239 00          1 103 
623A 20 57 49 4E 1 104 STR_WINNER              DEFM    " WINS \0"
623E 53 20 00    1 104 
6241 20 20 20 20 1 105 STR_EMPTY4              DEFM    "    \0"
6245 00          1 105 
6246 20 20 20 20 1 106 STR_EMPTY6              DEFM    "      \0"
624A 20 20 00    1 106 
624D             1 108 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 109 ; Conversion table: from position to XY board indexes
624D             1 110 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 111 BOARD_COORDINATES:
624D 00 00 00 00 1 112 DEFB    $00, $00, $00, $00, $00, $00, $00, $00
6251 00 00 00 00 1 112 
6255 00 09 0A 0B 1 113 DEFB    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
6259 0C 0D 0E 0F 1 113 
625D 00 12 13 14 1 114 DEFB    $00, $12, $13, $14, $15, $16, $17, $18
6261 15 16 17 18 1 114 
6265 00 1B 1C 1D 1 115 DEFB    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
6269 1E 1F 20 21 1 115 
626D 00 24 25 26 1 116 DEFB    $00, $24, $25, $26, $27, $28, $29, $2A
6271 27 28 29 2A 1 116 
6275 00 2D 2E 2F 1 117 DEFB    $00, $2D, $2E, $2F, $30, $31, $32, $33
6279 30 31 32 33 1 117 
627D 00 36 37 38 1 118 DEFB    $00, $36, $37, $38, $39, $3A, $3B, $3C
6281 39 3A 3B 3C 1 118 
6285 00 3F 40 41 1 119 DEFB    $00, $3F, $40, $41, $42, $43, $44, $45
6289 42 43 44 45 1 119 
628D             1 121 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 122 ; Graphics map indexes for the frame tiles
628D             1 123 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 124 FRAME_MAP:
628D 00 01 01 01 1 125 DEFB      0,   1,   1,   1,   1,   1,   2,   3
6291 01 01 02 03 1 125 
6295 04 FF FF FF 1 126 DEFB      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
6299 FF FF FF FF 1 126 
629D 05 06 07 01 1 127 DEFB      5,   6,   7,   1,   1,   1,   1,   1
62A1 01 01 01 01 1 127 
62A5 01 01 01 01 1 128 DEFB      1,   1,   1,   1,   1,   1,   1,   8
62A9 01 01 01 08 1 128 
62AD 09 01 01 01 1 129 DEFB      9,   1,   1,   1,   1,   1,   1,   1
62B1 01 01 01 01 1 129 
62B5 01 01 01 01 1 130 DEFB      1,   1,   1,   1,   1,   1,   1,   1
62B9 01 01 01 01 1 130 
62BD 0A 06 0D 0D 1 131 DEFB     10,   6,  13,  13,  13,   3,  11,   1
62C1 0D 03 0B 01 1 131 
62C5 01 01 01 01 1 132 DEFB      1,   1,   1,   1,   1,   1,   1,  12
62C9 01 01 01 0C 1 132 
62CD             1 134 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 135 ; Definition of a small "Opening Book" for speccy first move
62CD             1 136 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 137 OPENINGS:
62CD 0F 14 16 17 1 138 DEFB    $0F, $14, $16, $17, $18, $1C, $1D
62D1 18 1C 1D    1 138 
62D4 1E 1F 20 24 1 139 DEFB    $1E, $1F, $20, $24, $25, $26, $27
62D8 25 26 27    1 139 
62DB 28 29 2A 2E 1 140 DEFB    $28, $29, $2A, $2E, $2F, $30, $31
62DF 2F 30 31    1 140 
62E2 32 36 37 38 1 141 DEFB    $32, $36, $37, $38, $3A, $3F
62E6 3A 3F       1 141 
62E8             1 143 ; ----------------------------------------------------------------------------------------------------------------------
62E8             1 144 ; Timer variables
62E8             1 145 ; ----------------------------------------------------------------------------------------------------------------------
62E8 00          1 146 TIMER_FLAG              DEFB    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62E9             1 147 ; for each timer:
62E9             1 148 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62E9             1 149 ;   2nd byte = seconds counter
62E9             1 150 ;   3th byte = minutes counter
62E9 32 00 00    1 151 CYAN_TIMER              DEFB    50, 0, 0
62EC 32 00 00    1 152 RED_TIMER               DEFB    50, 0, 0
62EF             1 154 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 155 ; Screen addresses look-up array for board numbers
62EF             1 156 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 157 NUMBER_SCREEN:
62EF A5 43 E6 43 1 158 DEFW    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F3 27 4B 68 4B 1 158 
62F7 A9 4B EA 4B 1 158 
62FB 2B 53       1 158 
62FD FF FF FF    1 160 FILLER_1                DEFB    $FF, $FF, $FF               ; filler to align next block (not used)
6300             1 162 ;ORG     $6300
6300             1 163 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 164 ; Circular queue
6300             1 165 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 166 RED_QUEUE_AREA          DEFS    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 166 
6308 00 00 00 00 1 166 
630C 00 00 00 00 1 166 
6310 00 00 00 00 1 166 
6314 00 00 00 00 1 166 
6318 00 00 00 00 1 166 
631C 00 00 00 00 1 166 
6320 00 00 00 00 1 166 
6324 00 00 00 00 1 166 
6328 00 00 00 00 1 166 
632C 00 00 00 00 1 166 
6330 00 00 00 00 1 166 
6334 00 00 00 00 1 166 
6338 00 00 00 00 1 166 
633C 00 00 00 00 1 166 
6340 00 00 00 00 1 166 
6344 00 00 00 00 1 166 
6348 00 00 00 00 1 166 
634C 00 00 00 00 1 166 
6350 00 00 00 00 1 166 
6354 00 00 00 00 1 166 
6358 00 00 00 00 1 166 
635C 00 00 00 00 1 166 
6360 00 00 00 00 1 166 
6364 00 00 00 00 1 166 
6368 00 00 00 00 1 166 
636C 00 00 00 00 1 166 
6370 00 00 00 00 1 166 
6374 00 00 00 00 1 166 
6378 00 00 00 00 1 166 
637C 00 00 00 00 1 166 
6380 00 00 00 00 1 166 
6384 00 00 00 00 1 166 
6388 00 00 00 00 1 166 
638C 00 00 00 00 1 166 
6390 00 00 00 00 1 166 
6394 00 00 00 00 1 166 
6398 00 00 00 00 1 166 
639C 00 00 00 00 1 166 
63A0 00 00 00 00 1 166 
63A4 00 00 00 00 1 166 
63A8 00 00 00 00 1 166 
63AC 00 00 00 00 1 166 
63B0 00 00 00 00 1 166 
63B4 00 00 00 00 1 166 
63B8 00 00 00 00 1 166 
63BC 00 00 00 00 1 166 
63C0 00 00 00 00 1 166 
63C4 00 00 00 00 1 166 
63C8 00 00 00 00 1 166 
63CC 00 00 00 00 1 166 
63D0 00 00 00 00 1 166 
63D4 00 00 00 00 1 166 
63D8 00 00 00 00 1 166 
63DC 00 00 00 00 1 166 
63E0 00 00 00 00 1 166 
63E4 00 00 00 00 1 166 
63E8 00 00 00 00 1 166 
63EC 00 00 00 00 1 166 
63F0 00 00 00 00 1 166 
63F4 00 00 00 00 1 166 
63F8 00 00 00 00 1 166 
63FC 00 00 00 00 1 166 
6400             1 168 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 169 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 170 ; 
6400             1 171 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 172 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 173 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 174 ; 
6400             1 175 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 176 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 177 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 178 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 179 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 180 DEFB      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 180 
6408 7F 00 00 00 1 181 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 181 
6410 80          1 181 
6411 7F 00 00 00 1 182 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 182 
6419 81          1 182 
641A 7F 00 00 00 1 183 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 183 
6422 82          1 183 
6423 7F 00 00 00 1 184 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 184 
642B 83          1 184 
642C 7F 00 00 00 1 185 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 185 
6434 84          1 185 
6435 7F 00 00 00 1 186 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 186 
643D 85          1 186 
643E 7F 00 00 00 1 187 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 187 
6446 86          1 187 
6447 7F 7F 7F 7F 1 188 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 188 
644F 7F          1 188 
6450             1 189 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 190 DEFB    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 190 
6458 7F          1 190 
6459 81 00 00 00 1 191 DEFB       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 191 
6461 7F          1 191 
6462 82 00 00 00 1 192 DEFB          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 192 
646A 7F          1 192 
646B 83 00 00 00 1 193 DEFB             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 193 
6473 7F          1 193 
6474 84 00 00 00 1 194 DEFB                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 194 
647C 7F          1 194 
647D 85 00 00 00 1 195 DEFB                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 195 
6485 7F          1 195 
6486 86 00 00 00 1 196 DEFB                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 196 
648E 7F          1 196 
648F 7F 7F 7F 7F 1 197 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 197 
6497             1 199 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 200 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 201 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 202 TIMER_DIGITS:
6497 00 0F 0B 0B 1 203 DEFB    $00, $0F, $0B, $0B, $0B, $0F, $00, $00
649B 0B 0F 00 00 1 203 
649F 00 06 0E 06 1 204 DEFB    $00, $06, $0E, $06, $06, $06, $00, $00
64A3 06 06 00 00 1 204 
64A7 00 0F 03 0F 1 205 DEFB    $00, $0F, $03, $0F, $08, $0F, $00, $00
64AB 08 0F 00 00 1 205 
64AF 00 0F 03 07 1 206 DEFB    $00, $0F, $03, $07, $03, $0F, $00, $00
64B3 03 0F 00 00 1 206 
64B7 00 0B 0B 0F 1 207 DEFB    $00, $0B, $0B, $0F, $03, $03, $00, $00
64BB 03 03 00 00 1 207 
64BF 00 0F 08 0F 1 208 DEFB    $00, $0F, $08, $0F, $03, $0F, $00, $00
64C3 03 0F 00 00 1 208 
64C7 00 0F 0C 0F 1 209 DEFB    $00, $0F, $0C, $0F, $0D, $0F, $00, $00
64CB 0D 0F 00 00 1 209 
64CF 00 0F 03 03 1 210 DEFB    $00, $0F, $03, $03, $03, $03, $00, $00
64D3 03 03 00 00 1 210 
64D7 00 0F 0B 0F 1 211 DEFB    $00, $0F, $0B, $0F, $0B, $0F, $00, $00
64DB 0B 0F 00 00 1 211 
64DF 00 0F 0B 0F 1 212 DEFB    $00, $0F, $0B, $0F, $03, $0F, $00, $00
64E3 03 0F 00 00 1 212 
64E7             1 214 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 215 ; Tone parameters for sound effects
64E7             1 216 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 217 ; for each tone (from left to right):
64E7             1 218 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 219 ;   - length of a frame (1..65536)
64E7             1 220 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 221 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 222 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 223 TOKEN_FX                DEFW       1, 1000, 1400,   0
64EB 78 05 00 00 1 223 
64EF 05 00 88 13 1 224 WINNER_FX               DEFW       5, 5000,  200, 100
64F3 C8 00 64 00 1 224 
64F7 E8 03 0A 00 1 225 FILLED_FX               DEFW    1000,   10,  100,   0
64FB 64 00 00 00 1 225 
64FF FF          1 227 FILLER_2                DEFB    $FF                         ; filler to align next block (not used)
6500             1 229 ;ORG     $6500
6500             1 230 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 231 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 232 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 233 RED_VECTOR_TABLE:
6500 4B 72       1 234 DEFW    PathFinder_RED_Edge_0
6502 79 72       1 235 DEFW    PathFinder_RED_Edge_1
6504 9F 72       1 236 DEFW    PathFinder_RED_Edge_2
6506 C5 72       1 237 DEFW    PathFinder_RED_Edge_3
6508 EB 72       1 238 DEFW    PathFinder_RED_Edge_4
650A 11 73       1 239 DEFW    PathFinder_RED_Edge_5
650C 37 73       1 240 DEFW    PathFinder_RED_Edge_6
650E             1 242 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 243 ; Graphics for the screen frame
650E             1 244 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 245 FRAME_TILES:
650E 00 00 1F 3F 1 246 DEFB    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C
6512 3F 3F 3C 3C 1 246 
6516 00 00 FF FF 1 247 DEFB    $00, $00, $FF, $FF, $FF, $FF, $00, $00
651A FF FF 00 00 1 247 
651E 00 00 FF FE 1 248 DEFB    $00, $00, $FF, $FE, $FE, $FF, $00, $00
6522 FE FF 00 00 1 248 
6526 03 07 0F 0F 1 249 DEFB    $03, $07, $0F, $0F, $0F, $0F, $07, $03
652A 0F 0F 07 03 1 249 
652E FF FE FC FC 1 250 DEFB    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF
6532 FC FC FE FF 1 250 
6536 FF 7F 3F 3F 1 251 DEFB    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF
653A 3F 3F 7F FF 1 251 
653E C0 E0 F0 F0 1 252 DEFB    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0
6542 F0 F0 E0 C0 1 252 
6546 00 00 FF 7F 1 253 DEFB    $00, $00, $FF, $7F, $7F, $FF, $00, $00
654A 7F FF 00 00 1 253 
654E 00 00 F8 FC 1 254 DEFB    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C
6552 FC FC 3C 3C 1 254 
6556 3C 3C 3F 3F 1 255 DEFB    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00
655A 3F 1F 00 00 1 255 
655E 00 00 FE FF 1 256 DEFB    $00, $00, $FE, $FF, $FF, $FE, $00, $00
6562 FF FE 00 00 1 256 
6566 00 00 7F FF 1 257 DEFB    $00, $00, $7F, $FF, $FF, $7F, $00, $00
656A FF 7F 00 00 1 257 
656E 3C 3C FC FC 1 258 DEFB    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00
6572 FC F8 00 00 1 258 
6576 00 00 38 7C 1 259 DEFB    $00, $00, $38, $7C, $7C, $38, $00, $00
657A 7C 38 00 00 1 259 
657E             1 261 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 262 ; Hexagon sprites
657E             1 263 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 264 HEXAGON_EMPTY:
657E 07 E0 18 18 1 265 DEFB    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 265 
6586 48 02 48 02 1 266 DEFB    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 266 
658E 40 02 40 02 1 267 DEFB    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 267 
6596 20 24 20 04 1 268 DEFB    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 268 
659E             1 269 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 270 DEFB    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 270 
65A6 24 04 24 04 1 271 DEFB    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 271 
65AE 20 04 20 04 1 272 DEFB    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 272 
65B6 10 48 10 08 1 273 DEFB    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 273 
65BE 01 80 02 40 1 275 DEFB    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 275 
65C6 0A 10 0A 10 1 276 DEFB    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 276 
65CE 08 10 08 10 1 277 DEFB    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 277 
65D6 08 90 04 20 1 278 DEFB    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 278 
65DE 00 80 00 80 1 280 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 280 
65E6 00 80 00 80 1 281 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 281 
65EE 00 80 00 80 1 282 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 282 
65F6 00 80 00 80 1 283 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 283 
65FE 01 80 02 40 1 285 DEFB    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 285 
6606 0B D0 0B D0 1 286 DEFB    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 286 
660E 0B D0 0B D0 1 287 DEFB    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 287 
6616 0B D0 05 A0 1 288 DEFB    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 288 
661E 03 C0 0C 30 1 290 DEFB    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 290 
6626 2F F4 2F F4 1 291 DEFB    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 291 
662E 2F F4 2F F4 1 292 DEFB    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 292 
6636 17 E8 13 C8 1 293 DEFB    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 293 
663E             1 294 HEXAGON_TOKEN:
663E 07 E0 18 18 1 295 DEFB    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 295 
6646 5F FA 5F FA 1 296 DEFB    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 296 
664E 5F FA 5F FA 1 297 DEFB    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 297 
6656 2F F4 27 E4 1 298 DEFB    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 298 
665E             1 300 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 301 ; Board letter sprites
665E             1 302 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 303 LETTER_SPRITES:
665E 3C 7E FF C3 1 304 DEFB    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C
6662 F3 C3 D3 C3 1 304 
6666 7E 3C       1 304 
6668 3C 7E CF CF 1 305 DEFB    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C
666C C3 CB CB C3 1 305 
6670 7E 3C       1 305 
6672 3C 7E FF E3 1 306 DEFB    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C
6676 CF CF CF E3 1 306 
667A 7E 3C       1 306 
667C 3C 7E F3 F3 1 307 DEFB    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C
6680 C3 D3 D3 C3 1 307 
6684 7E 3C       1 307 
6686 3C 7E FF E3 1 308 DEFB    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C
668A CB C3 CF E3 1 308 
668E 7E 3C       1 308 
6690 3C 7E E3 CF 1 309 DEFB    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C
6694 C7 CF CF CF 1 309 
6698 7E 3C       1 309 
669A 3C 7E FF E3 1 310 DEFB    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C
669E D3 D3 E3 F3 1 310 
66A2 46 3C       1 310 
66A4             1 312 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 313 ; Board number sprites
66A4             1 314 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 315 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 316 DEFB    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C
66A8 E7 E7 E7 E7 1 316 
66AC 7E 3C       1 316 
66AE 3C 7E E7 D3 1 317 DEFB    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C
66B2 F3 E7 CF C3 1 317 
66B6 7E 3C       1 317 
66B8 3C 7E C7 F3 1 318 DEFB    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C
66BC E3 F3 F3 C7 1 318 
66C0 7E 3C       1 318 
66C2 3C 7E D3 D3 1 319 DEFB    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C
66C6 C3 F3 F3 F3 1 319 
66CA 7E 3C       1 319 
66CC 3C 7E C3 CF 1 320 DEFB    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C
66D0 C7 F3 F3 C7 1 320 
66D4 7E 3C       1 320 
66D6 3C 7E E3 CF 1 321 DEFB    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C
66DA C3 CB CB C3 1 321 
66DE 7E 3C       1 321 
66E0 3C 7E C3 F3 1 322 DEFB    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C
66E4 F3 E7 E7 E7 1 322 
66E8 7E 3C       1 322 
66EA             1 324 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 325 ; Screen addresses for menu hexagons
66EA             1 326 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 327 MENU_HEXAGONS:
66EA 01 40 05 40 1 328 DEFW    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 328 
66F2 0F 40 13 40 1 328 
66F6 1A 40       1 328 
66F8 45 40 48 40 1 329 DEFW    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 329 
6700 81 40 83 40 1 329 
6704 85 40       1 329 
6706 88 40 8A 40 1 330 DEFW    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 330 
670E C1 40 D0 40 1 330 
6712 D9 40       1 330 
6714 05 48 08 48 1 331 DEFW    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 331 
671C 19 48 1B 48 1 331 
6720 1D 48       1 331 
6722 0A 40 59 40 1 332 DEFW    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 332 
672A D2 40 0C 48 1 332 
672E 1C 40       1 332 
6730 41 40 50 40 1 333 DEFW    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 333 
6738 0F 48       1 333 
673A             1 334 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 335 DEFW    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 335 
6742 EF 40 F1 40 1 335 
6746 B2 40       1 335 
6748 E9 40 6F 48 1 336 DEFW    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 336 
6750 AA 48 AC 40 1 336 
6754 EF 48       1 336 
6756 2A 48 6D 48 1 337 DEFW    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 337 
675E             1 338 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 339 DEFW    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 339 
6766 AE 48 EF 48 1 339 
676A 2E 50       1 339 
676C AC 48 B4 48 1 340 DEFW    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 340 
6774 2E 48 F1 40 1 340 
6778 F3 40       1 340 
677A 73 48 B2 48 1 341 DEFW    $4873, $48B2, $5030
677E 30 50       1 341 
6780             1 343 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 344 ; Strings
6780             1 345 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 346 STR_OPTIONS:
6780 53 74 61 72 1 347 DEFM    "Start new game\0"
6784 74 20 6E 65 1 347 
6788 77 20 67 61 1 347 
678C 6D 65 00    1 347 
678F 48 6F 77 20 1 348 DEFM    "How to play\0"
6793 74 6F 20 70 1 348 
6797 6C 61 79 00 1 348 
679B 43 72 65 64 1 349 DEFM    "Credits\0"
679F 69 74 73 00 1 349 
67A3 44 65 73 69 1 350 STR_DESIGN              DEFM    "Design:     \0"
67A7 67 6E 3A 20 1 350 
67AB 20 20 20 20 1 350 
67AF 00          1 350 
67B0 43 6F 64 65 1 351 STR_CODE                DEFM    "Code:       \0"
67B4 3A 20 20 20 1 351 
67B8 20 20 20 20 1 351 
67BC 00          1 351 
67BD 46 6F 6E 74 1 352 STR_FONT                DEFM    "Font:       \0"
67C1 3A 20 20 20 1 352 
67C5 20 20 20 20 1 352 
67C9 00          1 352 
67CA 47 72 61 70 1 353 STR_GRAPHICS            DEFM    "Graphics:   \0"
67CE 68 69 63 73 1 353 
67D2 3A 20 20 20 1 353 
67D6 00          1 353 
67D7 45 69 6E 61 1 354 STR_EINAR               DEFM    "Einar Saukas\0"
67DB 72 20 53 61 1 354 
67DF 75 6B 61 73 1 354 
67E3 00          1 354 
67E4 20 20 20 20 1 355 STR_EMPTY12             DEFM    "            \0"
67E8 20 20 20 20 1 355 
67EC 20 20 20 20 1 355 
67F0 00          1 355 
67F1 41 6E 74 6F 1 356 STR_ANTONIO             DEFM    "Antonio Luque\0"
67F5 6E 69 6F 20 1 356 
67F9 4C 75 71 75 1 356 
67FD 65 00       1 356 
67FF 50 72 65 73 1 357 STR_PRESSKEY            DEFM    "Press any key\0"
6803 73 20 61 6E 1 357 
6807 79 20 6B 65 1 357 
680B 79 00       1 357 
680D             1 358 STR_BUTTONS:
680D 4E 65 78 74 1 359 DEFM    "Next\0"
6811 00          1 359 
6812 42 61 63 6B 1 360 DEFM    "Back\0"
6816 00          1 360 
6817 52 45 44 00 1 361 STR_RED                 DEFM    "RED\0"
681B 43 59 41 4E 1 362 STR_CYAN                DEFM    "CYAN\0"
681F 00          1 362 
6820 43 6F 6E 6E 1 363 STR_HELP1               DEFM    "Connect\0"
6824 65 63 74 00 1 363 
6828 6C 65 66 74 1 364 STR_HELP2_RED           DEFM    "left and\0"
682C 20 61 6E 64 1 364 
6830 00          1 364 
6831 75 70 20 61 1 365 STR_HELP2_CYAN          DEFM    "up and\0"
6835 6E 64 00    1 365 
6838 72 69 67 68 1 366 STR_HELP3_RED           DEFM    "right\0"
683C 74 00       1 366 
683E 64 6F 77 6E 1 367 STR_HELP3_CYAN          DEFM    "down\0"
6842 00          1 367 
6843 62 6F 72 64 1 368 STR_HELP4               DEFM    "borders\0"
6847 65 72 73 00 1 368 
684B 74 6F 20 77 1 369 STR_HELP5               DEFM    "to win\0"
684F 69 6E 00    1 369 
6852             1 370 STR_HELP:
6852 57 69 6E 20 1 371 DEFM    "Win three\0"
6856 74 68 72 65 1 371 
685A 65 00       1 371 
685C 74 69 6D 65 1 372 DEFM    "times in\0"
6860 73 20 69 6E 1 372 
6864 00          1 372 
6865 61 20 72 6F 1 373 DEFM    "a row to\0"
6869 77 20 74 6F 1 373 
686D 00          1 373 
686E 6C 65 76 65 1 374 DEFM    "level up\0"
6872 6C 20 75 70 1 374 
6876 00          1 374 
6877 20 43 4F 4E 1 375 STR_CONGRATS            DEFM    " CONGRATULATIONS \0"
687B 47 52 41 54 1 375 
687F 55 4C 41 54 1 375 
6883 49 4F 4E 53 1 375 
6887 20 00       1 375 
6889             1 376 STR_LAST_LEVEL:
6889 57 65 6C 6C 1 377 DEFM    "Well done! Last level passed\0"
688D 20 64 6F 6E 1 377 
6891 65 21 20 4C 1 377 
6895 61 73 74 20 1 377 
6899 6C 65 76 65 1 377 
689D 6C 20 70 61 1 377 
68A1 73 73 65 64 1 377 
68A5 00          1 377 
68A6 43 68 6F 6F 1 378 DEFM    "Choose level to restart, 1-4\0"
68AA 73 65 20 6C 1 378 
68AE 65 76 65 6C 1 378 
68B2 20 74 6F 20 1 378 
68B6 72 65 73 74 1 378 
68BA 61 72 74 2C 1 378 
68BE 20 31 2D 34 1 378 
68C2 00          1 378 
68C3             1 380 ; ----------------------------------------------------------------------------------------------------------------------
68C3             1 381 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
68C3             1 382 ; this font was designed by Einar Saukas for Hex game
68C3             1 383 ; ----------------------------------------------------------------------------------------------------------------------
68C3             1 384 FONT:
68C3 00 00 00 00 1 385 INCLUDEBIN "King+.bin"
68C7 00 00 00 00 1 385 
68CB 00 18 18 18 1 385 
68CF 00 18 18 00 1 385 
68D3 00 24 24 00 1 385 
68D7 00 00 00 00 1 385 
68DB 00 24 7E 24 1 385 
68DF 24 7E 24 00 1 385 
68E3 00 08 3E 28 1 385 
68E7 3E 0A 3E 08 1 385 
68EB 00 62 64 08 1 385 
68EF 10 26 46 00 1 385 
68F3 00 10 28 10 1 385 
68F7 2A 44 3A 00 1 385 
68FB 00 18 30 00 1 385 
68FF 00 00 00 00 1 385 
6903 06 0C 08 08 1 385 
6907 08 0C 06 00 1 385 
690B 60 30 10 10 1 385 
690F 10 30 60 00 1 385 
6913 00 00 14 08 1 385 
6917 3E 08 14 00 1 385 
691B 00 00 08 08 1 385 
691F 3E 08 08 00 1 385 
6923 00 00 00 00 1 385 
6927 00 0C 18 30 1 385 
692B 00 00 00 7E 1 385 
692F 7E 00 00 00 1 385 
6933 00 00 00 00 1 385 
6937 30 70 70 00 1 385 
693B 02 06 0C 18 1 385 
693F 30 60 40 00 1 385 
6943 00 7E 62 62 1 385 
6947 62 62 7E 00 1 385 
694B 00 18 38 18 1 385 
694F 18 18 3C 00 1 385 
6953 00 38 4C 4C 1 385 
6957 18 30 7C 00 1 385 
695B 00 3C 62 0C 1 385 
695F 06 66 3C 00 1 385 
6963 00 30 30 30 1 385 
6967 30 34 3E 04 1 385 
696B 00 7E 60 7E 1 385 
696F 06 66 3C 00 1 385 
6973 00 30 60 7C 1 385 
6977 66 66 3C 00 1 385 
697B 00 7E 46 0C 1 385 
697F 18 30 60 00 1 385 
6983 00 3C 66 3C 1 385 
6987 66 66 3C 00 1 385 
698B 00 3C 66 66 1 385 
698F 3E 06 3C 00 1 385 
6993 00 00 08 18 1 385 
6997 00 08 18 00 1 385 
699B 00 00 04 0C 1 385 
699F 00 0C 18 30 1 385 
69A3 00 00 04 08 1 385 
69A7 10 08 04 00 1 385 
69AB 00 00 00 3E 1 385 
69AF 00 3E 00 00 1 385 
69B3 00 00 10 08 1 385 
69B7 04 08 10 00 1 385 
69BB 00 3C 42 04 1 385 
69BF 08 00 08 00 1 385 
69C3 00 3C 4A 56 1 385 
69C7 5E 40 3C 00 1 385 
69CB 00 7E 46 46 1 385 
69CF 7E 46 46 00 1 385 
69D3 00 7C 62 7C 1 385 
69D7 62 62 7C 00 1 385 
69DB 00 7E 66 60 1 385 
69DF 60 66 7E 00 1 385 
69E3 00 7C 46 46 1 385 
69E7 46 46 7C 00 1 385 
69EB 00 7E 60 7C 1 385 
69EF 60 60 7E 00 1 385 
69F3 00 7E 60 7C 1 385 
69F7 60 60 60 00 1 385 
69FB 00 3E 62 60 1 385 
69FF 66 66 3E 00 1 385 
6A03 00 62 62 7E 1 385 
6A07 62 62 62 00 1 385 
6A0B 00 18 18 18 1 385 
6A0F 18 18 18 00 1 385 
6A13 00 0C 0C 0C 1 385 
6A17 0C 4C 38 00 1 385 
6A1B 00 66 64 68 1 385 
6A1F 7E 46 66 00 1 385 
6A23 00 60 60 60 1 385 
6A27 60 60 7E 00 1 385 
6A2B 00 7E 56 56 1 385 
6A2F 56 56 56 00 1 385 
6A33 00 7E 46 46 1 385 
6A37 46 46 46 00 1 385 
6A3B 00 7E 62 62 1 385 
6A3F 62 62 7E 00 1 385 
6A43 00 7E 62 62 1 385 
6A47 7E 60 60 00 1 385 
6A4B 00 7C 64 64 1 385 
6A4F 64 64 7E 00 1 385 
6A53 00 7C 62 64 1 385 
6A57 7C 46 46 00 1 385 
6A5B 00 7E 60 7E 1 385 
6A5F 06 06 7E 00 1 385 
6A63 00 7E 18 18 1 385 
6A67 18 18 18 00 1 385 
6A6B 00 62 62 62 1 385 
6A6F 62 62 7E 00 1 385 
6A73 00 62 62 62 1 385 
6A77 62 34 18 00 1 385 
6A7B 00 6A 6A 6A 1 385 
6A7F 6A 6A 7E 00 1 385 
6A83 00 62 62 34 1 385 
6A87 4E 46 46 00 1 385 
6A8B 00 62 62 7E 1 385 
6A8F 18 18 18 00 1 385 
6A93 00 7E 06 1C 1 385 
6A97 38 60 7E 00 1 385 
6A9B 00 0E 08 08 1 385 
6A9F 08 08 0E 00 1 385 
6AA3 00 00 40 20 1 385 
6AA7 10 08 04 00 1 385 
6AAB 00 70 10 10 1 385 
6AAF 10 10 70 00 1 385 
6AB3 00 08 1C 2A 1 385 
6AB7 08 08 08 08 1 385 
6ABB 00 00 00 00 1 385 
6ABF 00 00 00 FF 1 385 
6AC3 0C 12 10 38 1 385 
6AC7 10 10 3E 00 1 385 
6ACB 00 00 3C 06 1 385 
6ACF 7E 46 7E 00 1 385 
6AD3 00 60 60 7E 1 385 
6AD7 62 62 7E 00 1 385 
6ADB 00 00 7E 62 1 385 
6ADF 60 62 7E 00 1 385 
6AE3 00 06 06 7E 1 385 
6AE7 46 46 7E 00 1 385 
6AEB 00 00 7E 46 1 385 
6AEF 7E 60 7E 00 1 385 
6AF3 00 1E 30 3C 1 385 
6AF7 30 30 30 00 1 385 
6AFB 00 00 7E 46 1 385 
6AFF 46 3E 06 3E 1 385 
6B03 00 60 60 7C 1 385 
6B07 66 66 66 00 1 385 
6B0B 00 18 00 38 1 385 
6B0F 18 18 3C 00 1 385 
6B13 00 0C 00 0C 1 385 
6B17 0C 0C 4C 38 1 385 
6B1B 00 20 2C 38 1 385 
6B1F 38 2C 26 00 1 385 
6B23 00 18 18 18 1 385 
6B27 18 18 0E 00 1 385 
6B2B 00 00 6C 56 1 385 
6B2F 56 56 46 00 1 385 
6B33 00 00 7C 46 1 385 
6B37 46 46 46 00 1 385 
6B3B 00 00 3C 46 1 385 
6B3F 46 46 3C 00 1 385 
6B43 00 00 7C 66 1 385 
6B47 66 7C 60 60 1 385 
6B4B 00 00 3E 46 1 385 
6B4F 46 3E 06 06 1 385 
6B53 00 00 3C 62 1 385 
6B57 60 60 60 00 1 385 
6B5B 00 00 3C 60 1 385 
6B5F 3C 06 3C 00 1 385 
6B63 00 30 78 30 1 385 
6B67 30 30 1C 00 1 385 
6B6B 00 00 46 46 1 385 
6B6F 46 46 3C 00 1 385 
6B73 00 00 46 46 1 385 
6B77 2C 3C 18 00 1 385 
6B7B 00 00 46 56 1 385 
6B7F 56 56 2C 00 1 385 
6B83 00 00 46 2C 1 385 
6B87 18 2C 46 00 1 385 
6B8B 00 00 46 46 1 385 
6B8F 46 3E 06 3C 1 385 
6B93 00 00 7E 0C 1 385 
6B97 18 30 7E 00 1 385 
6B9B 00 0E 08 30 1 385 
6B9F 08 08 0E 00 1 385 
6BA3 00 08 08 08 1 385 
6BA7 08 2A 1C 08 1 385 
6BAB 00 70 10 0C 1 385 
6BAF 10 10 70 00 1 385 
6BB3 00 14 28 00 1 385 
6BB7 00 00 00 00 1 385 
6BBB FF 81 81 81 1 385 
6BBF 81 81 81 FF 1 385 

; File #2: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Main.z80asm

6BC3             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6BC3             2 2 ; Main.z80asm
6BC3             2 3 ; Coded by Antonio Luque
6BC3             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6BC3             2 6 CYAN_COLOR              EQU     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6BC3             2 7 RED_COLOR               EQU     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6BC3             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6BC3             2 10 ; Entry point of the program - Initialization
6BC3             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6BC3             2 12 Main                    ENT     $                           ; SpectNet IDE pragma: defines the entry code of the program
6BC3 F3          2 14 di                                  ; disable interrupts
6BC4             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6BC4 21 E2 75    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6BC7 FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6BCB FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6BCE FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6BD1 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6BD3 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6BD5 ED 5E       2 24 im      2                           ; set interrupt mode 2
6BD7             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6BD7             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6BD7             2 28 ; resultant vector address is formed as follows:
6BD7             2 29 ;
6BD7             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6BD7             2 31 ; Source: 
6BD7             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#modo-im-2-en-spectrum-16k
6BD7             2 33 ;
6BD7             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6BD7             2 35 ; memory area and it is used by some ROM routines, but none of them are called by HEX2 program.
6BD7 31 00 60    2 37 ld      sp, STACK                   ; move stack
6BDA AF          2 39 xor     a                           ; set border color (black)
6BDB D3 FE       2 40 out     ($FE), a
6BDD CD 23 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6BE0             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6BE0             2 44 ; Start new game
6BE0             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6BE0             2 46 Main_Start
6BE0 CD C0 76    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6BE3 CD CD 76    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6BE6 CD F9 76    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6BE9 CD 38 77    2 50 call    Screen_Frame                ; draw the screen frame
6BEC CD 90 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6BEF CD AF 77    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6BF2 CD F2 77    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6BF5 FB          2 55 ei                                  ; enable interrupts
6BF6             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6BF6             2 58 ; New level
6BF6             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6BF6             2 60 Main_New_Level
6BF6 3E 04       2 61 ld      a, 4                        ; maximum level
6BF8 21 99 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6BFB BE          2 63 cp      (hl)                        ; level 4 achieved?
6BFC 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6BFE CD 2C 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C01 18 DD       2 66 jr      Main_Start                  ; start a new game
6C03             2 67 Main_Increment_Level
6C03 34          2 68 inc     (hl)                        ; increment game level
6C04 06 00       2 69 ld      b, 0                        ; set game level in BC
6C06 4E          2 70 ld      c, (hl)
6C07 23          2 71 inc     hl                          ; HL points to recursion depth level
6C08 71          2 72 ld      (hl), c                     ; save recursion depth level
6C09 CD CA 78    2 73 call    Screen_Frame_Color          ; set up frame color depending on current level
6C0C CD B9 78    2 74 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C0F AF          2 75 xor     a                           ; initialize three-in-a-row counter
6C10 32 0E 62    2 76 ld      (THREE_ROW), a
6C13             2 78 ; ----------------------------------------------------------------------------------------------------------------------
6C13             2 79 ; Start new match
6C13             2 80 ; ----------------------------------------------------------------------------------------------------------------------
6C13             2 81 Main_Start_Match
6C13             2 82 ; set up timers and clear last messages
6C13 CD 15 76    2 84 call    Timer_Reset                 ; reset and display timers
6C16 AF          2 85 xor     a                           ; stop timers
6C17 32 E8 62    2 86 ld      (TIMER_FLAG), a
6C1A CD C9 6E    2 87 call    Print_Clear_Alert           ; clear last alert
6C1D 3E 02       2 88 ld      a, RED_COLOR                ; set red color in A
6C1F 32 9E 61    2 89 ld      (TOKEN_COLOR), a            ; save token color
6C22 CD F0 6E    2 90 call    Print_Clear_Move            ; clear red player last move
6C25             2 92 ; swap players' colors
6C25 3A 9F 61    2 94 ld      a, (PLAYER_COLOR)           ; get current player color
6C28 EE 07       2 95 xor     %00000111                   ; swap color
6C2A 32 9F 61    2 96 ld      (PLAYER_COLOR), a           ; save swapped player color
6C2D CD AC 6E    2 97 call    Print_Players               ; print "Player" and "Speccy" strings
6C30             2 99 ; initialize positions and draw empty board
6C30 21 00 7D    2 101 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C33 11 01 7D    2 102 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C36 36 00       2 103 ld      (hl), EMPTY                 ; set first position as empty
6C38 01 FF 01    2 104 ld      bc, 256*2-1                 ; length of cyan + red positions areas (-1 already set)
6C3B ED B0       2 105 ldir                                ; fill the rest of positions as empty
6C3D CD 5D 6D    2 106 call    Draw_Board                  ; draw an empty hexagons board
6C40             2 108 ; initialize draw token delay, move number and token color
6C40 3E 0A       2 110 ld      a, 10                       ; set delay duration in 'Draw_Token' routine
6C42 32 8C 6D    2 111 ld      (@Token_Delay+1), a
6C45 3E 01       2 112 ld      a, 1                        ; initialize move number
6C47 32 9D 61    2 113 ld      (MOVE_NUMBER), a
6C4A 21 9E 61    2 114 ld      hl, TOKEN_COLOR             ; HL points to current token color address
6C4D 3E 05       2 115 ld      a, CYAN_COLOR               ; first player token color
6C4F             2 117 ; ----------------------------------------------------------------------------------------------------------------------
6C4F             2 118 ; Process players moves - Match loop
6C4F             2 119 ; ----------------------------------------------------------------------------------------------------------------------
6C4F             2 120 Main_Match_Loop
6C4F 77          2 121 ld      (hl), a                     ; save current token color
6C50 E6 03       2 122 and     %00000011                   ; set timer flag based on current token color
6C52 32 E8 62    2 123 ld      (TIMER_FLAG), a             ; start timer
6C55             2 125 ; check player turn
6C55 7E          2 127 ld      a, (hl)                     ; get current token color
6C56 23          2 128 inc     hl                          ; HL points to player color address
6C57 BE          2 129 cp      (hl)                        ; check player color
6C58 CC F5 6C    2 130 call    z, Main_GetPlayer_Move      ; if player color = current token color, get player move
6C5B C4 B6 6C    2 131 call    nz, Main_GetSpeccy_Move     ; else, get speccy move (previous call always set Z flag)
6C5E             2 133 ; update positions with player/speccy move
6C5E CD AE 70    2 135 call    PathFinder_Friend           ; get player/speccy side
6C61 CD B7 70    2 136 call    PathFinder_PutToken         ; put token on cyan and red positions
6C64             2 138 ; draw token on the board
6C64 AF          2 140 xor     a                           ; stop timers
6C65 32 E8 62    2 141 ld      (TIMER_FLAG), a
6C68 CD 78 6D    2 142 call    Draw_Token                  ; animate hexagon sprite on the screen
6C6B DD 21 E7 64 2 143 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6C6F CD 7E 76    2 144 call    Sound_FX                    ; play sound effect
6C72             2 146 ; check for a winner
6C72 CD 5E 75    2 148 call    PathFinder_VictoryPath      ; check current player victory path
6C75 3C          2 149 inc     a                           ; is there a victory path?
6C76 20 0A       2 150 jr      nz, Main_Match_End          ; yes, match ends
6C78             2 152 ; increment move number and swap players' token color
6C78 21 9D 61    2 154 ld      hl, MOVE_NUMBER             ; HL points to move number address
6C7B 34          2 155 inc     (hl)                        ; increment move number
6C7C 23          2 156 inc     hl                          ; HL points to current token color address
6C7D 3E 07       2 157 ld      a, %00000111                ; swap token color
6C7F AE          2 158 xor     (hl)
6C80 18 CD       2 159 jr      Main_Match_Loop             ; repeat match loop
6C82             2 161 ; ----------------------------------------------------------------------------------------------------------------------
6C82             2 162 ; Current player wins the match
6C82             2 163 ; ----------------------------------------------------------------------------------------------------------------------
6C82             2 164 Main_Match_End
6C82 CD 95 75    2 165 call    PathFinder_BrightPath       ; animate and highlight the winner path
6C85 11 3A 62    2 166 ld      de, STR_WINNER              ; DE points to "WINS" string address
6C88 CD D0 6E    2 167 call    Print_Alert                 ; print string
6C8B DD 21 EF 64 2 168 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
6C8F CD 7E 76    2 169 call    Sound_FX                    ; play sound fx
6C92 21 9E 61    2 171 ld      hl, TOKEN_COLOR             ; HL points to current token color address
6C95 7E          2 172 ld      a, (hl)                     ; get current token color
6C96 23          2 173 inc     hl                          ; HL points to player color address
6C97 BE          2 174 cp      (hl)                        ; check player color
6C98 21 0E 62    2 175 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6C9B 28 04       2 176 jr      z, Main_ThreeRow_Increment  ; if player color = current token color, increment counter
6C9D 35          2 177 dec     (hl)                        ; decrement three-in-a-row counter
6C9E F2 A2 6C    2 178 jp      p, Main_ThreeRow_Clear      ; if not negative (-1), skip increment
6CA1             2 179 Main_ThreeRow_Increment
6CA1 34          2 180 inc     (hl)                        ; increment three-in-a-row counter
6CA2             2 181 Main_ThreeRow_Clear
6CA2 CD B9 78    2 182 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6CA5 C4 A2 78    2 183 call    nz, Screen_ThreeRow         ; if counter is not zero, color the three-in-a-row marks
6CA8 3E FF       2 185 ld      a, 255                      ; set delay duration
6CAA CD 4D 6D    2 186 call    Main_Delay                  ; execute delay
6CAD 3E 03       2 188 ld      a, 3                        ; check three-in-a-row counter
6CAF BE          2 189 cp      (hl)                        ; is it 3?
6CB0 CA F6 6B    2 190 jp      z, Main_New_Level           ; yes, start a new level
6CB3 C3 13 6C    2 191 jp      Main_Start_Match            ; start a new match
6CB6             2 193 ; ----------------------------------------------------------------------------------------------------------------------
6CB6             2 194 ; Main_GetSpeccy_Move: get the speccy move
6CB6             2 195 ;
6CB6             2 196 ; Input:    -
6CB6             2 197 ;
6CB6             2 198 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CB6             2 199 ;           HL = CYAN_POSITIONS move address
6CB6             2 200 ;
6CB6             2 201 ; Uses:     MOVE_NUMBER (current move number)
6CB6             2 202 ;           STR_MOVE (formatted move string)
6CB6             2 203 ;
6CB6             2 204 ; Destroys: A, DE, IX, IY
6CB6             2 205 ; ----------------------------------------------------------------------------------------------------------------------
6CB6             2 206 Main_GetSpeccy_Move:
6CB6 CD E9 6E    2 207 call    Print_Wait                  ; print "WAIT" message
6CB9 3A 9D 61    2 208 ld      a, (MOVE_NUMBER)            ; get move number
6CBC 3D          2 209 dec     a                           ; is it cyan first move?
6CBD 28 24       2 210 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CBF DD 21 00 7F 2 212 ld      ix, CANDIDATES              ; IX points to candidates list address
6CC3 CD AE 70    2 213 call    PathFinder_Friend           ; get speccy side (FRIEND or ENEMY)
6CC6 CD 3A 6F    2 214 call    BRAINIAC_best_move          ; get speccy best move
6CC9 6B          2 215 ld      l, e                        ; set node index in L
6CCA             2 216 Main_GetSpeccy_Positions
6CCA 26 7D       2 217 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6CCC E5          2 218 push    hl                          ; store CYAN_POSITIONS move address
6CCD CD 3B 6D    2 219 call    Main_Board2Indexes          ; convert board position to indexes
6CD0 78          2 220 ld      a, b                        ; get 1..7 column
6CD1 C6 60       2 221 add     a, $60                      ; adjust to charset ('a'..'g')
6CD3 32 15 62    2 222 ld      (STR_MOVE+0), a             ; put it on formatted move string
6CD6 79          2 223 ld      a, c                        ; get 1..7 row
6CD7 C6 30       2 224 add     a, $30                      ; adjust to charset ('1'..'7')
6CD9 32 18 62    2 225 ld      (STR_MOVE+3), a             ; put it on formatted move string
6CDC C5          2 226 push    bc                          ; store hexagon board indexes
6CDD CD F7 6E    2 227 call    Print_Move                  ; print Speccy move
6CE0 C1          2 228 pop     bc                          ; restore hexagon board indexes
6CE1 E1          2 229 pop     hl                          ; restore CYAN_POSITIONS move address
6CE2 C9          2 230 ret
6CE3             2 231 Main_GetSpeccy_Book
6CE3 ED 5F       2 232 ld      a, r                        ; get a pseudo-random number (0..127)
6CE5 E6 1F       2 233 and     %00011111                   ; number is in range (0..31)
6CE7 FE 1B       2 234 cp      27                          ; is it >= 27?
6CE9 30 F8       2 235 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6CEB 21 CD 62    2 236 ld      hl, OPENINGS                ; HL points to opening book address
6CEE 16 00       2 237 ld      d, 0                        ; set index in DE
6CF0 5F          2 238 ld      e, a
6CF1 19          2 239 add     hl, de                      ; HL points to move index address
6CF2 6E          2 240 ld      l, (hl)                     ; get move from opening book
6CF3 18 D5       2 241 jr      Main_GetSpeccy_Positions    ; get speccy move positions
6CF5             2 243 ; ----------------------------------------------------------------------------------------------------------------------
6CF5             2 244 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6CF5             2 245 ;
6CF5             2 246 ; Input:    -
6CF5             2 247 ;
6CF5             2 248 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CF5             2 249 ;           HL = CYAN_POSITIONS move address
6CF5             2 250 ;           Z  = flag set
6CF5             2 251 ;
6CF5             2 252 ; Uses:     STR_MOVE (formatted move string)
6CF5             2 253 ;
6CF5             2 254 ; Destroys: A, DE, IX
6CF5             2 255 ; ----------------------------------------------------------------------------------------------------------------------
6CF5             2 256 Main_GetPlayer_Move:
6CF5 CD F0 6E    2 257 call    Print_Clear_Move            ; clear player last move
6CF8 CD E7 6D    2 258 call    Input_Move                  ; wait for input player move
6CFB CD F7 6E    2 259 call    Print_Move                  ; print player move
6CFE 3A 15 62    2 261 ld      a, (STR_MOVE+0)             ; get column ('a'..'g')
6D01 D6 60       2 262 sub     $60                         ; convert to number (1..7)
6D03 47          2 263 ld      b, a                        ; set column index in B
6D04 3A 18 62    2 264 ld      a, (STR_MOVE+3)             ; get row ('1'..'7')
6D07 D6 30       2 265 sub     $30                         ; convert to number (1..7)
6D09 4F          2 266 ld      c, a                        ; set row index in C
6D0A 11 4D 62    2 267 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D0D CD 2D 6D    2 268 call    Main_Search_Table           ; search board position in board coordinates
6D10 6E          2 269 ld      l, (hl)                     ; set board position of player move
6D11 26 7D       2 270 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D13 7E          2 271 ld      a, (hl)                     ; check position
6D14 B7          2 272 or      a                           ; is position empty?
6D15 C8          2 273 ret     z                           ; yes, return with Z flag set
6D16             2 275 ; illegal player move (position not empty)
6D16 11 2E 62    2 277 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D19 CD D0 6E    2 278 call    Print_Alert                 ; print string
6D1C DD 21 F7 64 2 279 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D20 CD 7E 76    2 280 call    Sound_FX                    ; play sound fx
6D23 3E 50       2 281 ld      a, 80                       ; set delay counter
6D25 CD 4D 6D    2 282 call    Main_Delay                  ; execute delay
6D28 CD C9 6E    2 283 call    Print_Clear_Alert           ; clear alert message
6D2B 18 C8       2 284 jr      Main_GetPlayer_Move         ; repeat player input until move is legal
6D2D             2 286 ; ----------------------------------------------------------------------------------------------------------------------
6D2D             2 287 ; Main_Search_Table: search an element in a 8x8 bytes table
6D2D             2 288 ;
6D2D             2 289 ; Input:    BC = element indexes (B = column, C = row)
6D2D             2 290 ;           DE = table address in which to search for the element
6D2D             2 291 ;
6D2D             2 292 ; Output:   DE = address of first element in the C row of the table
6D2D             2 293 ;           HL = address of the element in the BC indexes of the table
6D2D             2 294 ;
6D2D             2 295 ; Destroys: A
6D2D             2 296 ; ----------------------------------------------------------------------------------------------------------------------
6D2D             2 297 Main_Search_Table:
6D2D 79          2 298 ld      a, c                        ; first, get the C row in table
6D2E 87          2 299 add     a, a                        ; a row is 8 bytes long
6D2F 87          2 300 add     a, a
6D30 87          2 301 add     a, a
6D31 6F          2 302 ld      l, a                        ; set index in HL
6D32 26 00       2 303 ld      h, 0
6D34 19          2 304 add     hl, de                      ; HL points to the address of C row 
6D35 EB          2 305 ex      de, hl                      ; put it on DE
6D36 68          2 306 ld      l, b                        ; set B index in HL
6D37 26 00       2 307 ld      h, 0
6D39 19          2 308 add     hl, de                      ; HL points to the address of BC indexes
6D3A C9          2 309 ret
6D3B             2 311 ; ----------------------------------------------------------------------------------------------------------------------
6D3B             2 312 ; Main_Board2Indexes: convert a board position into a board indexes
6D3B             2 313 ;
6D3B             2 314 ; Input:    L  = board position
6D3B             2 315 ;
6D3B             2 316 ; Output:   BC = board indexes (B = column, C = row)
6D3B             2 317 ;
6D3B             2 318 ; Destroys: HL
6D3B             2 319 ; ----------------------------------------------------------------------------------------------------------------------
6D3B             2 320 Main_Board2Indexes:
6D3B 7D          2 321 ld      a, l                        ; set board position in A to compare later
6D3C 21 8D 62    2 323 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D3F 0E 07       2 324 ld      c, 7                        ; 7 rows
6D41             2 325 Main_Board2Indexes_Row
6D41 06 07       2 326 ld      b, 7                        ; 7 columns
6D43             2 327 Main_Board2Indexes_Col
6D43 2B          2 328 dec     hl                          ; move HL to next board position address
6D44 BE          2 329 cp      (hl)                        ; is A the position?
6D45 C8          2 330 ret     z                           ; yes, return board indexes
6D46 10 FB       2 331 djnz    Main_Board2Indexes_Col      ; repeat for each column
6D48 2B          2 332 dec     hl                          ; skip borders
6D49 0D          2 333 dec     c                           ; decrement row
6D4A C3 41 6D    2 334 jp      Main_Board2Indexes_Row      ; loop until find position
6D4D             2 336 ; ----------------------------------------------------------------------------------------------------------------------
6D4D             2 337 ; Main_Delay: execute a delay
6D4D             2 338 ;
6D4D             2 339 ; Input:    A = delay counter
6D4D             2 340 ;
6D4D             2 341 ; Output:   -
6D4D             2 342 ;
6D4D             2 343 ; Destroys: A
6D4D             2 344 ; ----------------------------------------------------------------------------------------------------------------------
6D4D             2 345 Main_Delay:
6D4D C5          2 346 push    bc                          ; store BC register
6D4E             2 347 Main_Delay_Outer
6D4E F5          2 348 push    af                          ; store delay counter (outer loop)
6D4F 01 B0 04    2 349 ld      bc, 1200                    ; set inner loop counter in BC
6D52             2 350 Main_Delay_Inner
6D52 0B          2 351 dec     bc                          ; decrement inner loop counter
6D53 78          2 352 ld      a, b                        ; check inner loop counter
6D54 B1          2 353 or      c
6D55 20 FB       2 354 jr      nz, Main_Delay_Inner        ; repeat until inner loop counter = 0
6D57 F1          2 355 pop     af                          ; restore delay counter
6D58 3D          2 356 dec     a                           ; decrement delay counter
6D59 20 F3       2 357 jr      nz, Main_Delay_Outer        ; repeat until delay counter = 0
6D5B C1          2 358 pop     bc                          ; restore BC register
6D5C C9          2 359 ret

; File #3: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Draw.z80asm

6D5D             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6D5D             3 2 ; Draw.z80asm
6D5D             3 3 ; Coded by Antonio Luque
6D5D             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6D5D             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6D5D             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6D5D             3 8 ;
6D5D             3 9 ; Input:    -
6D5D             3 10 ;
6D5D             3 11 ; Output:   -
6D5D             3 12 ;
6D5D             3 13 ; Uses:     TOKEN_COLOR (current token color)
6D5D             3 14 ;
6D5D             3 15 ; Destroys: A, BC, DE, HL, IXL
6D5D             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6D5D             3 17 Draw_Board:
6D5D 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6D5F 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6D62 0E 07       3 20 ld      c, 7                        ; 7 rows
6D64             3 21 Draw_Board_Row
6D64 06 07       3 22 ld      b, 7                        ; 7 columns
6D66             3 23 Draw_Board_Column
6D66 CD 93 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6D69 CD CB 6D    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6D6C 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6D6F CD 9D 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6D72 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6D74 0D          3 29 dec     c                           ; decrement row
6D75 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6D77 C9          3 31 ret
6D78             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6D78             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6D78             3 35 ;
6D78             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6D78             3 37 ;
6D78             3 38 ; Output:   -
6D78             3 39 ;
6D78             3 40 ; Destroys: A, BC, DE, HL, IXL
6D78             3 41 ; ----------------------------------------------------------------------------------------------------------------------
6D78             3 42 Draw_Token:
6D78 CD 93 6D    3 43 call    Draw_GetHEX_Screen          ; get hexagon screen address
6D7B 01 04 06    3 44 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6D7E 11 9E 65    3 45 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6D81             3 46 Draw_Token_Loop
6D81 E5          3 47 push    hl                          ; store hexagon screen address
6D82 CD 9D 6D    3 48 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6D85 E1          3 49 pop     hl                          ; restore hexagon screen address
6D86 78          3 50 ld      a, b                        ; check loop counter
6D87 B9          3 51 cp      c                           ; is it 4?
6D88 CC CB 6D    3 52 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6D8B             3 53 @Token_Delay
6D8B 3E 00       3 54 ld      a, 0                        ; set delay duration (changed before calling this routine)
6D8D CD 4D 6D    3 55 call    Main_Delay                  ; execute delay
6D90 10 EF       3 56 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6D92 C9          3 57 ret
6D93             3 59 ; ----------------------------------------------------------------------------------------------------------------------
6D93             3 60 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6D93             3 61 ;
6D93             3 62 ; Input:    BC = hexagon board indexes (B:column, C:row)
6D93             3 63 ;
6D93             3 64 ; Output:   HL = hexagon screen address 
6D93             3 65 ;
6D93             3 66 ; Destroys: A, DE
6D93             3 67 ; ----------------------------------------------------------------------------------------------------------------------
6D93             3 68 Draw_GetHEX_Screen:
6D93 11 98 61    3 69 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6D96 CD 2D 6D    3 70 call    Main_Search_Table           ; search the screen address of the hexagon in table
6D99 6E          3 71 ld      l, (hl)                     ; set the low byte of the screen address in L
6D9A 1A          3 72 ld      a, (de)                     ; set the high byte of the screen address in H
6D9B 67          3 73 ld      h, a
6D9C C9          3 74 ret
6D9D             3 76 ; ----------------------------------------------------------------------------------------------------------------------
6D9D             3 77 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6D9D             3 78 ;
6D9D             3 79 ; Input:    DE = hexagon sprite address
6D9D             3 80 ;           HL = hexagon screen address
6D9D             3 81 ;
6D9D             3 82 ; Output:   DE = next hexagon sprite address
6D9D             3 83 ;
6D9D             3 84 ; Destroys: A, HL, IXL
6D9D             3 85 ; ----------------------------------------------------------------------------------------------------------------------
6D9D             3 86 Draw_Sprite_Hexagon:
6D9D DD 2E 10    3 87 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DA0             3 88 Draw_Sprite_HexLoop
6DA0 1A          3 89 ld      a, (de)                     ; get sprite byte
6DA1 77          3 90 ld      (hl), a                     ; put sprite byte on screen
6DA2 13          3 91 inc     de                          ; move DE to next sprite byte address
6DA3 2C          3 92 inc     l                           ; move HL to next screen column
6DA4 1A          3 93 ld      a, (de)                     ; get sprite byte
6DA5 77          3 94 ld      (hl), a                     ; put sprite byte on screen
6DA6 13          3 95 inc     de                          ; move DE to next sprite byte
6DA7 2D          3 96 dec     l                           ; move HL to previous screen column
6DA8 CD BC 6D    3 97 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DAB DD 2D       3 98 dec     ixl                         ; decrement sprite height
6DAD 20 F1       3 99 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6DAF C9          3 100 ret
6DB0             3 102 ; ----------------------------------------------------------------------------------------------------------------------
6DB0             3 103 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6DB0             3 104 ;
6DB0             3 105 ; Input:    DE = letter/number sprite address
6DB0             3 106 ;           HL = letter/number screen address
6DB0             3 107 ;
6DB0             3 108 ; Output:   DE = next letter/number sprite address
6DB0             3 109 ;
6DB0             3 110 ; Destroys: A, C, HL
6DB0             3 111 ; ----------------------------------------------------------------------------------------------------------------------
6DB0             3 112 Draw_Sprite_LetterNum:
6DB0 0E 0A       3 113 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6DB2             3 114 Draw_Sprite_Loop
6DB2 1A          3 115 ld      a, (de)                     ; get sprite byte
6DB3 77          3 116 ld      (hl), a                     ; put sprite byte on screen
6DB4 13          3 117 inc     de                          ; move DE to next sprite byte address
6DB5 CD BC 6D    3 118 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DB8 0D          3 119 dec     c                           ; decrement sprite height
6DB9 20 F7       3 120 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6DBB C9          3 121 ret
6DBC             3 123 ; ----------------------------------------------------------------------------------------------------------------------
6DBC             3 124 ; Draw_Down_PixelLine: move HL down one pixel-line
6DBC             3 125 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6DBC             3 126 ;
6DBC             3 127 ; The screen address of a pixel-line is encoded as follows:
6DBC             3 128 ;
6DBC             3 129 ;             H           |           L
6DBC             3 130 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DBC             3 131 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6DBC             3 132 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DBC             3 133 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6DBC             3 134 ;
6DBC             3 135 ; where:
6DBC             3 136 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6DBC             3 137 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6DBC             3 138 ;
6DBC             3 139 ; Input:    HL = pixel-line address
6DBC             3 140 ;
6DBC             3 141 ; Output:   HL = next (down) pixel-line address
6DBC             3 142 ;
6DBC             3 143 ; Destroys: A
6DBC             3 144 ; ----------------------------------------------------------------------------------------------------------------------
6DBC             3 145 Draw_Down_PixelLine:
6DBC 24          3 146 inc     h                           ; move HL down one pixel-line
6DBD 7C          3 147 ld      a, h                        ; get high byte of pixel-line address
6DBE E6 07       3 148 and     %00000111                   ; is pixel-line address inside a character line?
6DC0 C0          3 149 ret     nz                          ; yes, return
6DC1 7D          3 150 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6DC2 C6 20       3 151 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6DC4 6F          3 152 ld      l, a                        ; move HL down one character line
6DC5 D8          3 153 ret     c                           ; a third was crossed? yes, return
6DC6 7C          3 154 ld      a, h                        ; get high byte of pixel-line address
6DC7 D6 08       3 155 sub     8                           ; clean up the bit from Y6
6DC9 67          3 156 ld      h, a                        ; HL points to next (down) pixel-line address
6DCA C9          3 157 ret
6DCB             3 159 ; ----------------------------------------------------------------------------------------------------------------------
6DCB             3 160 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6DCB             3 161 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6DCB             3 162 ;
6DCB             3 163 ; This routine converts a screen address (HL) into an attribute address (IX):
6DCB             3 164 ;
6DCB             3 165 ;             H           |           L
6DCB             3 166 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DCB             3 167 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6DCB             3 168 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DCB             3 169 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6DCB             3 170 ;
6DCB             3 171 ;            IXH          |          IXL
6DCB             3 172 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DCB             3 173 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6DCB             3 174 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DCB             3 175 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6DCB             3 176 ;
6DCB             3 177 ; where:
6DCB             3 178 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6DCB             3 179 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6DCB             3 180 ;
6DCB             3 181 ; Input:    HL = screen address of the hexagon
6DCB             3 182 ;
6DCB             3 183 ; Output:   A  = TOKEN_COLOR (current token color)
6DCB             3 184 ;           IX = attribute address of the hexagon
6DCB             3 185 ;
6DCB             3 186 ; Uses:     TOKEN_COLOR (current token color)
6DCB             3 187 ;
6DCB             3 188 ; Destroys: -
6DCB             3 189 ; ----------------------------------------------------------------------------------------------------------------------
6DCB             3 190 Draw_Hexagon_Color:
6DCB 7C          3 191 ld      a, h                        ; get high byte of screen address
6DCC F6 87       3 192 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6DCE 1F          3 193 rra                                 ; shift Y7-Y6 two positions
6DCF 1F          3 194 rra
6DD0 CB 3F       3 195 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6DD2 DD 67       3 196 ld      ixh, a                      ; set high byte of attribute address in IXH
6DD4 7D          3 197 ld      a, l                        ; (the low byte for attribute address doesn't change)
6DD5 DD 6F       3 198 ld      ixl, a                      ; set low byte of attribute address in IXL
6DD7 3A 9E 61    3 199 ld      a, (TOKEN_COLOR)            ; get current token color
6DDA DD 77 00    3 200 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6DDD DD 77 01    3 201 ld      (ix+1), a
6DE0 DD 77 20    3 202 ld      (ix+32), a
6DE3 DD 77 21    3 203 ld      (ix+33), a
6DE6 C9          3 204 ret

; File #4: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Input.z80asm

6DE7             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6DE7             4 2 ; Input.z80asm
6DE7             4 3 ; Coded by Antonio Luque
6DE7             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6DE7             4 6 MAX_CHARS               EQU     2                           ; maximum of input chars
6DE7             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6DE7             4 9 ; Input_Move: wait for the input of a movement through the keyboard
6DE7             4 10 ;
6DE7             4 11 ; Based on assembler course by sromero:
6DE7             4 12 ; https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes#lectura-de-texto-desde-teclado
6DE7             4 13 ;
6DE7             4 14 ; Input:    -
6DE7             4 15 ;
6DE7             4 16 ; Output:   -
6DE7             4 17 ;
6DE7             4 18 ; Uses:     TOKEN_COLOR (current token color)
6DE7             4 19 ;           STR_MOVE (formatted move string)
6DE7             4 20 ;
6DE7             4 21 ; Destroys: A, BC, DE, HL, IX
6DE7             4 22 ; ----------------------------------------------------------------------------------------------------------------------
6DE7             4 23 Input_Move:
6DE7 01 00 02    4 24 ld      bc, MAX_CHARS*256           ; B = maximum of input chars, C = chars counter
6DEA DD 21 83 5A 4 26 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6DEE 21 83 50    4 27 ld      hl, $5083                   ; HL points to screen address of RED input text
6DF1 3A 9E 61    4 28 ld      a, (TOKEN_COLOR)            ; check current player color
6DF4 FE 02       4 29 cp      RED_COLOR                   ; is RED the current token color?
6DF6 28 07       4 30 jr      z, Input_Start              ; yes, start input
6DF8 DD 21 19 59 4 31 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6DFC 21 19 48    4 32 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6DFF             4 33 Input_Start
6DFF DD 36 00 C7 4 34 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E03 3E 5F       4 35 ld      a, '_'                      ; text input cursor
6E05 CD 20 6F    4 36 call    Print_Char                  ; print cursor
6E08             4 37 Input_Loop
6E08 CD 80 6E    4 38 call    Input_Key_Scan              ; scan for a key pressed
6E0B FE 0D       4 39 cp      13                          ; is it ENTER?
6E0D 28 64       4 40 jr      z, Input_Enter              ; yes, perform enter pressed
6E0F FE 30       4 41 cp      '0'                         ; is it "delete"? (char '0' acts as delete, without Shift)
6E11 28 42       4 42 jr      z, Input_Delete             ; yes, perform delete char
6E13 57          4 43 ld      d, a                        ; store char in D
6E14 79          4 44 ld      a, c                        ; check number of chars inserted
6E15 B8          4 45 cp      b                           ; chars limit reached?
6E16 28 F0       4 46 jr      z, Input_Loop               ; yes, repeat input loop
6E18 B7          4 48 or      a                           ; is it the first char?
6E19 20 21       4 49 jr      nz, Input_Numbers           ; no, perform input of second char
6E1B             4 51 ; restrict first char to 'a'-'g'
6E1B 7A          4 53 ld      a, d                        ; restore char
6E1C FE 61       4 54 cp      'a'                         ; is it < 'a'?
6E1E 38 E8       4 55 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E20 FE 68       4 56 cp      'g'+1                       ; is it > 'g'?
6E22 30 E4       4 57 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E24             4 59 ; char is valid as column
6E24 32 15 62    4 61 ld      (STR_MOVE+0), a             ; save char in player move
6E27 DD 36 00 47 4 62 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E2B CD 20 6F    4 63 call    Print_Char                  ; print key pressed
6E2E 0C          4 64 inc     c                           ; increment chars counter
6E2F 2C          4 65 inc     l                           ; increment X position of current input screen location
6E30 DD 2C       4 66 inc     ixl                         ; increment X position of current input attr location
6E32 3E 2D       4 67 ld      a, '-'                      ; set dash char
6E34 CD 20 6F    4 68 call    Print_Char                  ; print dash char
6E37 2C          4 69 inc     l                           ; increment X position of current input screen location
6E38 DD 2C       4 70 inc     ixl                         ; increment X position of current input attr location
6E3A 18 C3       4 71 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E3C             4 72 Input_Numbers
6E3C             4 73 ; restrict second char to '1'-'7'
6E3C 7A          4 75 ld      a, d                        ; restore char
6E3D FE 31       4 76 cp      '1'                         ; is it < '1'?
6E3F 38 C7       4 77 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E41 FE 38       4 78 cp      '7'+1                       ; is it > '7'?
6E43 30 C3       4 79 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E45             4 81 ; char is valid as row
6E45 32 18 62    4 83 ld      (STR_MOVE+3), a             ; save char in player move
6E48 DD 36 00 47 4 84 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E4C CD 20 6F    4 85 call    Print_Char                  ; print key pressed
6E4F 0C          4 86 inc     c                           ; increment chars counter
6E50 2C          4 87 inc     l                           ; increment X position of current input screen location
6E51 DD 2C       4 88 inc     ixl                         ; increment X position of current input attr location
6E53 18 AA       4 89 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E55             4 91 ; player pressed "delete" (char '0')
6E55             4 92 Input_Delete
6E55 79          4 93 ld      a, c                        ; get char counter
6E56 B7          4 94 or      a                           ; is it 0?
6E57 28 AF       4 95 jr      z, Input_Loop               ; repeat input loop (no chars to delete)
6E59 DD 36 00 47 4 97 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E5D B8          4 98 cp      b                           ; is it the first char?
6E5E 28 08       4 99 jr      z, Input_Delete_Char        ; yes, continue delete
6E60 3E 20       4 100 ld      a, ' '                      ; empty char
6E62 CD 20 6F    4 101 call    Print_Char                  ; delete cursor and last char
6E65 2D          4 102 dec     l                           ; decrement X position of input screen location
6E66 DD 2D       4 103 dec     ixl                         ; decrement X position of input attr location
6E68             4 104 Input_Delete_Char
6E68 0D          4 105 dec     c                           ; decrement char counter
6E69 3E 20       4 106 ld      a, ' '                      ; empty char
6E6B CD 20 6F    4 107 call    Print_Char                  ; delete cursor and last char
6E6E 2D          4 108 dec     l                           ; decrement X position of player input screen location
6E6F DD 2D       4 109 dec     ixl                         ; decrement X position of player input attr location
6E71 18 8C       4 110 jr      Input_Start                 ; get next char
6E73             4 112 ; player pressed ENTER
6E73             4 113 Input_Enter
6E73 79          4 114 ld      a, c                        ; check char counter  
6E74 B8          4 115 cp      b                           ; is it < MAX_CHARS?
6E75 38 91       4 116 jr      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6E77 DD 36 00 47 4 118 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E7B 3E 20       4 119 ld      a, ' '                      ; empty char
6E7D C3 20 6F    4 120 jp      Print_Char                  ; delete cursor and return via Print_Char
6E80             4 122 ; ----------------------------------------------------------------------------------------------------------------------
6E80             4 123 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6E80             4 124 ;
6E80             4 125 ;                           Bit
6E80             4 126 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6E80             4 127 ;  ------+-------+-------+-------+-------+-------+
6E80             4 128 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6E80             4 129 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6E80             4 130 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6E80             4 131 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6E80             4 132 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6E80             4 133 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6E80             4 134 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6E80             4 135 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6E80             4 136 ;
6E80             4 137 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6E80             4 138 ;
6E80             4 139 ; Input:    -
6E80             4 140 ;
6E80             4 141 ; Output:   A = ASCII code of key pressed
6E80             4 142 ;
6E80             4 143 ; Destroys: DE
6E80             4 144 ; ----------------------------------------------------------------------------------------------------------------------
6E80             4 145 Input_Key_Scan:
6E80 C5          4 146 push    bc                          ; store registers
6E81 E5          4 147 push    hl
6E82             4 148 Input_Key_Released
6E82 01 FE FE    4 149 ld      bc, $FEFE                   ; set keyboard port (see above)
6E85             4 150 Input_Key_Released_Line
6E85 ED 78       4 151 in      a, (c)                      ; read port
6E87 2F          4 152 cpl                                 ; invert bits
6E88 E6 1F       4 153 and     %00011111                   ; check 0 to 4 bits
6E8A 20 F6       4 154 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6E8C CB 00       4 155 rlc     b                           ; move BC to the next port
6E8E 38 F5       4 156 jr      c, Input_Key_Released_Line  ; repeat for each port
6E90 11 05 00    4 157 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6E93             4 158 Input_Key_Pressed_Begin
6E93 21 D8 61    4 159 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6E96             4 160 Input_Key_Pressed_Line
6E96 ED 78       4 161 in      a, (c)                      ; read port
6E98 2F          4 162 cpl                                 ; invert bits
6E99 E6 1F       4 163 and     %00011111                   ; check 0 to 4 bits
6E9B 20 08       4 164 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6E9D 19          4 165 add     hl, de                      ; HL points to the next KEY_MAP block
6E9E CB 00       4 166 rlc     b                           ; move BC to the next port
6EA0 38 F4       4 167 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6EA2 18 EF       4 168 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6EA4             4 169 Input_Key_Next
6EA4 23          4 170 inc     hl                          ; move HL to the next character
6EA5             4 171 Input_Key_Pressed
6EA5 1F          4 172 rra                                 ; rotate bits of port readed
6EA6 30 FC       4 173 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6EA8 7E          4 174 ld      a, (hl)                     ; return key pressed (ASCII) in A
6EA9 E1          4 175 pop     hl                          ; restore registers
6EAA C1          4 176 pop     bc
6EAB C9          4 177 ret

; File #5: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Print.z80asm

6EAC             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6EAC             5 2 ; Print.z80asm
6EAC             5 3 ; Coded by Antonio Luque
6EAC             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6EAC             5 6 CHAR_SET                EQU     FONT-256                    ; address of character set data, adjusted for ASCII codes
6EAC             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6EAC             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6EAC             5 10 ;
6EAC             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6EAC             5 12 ;
6EAC             5 13 ; Output:   -
6EAC             5 14 ;
6EAC             5 15 ; Destroys: A, BC, DE, HL
6EAC             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6EAC             5 17 Print_Players:
6EAC 11 21 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6EAF 01 1A 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6EB2 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6EB5 FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6EB7 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6EB9 11 1A 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6EBC 01 21 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6EBF             5 25 Print_Players_Strings
6EBF CD 14 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6EC2 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6EC3 59          5 28 ld      e, c
6EC4 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6EC7 18 4B       5 30 jr      Print_String                ; print "Player" or "Speccy"
6EC9             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6EC9             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6EC9             5 34 ;
6EC9             5 35 ; Input:    -
6EC9             5 36 ; Output:   -
6EC9             5 37 ; Destroys: A, BC, DE, HL, IX
6EC9             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6EC9             5 39 Print_Clear_Alert:
6EC9 11 46 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6ECC 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6ECE 18 02       5 42 jr      Print_Alert_XY              ; print (clear) alert string
6ED0             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6ED0             5 45 ; Print_Alert: print an alert message below the current player input move
6ED0             5 46 ;
6ED0             5 47 ; Input:    DE = alert message string address
6ED0             5 48 ;
6ED0             5 49 ; Output:   -
6ED0             5 50 ;
6ED0             5 51 ; Uses:     TOKEN_COLOR (current token color)
6ED0             5 52 ;
6ED0             5 53 ; Destroys: A, BC, DE, HL, IX
6ED0             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6ED0             5 55 Print_Alert:
6ED0 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6ED2             5 57 Print_Alert_XY
6ED2 DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6ED6 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6ED9 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6EDC FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6EDE 28 31       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6EE0 DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6EE4 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6EE7 18 28       5 65 jr      Print_String_Color          ; print alert string with color
6EE9             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6EE9             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6EE9             5 69 ;
6EE9             5 70 ; Input:    -
6EE9             5 71 ;
6EE9             5 72 ; Output:   -
6EE9             5 73 ;
6EE9             5 74 ; Destroys: A, BC, DE, HL, IX
6EE9             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6EE9             5 76 Print_Wait:
6EE9 11 35 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6EEC 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6EEE 18 0C       5 79 jr      Print_Move_XY               ; print wait string
6EF0             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6EF0             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6EF0             5 83 ;
6EF0             5 84 ; Input:    -
6EF0             5 85 ;
6EF0             5 86 ; Output:   -
6EF0             5 87 ;
6EF0             5 88 ; Destroys: A, BC, DE, HL, IX
6EF0             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6EF0             5 90 Print_Clear_Move:
6EF0 11 41 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6EF3 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6EF5 18 05       5 93 jr      Print_Move_XY               ; print (clear) move string
6EF7             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6EF7             5 96 ; Print_Move: print a formatted move at current player input move location 
6EF7             5 97 ;
6EF7             5 98 ; Input:    -
6EF7             5 99 ;
6EF7             5 100 ; Output:   -
6EF7             5 101 ;
6EF7             5 102 ; Uses:     TOKEN_COLOR (current token color)
6EF7             5 103 ;
6EF7             5 104 ; Destroys: A, BC, DE, HL, IX
6EF7             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6EF7             5 106 Print_Move:
6EF7 11 15 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6EFA 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6EFC             5 109 Print_Move_XY
6EFC DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F00 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F03 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F06 FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F08 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F0A DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F0E 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F11             5 117 Print_String_Color
6F11 CD 22 78    5 118 call    Screen_Apply_Color_6        ; apply color to string area
6F14             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F14             5 120 ; Print_String: print a string on the screen
6F14             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F14             5 122 ;
6F14             5 123 ; Input:    DE = string address (ending with 0)
6F14             5 124 ;           HL = string screen address
6F14             5 125 ;
6F14             5 126 ; Output:   -
6F14             5 127 ;
6F14             5 128 ; Destroys: A, DE, HL
6F14             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F14             5 130 Print_String:
6F14 1A          5 131 ld      a, (de)                     ; get string character
6F15 B7          5 132 or      a                           ; is it 0? (end of string)
6F16 C8          5 133 ret     z                           ; yes, return
6F17 D5          5 134 push    de                          ; store pointer to string address
6F18 CD 20 6F    5 135 call    Print_Char                  ; print character
6F1B D1          5 136 pop     de                          ; restore pointer to string address
6F1C 13          5 137 inc     de                          ; move DE to next string character
6F1D 2C          5 138 inc     l                           ; move HL to next screen column
6F1E 18 F4       5 139 jr      Print_String                ; repeat until end of string
6F20             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F20             5 142 ; Print_Char: print a character on the screen
6F20             5 143 ;
6F20             5 144 ; Input:    A  = character to print (ASCII)
6F20             5 145 ;           HL = character screen address
6F20             5 146 ;
6F20             5 147 ; Output:   -
6F20             5 148 ;
6F20             5 149 ; Destroys: A, DE
6F20             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F20             5 151 Print_Char:
6F20 11 C3 67    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F23             5 153 Print_Tile:
6F23 E5          5 154 push    hl                          ; store pointer to character/tile screen address
6F24 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F26 6F          5 156 ld      l, a
6F27 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6F28 29          5 158 add     hl, hl
6F29 29          5 159 add     hl, hl
6F2A 19          5 160 add     hl, de                      ; move HL to character/tile address
6F2B EB          5 161 ex      de, hl                      ; DE points to character/tile address
6F2C E1          5 162 pop     hl                          ; restore pointer to character/tile screen address
6F2D C5          5 163 push    bc                          ; store BC register
6F2E 4C          5 164 ld      c, h                        ; save high byte of character/tile screen address
6F2F 06 08       5 165 ld      b, 8                        ; number of character/tile bytes (loop counter)
6F31             5 166 Print_Tile_Pixels
6F31 1A          5 167 ld      a, (de)                     ; get character/tile byte
6F32 77          5 168 ld      (hl), a                     ; put character/tile byte on screen
6F33 13          5 169 inc     de                          ; move DE to next character/tile byte
6F34 24          5 170 inc     h                           ; move HL down one pixel-line
6F35 10 FA       5 171 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6F37 61          5 172 ld      h, c                        ; restore high byte of character/tile screen address
6F38 C1          5 173 pop     bc                          ; restore BC register
6F39 C9          5 174 ret

; File #6: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Brainiac.z80asm

6F3A             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6F3A             6 2 ; Brainiac.z80asm
6F3A             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F3A             6 4 ;
6F3A             6 5 ; Adapted for Hex game by Einar Saukas
6F3A             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6F3A             6 8 MIN_VALUE               EQU     0                           ; alphaBeta pruning minimum value
6F3A             6 9 MAX_VALUE               EQU     255                         ; alphaBeta pruning maximum value
6F3A             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6F3A             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6F3A             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6F3A             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6F3A             6 15 ; depth.
6F3A             6 16 ;
6F3A             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F3A             6 18 ;
6F3A             6 19 ; Input:    A   = speccy side (FRIEND or ENEMY)
6F3A             6 20 ;           IX  = candidates vector address
6F3A             6 21 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
6F3A             6 22 ;
6F3A             6 23 ; Output:   E  = selected position (speccy move)
6F3A             6 24 ;
6F3A             6 25 ; Uses:     AI_PLAYER (speccy side)
6F3A             6 26 ;           AI_DEPTH (recursion depth level)
6F3A             6 27 ;
6F3A             6 28 ; Destroys: A, A', BC, D, HL, IX, IY
6F3A             6 29 ; ----------------------------------------------------------------------------------------------------------------------
6F3A             6 30 BRAINIAC_best_move:
6F3A 32 9B 61    6 31 ld      (AI_PLAYER), a              ; save speccy side
6F3D CD 36 74    6 33 call    PathFinder_Score            ; get board score (needed to get candidates)
6F40 CD D9 74    6 34 call    PathFinder_Candidates       ; get candidates from board potentials
6F43             6 36 ; BRAINIAC start
6F43             6 37 AI_First_Candidate
6F43 DD 7E 00    6 38 ld      a, (ix+0)                   ; A is our first candidate
6F46 5F          6 40 ld      e, a                        ; E = best speccy move (initialization)
6F47 16 00       6 41 ld      d, MIN_VALUE                ; D = alphaMax
6F49             6 43 AI_Main_Loop                                                ; for each candidate {
6F49 D5          6 44 push    de                          ;       store alphaMax and best speccy move
6F4A 26 7D       6 46 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F4C 6F          6 47 ld      l, a
6F4D E5          6 48 push    hl
6F4E 3A 9B 61    6 50 ld      a, (AI_PLAYER)              ;       get speccy side
6F51 CD B7 70    6 51 call    PathFinder_PutToken         ;       BRAINIAC_play
6F54 EE 7C       6 52 xor     $7C                         ;       restore speccy side
6F56 1E FF       6 53 ld      e, MAX_VALUE                ;       E = betaMin
6F58 CD 71 6F    6 54 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6F5B E1          6 56 pop     hl                          ;       restore candidate position
6F5C CD BD 70    6 57 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6F5F D1          6 59 pop     de                          ;       restore alphaMax and best player node
6F60 BA          6 61 cp      d
6F61 38 04       6 62 jr      c, AI_Main_Next
6F63 28 02       6 63 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6F65 57          6 65 ld      d, a                        ;       alphaMax = A
6F66 5D          6 66 ld      e, l                        ;       best move = E
6F67             6 68 AI_Main_Next
6F67 DD 2D       6 69 dec     ixl
6F69 DD 7E 00    6 70 ld      a, (ix+0)                   ;       A is our next candidate
6F6C B7          6 71 or      a                           ;       repeat until no more candidates
6F6D C2 49 6F    6 72 jp      nz, AI_Main_Loop            ; }
6F70 C9          6 73 ret
6F71             6 75 ; ----------------------------------------------------------------------------------------------------------------------
6F71             6 76 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6F71             6 77 ; Speccy's score.
6F71             6 78 ;
6F71             6 79 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6F71             6 80 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6F71             6 81 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6F71             6 82 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6F71             6 83 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6F71             6 84 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6F71             6 85 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6F71             6 86 ; could be just reproducing the best score from its sibling.
6F71             6 87 ;
6F71             6 88 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F71             6 89 ;
6F71             6 90 ; Input:    A   = speccy side (FRIEND or ENEMY)
6F71             6 91 ;           D   = alphaMax
6F71             6 92 ;           E   = betaMin
6F71             6 93 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
6F71             6 94 ;
6F71             6 95 ; Output:   A = "improved" betaMin
6F71             6 96 ;           D = alphaMax
6F71             6 97 ;           E = "improved" betaMin
6F71             6 98 ;
6F71             6 99 ; Uses:     AI_PLAYER (speccy side)
6F71             6 100 ;           AI_DEPTH (recursion depth level)
6F71             6 101 ;
6F71             6 102 ; Destroys: BC, HL, IX, IY
6F71             6 103 ; ----------------------------------------------------------------------------------------------------------------------
6F71             6 104 Alphabeta_Min:
6F71 D5          6 105 push    de
6F72             6 107 ; check if last speccy move is a winner one
6F72 CD 36 74    6 109 call    PathFinder_Score            ; if (speccy won)
6F75 B7          6 110 or      a
6F76 C2 80 6F    6 111 jp      nz, Alphabeta_Min_Candidates
6F79 3A 9A 61    6 112 ld      a, (AI_DEPTH)
6F7C C6 E0       6 113 add     a, 224                      ;     return 224+depth
6F7E D1          6 114 pop     de
6F7F C9          6 115 ret
6F80             6 117 Alphabeta_Min_Candidates
6F80 CD D9 74    6 118 call    PathFinder_Candidates       ; find candidates for next move
6F83 D1          6 119 pop     de
6F84 DD 7E 00    6 121 ld      a, (ix+0)                   ; A is our first candidate
6F87 21 9A 61    6 123 ld      hl, AI_DEPTH
6F8A 35          6 124 dec     (hl)                        ; depth--
6F8B CA CB 6F    6 125 jp      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
6F8E             6 127 Alphabeta_Min_Loop                                          ; for each candidate {
6F8E D5          6 128 push    de                          ;       store alphaMax and betaMin
6F8F 26 7D       6 130 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F91 6F          6 131 ld      l, a
6F92 E5          6 132 push    hl
6F93 3A 9B 61    6 134 ld      a, (AI_PLAYER)              ;       get speccy side
6F96 EE 7C       6 135 xor     $7C                         ;       switch to player side
6F98 CD B7 70    6 136 call    PathFinder_PutToken         ;       BRAINIAC_play
6F9B CD 0F 70    6 137 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
6F9E E1          6 139 pop     hl                          ;       restore candidate position
6F9F CD BD 70    6 140 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FA2 D1          6 142 pop     de                          ;       restore alphaMax and betaMin
6FA3 BB          6 144 cp      e
6FA4 30 06       6 145 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
6FA6 BA          6 147 cp      d
6FA7 38 12       6 148 jr      c, Alphabeta_Min_Exit
6FA9 28 10       6 149 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FAB 5F          6 151 ld      e, a                        ;       betaMin = A
6FAC             6 153 Alphabeta_Min_Next
6FAC DD 2D       6 154 dec     ixl
6FAE DD 7E 00    6 155 ld      a, (ix+0)                   ;       A is our next candidate
6FB1 B7          6 156 or      a                           ;       repeat until no more candidates
6FB2 C2 8E 6F    6 157 jp      nz, Alphabeta_Min_Loop      ; }
6FB5 7B          6 159 ld      a, e                        ; return betaMin
6FB6 21 9A 61    6 161 ld      hl, AI_DEPTH
6FB9 34          6 162 inc     (hl)                        ; depth++
6FBA C9          6 163 ret
6FBB             6 165 Alphabeta_Min_Exit
6FBB 5F          6 166 ld      e, a                        ; (discard remaining candidates)
6FBC AF          6 167 xor     a
6FBD             6 168 Alphabeta_Min_Skip
6FBD DD 2D       6 169 dec     ixl
6FBF DD BE 00    6 170 cp      (ix+0)
6FC2 C2 BD 6F    6 171 jp      nz, Alphabeta_Min_Skip
6FC5 7B          6 172 ld      a, e
6FC6 21 9A 61    6 174 ld      hl, AI_DEPTH
6FC9 34          6 175 inc     (hl)                        ; (depth++)
6FCA C9          6 176 ret
6FCB             6 178 ; ----------------------------------------------------------------------------------------------------------------------
6FCB             6 179 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
6FCB             6 180 ; beta pruning, when it requires MINIMIZING Speccy's score.
6FCB             6 181 ;
6FCB             6 182 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
6FCB             6 183 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
6FCB             6 184 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
6FCB             6 185 ; faster.
6FCB             6 186 ;
6FCB             6 187 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FCB             6 188 ;
6FCB             6 189 ; Input:    A = first candidate
6FCB             6 190 ;           D = alphaMax
6FCB             6 191 ;           E = betaMin
6FCB             6 192 ;
6FCB             6 193 ; Output:   A = "improved" betaMin
6FCB             6 194 ;           D = alphaMax
6FCB             6 195 ;           E = "improved" betaMin
6FCB             6 196 ;
6FCB             6 197 ; Uses:     AI_PLAYER (speccy side)
6FCB             6 198 ;           AI_DEPTH (recursion depth level)
6FCB             6 199 ;
6FCB             6 200 ; Destroys: BC, HL, IX, IY
6FCB             6 201 ; ----------------------------------------------------------------------------------------------------------------------
6FCB             6 202 Heuristic_Min:                                              ; for each candidate {
6FCB D5          6 203 push    de                          ;       store alphaMax and betaMin
6FCC 26 7D       6 205 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FCE 6F          6 206 ld      l, a
6FCF E5          6 207 push    hl
6FD0 3A 9B 61    6 209 ld      a, (AI_PLAYER)              ;       get speccy side
6FD3 EE 7C       6 210 xor     $7C                         ;       switch to player side
6FD5 CD B7 70    6 211 call    PathFinder_PutToken         ;       BRAINIAC_play
6FD8 CD 36 74    6 213 call    PathFinder_Score            ;       if (player won)
6FDB FE FF       6 214 cp      -1
6FDD C2 E2 6F    6 215 jp      nz, Heuristic_Min_Continue
6FE0 3E 20       6 216 ld      a, 32                       ;           A = 32
6FE2             6 217 Heuristic_Min_Continue
6FE2 E1          6 218 pop     hl
6FE3 CD BD 70    6 219 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FE6 D1          6 221 pop     de
6FE7 BB          6 223 cp      e
6FE8 30 06       6 224 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
6FEA BA          6 226 cp      d
6FEB 38 12       6 227 jr      c, Heuristic_Min_Exit
6FED 28 10       6 228 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FEF 5F          6 230 ld      e, a                        ;       betaMin = A
6FF0             6 232 Heuristic_Min_Next
6FF0 DD 2D       6 233 dec     ixl
6FF2 DD 7E 00    6 234 ld      a, (ix+0)                   ;       A is our next candidate
6FF5 B7          6 235 or      a                           ;       repeat until no more candidates
6FF6 C2 CB 6F    6 236 jp      nz, Heuristic_Min           ; }
6FF9 7B          6 238 ld      a, e                        ; return betaMin
6FFA 21 9A 61    6 240 ld      hl, AI_DEPTH
6FFD 34          6 241 inc     (hl)                        ; depth++
6FFE C9          6 242 ret
6FFF             6 244 Heuristic_Min_Exit
6FFF 5F          6 245 ld      e, a                        ; (discard remaining candidates)
7000 AF          6 246 xor     a
7001             6 247 Heuristic_Min_Skip
7001 DD 2D       6 248 dec     ixl
7003 DD BE 00    6 249 cp      (ix+0)
7006 C2 01 70    6 250 jp      nz, Heuristic_Min_Skip
7009 7B          6 251 ld      a, e
700A 21 9A 61    6 253 ld      hl, AI_DEPTH
700D 34          6 254 inc     (hl)                        ; (depth++)
700E C9          6 255 ret
700F             6 257 ; ----------------------------------------------------------------------------------------------------------------------
700F             6 258 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
700F             6 259 ; Speccy's score.
700F             6 260 ;
700F             6 261 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
700F             6 262 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
700F             6 263 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
700F             6 264 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
700F             6 265 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
700F             6 266 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
700F             6 267 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
700F             6 268 ; the same score and could be just reproducing the best score from its sibling.
700F             6 269 ;
700F             6 270 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
700F             6 271 ;
700F             6 272 ; Input:    A   = speccy side (FRIEND or ENEMY)
700F             6 273 ;           D   = alphaMax
700F             6 274 ;           E   = betaMin
700F             6 275 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
700F             6 276 ;
700F             6 277 ; Output:   A = "improved" alphaMax
700F             6 278 ;           D = "improved" alphaMax
700F             6 279 ;           E = betaMin
700F             6 280 ;
700F             6 281 ; Uses:     AI_PLAYER (speccy side)
700F             6 282 ;           AI_DEPTH (recursion depth level)
700F             6 283 ;
700F             6 284 ; Destroys: BC, HL, IX, IY
700F             6 285 ; ----------------------------------------------------------------------------------------------------------------------
700F             6 286 Alphabeta_Max:
700F D5          6 287 push    de
7010             6 289 ; check if last player move is a winner one
7010 CD 36 74    6 291 call    PathFinder_Score            ; if (player won)
7013 FE FF       6 292 cp      -1
7015 C2 20 70    6 293 jp      nz, Alphabeta_Max_Candidates
7018 3A 9A 61    6 294 ld      a, (AI_DEPTH)
701B 2F          6 295 cpl
701C C6 21       6 296 add     a, 32+1                     ;     return 32-depth
701E D1          6 297 pop     de
701F C9          6 298 ret
7020             6 300 Alphabeta_Max_Candidates
7020 CD D9 74    6 301 call    PathFinder_Candidates       ; find candidates for next move
7023 D1          6 302 pop     de
7024 DD 7E 00    6 304 ld      a, (ix+0)                   ; A is our first candidate
7027 21 9A 61    6 306 ld      hl, AI_DEPTH
702A 35          6 307 dec     (hl)                        ; depth--
702B CA 6B 70    6 308 jp      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
702E             6 310 Alphabeta_Max_Loop                                          ; for each candidate {
702E D5          6 311 push    de                          ;       store alphaMax and betaMin
702F 26 7D       6 313 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7031 6F          6 314 ld      l, a
7032 E5          6 315 push    hl
7033 3A 9B 61    6 317 ld      a, (AI_PLAYER)              ;       get speccy side
7036 CD B7 70    6 318 call    PathFinder_PutToken         ;       BRAINIAC_play
7039 EE 7C       6 319 xor     $7C                         ;       restore speccy side
703B CD 71 6F    6 320 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
703E E1          6 322 pop     hl                          ;       restore candidate position
703F CD BD 70    6 323 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7042 D1          6 325 pop     de                          ;       restore alphaMax and betaMin
7043 BA          6 327 cp      d
7044 38 06       6 328 jr      c, Alphabeta_Max_Next
7046 28 04       6 329 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
7048 BB          6 331 cp      e
7049 30 10       6 332 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
704B 57          6 334 ld      d, a                        ;       alphaMax = A
704C             6 336 Alphabeta_Max_Next
704C DD 2D       6 337 dec     ixl
704E DD 7E 00    6 338 ld      a, (ix+0)                   ;       A is our next candidate
7051 B7          6 339 or      a                           ;       repeat until no more candidates
7052 C2 2E 70    6 340 jp      nz, Alphabeta_Max_Loop      ; }
7055 7A          6 342 ld      a, d                        ; return alphaMax
7056 21 9A 61    6 344 ld      hl, AI_DEPTH
7059 34          6 345 inc     (hl)                        ; depth++
705A C9          6 346 ret
705B             6 348 Alphabeta_Max_Exit
705B 57          6 349 ld      d, a                        ; (discard remaining candidates)
705C AF          6 350 xor     a
705D             6 351 Alphabeta_Max_Skip
705D DD 2D       6 352 dec     ixl
705F DD BE 00    6 353 cp      (ix+0)
7062 C2 5D 70    6 354 jp      nz, Alphabeta_Max_Skip
7065 7A          6 355 ld      a, d
7066 21 9A 61    6 357 ld      hl, AI_DEPTH
7069 34          6 358 inc     (hl)                        ; (depth++)
706A C9          6 359 ret
706B             6 361 ; ----------------------------------------------------------------------------------------------------------------------
706B             6 362 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
706B             6 363 ; beta pruning, when it requires MAXIMIZING Speccy's score.
706B             6 364 ;
706B             6 365 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
706B             6 366 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
706B             6 367 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
706B             6 368 ; faster.
706B             6 369 ;
706B             6 370 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
706B             6 371 ;
706B             6 372 ; Input:    A = first candidate
706B             6 373 ;           D = alphaMax
706B             6 374 ;           E = betaMin
706B             6 375 ;
706B             6 376 ; Returns:  A = "improved" alphaMax
706B             6 377 ;           D = "improved" alphaMax
706B             6 378 ;           E = betaMin
706B             6 379 ;
706B             6 380 ; Uses:     AI_PLAYER (speccy side)
706B             6 381 ;           AI_DEPTH (recursion depth level)
706B             6 382 ;
706B             6 383 ; Destroys: BC, HL, IX, IY
706B             6 384 ; ----------------------------------------------------------------------------------------------------------------------
706B             6 385 Heuristic_Max:                                              ; for each candidate {
706B D5          6 386 push    de                          ;       store alphaMax and betaMin
706C 26 7D       6 388 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
706E 6F          6 389 ld      l, a
706F E5          6 390 push    hl
7070 3A 9B 61    6 392 ld      a, (AI_PLAYER)              ;       get speccy side
7073 CD B7 70    6 393 call    PathFinder_PutToken         ;       (BRAINIAC_play)
7076 EE 7C       6 394 xor     $7C                         ;       restore speccy side
7078 CD 36 74    6 396 call    PathFinder_Score            ;       if (speccy won)
707B B7          6 397 or      a
707C C2 81 70    6 398 jp      nz, Heuristic_Max_Continue
707F 3E E0       6 399 ld      a, 224                      ;           A = 224
7081             6 400 Heuristic_Max_Continue
7081 E1          6 401 pop     hl                          ;       restore candidate position
7082 CD BD 70    6 402 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7085 D1          6 404 pop     de                          ;       restore alphaMax and betaMin
7086 BA          6 406 cp      d
7087 38 06       6 407 jr      c, Heuristic_Max_Next
7089 28 04       6 408 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
708B BB          6 410 cp      e
708C 30 10       6 411 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
708E 57          6 413 ld      d, a                        ;       alphaMax = A
708F             6 415 Heuristic_Max_Next
708F DD 2D       6 416 dec     ixl
7091 DD 7E 00    6 417 ld      a, (ix+0)                   ;       A is our next candidate
7094 B7          6 418 or      a                           ;       repeat until no more candidates
7095 C2 6B 70    6 419 jp      nz, Heuristic_Max           ; }
7098 7A          6 421 ld      a, d                        ; return alphaMax
7099 21 9A 61    6 423 ld      hl, AI_DEPTH
709C 34          6 424 inc     (hl)                        ; depth++
709D C9          6 425 ret
709E             6 427 Heuristic_Max_Exit
709E 57          6 428 ld      d, a                        ; (discard remaining candidates)
709F AF          6 429 xor     a
70A0             6 430 Heuristic_Max_Skip
70A0 DD 2D       6 431 dec     ixl
70A2 DD BE 00    6 432 cp      (ix+0)
70A5 C2 A0 70    6 433 jp      nz, Heuristic_Max_Skip
70A8 7A          6 434 ld      a, d
70A9 21 9A 61    6 436 ld      hl, AI_DEPTH
70AC 34          6 437 inc     (hl)                        ; (depth++)
70AD C9          6 438 ret

; File #7: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\PathFinder.z80asm

70AE             7 1 ; ----------------------------------------------------------------------------------------------------------------------
70AE             7 2 ; PathFinder.z80asm
70AE             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
70AE             7 4 ;
70AE             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
70AE             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
70AE             7 7 ; ----------------------------------------------------------------------------------------------------------------------
70AE             7 9 EMPTY                   EQU     $00                         ; empty positions on the board
70AE             7 10 SKIPPED                 EQU     $01                         ; skipped positions on the board
70AE             7 11 FRIEND                  EQU     $02                         ; positions occupied by friendly tokens on the board
70AE             7 12 ENEMY                   EQU     $7E                         ; positions occupied by opponent tokens on the board
70AE             7 13 VICTORY                 EQU     $03                         ; internal value if victory
70AE             7 14 WIDTH                   EQU     $08                         ; distance to up-left/down-right neighbor
70AE             7 16 CYAN_POSITIONS          EQU     $7D00                       ; a 256-aligned memory area reserved for cyan positions
70AE             7 17 RED_POSITIONS           EQU     $7E00                       ; a 256-aligned memory area reserved for red positions
70AE             7 18 CANDIDATES              EQU     $7F00                       ; a 256-aligned memory area reserved to store candidates
70AE             7 20 ; ----------------------------------------------------------------------------------------------------------------------
70AE             7 21 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
70AE             7 22 ;
70AE             7 23 ; Input:    -
70AE             7 24 ;
70AE             7 25 ; Output:   A   = FRIEND if current token color is cyan, or A = ENEMY if current token color is red
70AE             7 26 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70AE             7 27 ;
70AE             7 28 ; Uses:     TOKEN_COLOR (current token color)
70AE             7 29 ;
70AE             7 30 ; Destroys: -
70AE             7 31 ; ----------------------------------------------------------------------------------------------------------------------
70AE             7 32 PathFinder_Friend:
70AE 3A 9E 61    7 33 ld      a, (TOKEN_COLOR)            ; get current player color
70B1 EE 07       7 34 xor     $07                         ; is current player color cyan?
70B3 E0          7 35 ret     po                          ; yes, return FRIEND 
70B4 3E 7E       7 36 ld      a, ENEMY                    ; no, return ENEMY
70B6 C9          7 37 ret
70B7             7 39 ; ----------------------------------------------------------------------------------------------------------------------
70B7             7 40 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
70B7             7 41 ;
70B7             7 42 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
70B7             7 43 ;           HL = CYAN_POSITIONS token address
70B7             7 44 ;
70B7             7 45 ; Output:   A   = inverted side (FRIEND or ENEMY)
70B7             7 46 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70B7             7 47 ;
70B7             7 48 ; Destroys: -
70B7             7 49 ; ----------------------------------------------------------------------------------------------------------------------
70B7             7 50 PathFinder_PutToken:
70B7 77          7 51 ld      (hl), a                     ; put token at cyan position
70B8 24          7 52 inc     h                           ; move HL to red position address
70B9 EE 7C       7 53 xor     $7C                         ; invert side
70BB 77          7 54 ld      (hl), a                     ; put token at red position
70BC C9          7 55 ret
70BD             7 57 ; ----------------------------------------------------------------------------------------------------------------------
70BD             7 58 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
70BD             7 59 ;
70BD             7 60 ; Input:    HL = CYAN_POSITIONS token address
70BD             7 61 ;
70BD             7 62 ; Output:   -
70BD             7 63 ;
70BD             7 64 ; Destroys: -
70BD             7 65 ; ----------------------------------------------------------------------------------------------------------------------
70BD             7 66 PathFinder_EraseToken:
70BD 36 00       7 67 ld      (hl), EMPTY                 ; erase token at cyan position
70BF 24          7 68 inc     h                           ; move HL to red position address
70C0 36 00       7 69 ld      (hl), EMPTY                 ; erase token at red position
70C2 C9          7 70 ret
70C3             7 72 ; ----------------------------------------------------------------------------------------------------------------------
70C3             7 73 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
70C3             7 74 ;
70C3             7 75 ; Input:    DE = cyan or red board address (destiny)
70C3             7 76 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
70C3             7 77 ;
70C3             7 78 ; Output:   DE = cyan or red board address (last position+1)
70C3             7 79 ;
70C3             7 80 ; Destroys: BC, HL
70C3             7 81 ; ----------------------------------------------------------------------------------------------------------------------
70C3             7 82 PathFinder_CopyPositions:
70C3 01 31 00    7 83 ld      bc, 7*7                     ; number of positions to be copied
70C6             7 84 PathFinder_CopyLoop
70C6 2C          7 85 inc     l                           ; skip borders on positions
70C7 2C          7 86 inc     l
70C8 1C          7 87 inc     e                           ; skip borders on board
70C9 1C          7 88 inc     e
70CA ED A0       7 89 ldi                                 ; copy a row of 7 positions
70CC ED A0       7 90 ldi
70CE ED A0       7 91 ldi
70D0 ED A0       7 92 ldi
70D2 ED A0       7 93 ldi
70D4 ED A0       7 94 ldi
70D6 ED A0       7 95 ldi
70D8 EA C6 70    7 96 jp      pe, PathFinder_CopyLoop     ; repeat for each row
70DB C9          7 97 ret
70DC             7 99 ; ----------------------------------------------------------------------------------------------------------------------
70DC             7 100 ; PathFinder_Update: update current board position during heuristic function evaluation
70DC             7 101 ;
70DC             7 102 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
70DC             7 103 ; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
70DC             7 104 ; adjacent".
70DC             7 105 ;
70DC             7 106 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
70DC             7 107 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
70DC             7 108 ; follows, depending on current content:
70DC             7 109 ;
70DC             7 110 ; * SKIPPED: 1 + distance of neighbor closest to goal
70DC             7 111 ; * FRIEND:  distance of neighbor closest to goal
70DC             7 112 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
70DC             7 113 ;
70DC             7 114 ; Input:    Z    = flag set when (HL) is FRIEND
70DC             7 115 ;           C    = current distance (also with a flag at 6th bit that indicates a friendly position)
70DC             7 116 ;           HL   = current position address (on either cyan boards or red boards)
70DC             7 117 ;           SP+2 = queue head address (on either cyan queue or red queue areas)
70DC             7 118 ;
70DC             7 119 ; Output:   -
70DC             7 120 ;
70DC             7 121 ; Destroys: B, DE
70DC             7 122 ; ----------------------------------------------------------------------------------------------------------------------
70DC             7 123 PathFinder_Update:
70DC 28 12       7 124 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
70DE 46          7 125 ld      b, (hl)                     ; check current position
70DF 10 1A       7 126 djnz    PathFinder_EMPTY            ; if (hl) = EMPTY, jump below
70E1             7 127 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
70E1             7 128 PathFinder_Skipped:
70E1 71          7 129 ld      (hl), c                     ; save current distance in current position
70E2 34          7 130 inc     (hl)                        ; increment distance of current position
70E3 CB B6       7 131 res     6, (hl)                     ; reset friendly token flag
70E5 EB          7 132 ex      de, hl                      ; store current position in DE
70E6             7 133 @Queue_Tail
70E6 21 00 00    7 134 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
70E9 2C          7 135 inc     l                           ; move queue tail down
70EA 73          7 136 ld      (hl), e                     ; store position into queue tail
70EB 22 E7 70    7 137 ld      (@Queue_Tail+1), hl         ; update queue tail
70EE EB          7 138 ex      de, hl                      ; restore current position
70EF C9          7 139 ret
70F0             7 140 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
70F0             7 141 PathFinder_Friendly
70F0 71          7 142 ld      (hl), c                     ; save current distance in current position
70F1 CB F6       7 143 set     6, (hl)                     ; set friendly token flag
70F3 45          7 144 ld      b, l                        ; save current position in B
70F4 D1          7 145 pop     de                          ; preserve RET address
70F5 E3          7 146 ex      (sp), hl                    ; retrieve queue head
70F6 70          7 147 ld      (hl), b                     ; push this position into queue head
70F7 2D          7 148 dec     l                           ; move queue head up
70F8 E3          7 149 ex      (sp), hl                    ; update queue head
70F9 D5          7 150 push    de                          ; restore RET address
70FA C9          7 151 ret
70FB             7 152 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
70FB             7 153 PathFinder_EMPTY
70FB CB 71       7 154 bit     6, c                        ; is current distance friendly?
70FD 20 E2       7 155 jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
70FF 34          7 156 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
7100 C9          7 157 ret
7101             7 159 ; ----------------------------------------------------------------------------------------------------------------------
7101             7 160 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7101             7 161 ;
7101             7 162 ; Input:    -
7101             7 163 ;
7101             7 164 ; Output:   A  = -1, if down edge couldn't be reached
7101             7 165 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
7101             7 166 ;           A  = last edge position visited (-1), otherwise
7101             7 167 ;           HL = cyan queue head address
7101             7 168 ;
7101             7 169 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7101             7 170 ;
7101             7 171 ; Destroys: BC, DE, IY
7101             7 172 ; ----------------------------------------------------------------------------------------------------------------------
7101             7 173 PathFinder_Cyan_UpDown:
7101 21 07 7D    7 174 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7104 11 07 61    7 175 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
7107 CD C3 70    7 176 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
710A             7 178 ; entry point for PathFinder_VictoryPath
710A             7 179 PathFinder_Cyan_CheckPath:
710A FD 21 00 09 7 180 ld      iy, $0900                   ; IYH = distance to check edge positions
710E             7 181 ; IYL = last edge position visited
710E 26 60       7 182 ld      h, CYAN_QUEUE_AREA/256      ; HL points to cyan queue area address
7110 22 E7 70    7 183 ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
7113 E5          7 184 push    hl                          ; store cyan queue head
7114             7 186 ; set up cyan board (up-down) start positions distances
7114 21 09 61    7 188 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7117 0E 43       7 189 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7119 3E 02       7 190 ld      a, FRIEND                   ; set distance to compare with
711B BE          7 191 cp      (hl)                        ; check 1st start position distance
711C D4 DC 70    7 192 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
711F 2C          7 193 inc     l                           ; move HL to next start position address
7120 BE          7 194 cp      (hl)                        ; check 2nd start position distance
7121 D4 DC 70    7 195 call    nc, PathFinder_Update       ; (repeat for each start position)
7124 2C          7 196 inc     l
7125 BE          7 197 cp      (hl)                        ; check 3rd start position distance
7126 D4 DC 70    7 198 call    nc, PathFinder_Update
7129 2C          7 199 inc     l
712A BE          7 200 cp      (hl)                        ; check 4th start position distance
712B D4 DC 70    7 201 call    nc, PathFinder_Update
712E 2C          7 202 inc     l
712F BE          7 203 cp      (hl)                        ; check 5th start position distance
7130 D4 DC 70    7 204 call    nc, PathFinder_Update
7133 2C          7 205 inc     l
7134 BE          7 206 cp      (hl)                        ; check 6th start position distance
7135 D4 DC 70    7 207 call    nc, PathFinder_Update
7138 2C          7 208 inc     l
7139 C3 25 72    7 209 jp      PathFinder_First            ; calculate two-distances of cyan board (up-down)
713C             7 211 ; ----------------------------------------------------------------------------------------------------------------------
713C             7 212 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
713C             7 213 ;
713C             7 214 ; Input:    -
713C             7 215 ;
713C             7 216 ; Output:   A  = -1, if up edge couldn't be reached
713C             7 217 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
713C             7 218 ;           A  = last edge position visited (-1), otherwise
713C             7 219 ;           HL = cyan queue head address
713C             7 220 ;
713C             7 221 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
713C             7 222 ;
713C             7 223 ; Destroys: BC, DE, IY
713C             7 224 ; ----------------------------------------------------------------------------------------------------------------------
713C             7 225 PathFinder_Cyan_DownUp:
713C 21 07 7D    7 226 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
713F 11 4F 61    7 227 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
7142 CD C3 70    7 228 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
7145 FD 21 00 F7 7 230 ld      iy, $F700                   ; IYH = distance to check edge positions
7149             7 231 ; IYL = last edge position visited
7149 2A E7 70    7 232 ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
714C E5          7 233 push    hl                          ; initialize cyan queue head
714D             7 235 ; set up cyan board (down-up) start positions distances
714D EB          7 237 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
714E 2D          7 238 dec     l                           ; move HL to cyan boad down-up address (last position)
714F 0E 43       7 239 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7151 3E 02       7 240 ld      a, FRIEND                   ; set distance to compare with
7153 BE          7 241 cp      (hl)                        ; check 1st start position distance
7154 D4 DC 70    7 242 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7157 2D          7 243 dec     l                           ; move HL to next start position address
7158 BE          7 244 cp      (hl)                        ; check 2nd start position distance
7159 D4 DC 70    7 245 call    nc, PathFinder_Update       ; (repeat for each start position)
715C 2D          7 246 dec     l
715D BE          7 247 cp      (hl)                        ; check 3rd start position distance
715E D4 DC 70    7 248 call    nc, PathFinder_Update
7161 2D          7 249 dec     l
7162 BE          7 250 cp      (hl)                        ; check 4th start position distance
7163 D4 DC 70    7 251 call    nc, PathFinder_Update
7166 2D          7 252 dec     l
7167 BE          7 253 cp      (hl)                        ; check 5th start position distance
7168 D4 DC 70    7 254 call    nc, PathFinder_Update
716B 2D          7 255 dec     l
716C BE          7 256 cp      (hl)                        ; check 6th start position distance
716D D4 DC 70    7 257 call    nc, PathFinder_Update
7170 2D          7 258 dec     l
7171 C3 25 72    7 259 jp      PathFinder_First            ; calculate two-distances of cyan board (down-up)
7174             7 261 ; ----------------------------------------------------------------------------------------------------------------------
7174             7 262 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
7174             7 263 ;
7174             7 264 ; Input:    -
7174             7 265 ;
7174             7 266 ; Output:   A  = -1, if right edge couldn't be reached
7174             7 267 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
7174             7 268 ;           A  = last edge position visited (-1), otherwise
7174             7 269 ;           HL = red queue head address
7174             7 270 ;
7174             7 271 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7174             7 272 ;
7174             7 273 ; Destroys: BC, DE, IY
7174             7 274 ; ----------------------------------------------------------------------------------------------------------------------
7174             7 275 PathFinder_Red_LeftRight:
7174 21 07 7E    7 276 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
7177 11 07 64    7 277 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
717A CD C3 70    7 278 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
717D             7 280 ; entry point for PathFinder_VictoryPath
717D             7 281 PathFinder_Red_CheckPath
717D FD 21 00 01 7 282 ld      iy, $0100                   ; IYH = distance to check edge positions
7181             7 283 ; IYL = last edge position visited
7181 26 63       7 284 ld      h, RED_QUEUE_AREA/256       ; HL points to red queue area address
7183 22 E7 70    7 285 ld      (@Queue_Tail+1), hl         ; initialize red queue tail
7186 E5          7 286 push    hl                          ; store red queue head
7187             7 288 ; set up red board (left-right) start positions distances
7187 21 09 64    7 290 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
718A 0E 43       7 291 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
718C 3E 02       7 292 ld      a, FRIEND                   ; set distance to compare with
718E BE          7 293 cp      (hl)                        ; check 1st start position distance
718F D4 DC 70    7 294 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7192 2E 12       7 295 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
7194 BE          7 296 cp      (hl)                        ; check 2nd start position distance
7195 D4 DC 70    7 297 call    nc, PathFinder_Update       ; (repeat for each start position)
7198 2E 1B       7 298 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
719A BE          7 299 cp      (hl)                        ; check 3rd start position distance
719B D4 DC 70    7 300 call    nc, PathFinder_Update
719E 2E 24       7 301 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
71A0 BE          7 302 cp      (hl)                        ; check 4th start position distance
71A1 D4 DC 70    7 303 call    nc, PathFinder_Update
71A4 2E 2D       7 304 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
71A6 BE          7 305 cp      (hl)                        ; check 5th start position distance
71A7 D4 DC 70    7 306 call    nc, PathFinder_Update
71AA 2E 36       7 307 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
71AC BE          7 308 cp      (hl)                        ; check 6th start position distance
71AD D4 DC 70    7 309 call    nc, PathFinder_Update
71B0 2E 3F       7 310 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
71B2 C3 25 72    7 311 jp      PathFinder_First            ; calculate two-distances of red board (left-right)
71B5             7 313 ; ----------------------------------------------------------------------------------------------------------------------
71B5             7 314 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
71B5             7 315 ;
71B5             7 316 ; Input:    -
71B5             7 317 ;
71B5             7 318 ; Output:   A  = -1, if left edge couldn't be reached
71B5             7 319 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
71B5             7 320 ;           A  = last edge position visited (-1), otherwise
71B5             7 321 ;           HL = red queue head address
71B5             7 322 ;
71B5             7 323 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71B5             7 324 ;
71B5             7 325 ; Destroys: BC, DE, IY
71B5             7 326 ; ----------------------------------------------------------------------------------------------------------------------
71B5             7 327 PathFinder_Red_RightLeft:
71B5 21 07 7E    7 328 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71B8 11 4F 64    7 329 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
71BB CD C3 70    7 330 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
71BE FD 21 00 FF 7 332 ld      iy, $FF00                   ; IYH = distance to check edge positions
71C2             7 333 ; IYL = last edge position visited
71C2 2A E7 70    7 334 ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
71C5 E5          7 335 push    hl                          ; initialize red queue head
71C6             7 337 ; set up red board (right-left) start positions distances
71C6 EB          7 339 ex      de, hl                      ; take advantage of last "CopyPositions" execution
71C7 2D          7 340 dec     l                           ; move HL to red board right-left address (last position)
71C8 0E 43       7 341 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71CA 3E 02       7 342 ld      a, FRIEND                   ; set distance to compare with
71CC BE          7 343 cp      (hl)                        ; check 1st start position distance
71CD D4 DC 70    7 344 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71D0 2E 84       7 345 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
71D2 BE          7 346 cp      (hl)                        ; check 2nd start position distance
71D3 D4 DC 70    7 347 call    nc, PathFinder_Update       ; (repeat for each start position)
71D6 2E 7B       7 348 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
71D8 BE          7 349 cp      (hl)                        ; check 3rd start position distance
71D9 D4 DC 70    7 350 call    nc, PathFinder_Update
71DC 2E 72       7 351 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
71DE BE          7 352 cp      (hl)                        ; check 4th start position distance
71DF D4 DC 70    7 353 call    nc, PathFinder_Update
71E2 2E 69       7 354 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
71E4 BE          7 355 cp      (hl)                        ; check 5th start position distance
71E5 D4 DC 70    7 356 call    nc, PathFinder_Update
71E8 2E 60       7 357 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
71EA BE          7 358 cp      (hl)                        ; check 6th start position distance
71EB D4 DC 70    7 359 call    nc, PathFinder_Update
71EE 2E 57       7 360 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
71F0 C3 25 72    7 361 jp      PathFinder_First            ; calculate red two-distance (right-left)
71F3             7 363 ; ----------------------------------------------------------------------------------------------------------------------
71F3             7 364 ; PathFinder: calculate two-distance metric for each board position
71F3             7 365 ;
71F3             7 366 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
71F3             7 367 ;
71F3             7 368 ; Input:    HL  = cyan or red queue area address
71F3             7 369 ;           IYH = distance to check edge positions
71F3             7 370 ;           IYL = 0
71F3             7 371 ;
71F3             7 372 ; Output:   A   = -1, if corresponding edge couldn't be reached
71F3             7 373 ;           A   =  0, if there is chain of connected (color) tokens between the two edges
71F3             7 374 ;           A   = last edge position visited (-1), otherwise
71F3             7 375 ;           HL  = cyan or red queue head address
71F3             7 376 ;
71F3             7 377 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71F3             7 378 ;
71F3             7 379 ; Destroys: BC, DE, IY
71F3             7 380 ; ----------------------------------------------------------------------------------------------------------------------
71F3             7 381 PathFinder:
71F3 2C          7 382 inc     l                           ; move queue head down
71F4 E5          7 383 push    hl                          ; preserve queue head address
71F5 6E          7 384 ld      l, (hl)                     ; retrieve next position to be checked
71F6 24          7 385 inc     h                           ; move HL to corresponding board address
71F7 4E          7 386 ld      c, (hl)                     ; retrieve distance from this position to start
71F8 5D          7 387 ld      e, l                        ; store current position
71F9             7 389 ; look for adjacent positions
71F9 7D          7 391 ld      a, l                        ; get current position
71FA FD 84       7 392 add     a, iyh                      ; add distance to check edge positions
71FC 6F          7 393 ld      l, a                        ; move HL to calculated position address
71FD CB 7E       7 394 bit     7, (hl)                     ; is it an edge?
71FF 20 34       7 395 jr      nz, PathFinder_Adjacent     ; yes, update adjacent positions
7201 3E 02       7 397 ld      a, FRIEND                   ; set distance to compare with
7203             7 398 ; return point from PathFinder_Adjacent
7203             7 399 PathFinder_Neighbors
7203 6B          7 400 ld      l, e                        ; restore current position to be checked
7204 2C          7 401 inc     l                           ; move HL to right neighbor address
7205 BE          7 402 cp      (hl)                        ; check right neighbor distance
7206 D4 DC 70    7 403 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7209 2D          7 404 dec     l                           ; move HL to left neighbor address
720A 2D          7 405 dec     l
720B BE          7 406 cp      (hl)                        ; check left neighbor distance
720C D4 DC 70    7 407 call    nc, PathFinder_Update       ; (repeat for each neighbor)
720F 11 F8 FF    7 408 ld      de, -WIDTH
7212 19          7 409 add     hl, de
7213 BE          7 410 cp      (hl)                        ; check upper-left neighbor distance
7214 D4 DC 70    7 411 call    nc, PathFinder_Update
7217 2C          7 412 inc     l
7218 BE          7 413 cp      (hl)                        ; check upper-right neighbor distance
7219 D4 DC 70    7 414 call    nc, PathFinder_Update
721C 11 10 00    7 415 ld      de, WIDTH*2
721F 19          7 416 add     hl, de
7220 BE          7 417 cp      (hl)                        ; check lower-left neighbor distance
7221 D4 DC 70    7 418 call    nc, PathFinder_Update
7224 2C          7 419 inc     l
7225             7 420 PathFinder_First
7225 BE          7 421 cp      (hl)                        ; check lower-right neighbor distance
7226 D4 DC 70    7 422 call    nc, PathFinder_Update
7229 E1          7 423 pop     hl                          ; retreive queue head address
722A 3A E7 70    7 424 ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
722D BD          7 425 cp      l                           ; is queue empty?
722E C2 F3 71    7 426 jp      nz, PathFinder              ; no, repeat until queue is empty
7231 FD 7D       7 428 ld      a, iyl                      ; get last edge position visited
7233 3D          7 429 dec     a                           ; return A = -1, if the edge couldn't be reached
7234 C9          7 430 ret
7235             7 432 ; ----------------------------------------------------------------------------------------------------------------------
7235             7 433 ; PathFinder_Adjacent: update adjacent positions
7235             7 434 ;
7235             7 435 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
7235             7 436 ; "two cells are adjacent if they share a common edge on the board."
7235             7 437 ;
7235             7 438 ; Input:    E  = current position
7235             7 439 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
7235             7 440 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
7235             7 441 ;                edge number)
7235             7 442 ;
7235             7 443 ; Output:   A  = 0 and HL = cyan or red queue head address, if there is a chain of connected tokens of the same color
7235             7 444 ;                between the two edges.
7235             7 445 ;           A  = FRIEND and E = current position, otherwise.
7235             7 446 ;
7235             7 447 ; Destroys: BC, D
7235             7 448 ; ----------------------------------------------------------------------------------------------------------------------
7235             7 449 PathFinder_Adjacent
7235 3E 43       7 450 ld      a, VICTORY+$40              ; set victory distance + friendly flag
7237 B9          7 451 cp      c                           ; is current distance victory and friendly?
7238 28 0E       7 452 jr      z, PathFinder_Abort         ; yes, abort path_finder
723A FD 6B       7 454 ld      iyl, e                      ; update last edge position visited
723C 54          7 455 ld      d, h                        ; store pointer to current position address in DE
723D 6E          7 456 ld      l, (hl)                     ; get current edge position
723E CB 25       7 457 sla     l                           ; calculate vector table routine index
7240 24          7 458 inc     h                           ; move HL to (cyan or red) vector table routine address
7241 7E          7 459 ld      a, (hl)                     ; get low byte of vector table routine address
7242 2C          7 460 inc     l                           ; move HL to high byte of vector table routine address
7243 66          7 461 ld      h, (hl)                     ; get high byte of vector table routine address
7244 6F          7 462 ld      l, a                        ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
7245 3E 02       7 463 ld      a, FRIEND                   ; set distance to compare with
7247 E9          7 464 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
7248             7 465 PathFinder_Abort
7248 E1          7 466 pop     hl                          ; restore queue head address
7249 AF          7 467 xor     a                           ; return A = 0
724A C9          7 468 ret
724B             7 470 ; ----------------------------------------------------------------------------------------------------------------------
724B             7 471 ;  Update two-distance of RED adjacent positions
724B             7 472 ; ----------------------------------------------------------------------------------------------------------------------
724B             7 473 PathFinder_RED_Edge_0
724B EB          7 474 ex      de, hl                      ; restore pointer to current position address
724C 11 12 00    7 475 ld      de, (WIDTH+1)*2             ; calculate distance to adjacent #2
724F 19          7 476 add     hl, de                      ; move HL to adjacent #2 address
7250 BE          7 477 cp      (hl)                        ; check adjacent #2 distance
7251 D4 DC 70    7 478 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
7254 11 09 00    7 479 ld      de, WIDTH+1                 ; calculate distance to adjacent #3
7257 19          7 480 add     hl, de                      ; move HL to adjacent #3 address
7258 BE          7 481 cp      (hl)                        ; check adjacent #3 distance
7259 D4 DC 70    7 482 call    nc, PathFinder_Update       ; (repeat for each adjacent)
725C 11 09 00    7 483 ld      de, WIDTH+1
725F 19          7 484 add     hl, de
7260 BE          7 485 cp      (hl)                        ; check adjacent #4 distance
7261 D4 DC 70    7 486 call    nc, PathFinder_Update
7264 11 09 00    7 487 ld      de, WIDTH+1
7267 19          7 488 add     hl, de
7268 BE          7 489 cp      (hl)                        ; check adjacent #5 distance
7269 D4 DC 70    7 490 call    nc, PathFinder_Update
726C 11 09 00    7 491 ld      de, WIDTH+1
726F 19          7 492 add     hl, de
7270 BE          7 493 cp      (hl)                        ; check adjacent #6 distance
7271 D4 DC 70    7 494 call    nc, PathFinder_Update
7274 FD 5D       7 495 ld      e, iyl                      ; restore current position
7276 C3 03 72    7 496 jp      PathFinder_Neighbors        ; continue processing neighbors
7279             7 498 PathFinder_RED_Edge_1
7279 EB          7 499 ex      de, hl                      ; restore pointer to current position address
727A 11 12 00    7 500 ld      de, (WIDTH+1)*2
727D 19          7 501 add     hl, de
727E BE          7 502 cp      (hl)                        ; check adjacent #3 distance
727F D4 DC 70    7 503 call    nc, PathFinder_Update
7282 11 09 00    7 504 ld      de, WIDTH+1
7285 19          7 505 add     hl, de
7286 BE          7 506 cp      (hl)                        ; check adjacent #4 distance
7287 D4 DC 70    7 507 call    nc, PathFinder_Update
728A 11 09 00    7 508 ld      de, WIDTH+1
728D 19          7 509 add     hl, de
728E BE          7 510 cp      (hl)                        ; check adjacent #5 distance
728F D4 DC 70    7 511 call    nc, PathFinder_Update
7292 11 09 00    7 512 ld      de, WIDTH+1
7295 19          7 513 add     hl, de
7296 BE          7 514 cp      (hl)                        ; check adjacent #6 distance
7297 D4 DC 70    7 515 call    nc, PathFinder_Update
729A FD 5D       7 516 ld      e, iyl                      ; restore current position
729C C3 03 72    7 517 jp      PathFinder_Neighbors        ; continue processing neighbors
729F             7 519 PathFinder_RED_Edge_2
729F EB          7 520 ex      de, hl                      ; restore pointer to current position address
72A0 11 12 00    7 521 ld      de, (WIDTH+1)*2
72A3 19          7 522 add     hl, de
72A4 BE          7 523 cp      (hl)                        ; check adjacent #4 distance
72A5 D4 DC 70    7 524 call    nc, PathFinder_Update
72A8 11 09 00    7 525 ld      de, WIDTH+1
72AB 19          7 526 add     hl, de
72AC BE          7 527 cp      (hl)                        ; check adjacent #5 distance
72AD D4 DC 70    7 528 call    nc, PathFinder_Update
72B0 11 09 00    7 529 ld      de, WIDTH+1
72B3 19          7 530 add     hl, de
72B4 BE          7 531 cp      (hl)                        ; check adjacent #6 distance
72B5 D4 DC 70    7 532 call    nc, PathFinder_Update
72B8 11 CA FF    7 533 ld      de, -(WIDTH+1)*6
72BB 19          7 534 add     hl, de
72BC BE          7 535 cp      (hl)                        ; check adjacent #0 distance
72BD D4 DC 70    7 536 call    nc, PathFinder_Update
72C0 FD 5D       7 537 ld      e, iyl                      ; restore current position
72C2 C3 03 72    7 538 jp      PathFinder_Neighbors        ; continue processing neighbors
72C5             7 540 PathFinder_RED_Edge_3
72C5 EB          7 541 ex      de, hl                      ; restore pointer to current position address
72C6 11 E5 FF    7 542 ld      de, -(WIDTH+1)*3
72C9 19          7 543 add     hl, de
72CA BE          7 544 cp      (hl)                        ; check adjacent #0 distance
72CB D4 DC 70    7 545 call    nc, PathFinder_Update
72CE 11 09 00    7 546 ld      de, WIDTH+1
72D1 19          7 547 add     hl, de
72D2 BE          7 548 cp      (hl)                        ; check adjacent #1 distance
72D3 D4 DC 70    7 549 call    nc, PathFinder_Update
72D6 11 24 00    7 550 ld      de, (WIDTH+1)*4
72D9 19          7 551 add     hl, de
72DA BE          7 552 cp      (hl)                        ; check adjacent #5 distance
72DB D4 DC 70    7 553 call    nc, PathFinder_Update
72DE 11 09 00    7 554 ld      de, WIDTH+1
72E1 19          7 555 add     hl, de
72E2 BE          7 556 cp      (hl)                        ; check adjacent #6 distance
72E3 D4 DC 70    7 557 call    nc, PathFinder_Update
72E6 FD 5D       7 558 ld      e, iyl                      ; restore current position
72E8 C3 03 72    7 559 jp      PathFinder_Neighbors        ; continue processing neighbors
72EB             7 561 PathFinder_RED_Edge_4
72EB EB          7 562 ex      de, hl                      ; restore pointer to current position address
72EC 11 12 00    7 563 ld      de, (WIDTH+1)*2
72EF 19          7 564 add     hl, de
72F0 BE          7 565 cp      (hl)                        ; check adjacent #6 distance
72F1 D4 DC 70    7 566 call    nc, PathFinder_Update
72F4 11 CA FF    7 567 ld      de, -(WIDTH+1)*6
72F7 19          7 568 add     hl, de
72F8 BE          7 569 cp      (hl)                        ; check adjacent #0 distance
72F9 D4 DC 70    7 570 call    nc, PathFinder_Update
72FC 11 09 00    7 571 ld      de, WIDTH+1
72FF 19          7 572 add     hl, de
7300 BE          7 573 cp      (hl)                        ; check adjacent #1 distance
7301 D4 DC 70    7 574 call    nc, PathFinder_Update
7304 11 09 00    7 575 ld      de, WIDTH+1
7307 19          7 576 add     hl, de
7308 BE          7 577 cp      (hl)                        ; check adjacent #2 distance
7309 D4 DC 70    7 578 call    nc, PathFinder_Update
730C FD 5D       7 579 ld      e, iyl                      ; restore current position
730E C3 03 72    7 580 jp      PathFinder_Neighbors        ; continue processing neighbors
7311             7 582 PathFinder_RED_Edge_5
7311 EB          7 583 ex      de, hl                      ; restore pointer to current position address
7312 11 D3 FF    7 584 ld      de, -(WIDTH+1)*5
7315 19          7 585 add     hl, de
7316 BE          7 586 cp      (hl)                        ; check adjacent #0 distance
7317 D4 DC 70    7 587 call    nc, PathFinder_Update
731A 11 09 00    7 588 ld      de, WIDTH+1
731D 19          7 589 add     hl, de
731E BE          7 590 cp      (hl)                        ; check adjacent #1 distance
731F D4 DC 70    7 591 call    nc, PathFinder_Update
7322 11 09 00    7 592 ld      de, WIDTH+1
7325 19          7 593 add     hl, de
7326 BE          7 594 cp      (hl)                        ; check adjacent #2 distance
7327 D4 DC 70    7 595 call    nc, PathFinder_Update
732A 11 09 00    7 596 ld      de, WIDTH+1
732D 19          7 597 add     hl, de
732E BE          7 598 cp      (hl)                        ; check adjacent #3 distance
732F D4 DC 70    7 599 call    nc, PathFinder_Update
7332 FD 5D       7 600 ld      e, iyl                      ; restore current position
7334 C3 03 72    7 601 jp      PathFinder_Neighbors        ; continue processing neighbors
7337             7 603 PathFinder_RED_Edge_6
7337 EB          7 604 ex      de, hl                      ; restore pointer to current position address
7338 11 CA FF    7 605 ld      de, -(WIDTH+1)*6
733B 19          7 606 add     hl, de
733C BE          7 607 cp      (hl)                        ; check adjacent #0 distance
733D D4 DC 70    7 608 call    nc, PathFinder_Update
7340 11 09 00    7 609 ld      de, WIDTH+1
7343 19          7 610 add     hl, de
7344 BE          7 611 cp      (hl)                        ; check adjacent #1 distance
7345 D4 DC 70    7 612 call    nc, PathFinder_Update
7348 11 09 00    7 613 ld      de, WIDTH+1
734B 19          7 614 add     hl, de
734C BE          7 615 cp      (hl)                        ; check adjacent #2 distance
734D D4 DC 70    7 616 call    nc, PathFinder_Update
7350 11 09 00    7 617 ld      de, WIDTH+1
7353 19          7 618 add     hl, de
7354 BE          7 619 cp      (hl)                        ; check adjacent #3 distance
7355 D4 DC 70    7 620 call    nc, PathFinder_Update
7358 11 09 00    7 621 ld      de, WIDTH+1
735B 19          7 622 add     hl, de
735C BE          7 623 cp      (hl)                        ; check adjacent #4 distance
735D D4 DC 70    7 624 call    nc, PathFinder_Update
7360 FD 5D       7 625 ld      e, iyl                      ; restore current position
7362 C3 03 72    7 626 jp      PathFinder_Neighbors        ; continue processing neighbors
7365             7 628 ; ----------------------------------------------------------------------------------------------------------------------
7365             7 629 ;  Update two-distance of CYAN adjacent positions
7365             7 630 ; ----------------------------------------------------------------------------------------------------------------------
7365             7 631 PathFinder_CYAN_Edge_0
7365 EB          7 632 ex      de, hl                      ; restore pointer to current position address
7366 2C          7 633 inc     l
7367 2C          7 634 inc     l
7368 BE          7 635 cp      (hl)                        ; check adjacent #2 distance
7369 D4 DC 70    7 636 call    nc, PathFinder_Update
736C 2C          7 637 inc     l
736D BE          7 638 cp      (hl)                        ; check adjacent #3 distance
736E D4 DC 70    7 639 call    nc, PathFinder_Update
7371 2C          7 640 inc     l
7372 BE          7 641 cp      (hl)                        ; check adjacent #4 distance
7373 D4 DC 70    7 642 call    nc, PathFinder_Update
7376 2C          7 643 inc     l
7377 BE          7 644 cp      (hl)                        ; check adjacent of edge number 5
7378 D4 DC 70    7 645 call    nc, PathFinder_Update
737B 2C          7 646 inc     l
737C BE          7 647 cp      (hl)                        ; check adjacent of edge number 6
737D D4 DC 70    7 648 call    nc, PathFinder_Update
7380 FD 5D       7 649 ld      e, iyl                      ; restore current position
7382 C3 03 72    7 650 jp      PathFinder_Neighbors        ; continue processing neighbors
7385             7 652 PathFinder_CYAN_Edge_1
7385 EB          7 653 ex      de, hl                      ; restore pointer to current position address
7386 2C          7 654 inc     l
7387 2C          7 655 inc     l
7388 BE          7 656 cp      (hl)                        ; check adjacent #3 distance
7389 D4 DC 70    7 657 call    nc, PathFinder_Update
738C 2C          7 658 inc     l
738D BE          7 659 cp      (hl)                        ; check adjacent #4 distance
738E D4 DC 70    7 660 call    nc, PathFinder_Update
7391 2C          7 661 inc     l
7392 BE          7 662 cp      (hl)                        ; check adjacent #5 distance
7393 D4 DC 70    7 663 call    nc, PathFinder_Update
7396 2C          7 664 inc     l
7397 BE          7 665 cp      (hl)                        ; check adjacent #6 distance
7398 D4 DC 70    7 666 call    nc, PathFinder_Update
739B FD 5D       7 667 ld      e, iyl                      ; restore current position
739D C3 03 72    7 668 jp      PathFinder_Neighbors        ; continue processing neighbors
73A0             7 670 PathFinder_CYAN_Edge_2
73A0 EB          7 671 ex      de, hl                      ; restore pointer to current position address
73A1 2D          7 672 dec     l
73A2 2D          7 673 dec     l
73A3 BE          7 674 cp      (hl)                        ; check adjacent #0 distance
73A4 D4 DC 70    7 675 call    nc, PathFinder_Update
73A7 2C          7 676 inc     l
73A8 2C          7 677 inc     l
73A9 2C          7 678 inc     l
73AA 2C          7 679 inc     l
73AB BE          7 680 cp      (hl)                        ; check adjacent #4 distance
73AC D4 DC 70    7 681 call    nc, PathFinder_Update
73AF 2C          7 682 inc     l
73B0 BE          7 683 cp      (hl)                        ; check adjacent #5 distance
73B1 D4 DC 70    7 684 call    nc, PathFinder_Update
73B4 2C          7 685 inc     l
73B5 BE          7 686 cp      (hl)                        ; check adjacent #6 distance
73B6 D4 DC 70    7 687 call    nc, PathFinder_Update
73B9 FD 5D       7 688 ld      e, iyl                      ; restore current position
73BB C3 03 72    7 689 jp      PathFinder_Neighbors        ; continue processing neighbors
73BE             7 691 PathFinder_CYAN_Edge_3
73BE EB          7 692 ex      de, hl                      ; restore pointer to current position address
73BF 2D          7 693 dec     l
73C0 2D          7 694 dec     l
73C1 2D          7 695 dec     l
73C2 BE          7 696 cp      (hl)                        ; check adjacent #0 distance
73C3 D4 DC 70    7 697 call    nc, PathFinder_Update
73C6 2C          7 698 inc     l
73C7 BE          7 699 cp      (hl)                        ; check adjacent #1 distance
73C8 D4 DC 70    7 700 call    nc, PathFinder_Update
73CB 2C          7 701 inc     l
73CC 2C          7 702 inc     l
73CD 2C          7 703 inc     l
73CE 2C          7 704 inc     l
73CF BE          7 705 cp      (hl)                        ; check adjacent #5 distance
73D0 D4 DC 70    7 706 call    nc, PathFinder_Update
73D3 2C          7 707 inc     l
73D4 BE          7 708 cp      (hl)                        ; check adjacent #6 distance
73D5 D4 DC 70    7 709 call    nc, PathFinder_Update
73D8 FD 5D       7 710 ld      e, iyl                      ; restore current position
73DA C3 03 72    7 711 jp      PathFinder_Neighbors        ; continue processing neighbors
73DD             7 713 PathFinder_CYAN_Edge_4
73DD EB          7 714 ex      de, hl                      ; restore pointer to current position address
73DE 2C          7 715 inc     l
73DF 2C          7 716 inc     l
73E0 BE          7 717 cp      (hl)                        ; check adjacent #6 distance
73E1 D4 DC 70    7 718 call    nc, PathFinder_Update
73E4 2D          7 719 dec     l
73E5 2D          7 720 dec     l
73E6 2D          7 721 dec     l
73E7 2D          7 722 dec     l
73E8 BE          7 723 cp      (hl)                        ; check adjacent #2 distance
73E9 D4 DC 70    7 724 call    nc, PathFinder_Update
73EC 2D          7 725 dec     l
73ED BE          7 726 cp      (hl)                        ; check adjacent #1 distance
73EE D4 DC 70    7 727 call    nc, PathFinder_Update
73F1 2D          7 728 dec     l
73F2 BE          7 729 cp      (hl)                        ; check adjacent #0 distance
73F3 D4 DC 70    7 730 call    nc, PathFinder_Update
73F6 FD 5D       7 731 ld      e, iyl                      ; restore current position
73F8 C3 03 72    7 732 jp      PathFinder_Neighbors        ; continue processing neighbors
73FB             7 734 PathFinder_CYAN_Edge_5
73FB EB          7 735 ex      de, hl                      ; restore pointer to current position address
73FC 2D          7 736 dec     l
73FD 2D          7 737 dec     l
73FE BE          7 738 cp      (hl)                        ; check adjacent #3 distance
73FF D4 DC 70    7 739 call    nc, PathFinder_Update
7402 2D          7 740 dec     l
7403 BE          7 741 cp      (hl)                        ; check adjacent #2 distance
7404 D4 DC 70    7 742 call    nc, PathFinder_Update
7407 2D          7 743 dec     l
7408 BE          7 744 cp      (hl)                        ; check adjacent #1 distance
7409 D4 DC 70    7 745 call    nc, PathFinder_Update
740C 2D          7 746 dec     l
740D BE          7 747 cp      (hl)                        ; check adjacent #0 distance
740E D4 DC 70    7 748 call    nc, PathFinder_Update
7411 FD 5D       7 749 ld      e, iyl                      ; restore current position
7413 C3 03 72    7 750 jp      PathFinder_Neighbors        ; continue processing neighbors
7416             7 752 PathFinder_CYAN_Edge_6
7416 EB          7 753 ex      de, hl                      ; restore pointer to current position address
7417 2D          7 754 dec     l
7418 2D          7 755 dec     l
7419 BE          7 756 cp      (hl)                        ; check adjacent #4 distance
741A D4 DC 70    7 757 call    nc, PathFinder_Update
741D 2D          7 758 dec     l
741E BE          7 759 cp      (hl)                        ; check adjacent #3 distance
741F D4 DC 70    7 760 call    nc, PathFinder_Update
7422 2D          7 761 dec     l
7423 BE          7 762 cp      (hl)                        ; check adjacent #2 distance
7424 D4 DC 70    7 763 call    nc, PathFinder_Update
7427 2D          7 764 dec     l
7428 BE          7 765 cp      (hl)                        ; check adjacent #1 distance
7429 D4 DC 70    7 766 call    nc, PathFinder_Update
742C 2D          7 767 dec     l
742D BE          7 768 cp      (hl)                        ; check adjacent #0 distance
742E D4 DC 70    7 769 call    nc, PathFinder_Update
7431 FD 5D       7 770 ld      e, iyl                      ; restore current position
7433 C3 03 72    7 771 jp      PathFinder_Neighbors        ; continue processing neighbors
7436             7 773 ; ----------------------------------------------------------------------------------------------------------------------
7436             7 774 ; PathFinder_Score: calculate board score depending on speccy color
7436             7 775 ;
7436             7 776 ; Input:    P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
7436             7 777 ;
7436             7 778 ; Output:   A = -1, if speccy can't reach his opposite edge
7436             7 779 ;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
7436             7 780 ;           A = speccy heuristic evaluation, otherwise
7436             7 781 ;
7436             7 782 ; Uses:     -
7436             7 783 ;
7436             7 784 ; Destroys: A', BC, DE, HL, IY
7436             7 785 ; ----------------------------------------------------------------------------------------------------------------------
7436             7 786 PathFinder_Score:
7436 E2 6A 74    7 787 jp      po, PathFinder_CyanScore    ; if speccy side is FRIEND, calculate CYAN score
7439             7 789 ; ----------------------------------------------------------------------------------------------------------------------
7439             7 790 ; PathFinder_RedScore: calculate red score
7439             7 791 ;
7439             7 792 ; Input:    -
7439             7 793 ;
7439             7 794 ; Output:   A = -1, if red can't reach his opposite edge
7439             7 795 ;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
7439             7 796 ;           A = red heuristic evaluation, otherwise
7439             7 797 ;
7439             7 798 ; Uses:     POTENTIALS (speccy board potential and attack mobility)
7439             7 799 ;
7439             7 800 ; Destroys: A', BC, DE, HL, IY
7439             7 801 ; ----------------------------------------------------------------------------------------------------------------------
7439             7 802 PathFinder_RedScore
7439 CD 74 71    7 803 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
743C C8          7 804 ret     z                           ; if red has a chain of connected tokens, return A = 0
743D 08          7 805 ex      af, af'                     ; save first result
743E CD B5 71    7 806 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
7441 47          7 807 ld      b, a                        ; save second result
7442 08          7 808 ex      af, af'                     ; restore first result
7443 90          7 809 sub     b                           ; subtract both results
7444 78          7 810 ld      a, b                        ; restore second result
7445 C8          7 811 ret     z                           ; if red can't reach his opposite edge, return A = -1
7446 CD 01 71    7 813 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
7449 08          7 814 ex      af, af'                     ; save result
744A CD 3C 71    7 815 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
744D 47          7 816 ld      b, a                        ; save second result
744E 08          7 817 ex      af, af'                     ; restore first result
744F 90          7 818 sub     b                           ; subtract both results
7450 C8          7 819 ret     z                           ; if cyan can't reach his opposite edge, return A = 0
7451 21 09 64    7 821 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
7454 11 51 64    7 822 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7457 CD A8 74    7 823 call    PathFinder_Potentials       ; calculate RED potentials
745A ED 43 97 61 7 824 ld      (POTENTIALS), bc            ; store RED potentials
745E 21 09 61    7 826 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7461 11 51 61    7 827 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7464 CD A8 74    7 828 call    PathFinder_Potentials       ; calculate cyan potentials
7467 C3 98 74    7 829 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
746A             7 831 ; ----------------------------------------------------------------------------------------------------------------------
746A             7 832 ; PathFinder_CyanScore: calculate cyan score
746A             7 833 ;
746A             7 834 ; Input:    -
746A             7 835 ;
746A             7 836 ; Output:   A = -1, if cyan can't reach his opposite edge
746A             7 837 ;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
746A             7 838 ;           A = cyan heuristic evaluation, otherwise
746A             7 839 ;
746A             7 840 ; Uses:     POTENTIALS (speccy board potential and attack mobility)
746A             7 841 ;
746A             7 842 ; Destroys: A', BC, DE, HL
746A             7 843 ; ----------------------------------------------------------------------------------------------------------------------
746A             7 844 PathFinder_CyanScore
746A CD 01 71    7 845 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
746D C8          7 846 ret     z                           ; if cyan has a chain of connected tokens, return A = 0
746E 08          7 847 ex      af, af'                     ; save result
746F CD 3C 71    7 848 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
7472 47          7 849 ld      b, a                        ; save second result
7473 08          7 850 ex      af, af'                     ; restore first result
7474 90          7 851 sub     b                           ; subtract both results
7475 78          7 852 ld      a, b                        ; restore second result
7476 C8          7 853 ret     z                           ; if cyan can't reach his opposite edge, return A = -1
7477 CD 74 71    7 855 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
747A 08          7 856 ex      af, af'                     ; save result
747B CD B5 71    7 857 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
747E 47          7 858 ld      b, a                        ; save second result
747F 08          7 859 ex      af, af'                     ; restore first result
7480 90          7 860 sub     b                           ; subtract both results
7481 C8          7 861 ret     z                           ; if red can't reach his opposite edge, return A = 0
7482 21 09 61    7 863 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7485 11 51 61    7 864 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7488 CD A8 74    7 865 call    PathFinder_Potentials       ; calculate cyan potentials
748B ED 43 97 61 7 866 ld      (POTENTIALS), bc            ; store cyan potentials
748F 21 09 64    7 868 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
7492 11 51 64    7 869 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7495 CD A8 74    7 870 call    PathFinder_Potentials       ; calculate red potentials
7498             7 871 ; ----------------------------------------------------------------------------------------------------------------------
7498             7 872 ; PathFinder_Evaluation: calculate heuristic evaluation.
7498             7 873 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
7498             7 874 ;
7498             7 875 ;                                       e = M (pC - pR) - (aC - aR)
7498             7 876 ; where:
7498             7 877 ;   pC = cyan board potential
7498             7 878 ;   pR = red board potential
7498             7 879 ;   aC = cyan attack mobility
7498             7 880 ;   aR = red attack mobility
7498             7 881 ;    M = a large number
7498             7 882 ;
7498             7 883 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
7498             7 884 ;
7498             7 885 ; Input:    B = player attack mobility
7498             7 886 ;           C = player board potential
7498             7 887 ;
7498             7 888 ; Output:   A = heuristic evaluation
7498             7 889 ;
7498             7 890 ; Uses:     POTENTIALS (speccy's board potential and attack mobility)
7498             7 891 ;
7498             7 892 ; Destroys: E, HL
7498             7 893 ; ----------------------------------------------------------------------------------------------------------------------
7498             7 894 PathFinder_Evaluation:
7498 21 98 61    7 895 ld      hl, POTENTIALS+1            ; HL points to speccy attack mobility address
749B 78          7 896 ld      a, b                        ; get player attack mobility
749C 96          7 897 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
749D 5F          7 898 ld      e, a                        ; save the result in E
749E 2D          7 899 dec     l                           ; move HL to speccy board potential address
749F 79          7 900 ld      a, c                        ; get player board potential
74A0 96          7 901 sub     (hl)                        ; subtract potentials -> (pC - pR)
74A1 87          7 902 add     a, a                        ; multiply by 8 -> M (pC - pR)
74A2 87          7 903 add     a, a
74A3 87          7 904 add     a, a
74A4 93          7 905 sub     e                           ; subtract result of attack mobilities subtraction
74A5             7 906 ; -> M (pC - pR) - (aC - aR)
74A5 EE 80       7 907 xor     $80                         ; invert sign for easier further comparative
74A7 C9          7 908 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
74A8             7 910 ; ----------------------------------------------------------------------------------------------------------------------
74A8             7 911 ; PathFinder_Potentials: calculate board potential and attack mobility
74A8             7 912 ;
74A8             7 913 ; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
74A8             7 914 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
74A8             7 915 ;   the board.
74A8             7 916 ; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
74A8             7 917 ;
74A8             7 918 ; Input:    HL = cyan board or red board address
74A8             7 919 ;           DE = cyan board or red board address
74A8             7 920 ;
74A8             7 921 ; Output:   B = attack mobility
74A8             7 922 ;           C = board potential
74A8             7 923 ;
74A8             7 924 ; Destroys: A, DE, HL, IYL
74A8             7 925 ; ----------------------------------------------------------------------------------------------------------------------
74A8             7 926 PathFinder_Potentials:
74A8 01 FF 00    7 927 ld      bc, $00FF                   ; initialize attack mobility and board potential
74AB FD 2E 3D    7 928 ld      iyl, 61                     ; number of cells to be checked (loop counter)
74AE             7 929 Potentials_Loop
74AE 7E          7 930 ld      a, (hl)                     ; get cell's two-distance pointed by HL
74AF FE 40       7 931 cp      $40                         ; is cell occupied or border?
74B1 30 14       7 932 jr      nc, Potentials_Next         ; yes, skip to next cell
74B3 FE 04       7 933 cp      $04                         ; cell distance was not updated?
74B5 38 18       7 934 jr      c, Potentials_Infinite      ; yes, set cell potential as infinite and skip
74B7 1A          7 935 ld      a, (de)                     ; get cell's two-distance pointed by DE
74B8 FE 04       7 936 cp      $04                         ; cell distance was not updated?
74BA 38 13       7 937 jr      c, Potentials_Infinite      ; yes, set cell potential as infinite and skip
74BC 86          7 938 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
74BD B9          7 939 cp      c                           ; is the new potential = board potential?
74BE 28 05       7 940 jr      z, Potentials_Increment     ; yes, increment attack mobility
74C0 30 04       7 941 jr      nc, Potentials_Update       ; if (new potential > board potential) update and skip
74C2 4F          7 942 ld      c, a                        ; board potential = new potential
74C3 06 00       7 943 ld      b, 0                        ; restart attack mobility
74C5             7 944 Potentials_Increment
74C5 04          7 945 inc     b                           ; increment attack mobility
74C6             7 946 Potentials_Update
74C6 77          7 947 ld      (hl), a                     ; save potential in the cell pointed by HL
74C7             7 948 Potentials_Next
74C7 1C          7 949 inc     e                           ; move to next cell of each board
74C8 2C          7 950 inc     l
74C9 FD 2D       7 951 dec     iyl                         ; decrement loop counter
74CB C2 AE 74    7 952 jp      nz, Potentials_Loop         ; repeat until end of boards
74CE C9          7 953 ret
74CF             7 954 Potentials_Infinite
74CF 1F          7 955 rra                                 ; as carry flag is set, the 7th bit of A is set
74D0 77          7 956 ld      (hl), a                     ; save potential as infinite in the cell pointed by HL
74D1 1C          7 957 inc     e                           ; move to next cell of each board
74D2 2C          7 958 inc     l
74D3 FD 2D       7 959 dec     iyl                         ; decrement loop counter
74D5 C2 AE 74    7 960 jp      nz, Potentials_Loop         ; repeat until end of boards
74D8 C9          7 961 ret
74D9             7 963 ; ----------------------------------------------------------------------------------------------------------------------
74D9             7 964 ; PathFinder_Candidates: search candidates based on score result and boards potentials
74D9             7 965 ;
74D9             7 966 ; Input :    A = -1, if speccy can't reach his opposite edge
74D9             7 967 ;            A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
74D9             7 968 ;            A = speccy heuristic evaluation, otherwise
74D9             7 969 ;           IX = candidates area address
74D9             7 970 ;
74D9             7 971 ; Output:   IX = first candidate address
74D9             7 972 ;
74D9             7 973 ; Uses:     AI_PLAYER (speccy side)
74D9             7 974 ;
74D9             7 975 ; Destroys: A, A', BC, DE, HL
74D9             7 976 ; ----------------------------------------------------------------------------------------------------------------------
74D9             7 977 PathFinder_Candidates:
74D9 DD 36 00 00 7 978 ld      (ix+0), 0                   ; set candidates endmarker
74DD B7          7 980 or      a                           ; is speccy the winner?
74DE 28 3D       7 981 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
74E0 3C          7 982 inc     a                           ; is speccy defeated?
74E1 28 4E       7 983 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
74E3             7 985 ; if score is not -1 nor 0, fill candidates from total potentials
74E3 21 09 61    7 987 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74E6 11 09 64    7 988 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
74E9 CD A8 74    7 989 call    PathFinder_Potentials       ; process candidates from total potentials
74EC 79          7 991 ld      a, c                        ; set board potential in A
74ED 08          7 992 ex      af, af'                     ; save board potential
74EE 50          7 993 ld      d, b                        ; store attack mobility
74EF DD 5D       7 994 ld      e, ixl                      ; store candidates position
74F1             7 996 ; insert the second best board potentials in candidates area
74F1             7 997 Candidates_2ndBest
74F1 2E 09       7 998 ld      l, 9                        ; HL points to board potentials address (1st position)
74F3 0C          7 999 inc     c                           ; increment board potential
74F4 79          7 1000 ld      a, c                        ; A = second best potential
74F5 FE 20       7 1001 cp      $20                         ; is potential >= $20? (2nd best max potential)
74F7 30 13       7 1002 jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential
74F9 06 3D       7 1004 ld      b, 61                       ; number of cells to be checked (loop counter)
74FB             7 1005 Candidates_2ndBest_Loop
74FB BE          7 1006 cp      (hl)                        ; is current board potential = 2nd best board potential?
74FC C2 04 75    7 1007 jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
74FF DD 2C       7 1008 inc     ixl                         ; yes, insert candidate
7501 DD 75 00    7 1009 ld      (ix+0), l
7504             7 1010 Candidates_2ndBest_Next
7504 2C          7 1011 inc     l                           ; move HL to next board potential address
7505 10 F4       7 1012 djnz    Candidates_2ndBest_Loop     ; repeat for each cell
7507 DD 7D       7 1013 ld      a, ixl                      ; A = current candidates position
7509 BB          7 1014 cp      e                           ; new candidates inserted?
750A 28 E5       7 1015 jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted
750C             7 1017 Candidates_2ndBest_Exit
750C 42          7 1018 ld      b, d                        ; restore attack mobility
750D 08          7 1019 ex      af, af'                     ; restore board potential
750E             7 1021 ; insert the best board potentials in candidates area
750E             7 1022 Candidates_Best
750E 2E 08       7 1023 ld      l, 8                        ; HL points to board potential address (1st position -1)
7510             7 1024 Candidates_Best_Loop
7510 2C          7 1025 inc     l                           ; move HL to next board potential address
7511 BE          7 1026 cp      (hl)                        ; is current board potential equal to best board potential?
7512 C2 10 75    7 1027 jp      nz, Candidates_Best_Loop    ; no, next potential
7515 DD 2C       7 1028 inc     ixl                         ; yes, insert candidate
7517 DD 75 00    7 1029 ld      (ix+0), l
751A 10 F4       7 1030 djnz    Candidates_Best_Loop        ; repeat for each cell
751C C9          7 1031 ret
751D             7 1033 ; ----------------------------------------------------------------------------------------------------------------------
751D             7 1034 ; Fill candidates for winner color
751D             7 1035 ; ----------------------------------------------------------------------------------------------------------------------
751D             7 1036 Candidates_Winner
751D 3A 9B 61    7 1037 ld      a, (AI_PLAYER)              ; check speccy side
7520 B7          7 1038 or      a                           ; is it FRIEND?
7521 E2 3E 75    7 1039 jp      po, Candidates_Cyan         ; yes, fill candidates from cyan potentials
7524 21 09 64    7 1041 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
7527 11 51 64    7 1042 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
752A CD A8 74    7 1043 call    PathFinder_Potentials       ; calculate red potentials
752D 79          7 1044 ld      a, c                        ; set board potential in A
752E C3 0E 75    7 1045 jp      Candidates_Best             ; fill only the best candidates
7531             7 1047 ; ----------------------------------------------------------------------------------------------------------------------
7531             7 1048 ; Fill candidates for defeated color
7531             7 1049 ; ----------------------------------------------------------------------------------------------------------------------
7531             7 1050 Candidates_Defeat
7531 3A 9B 61    7 1051 ld      a, (AI_PLAYER)              ; check speccy side
7534 B7          7 1052 or      a                           ; is it FRIEND?
7535 E2 4B 75    7 1053 jp      po, Candidates_Red          ; yes, fill candidates from red potentials
7538             7 1055 ; if RED is defeated, candidates are chosen from cyan board potentials
7538 CD 01 71    7 1057 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
753B CD 3C 71    7 1058 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
753E             7 1059 Candidates_Cyan
753E 21 09 61    7 1060 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7541 11 51 61    7 1061 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7544 CD A8 74    7 1062 call    PathFinder_Potentials       ; calculate cyan potentials
7547 79          7 1063 ld      a, c                        ; set board potential in A
7548 C3 0E 75    7 1064 jp      Candidates_Best             ; fill only the best candidates
754B             7 1066 ; if CYAN is defeated, candidates are chosen from red board potentials
754B             7 1067 Candidates_Red
754B CD 74 71    7 1068 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
754E CD B5 71    7 1069 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
7551 21 09 64    7 1070 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
7554 11 51 64    7 1071 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7557 CD A8 74    7 1072 call    PathFinder_Potentials       ; calculate red potentials
755A 79          7 1073 ld      a, c                        ; set board potential in A
755B C3 0E 75    7 1074 jp      Candidates_Best             ; fill only the best candidates
755E             7 1076 ; ----------------------------------------------------------------------------------------------------------------------
755E             7 1077 ; PathFinder_VictoryPath: calculate current player victory path
755E             7 1078 ;
755E             7 1079 ; Input:    -
755E             7 1080 ;
755E             7 1081 ; Output:   A   = -1, if there isn't a victory path
755E             7 1082 ;           A   = start position (-1) of the victory path, otherwise
755E             7 1083 ;           HL  = cyan or red queue head address
755E             7 1084 ;
755E             7 1085 ; Uses:     TOKEN_COLOR (current token color)
755E             7 1086 ;
755E             7 1087 ; Destroys: BC, DE, HL, IY
755E             7 1088 ; ----------------------------------------------------------------------------------------------------------------------
755E             7 1089 PathFinder_VictoryPath:
755E 3A 9E 61    7 1090 ld      a, (TOKEN_COLOR)            ; get current token color
7561 FE 05       7 1091 cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
7563 28 0C       7 1092 jr      z, PathFinder_VictoryPath_Cyan
7565 CD 74 71    7 1094 call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
7568 21 45 64    7 1095 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
756B CD 7D 75    7 1096 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
756E C3 7D 71    7 1097 jp      PathFinder_Red_CheckPath    ; calculate RED victory path
7571             7 1099 PathFinder_VictoryPath_Cyan
7571 CD 01 71    7 1100 call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
7574 21 45 61    7 1101 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
7577 CD 7D 75    7 1102 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
757A C3 0A 71    7 1103 jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path
757D             7 1105 ; ----------------------------------------------------------------------------------------------------------------------
757D             7 1106 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to SKIPPED, everything else to ENEMY.
757D             7 1107 ;
757D             7 1108 ; Immediately after executing 'PathFinder_[color]_xxxx', you can execute this routine, then execute 'PathFinder_[color]
757D             7 1109 ; _CheckPath' to find a victory path.
757D             7 1110 ;
757D             7 1111 ; Coded by Einar Saukas
757D             7 1112 ;
757D             7 1113 ; Input:    HL = pointer to last position of [color]_BOARD_XX_YY
757D             7 1114 ;
757D             7 1115 ; Output:   -
757D             7 1116 ;
757D             7 1117 ; Destroys: A, BC, HL
757D             7 1118 ; ----------------------------------------------------------------------------------------------------------------------
757D             7 1119 PathFinder_PrepareBoard:
757D 3E 43       7 1120 ld      a, VICTORY+$40              ; set victory distance + friendly flag
757F 0E 07       7 1121 ld      c, 7                        ; 7 rows
7581             7 1122 PrepareBoard_Row
7581 06 07       7 1123 ld      b, 7                        ; 7 columns
7583             7 1124 PrepareBoard_Column
7583 BE          7 1125 cp      (hl)                        ; check win condition
7584 36 7E       7 1126 ld      (hl), ENEMY                 ; save ENEMY by default
7586 C2 8B 75    7 1127 jp      nz, PrepareBoard_Next       ; if not win condition, skip to position
7589 36 01       7 1128 ld      (hl), SKIPPED               ; else, save SKIPPED
758B             7 1129 PrepareBoard_Next
758B 2D          7 1130 dec     l                           ; HL points to next board position
758C 10 F5       7 1131 djnz    PrepareBoard_Column         ; repeat for each column
758E 2D          7 1133 dec     l                           ; skip borders
758F 2D          7 1134 dec     l
7590 0D          7 1135 dec     c                           ; decrement rows
7591 C2 81 75    7 1136 jp      nz, PrepareBoard_Row        ; repeat for each row
7594 C9          7 1137 ret
7595             7 1139 ; ----------------------------------------------------------------------------------------------------------------------
7595             7 1140 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
7595             7 1141 ;
7595             7 1142 ; Input:    A  = start position of the victory path
7595             7 1143 ;           HL = cyan or red queue head address
7595             7 1144 ;
7595             7 1145 ; Output:   -
7595             7 1146 ;
7595             7 1147 ; Uses:     TOKEN_COLOR (current token color)
7595             7 1148 ;
7595             7 1149 ; Destroys: A, BC, DE, HL, IX
7595             7 1150 ; ----------------------------------------------------------------------------------------------------------------------
7595             7 1151 PathFinder_BrightPath:
7595 6F          7 1152 ld      l, a                        ; move HL to the start position of the victory path
7596 24          7 1153 inc     h
7597 4E          7 1154 ld      c, (hl)                     ; set current victory path length in C
7598 06 03       7 1155 ld      b, VICTORY                  ; set victory length in B
759A 3A 9E 61    7 1157 ld      a, (TOKEN_COLOR)            ; get current token color
759D C6 40       7 1158 add     a, BRIGHT                   ; switch on bright attribute
759F 32 9E 61    7 1159 ld      (TOKEN_COLOR), a
75A2 3E 04       7 1160 ld      a, 4                        ; set delay duration for animate hexagons
75A4 32 8C 6D    7 1161 ld      (@Token_Delay+1), a
75A7 18 1C       7 1162 jr      BrightPath_Position         ; animate and highlight the hexagon position
75A9             7 1163 BrightPath_Neighbor
75A9 2C          7 1164 inc     l                           ; move HL to left neighbor address
75AA BE          7 1165 cp      (hl)                        ; is it the same as current victory path length?
75AB 28 18       7 1166 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75AD 2D          7 1167 dec     l                           ; move HL to right neighbor address
75AE 2D          7 1168 dec     l
75AF BE          7 1169 cp      (hl)                        ; is it the same as current victory path length?
75B0 28 13       7 1170 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75B2 11 F8 FF    7 1171 ld      de, -WIDTH                  ; move HL to upper-right neighbor address
75B5 19          7 1172 add     hl, de
75B6 BE          7 1173 cp      (hl)                        ; is it the same as current victory path length?
75B7 28 0C       7 1174 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75B9 2C          7 1175 inc     l                           ; move HL to upper-left neighbor address
75BA BE          7 1176 cp      (hl)                        ; is it the same as current victory path length?
75BB 28 08       7 1177 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75BD 11 10 00    7 1178 ld      de, WIDTH*2                 ; move HL to lower-right neighbor address
75C0 19          7 1179 add     hl, de
75C1 BE          7 1180 cp      (hl)                        ; is it the same as current victory path length?
75C2 28 01       7 1181 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75C4 2C          7 1182 inc     l                           ; move HL to lower-left neighbor address
75C5             7 1183 BrightPath_Position
75C5 C5          7 1184 push    bc                          ; store current victory path length
75C6 E5          7 1185 push    hl                          ; store current position pointer
75C7 CD 3B 6D    7 1186 call    Main_Board2Indexes          ; convert a board position into a board indexes
75CA CD 78 6D    7 1187 call    Draw_Token                  ; animate hexagon sprite on the screen
75CD DD 21 E7 64 7 1188 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
75D1 CD 7E 76    7 1189 call    Sound_FX                    ; play sound effect
75D4 E1          7 1190 pop     hl                          ; restore current position pointer
75D5 C1          7 1191 pop     bc                          ; restore current victory path length
75D6 0D          7 1192 dec     c                           ; decrement current victory path length
75D7 79          7 1193 ld      a, c                        ; set current victory path length in A
75D8 B8          7 1194 cp      b                           ; has reached victory length?
75D9 C2 A9 75    7 1195 jp      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach victory length
75DC 21 9E 61    7 1197 ld      hl, TOKEN_COLOR             ; get current token color address
75DF CB B6       7 1198 res     6, (hl)                     ; switch off bright attribute
75E1 C9          7 1199 ret

; File #8: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Timer.z80asm

75E2             8 1 ; ----------------------------------------------------------------------------------------------------------------------
75E2             8 2 ; Timer.z80asm
75E2             8 3 ; Coded by Antonio Luque
75E2             8 4 ;
75E2             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
75E2             8 6 ; ----------------------------------------------------------------------------------------------------------------------
75E2             8 8 CYAN_TIMER_ON           EQU     1                           ; cyan timer flag on
75E2             8 9 RED_TIMER_ON            EQU     2                           ; red timer flag on
75E2             8 11 ; ----------------------------------------------------------------------------------------------------------------------
75E2             8 12 ; Timer_Interrupt: interrupt routine to manage players' timers
75E2             8 13 ;
75E2             8 14 ; Input:    -
75E2             8 15 ;
75E2             8 16 ; Output:   -
75E2             8 17 ;
75E2             8 18 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
75E2             8 19 ;
75E2             8 20 ; Destroys: BC', DE', HL'
75E2             8 21 ; ----------------------------------------------------------------------------------------------------------------------
75E2             8 22 Timer_Interrupt:
75E2 F5          8 23 push    af                          ; store AF register
75E3 D9          8 24 exx                                 ; store BC, DE and HL registers
75E4 3A E8 62    8 26 ld      a, (TIMER_FLAG)             ; check timer flag
75E7 B7          8 27 or      a                           ; is timer stopped?
75E8 CA 11 76    8 28 jp      z, Timer_Exit               ; yes, exit routine
75EB 21 EC 62    8 30 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
75EE 3D          8 31 dec     a                           ; is red timer on?
75EF C2 F5 75    8 32 jp      nz, Timer_Counters          ; yes, check interrupt counter 
75F2 21 E9 62    8 33 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
75F5             8 34 Timer_Counters
75F5 35          8 35 dec     (hl)                        ; decrement interrupt counter
75F6 C2 11 76    8 36 jp      nz, Timer_Exit              ; if not 0, exit routine
75F9 36 32       8 38 ld      (hl), 50                    ; restart interrupt counter
75FB 23          8 39 inc     hl                          ; move HL to seconds counter address
75FC 3E 01       8 40 ld      a, 1                        ; increment seconds counter
75FE 86          8 41 add     a, (hl)
75FF 27          8 42 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7600 77          8 43 ld      (hl), a                     ; store seconds
7601 FE 60       8 44 cp      $60                         ; 60 seconds reached?
7603 C2 0E 76    8 45 jp      nz, Timer_Show              ; no, show timer
7606 36 00       8 46 ld      (hl), 0                     ; restart seconds counter
7608 23          8 47 inc     hl                          ; move HL to minutes counter address
7609 3E 01       8 48 ld      a, 1                        ; increment minutes counter
760B 86          8 49 add     a, (hl)
760C 27          8 50 daa                                 ; convert to BCD (Binary-Coded-Decimal)
760D 77          8 51 ld      (hl), a                     ; store minutes
760E             8 52 Timer_Show
760E CD 31 76    8 53 call    Timer_Display               ; display timer on the screen
7611             8 54 Timer_Exit
7611 D9          8 55 exx                                 ; restore BC, DE and HL registers
7612 F1          8 56 pop     af                          ; restore AF register
7613 FB          8 58 ei                                  ; enable interrupts
7614 C9          8 59 ret
7615             8 61 ; ----------------------------------------------------------------------------------------------------------------------
7615             8 62 ; Timer_Reset: initialize and display cyan and red timers
7615             8 63 ;
7615             8 64 ; Input:    -
7615             8 65 ;
7615             8 66 ; Output:   -
7615             8 67 ;
7615             8 68 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7615             8 69 ;
7615             8 70 ; Destroys: A, BC, DE, HL
7615             8 71 ; ----------------------------------------------------------------------------------------------------------------------
7615             8 72 Timer_Reset:
7615 21 EE 62    8 73 ld      hl, RED_TIMER+2             ; HL points to red's minutes counter address
7618 AF          8 74 xor     a                           ; reset minutes counter
7619 77          8 75 ld      (hl), a
761A 2B          8 76 dec     hl                          ; move HL to red's seconds counter address
761B 77          8 77 ld      (hl), a                     ; reset seconds counter
761C 2B          8 78 dec     hl                          ; move HL to red's interrupt counter
761D 36 32       8 79 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
761F 2B          8 81 dec     hl                          ; move HL to cyan's minutes counter address
7620 77          8 82 ld      (hl), a                     ; reset minutes counter
7621 2B          8 83 dec     hl                          ; move HL to cyan's seconds counter address
7622 77          8 84 ld      (hl), a                     ; reset seconds counter
7623 2B          8 85 dec     hl                          ; move HL to cyan's interrupt counter
7624 36 32       8 86 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
7626 2B          8 88 dec     hl                          ; move HL to timer flag address
7627 36 01       8 89 ld      (hl), CYAN_TIMER_ON         ; set cyan timer on
7629 CD 31 76    8 90 call    Timer_Display               ; display cyan timer
762C 3E 02       8 92 ld      a, RED_TIMER_ON             ; set red timer on
762E 32 E8 62    8 93 ld      (TIMER_FLAG), a
7631             8 95 ; ----------------------------------------------------------------------------------------------------------------------
7631             8 96 ; Timer_Display: display a timer on the screen
7631             8 97 ;
7631             8 98 ; Input:    -
7631             8 99 ;
7631             8 100 ; Output:   -
7631             8 101 ;
7631             8 102 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7631             8 103 ;
7631             8 104 ; Destroys: A, BC, DE, HL
7631             8 105 ; ----------------------------------------------------------------------------------------------------------------------
7631             8 106 Timer_Display:
7631 01 EE 62    8 107 ld      bc, RED_TIMER+2             ; BC points to red's minutes counter address
7634 11 E2 48    8 108 ld      de, $48E2                   ; DE points to red's minutes screen address
7637 3A E8 62    8 109 ld      a, (TIMER_FLAG)             ; check timer flag
763A 3D          8 110 dec     a                           ; is cyan timer on?
763B C2 44 76    8 111 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
763E 01 EB 62    8 112 ld      bc, CYAN_TIMER+2            ; BC points to cyan's minutes counter address
7641 11 78 40    8 113 ld      de, $4078                   ; DE points to cyan's minutes screen address
7644             8 114 Timer_Display_Min
7644 CD 49 76    8 115 call    Timer_Display_MinSec        ; display minutes counter on screen
7647 0B          8 116 dec     bc                          ; BC points to seconds counter address
7648 1C          8 117 inc     e                           ; DE points to seconds screen address
7649             8 118 Timer_Display_MinSec:
7649 0A          8 119 ld      a, (bc)                     ; set min/sec counter in A
764A 1F          8 120 rra                                 ; move tens digit to the first 4th bits of A
764B 1F          8 121 rra
764C 1F          8 122 rra
764D 1F          8 123 rra
764E CD 52 76    8 124 call    Timer_Display_Digit         ; display tens digit on screen
7651 0A          8 125 ld      a, (bc)                     ; set min/sec counter in A 
7652             8 126 Timer_Display_Digit:
7652 E6 0F       8 127 and     %00001111                   ; discard the last 4th bits of the digit
7654 D5          8 128 push    de                          ; store digit screen address
7655 21 97 64    8 130 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
7658 87          8 131 add     a, a                        ; a digit is 8 bytes long
7659 87          8 132 add     a, a
765A 87          8 133 add     a, a
765B 85          8 134 add     a, l                        ; set digit index in HL
765C 6F          8 135 ld      l, a
765D 7E          8 137 ld      a, (hl)                     ; get digit tile
765E 12          8 138 ld      (de), a                     ; put it on screen address
765F 14          8 139 inc     d                           ; move DE to next pixel-line address
7660 2C          8 140 inc     l                           ; move HL to next digit tile address
7661 7E          8 141 ld      a, (hl)                     ; (repeat 7 more times)
7662 12          8 142 ld      (de), a
7663 14          8 143 inc     d
7664 2C          8 144 inc     l
7665 7E          8 145 ld      a, (hl)
7666 12          8 146 ld      (de), a
7667 14          8 147 inc     d
7668 2C          8 148 inc     l
7669 7E          8 149 ld      a, (hl)
766A 12          8 150 ld      (de), a
766B 14          8 151 inc     d
766C 2C          8 152 inc     l
766D 7E          8 153 ld      a, (hl)
766E 12          8 154 ld      (de), a
766F 14          8 155 inc     d
7670 2C          8 156 inc     l
7671 7E          8 157 ld      a, (hl)
7672 12          8 158 ld      (de), a
7673 14          8 159 inc     d
7674 2C          8 160 inc     l
7675 7E          8 161 ld      a, (hl)
7676 12          8 162 ld      (de), a
7677 14          8 163 inc     d
7678 2C          8 164 inc     l
7679 7E          8 165 ld      a, (hl)
767A 12          8 166 ld      (de), a
767B D1          8 168 pop     de                          ; restore digit screen address
767C 1C          8 169 inc     e                           ; move screen address to next column
767D C9          8 170 ret

; File #9: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Sound.z80asm

767E             9 1 ; ----------------------------------------------------------------------------------------------------------------------
767E             9 2 ; Sound.z80asm
767E             9 3 ; Coded with BeepFX player tool by Shiru: https://shiru.untergrund.net/software.shtml
767E             9 4 ;
767E             9 5 ; Adapted for Hex game by Antonio Luque
767E             9 6 ; ----------------------------------------------------------------------------------------------------------------------
767E             9 8 ; ----------------------------------------------------------------------------------------------------------------------
767E             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
767E             9 10 ; 
767E             9 11 ; Input:    IX = tone parameters address
767E             9 12 ;
767E             9 13 ; Output:   -
767E             9 14 ;
767E             9 15 ; Destroys: A, BC, DE, HL, IY
767E             9 16 ; ----------------------------------------------------------------------------------------------------------------------
767E             9 17 Sound_FX:
767E F3          9 18 di                                  ; disable interrupts
767F DD 4E 00    9 20 ld      c, (ix+0)                   ; BC = frames
7682 DD 46 01    9 21 ld      b, (ix+1)
7685 DD 5E 02    9 22 ld      e, (ix+2)                   ; DE = frame length
7688 DD 56 03    9 23 ld      d, (ix+3)
768B D5          9 24 push    de                          ; store frame length in IY
768C FD E1       9 25 pop     iy
768E DD 5E 04    9 26 ld      e, (ix+4)                   ; DE = pitch
7691 DD 56 05    9 27 ld      d, (ix+5)
7694 21 00 00    9 28 ld      hl, 0                       ; reset HL
7697             9 30 Sound_FX_Frames
7697 C5          9 31 push    bc                          ; store frames
7698 FD E5       9 32 push    iy                          ; restore frame length in BC
769A C1          9 33 pop     bc
769B             9 34 Sound_FX_FrameLength
769B 19          9 35 add     hl, de                      ; HL = incremented pitch
769C 7C          9 36 ld      a, h                        ; compares with fixed duty cycle ($80 for 50% square wave)
769D FE 80       9 37 cp      $80                         ; if (incremented pitch < duty cycle)
769F 9F          9 38 sbc     a, a                        ;    { A = %11111111 } else { A = %00000000 }
76A0 E6 10       9 39 and     %00010000                   ; toggling bit 4 controls the internal speaker
76A2 F6 00       9 40 or      0                           ; keep border unchanged, dummy (7t)
76A4 D3 FE       9 41 out     ($FE), a                    ; send bit to internal speaker
76A6 3A 00 00    9 42 ld      a, (0)                      ; dummy (13t)
76A9 0B          9 43 dec     bc                          ; decrement frame length
76AA 78          9 44 ld      a, b                        ; check frame length
76AB B1          9 45 or      c                           ; frame length = 0?
76AC C2 9B 76    9 46 jp      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times (loop = 88t)
76AF DD 4E 06    9 48 ld      c, (ix+6)                   ; BC = pitch slide
76B2 DD 46 07    9 49 ld      b, (ix+7)
76B5 EB          9 50 ex      de, hl                      ; HL = current pitch
76B6 09          9 51 add     hl, bc                      ; increment pitch with pitch slide
76B7 EB          9 52 ex      de, hl                      ; DE = new pitch
76B8 C1          9 54 pop     bc                          ; restore frames
76B9 0B          9 55 dec     bc                          ; decrement frames
76BA 78          9 56 ld      a, b                        ; check frames
76BB B1          9 57 or      c                           ; frames = 0?
76BC 20 D9       9 58 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
76BE FB          9 60 ei                                  ; enable interrupts
76BF C9          9 61 ret

; File #10: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Screen.z80asm

76C0             10 1 ; ----------------------------------------------------------------------------------------------------------------------
76C0             10 2 ; Screen.z80asm
76C0             10 3 ; Coded by Antonio Luque
76C0             10 4 ; ----------------------------------------------------------------------------------------------------------------------
76C0             10 6 BLUE_INK                EQU     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
76C0             10 7 BLUE_PAPER              EQU     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
76C0             10 8 WHITE_PAPER             EQU     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
76C0             10 9 WHITE                   EQU     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
76C0             10 10 BRIGHT                  EQU     %01000000                   ; mask to apply bright to attributes
76C0             10 11 FLASH                   EQU     %10000000                   ; mask to apply flash to attributes
76C0             10 12 WHITE_FLASH0            EQU     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
76C0             10 13 WHITE_FLASH1            EQU     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
76C0             10 15 ; ----------------------------------------------------------------------------------------------------------------------
76C0             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
76C0             10 17 ;
76C0             10 18 ; Input:    -
76C0             10 19 ;
76C0             10 20 ; Output:   -
76C0             10 21 ;
76C0             10 22 ; Destroys: BC, DE, HL
76C0             10 23 ; ----------------------------------------------------------------------------------------------------------------------
76C0             10 24 Screen_Clear:
76C0 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
76C3 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
76C6 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
76C7 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
76CA ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
76CC C9          10 30 ret
76CD             10 32 ; ----------------------------------------------------------------------------------------------------------------------
76CD             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
76CD             10 34 ;
76CD             10 35 ; Input:    -
76CD             10 36 ;
76CD             10 37 ; Output:   -
76CD             10 38 ;
76CD             10 39 ; Destroys: A, BC, DE, HL, IX
76CD             10 40 ; ----------------------------------------------------------------------------------------------------------------------
76CD             10 41 Screen_Letters:
76CD 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
76D0 DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
76D4 CD DE 76    10 44 call    Screen_Letters_Row          ; draw top row of letters
76D7 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
76DA DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
76DE             10 47 Screen_Letters_Row:
76DE 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
76E1 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
76E3             10 50 Screen_Letter_Loop
76E3 E5          10 51 push    hl                          ; store letter screen address
76E4 CD B0 6D    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
76E7 E1          10 53 pop     hl                          ; restore letter screen address
76E8 2C          10 54 inc     l                           ; move HL to next screen address
76E9 2C          10 55 inc     l
76EA DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
76EE DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
76F2 DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
76F4 DD 2C       10 59 inc     ixl
76F6 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
76F8 C9          10 61 ret
76F9             10 63 ; ----------------------------------------------------------------------------------------------------------------------
76F9             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
76F9             10 65 ;
76F9             10 66 ; Input:    -
76F9             10 67 ;
76F9             10 68 ; Output:   -
76F9             10 69 ;
76F9             10 70 ; Destroys: A, BC, DE, HL, IX, IY
76F9             10 71 ; ----------------------------------------------------------------------------------------------------------------------
76F9             10 72 Screen_Numbers:
76F9 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
76FC FD 21 EF 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
7700 DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
7704 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
7706             10 77 Screen_Number_Loop
7706 FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
7709 FD 66 01    10 79 ld      h, (iy+1)
770C E5          10 80 push    hl                          ; store pointer to number screen address
770D D5          10 81 push    de                          ; store pointer to sprite address
770E CD B0 6D    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
7711 D1          10 83 pop     de                          ; restore pointer to sprite address
7712 E1          10 84 pop     hl                          ; restore pointer to number screen address
7713 DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7717 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
771B 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
771C C6 0F       10 88 add     a, 15
771E 6F          10 89 ld      l, a
771F CD B0 6D    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
7722 DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
7726 DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
772A 78          10 93 ld      a, b                        ; save loop counter
772B 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
772E DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
7730 FD 23       10 96 inc     iy                          ; move IY to next number screen address
7732 FD 23       10 97 inc     iy
7734 47          10 98 ld      b, a                        ; restore loop counter
7735 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
7737 C9          10 100 ret
7738             10 102 ; ----------------------------------------------------------------------------------------------------------------------
7738             10 103 ; Screen_Frame: draw the screen frame on the screen
7738             10 104 ;
7738             10 105 ; Input:    -
7738             10 106 ;
7738             10 107 ; Output:   -
7738             10 108 ;
7738             10 109 ; Destroys: A, BC, DE, HL, IX
7738             10 110 ; ----------------------------------------------------------------------------------------------------------------------
7738             10 111 Screen_Frame:
7738 11 28 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
773B 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
773E CD 14 6F    10 114 call    Print_String                ; print "Level"
7741 CD 7D 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
7744 01 8D 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
7747 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
774A CD 50 77    10 119 call    Screen_Frame_Border         ; draw up-border
774D 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
7750             10 121 Screen_Frame_Border:
7750 DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
7753             10 123 Screen_Frame_Loop
7753 0A          10 124 ld      a, (bc)                     ; get tile index
7754 FE FF       10 125 cp      -1                          ; is it -1?
7756 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
7758 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
775B CD 23 6F    10 128 call    Print_Tile                  ; print frame tile
775E             10 129 Screen_Frame_Next
775E 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
775F 03          10 131 inc     bc                          ; BC points to the next tile index
7760 DD 2D       10 132 dec     ixl                         ; decrement loop counter
7762 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
7764 DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
7768 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
776C DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
7770 DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
7774 DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
7778 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
777C C9          10 141 ret
777D             10 143 ; ----------------------------------------------------------------------------------------------------------------------
777D             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
777D             10 145 ;
777D             10 146 ; Input:    -
777D             10 147 ;
777D             10 148 ; Output:   -
777D             10 149 ;
777D             10 150 ; Destroys: A, BC, HL
777D             10 151 ; ----------------------------------------------------------------------------------------------------------------------
777D             10 152 Screen_Vertical_Bars:
777D 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
7780 CD 86 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
7783 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
7786             10 156 Screen_Vertical_Bar:
7786 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
7788             10 158 Screen_Vertical_Loop
7788 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
778A CD BC 6D    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
778D 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
778F C9          10 162 ret
7790             10 164 ; ----------------------------------------------------------------------------------------------------------------------
7790             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
7790             10 166 ;
7790             10 167 ; Input:    -
7790             10 168 ;
7790             10 169 ; Output:   -
7790             10 170 ;
7790             10 171 ; Uses:     TOKEN_COLOR (current token color)
7790             10 172 ;
7790             10 173 ; Destroys: A, BC, DE, HL, IX
7790             10 174 ; ----------------------------------------------------------------------------------------------------------------------
7790             10 175 Screen_Tokens:
7790 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
7792 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
7795 CD 9D 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
7798 3E 02       10 180 ld      a, RED_COLOR                ; set token color
779A 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
779D             10 182 Screen_Tokens_Draw:
779D 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77A0 CD CB 6D    10 184 call    Draw_Hexagon_Color          ; color fixed token area
77A3 DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
77A6 DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
77A9 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
77AC C3 9D 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
77AF             10 190 ; ----------------------------------------------------------------------------------------------------------------------
77AF             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
77AF             10 192 ;
77AF             10 193 ; Input:    -
77AF             10 194 ;
77AF             10 195 ; Output:   -
77AF             10 196 ;
77AF             10 197 ; Destroys: IX
77AF             10 198 ; ----------------------------------------------------------------------------------------------------------------------
77AF             10 199 Screen_Timer_Quotes:
77AF DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
77B3 DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
77B7 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
77BB DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
77BD DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
77C1 DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
77C5 DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
77C8 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
77CC DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
77D0 DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
77D4 DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
77D8 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
77DC DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
77DE DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
77E2 DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
77E6 DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
77E9 DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
77ED DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
77F1 C9          10 219 ret
77F2             10 221 ; ----------------------------------------------------------------------------------------------------------------------
77F2             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
77F2             10 223 ;
77F2             10 224 ; Input:    -
77F2             10 225 ;
77F2             10 226 ; Output:   -
77F2             10 227 ;
77F2             10 228 ; Destroys: BC, IX
77F2             10 229 ; ----------------------------------------------------------------------------------------------------------------------
77F2             10 230 Screen_Color_Statics:
77F2 DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
77F6 0E 07       10 232 ld      c, WHITE                    ; set color in C
77F8 CD 22 78    10 233 call    Screen_Apply_Color_6        ; apply color
77FB DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
77FE 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
7800 CD 22 78    10 236 call    Screen_Apply_Color_6        ; apply color
7803 DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7807 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
7809 CD 22 78    10 239 call    Screen_Apply_Color_6        ; apply color
780C DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
780F 0E 07       10 241 ld      c, WHITE                    ; set color in C
7811 CD 22 78    10 242 call    Screen_Apply_Color_6        ; apply color
7814 DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7818 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
781A CD 22 78    10 245 call    Screen_Apply_Color_6        ; apply color
781D DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
7820 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
7822             10 248 Screen_Apply_Color_6:
7822 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
7824             10 250 ; ----------------------------------------------------------------------------------------------------------------------
7824             10 251 ; Screen_Apply_Color: apply color to a screen area
7824             10 252 ;
7824             10 253 ; Input:    B  = area length
7824             10 254 ;           C  = color attribute to apply
7824             10 255 ;           IX = attribute's area address
7824             10 256 ;
7824             10 257 ; Output:   -
7824             10 258 ;
7824             10 259 ; Destroys: B, IX
7824             10 260 ; ----------------------------------------------------------------------------------------------------------------------
7824             10 261 Screen_Apply_Color:
7824 DD 71 00    10 262 ld      (ix+0), c                   ; apply color
7827 DD 2C       10 263 inc     ixl                         ; move IX to the next attribute address
7829 10 F9       10 264 djnz    Screen_Apply_Color          ; repeat for each byte
782B C9          10 265 ret
782C             10 267 ; ----------------------------------------------------------------------------------------------------------------------
782C             10 268 ; Screen_Last_Level: show last level screen and input game level
782C             10 269 ;
782C             10 270 ; Input:    -
782C             10 271 ;
782C             10 272 ; Output:   -
782C             10 273 ;
782C             10 274 ; Uses:     GAME_LEVEL (current game level)
782C             10 275 ;
782C             10 276 ; Destroys: A, BC, DE, HL, IX, IY
782C             10 277 ; ----------------------------------------------------------------------------------------------------------------------
782C             10 278 Screen_Last_Level:
782C 11 FF 67    10 279 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
782F 21 AD 50    10 280 ld      hl, $50AD                   ; HL points to string screen address
7832 CD 14 6F    10 281 call    Print_String                ; print "Press any key"
7835 DD 21 AD 5A 10 282 ld      ix, $5AAD                   ; IX points to string attributes address
7839 01 38 0D    10 283 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
783C CD 24 78    10 284 call    Screen_Apply_Color          ; apply color to string area
783F CD 80 6E    10 285 call    Input_Key_Scan              ; wait for a key pressed
7842 CD C0 76    10 287 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7845 CD F9 7B    10 288 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7848 DD 21 C7 59 10 289 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
784C 01 C7 11    10 290 ld      bc, 17*256+WHITE_FLASH1     ; B = string length (loop counter), C = color attributes
784F CD 24 78    10 291 call    Screen_Apply_Color          ; apply color to string area
7852 11 77 68    10 292 ld      de, STR_CONGRATS            ; DE points to string address
7855 21 C7 48    10 293 ld      hl, $48C7                   ; HL points to string screen address
7858 CD 14 6F    10 294 call    Print_String                ; print "CONGRATULATIONS"
785B DD 21 EF 64 10 295 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
785F CD 7E 76    10 296 call    Sound_FX                    ; play sound fx
7862 F3          10 298 di                                  ; disable interrupts
7863 DD 21 42 5A 10 299 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
7867 01 07 1C    10 300 ld      bc, 28*256+WHITE            ; B = string length (loop counter), C = color attributes
786A CD 24 78    10 301 call    Screen_Apply_Color          ; apply color to string area
786D 11 89 68    10 302 ld      de, STR_LAST_LEVEL          ; DE points to string address
7870 21 42 50    10 303 ld      hl, $5042                   ; HL points to string screen address
7873 CD 14 6F    10 304 call    Print_String                ; print "Well done!..."
7876 DD 2E 82    10 305 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
7879 06 18       10 306 ld      b, 24                       ; string length-4 (loop counter)
787B CD 24 78    10 307 call    Screen_Apply_Color          ; apply color to string area
787E DD 36 01 78 10 308 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
7882 DD 36 02 78 10 309 ld      (ix+2), WHITE_PAPER+BRIGHT
7886 DD 36 03 78 10 310 ld      (ix+3), WHITE_PAPER+BRIGHT
788A 13          10 311 inc     de                          ; move DE to next string address
788B 2E 82       10 312 ld      l, $82                      ; HL points to string screen address
788D CD 14 6F    10 313 call    Print_String                ; print "Choose..."
7890             10 314 Screen_Choose_Level
7890 CD 80 6E    10 315 call    Input_Key_Scan              ; wait for a key pressed
7893 FE 31       10 316 cp      '1'                         ; is it < '1' ?
7895 38 F9       10 317 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
7897 FE 35       10 318 cp      '5'                         ; is it >= '5' ?
7899 30 F5       10 319 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
789B D6 31       10 320 sub     $31                         ; convert ASCII into level number (-1)
789D 21 99 61    10 321 ld      hl, GAME_LEVEL              ; HL points to game level address
78A0 77          10 322 ld      (hl), a                     ; save chosen game level (-1)
78A1 C9          10 323 ret
78A2             10 325 ; ----------------------------------------------------------------------------------------------------------------------
78A2             10 326 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
78A2             10 327 ;
78A2             10 328 ; Input:    HL = three-in-a-row counter address
78A2             10 329 ;           IX = three-in-a-row marks attribute address
78A2             10 330 ;
78A2             10 331 ; Output:   -
78A2             10 332 ;
78A2             10 333 ; Uses:     LEVEL_COLOR (current level color for frame border)
78A2             10 334 ;
78A2             10 335 ; Destroys: A, C
78A2             10 336 ; ----------------------------------------------------------------------------------------------------------------------
78A2             10 337 Screen_ThreeRow:
78A2 E5          10 338 push    hl                          ; store three-in-a-row counter address
78A3 7E          10 339 ld      a, (hl)                     ; set three-in-a-row counter in A
78A4 21 9C 61    10 341 ld      hl, LEVEL_COLOR             ; HL points to level color address
78A7 4E          10 342 ld      c, (hl)                     ; save level color in C
78A8 3D          10 343 dec     a                           ; is it 1?
78A9 28 09       10 344 jr      z, Screen_ThreeRow_1        ; yes, color first mark
78AB 3D          10 345 dec     a                           ; is it 2?
78AC 28 03       10 346 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
78AE DD 71 00    10 347 ld      (ix+0), c                   ; color 3rd mark
78B1             10 348 Screen_ThreeRow_2
78B1 DD 71 01    10 349 ld      (ix+1), c                   ; color 2nd mark
78B4             10 350 Screen_ThreeRow_1
78B4 DD 71 02    10 351 ld      (ix+2), c                   ; color 1st mark
78B7 E1          10 353 pop     hl                          ; restore three-in-a-row counter address
78B8 C9          10 354 ret
78B9             10 356 ; ----------------------------------------------------------------------------------------------------------------------
78B9             10 357 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
78B9             10 358 ;
78B9             10 359 ; Input:    -
78B9             10 360 ;
78B9             10 361 ; Output:   IX = three-in-a-row marks attribute address
78B9             10 362 ;
78B9             10 363 ; Destroys: -
78B9             10 364 ; ----------------------------------------------------------------------------------------------------------------------
78B9             10 365 Screen_Clear_ThreeRow:
78B9 DD 21 F2 5A 10 366 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
78BD DD 36 00 01 10 367 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
78C1 DD 36 01 01 10 368 ld      (ix+1), BLUE_INK
78C5 DD 36 02 01 10 369 ld      (ix+2), BLUE_INK
78C9 C9          10 370 ret
78CA             10 372 ; ----------------------------------------------------------------------------------------------------------------------
78CA             10 373 ; Screen_Frame_Color: set up frame color and print level number depending on current level
78CA             10 374 ;
78CA             10 375 ; Input:    BC = game level
78CA             10 376 ;
78CA             10 377 ; Output:   -
78CA             10 378 ;
78CA             10 379 ; Uses:     LEVEL_COLOR (current level color for frame border)
78CA             10 380 ;
78CA             10 381 ; Destroys: A, BC, DE, HL
78CA             10 382 ; ----------------------------------------------------------------------------------------------------------------------
78CA             10 383 Screen_Frame_Color:
78CA 3E 30       10 384 ld      a, $30                      ; convert game level number to game level character
78CC 81          10 385 add     a, c
78CD 21 0F 40    10 386 ld      hl, $400F                   ; HL points to screen address of game level
78D0 CD 20 6F    10 387 call    Print_Char                  ; print game level
78D3 21 0E 62    10 388 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
78D6 09          10 389 add     hl, bc                      ; use BC as index for color map address
78D7 7E          10 390 ld      a, (hl)                     ; A = level color
78D8 CD ED 78    10 391 call    Screen_Tiles_Color          ; color the frame according to the current level
78DB E6 07       10 392 and     %00000111                   ; mask color
78DD 32 9C 61    10 393 ld      (LEVEL_COLOR), a            ; save masked color
78E0 17          10 394 rla                                 ; rotate to text level color
78E1 17          10 395 rla
78E2 17          10 396 rla
78E3 21 08 58    10 397 ld      hl, $5808                   ; HL points to attribute address of level text
78E6 06 09       10 398 ld      b, 9                        ; length of level text (loop counter)
78E8             10 399 Screen_Level_Loop
78E8 77          10 400 ld      (hl), a                     ; apply color to level text
78E9 2C          10 401 inc     l                           ; HL points to attr address of next character of level text
78EA 10 FC       10 402 djnz    Screen_Level_Loop           ; repeat for each character of level text
78EC C9          10 403 ret
78ED             10 405 ; ----------------------------------------------------------------------------------------------------------------------
78ED             10 406 ; Screen_Tiles_Color: apply color to the frame tiles
78ED             10 407 ;
78ED             10 408 ; Input:    A = color to apply
78ED             10 409 ;
78ED             10 410 ; Output:   -
78ED             10 411 ;
78ED             10 412 ; Destroys: BC, DE, HL
78ED             10 413 ; ----------------------------------------------------------------------------------------------------------------------
78ED             10 414 Screen_Tiles_Color:
78ED             10 415 ; color up row
78ED 21 01 58    10 417 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
78F0 06 06       10 418 ld      b, 6                        ; number of tiles (loop counter)
78F2             10 419 Screen_Tiles_URow1
78F2 77          10 420 ld      (hl), a                     ; apply color
78F3 2C          10 421 inc     l                           ; move HL to the next attribute address
78F4 10 FC       10 422 djnz    Screen_Tiles_URow1          ; repeat for each tile
78F6 2E 12       10 423 ld      l, $12                      ; move HL to the next attribute address
78F8 06 0D       10 424 ld      b, 13                       ; number of tiles (loop counter)
78FA             10 425 Screen_Tiles_URow2
78FA 77          10 426 ld      (hl), a                     ; apply color
78FB 2C          10 427 inc     l                           ; move HL to the next attribute address
78FC 10 FC       10 428 djnz    Screen_Tiles_URow2          ; repeat for each tile
78FE             10 430 ; color vertical bars
78FE 2E 00       10 432 ld      l, 0                        ; move HL to the next attribute address
7900 11 1F 00    10 433 ld      de, 31                      ; attribute address displacement (for each bar)
7903 0E 03       10 434 ld      c, 3                        ; number of screen thirds (outer loop counter)
7905             10 435 Screen_Tiles_VBar1
7905 06 08       10 436 ld      b, 8                        ; number of tiles (inner loop counter)
7907             10 437 Screen_Tiles_VBar2
7907 77          10 438 ld      (hl), a                     ; apply color
7908 19          10 439 add     hl, de                      ; move HL to the right column
7909 77          10 440 ld      (hl), a                     ; apply color
790A 2C          10 441 inc     l                           ; move HL to the next attribute address
790B 10 FA       10 442 djnz    Screen_Tiles_VBar2          ; repeat for each tile
790D 24          10 443 inc     h                           ; move HL to the next screen third
790E 0D          10 444 dec     c                           ; decrement number of thirds
790F 20 F4       10 445 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
7911             10 447 ; color bottom row
7911 21 E1 5A    10 449 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
7914 06 10       10 450 ld      b, 16                       ; number of tiles (loop counter)
7916             10 451 Screen_Tiles_BRow1
7916 77          10 452 ld      (hl), a                     ; apply color
7917 2C          10 453 inc     l                           ; move HL to the next attribute address
7918 10 FC       10 454 djnz    Screen_Tiles_BRow1          ; repeat for each tile
791A 2E F6       10 455 ld      l, $F6                      ; move HL to the next attribute address
791C 06 09       10 456 ld      b, 9                        ; number of tiles (loop counter)
791E             10 457 Screen_Tiles_BRow2
791E 77          10 458 ld      (hl), a                     ; apply color
791F 2C          10 459 inc     l                           ; move HL to the next attribute address
7920 10 FC       10 460 djnz    Screen_Tiles_BRow2          ; repeat for each tile
7922 C9          10 461 ret
7923             10 463 ; ----------------------------------------------------------------------------------------------------------------------
7923             10 464 ; Screen_Menu: show main menu and wait for an option
7923             10 465 ;
7923             10 466 ; Input:    -
7923             10 467 ;
7923             10 468 ; Output:   -
7923             10 469 ;
7923             10 470 ; Uses:     GAME_LEVEL (current game level)
7923             10 471 ;
7923             10 472 ; Destroys: A, BC, DE, HL, IX, IY
7923             10 473 ; ----------------------------------------------------------------------------------------------------------------------
7923             10 474 Screen_Menu:
7923 CD C0 76    10 475 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7926 CD F9 7B    10 476 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7929             10 477 Screen_Menu_Strings
7929 DD 21 CA 59 10 478 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
792D DD 36 FF 78 10 479 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7931 01 47 0D    10 480 ld      bc, 13*256+WHITE_FLASH0     ; B = string length-1 (loop counter), C = color attributes
7934 CD 24 78    10 481 call    Screen_Apply_Color          ; apply color to string area
7937 11 80 67    10 482 ld      de, STR_OPTIONS             ; DE points to string address
793A 21 C9 48    10 483 ld      hl, $48C9                   ; HL points to string screen address
793D CD 14 6F    10 484 call    Print_String                ; print "Start new game"
7940 DD 21 2A 5A 10 485 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
7944 DD 36 FF 78 10 486 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7948 06 0A       10 487 ld      b, 10                       ; string length-1 (loop counter)
794A CD 24 78    10 488 call    Screen_Apply_Color          ; apply color to string area
794D 13          10 489 inc     de                          ; move DE to "How to play" string address
794E 21 29 50    10 490 ld      hl, $5029                   ; HL points to string screen address
7951 CD 14 6F    10 491 call    Print_String                ; print "How to play"
7954 DD 2E 8A    10 492 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
7957 DD 36 FF 78 10 493 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
795B CD 22 78    10 494 call    Screen_Apply_Color_6        ; apply color to string area
795E 13          10 495 inc     de                          ; move DE to "Credits" string address
795F 2E 89       10 496 ld      l, $89                      ; HL points to string screen address
7961 CD 14 6F    10 497 call    Print_String                ; print "Credits"
7964             10 498 Screen_Menu_Options
7964 CD 80 6E    10 499 call    Input_Key_Scan              ; wait for a key pressed
7967 FE 73       10 500 cp      's'                         ; is it 's'?
7969 C8          10 501 ret     z                           ; yes, return
796A FE 63       10 502 cp      'c'                         ; is it 'c'?
796C CA 83 7B    10 503 jp      z, Screen_Menu_Credits      ; yes, show credits
796F FE 68       10 504 cp      'h'                         ; is it 'h'?
7971 20 F1       10 505 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
7973             10 507 ; ----------------------------------------------------------------------------------------------------------------------
7973             10 508 ; Show "How to play" pages
7973             10 509 ; ----------------------------------------------------------------------------------------------------------------------
7973             10 510 Screen_Menu_How2Play
7973 CD C0 76    10 511 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7976 CD CD 76    10 512 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
7979 CD F9 76    10 513 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
797C CD 38 77    10 514 call    Screen_Frame                ; draw the screen frame
797F 21 99 61    10 516 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
7982 34          10 517 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
7983 06 00       10 518 ld      b, 0                        ; set game level in BC
7985 4E          10 519 ld      c, (hl)
7986 CD CA 78    10 520 call    Screen_Frame_Color          ; set up frame color depending on current level
7989 CD B9 78    10 521 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
798C 11 0D 68    10 523 ld      de, STR_BUTTONS             ; DE points to "Next" string address
798F 21 DB 50    10 524 ld      hl, $50DB                   ; HL points to string screen address
7992 CD 14 6F    10 525 call    Print_String                ; print "Next"
7995 13          10 526 inc     de                          ; move DE to "Back" string address
7996 21 C1 50    10 527 ld      hl, $50C1                   ; HL points to string screen address
7999 CD 14 6F    10 528 call    Print_String                ; print "Back"
799C             10 530 Screen_How2Play_RED
799C 21 5E 58    10 531 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
799F CD 33 7C    10 532 call    Screen_Clear_Text           ; clear text area attributes
79A2 CD 5D 6D    10 533 call    Draw_Board                  ; draw an empty hexagons board
79A5             10 535 ; text for RED
79A5 DD 21 01 5A 10 537 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
79A9 01 07 07    10 538 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
79AC CD 24 78    10 539 call    Screen_Apply_Color          ; apply color to string area
79AF 11 20 68    10 540 ld      de, STR_HELP1               ; DE points to string address
79B2 21 01 50    10 541 ld      hl, $5001                   ; HL points to string screen address
79B5 CD 14 6F    10 542 call    Print_String                ; print "Connect"
79B8 DD 2E 21    10 543 ld      ixl, $21                    ; IX points to "left and" string attributes address
79BB 06 08       10 544 ld      b, 8                        ; string length (loop counter)
79BD CD 24 78    10 545 call    Screen_Apply_Color          ; apply color to string area
79C0 13          10 546 inc     de                          ; move DE to "left and" string address
79C1 2E 21       10 547 ld      l, $21                      ; HL points to string screen address
79C3 CD 14 6F    10 548 call    Print_String                ; print "left and"
79C6 DD 2E 41    10 549 ld      ixl, $41                    ; IX points to "right" string attributes address
79C9 06 05       10 550 ld      b, 5                        ; set string length (loop counter)
79CB CD 24 78    10 551 call    Screen_Apply_Color          ; apply color to string area
79CE 11 38 68    10 552 ld      de, STR_HELP3_RED           ; DE points to "right" string address
79D1 2E 41       10 553 ld      l, $41                      ; HL points to string screen address
79D3 CD 14 6F    10 554 call    Print_String                ; print "right"
79D6 DD 2E 61    10 555 ld      ixl, $61                    ; IX points to "borders" string attributes address
79D9 06 07       10 556 ld      b, 7                        ; set string length (loop counter)
79DB CD 24 78    10 557 call    Screen_Apply_Color          ; apply color to string area
79DE 11 43 68    10 558 ld      de, STR_HELP4               ; DE points to "borders" string address
79E1 2E 61       10 559 ld      l, $61                      ; HL points to string screen address
79E3 CD 14 6F    10 560 call    Print_String                ; print "borders"
79E6 DD 2E 81    10 561 ld      ixl, $81                    ; IX points to "to win" string attributes address
79E9 CD 22 78    10 562 call    Screen_Apply_Color_6        ; apply color to string area
79EC 13          10 563 inc     de                          ; move DE to "to win" string address
79ED 2E 81       10 564 ld      l, $81                      ; HL points to string screen address
79EF CD 14 6F    10 565 call    Print_String                ; print "to win"
79F2 DD 21 E3 59 10 566 ld      ix, $59E3                   ; IX points to "RED" string attributes address
79F6 01 42 03    10 567 ld      bc, 3*256+RED_COLOR+BRIGHT  ; B = string length (loop counter), C = color attributes
79F9 CD 24 78    10 568 call    Screen_Apply_Color          ; apply color to string area
79FC 11 17 68    10 569 ld      de, STR_RED                 ; DE points to "RED" string address
79FF 21 E3 48    10 570 ld      hl, $48E3                   ; HL points to string screen address
7A02 CD 14 6F    10 571 call    Print_String                ; print "RED"
7A05             10 573 ; draw RED sample board
7A05 FD 21 3A 67 10 575 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A09 11 3E 66    10 576 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A0C 06 07       10 577 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A0E 3E 42       10 578 ld      a, RED_COLOR+BRIGHT         ; set token color
7A10 32 9E 61    10 579 ld      (TOKEN_COLOR), a            ; save token color
7A13 CD 1E 7C    10 580 call    Screen_Hexagons_Loop        ; draw tokens
7A16 06 02       10 581 ld      b, 2                        ; number of red tokens (loop counter)
7A18 3E 02       10 582 ld      a, RED_COLOR                ; set token color
7A1A 32 9E 61    10 583 ld      (TOKEN_COLOR), a            ; save token color
7A1D CD 1E 7C    10 584 call    Screen_Hexagons_Loop        ; draw tokens
7A20 06 09       10 585 ld      b, 9                        ; number of cyan tokens (loop counter)
7A22 3E 05       10 586 ld      a, CYAN_COLOR               ; set token color
7A24 32 9E 61    10 587 ld      (TOKEN_COLOR), a            ; save token color
7A27 CD 1E 7C    10 588 call    Screen_Hexagons_Loop        ; draw tokens
7A2A             10 590 ; wait for "Next" option pressed
7A2A DD 21 C1 5A 10 592 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A2E 01 00 04    10 593 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7A31 CD 24 78    10 594 call    Screen_Apply_Color          ; hide "Back" string
7A34 DD 2E DC    10 595 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7A37 DD 36 FF 78 10 596 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7A3B 01 47 03    10 597 ld      bc, 3*256+WHITE_FLASH0      ; B = string length-1 (loop counter), C = color attributes
7A3E CD 24 78    10 598 call    Screen_Apply_Color          ; apply color to string area
7A41             10 599 Screen_How2PlayRED_End
7A41 CD 80 6E    10 600 call    Input_Key_Scan              ; wait for a key pressed
7A44 FE 6E       10 601 cp      'n'                         ; is it 'n'?
7A46 20 F9       10 602 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7A48             10 604 Screen_How2Play_CYAN
7A48 21 0F 58    10 605 ld      hl, $580F                   ; HL points to level number attribute address
7A4B CB BE       10 606 res     7, (hl)                     ; reset flash attribute
7A4D 26 40       10 607 ld      h, $40                      ; HL points to level number screen address
7A4F 3E 31       10 608 ld      a, '1'                      ; set level number (char)
7A51 CD 20 6F    10 609 call    Print_Char                  ; print '1'
7A54 CD B9 78    10 610 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7A57 21 C9 59    10 612 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7A5A CD 33 7C    10 613 call    Screen_Clear_Text           ; clear text area attributes
7A5D CD 5D 6D    10 614 call    Draw_Board                  ; draw an empty hexagons board
7A60             10 616 ; text for CYAN
7A60 DD 21 98 58 10 618 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7A64 01 07 07    10 619 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7A67 CD 24 78    10 620 call    Screen_Apply_Color          ; apply color to string area
7A6A 11 20 68    10 621 ld      de, STR_HELP1               ; DE points to "Connect" string address
7A6D 21 98 40    10 622 ld      hl, $4098                   ; HL points to string screen address
7A70 CD 14 6F    10 623 call    Print_String                ; print "Connect"
7A73 DD 2E B9    10 624 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7A76 CD 22 78    10 625 call    Screen_Apply_Color_6        ; apply color to string area
7A79 11 31 68    10 626 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7A7C 2E B9       10 627 ld      l, $B9                      ; HL points to string screen address
7A7E CD 14 6F    10 628 call    Print_String                ; print "up and"
7A81 DD 2E DB    10 629 ld      ixl, $DB                    ; IX points to "down" string attributes address
7A84 06 04       10 630 ld      b, 4                        ; string length (loop counter)
7A86 CD 24 78    10 631 call    Screen_Apply_Color          ; apply color to string area
7A89 11 3E 68    10 632 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7A8C 2E DB       10 633 ld      l, $DB                      ; HL points to string screen address
7A8E CD 14 6F    10 634 call    Print_String                ; print "down"
7A91 DD 2E F8    10 635 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7A94 06 07       10 636 ld      b, 7                        ; string length (loop counter)
7A96 CD 24 78    10 637 call    Screen_Apply_Color          ; apply color to string area
7A99 13          10 638 inc     de                          ; move DE to "borders" string address
7A9A 2E F8       10 639 ld      l, $F8                      ; HL points to string screen address
7A9C CD 14 6F    10 640 call    Print_String                ; print "borders"
7A9F DD 21 19 59 10 641 ld      ix, $5919                   ; IX points to "to win" string attributes address
7AA3 CD 22 78    10 642 call    Screen_Apply_Color_6        ; apply color to string area
7AA6 13          10 643 inc     de                          ; move DE to "to win" string address
7AA7 21 19 48    10 644 ld      hl, $4819                   ; HL points to string screen address
7AAA CD 14 6F    10 645 call    Print_String                ; print "to win"
7AAD DD 21 7A 58 10 646 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7AB1 01 45 04    10 647 ld      bc, $0445                   ; B = string length (loop counter)
7AB4             10 648 ; C = color attributes (cyan+bright)
7AB4 CD 24 78    10 649 call    Screen_Apply_Color          ; apply color to string area
7AB7 11 1B 68    10 650 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7ABA 21 7A 40    10 651 ld      hl, $407A                   ; HL points to string screen address
7ABD CD 14 6F    10 652 call    Print_String                ; print "CYAN"
7AC0             10 654 ; draw CYAN sample board
7AC0 FD 21 5E 67 10 656 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7AC4 11 3E 66    10 657 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7AC7 06 07       10 658 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7AC9 3E 45       10 659 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7ACB 32 9E 61    10 660 ld      (TOKEN_COLOR), a            ; save token color
7ACE CD 1E 7C    10 661 call    Screen_Hexagons_Loop        ; draw tokens
7AD1 06 02       10 662 ld      b, 2                        ; number of cyan tokens (loop counter)
7AD3 3E 05       10 663 ld      a, CYAN_COLOR               ; set token color
7AD5 32 9E 61    10 664 ld      (TOKEN_COLOR), a            ; save token color
7AD8 CD 1E 7C    10 665 call    Screen_Hexagons_Loop        ; draw tokens
7ADB 06 08       10 666 ld      b, 8                        ; number of red tokens (loop counter)
7ADD 3E 02       10 667 ld      a, RED_COLOR                ; set token color
7ADF 32 9E 61    10 668 ld      (TOKEN_COLOR), a            ; save token color
7AE2 CD 1E 7C    10 669 call    Screen_Hexagons_Loop        ; draw tokens
7AE5             10 671 ; wait for "Next" or "Back" options pressed
7AE5 DD 21 C2 5A 10 673 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7AE9 DD 36 FF 78 10 674 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7AED 01 47 03    10 675 ld      bc, 3*256+WHITE_FLASH0      ; B = string length (-1), C = color attributes
7AF0 CD 24 78    10 676 call    Screen_Apply_Color          ; apply color to string area
7AF3             10 677 Screen_How2PlayCYAN_End
7AF3 CD 80 6E    10 678 call    Input_Key_Scan              ; wait for a key pressed
7AF6 FE 62       10 679 cp      'b'                         ; is it 'b'?
7AF8 CA 9C 79    10 680 jp      z, Screen_How2Play_RED      ; yes, show RED page
7AFB FE 6E       10 681 cp      'n'                         ; is it 'n'?
7AFD 20 F4       10 682 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7AFF             10 684 Screen_How2Play_LevelUp
7AFF 21 5E 58    10 685 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B02 CD 33 7C    10 686 call    Screen_Clear_Text           ; clear text area attributes
7B05             10 688 ; text for Level Up
7B05 DD 21 21 5A 10 690 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B09 01 07 09    10 691 ld      bc, 9*256+WHITE             ; B = string length (loop counter), C = color attributes
7B0C CD 24 78    10 692 call    Screen_Apply_Color          ; apply color to string area
7B0F 11 52 68    10 693 ld      de, STR_HELP                ; DE points to "Win three" string address
7B12 21 21 50    10 694 ld      hl, $5021                   ; HL points to string screen address
7B15 CD 14 6F    10 695 call    Print_String                ; print "Win three"
7B18 DD 2E 41    10 696 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B1B 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7B1D CD 24 78    10 698 call    Screen_Apply_Color          ; apply color to string area
7B20 13          10 699 inc     de                          ; move DE to "times in" string address
7B21 2E 41       10 700 ld      l, $41                      ; HL points to string screen address
7B23 CD 14 6F    10 701 call    Print_String                ; print "times in"
7B26 DD 2E 61    10 702 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B29 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7B2B CD 24 78    10 704 call    Screen_Apply_Color          ; apply color to string area
7B2E 13          10 705 inc     de                          ; move DE to "a row to" string address
7B2F 2E 61       10 706 ld      l, $61                      ; HL points to string screen address
7B31 CD 14 6F    10 707 call    Print_String                ; print "a row to"
7B34 DD 2E 81    10 708 ld      ixl, $81                    ; IX points to "level up" string attributes address
7B37 06 08       10 709 ld      b, 8                        ; string length (loop counter)
7B39 CD 24 78    10 710 call    Screen_Apply_Color          ; apply color to string area
7B3C 13          10 711 inc     de                          ; move DE to "level up" string address
7B3D 2E 81       10 712 ld      l, $81                      ; HL points to string screen address
7B3F CD 14 6F    10 713 call    Print_String                ; print "level up"
7B42             10 715 ; reset bright of cyan tokens
7B42 FD 21 5E 67 10 717 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B46 11 3E 66    10 718 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B49 06 07       10 719 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B4B 3E 05       10 720 ld      a, CYAN_COLOR               ; set new token color
7B4D 32 9E 61    10 721 ld      (TOKEN_COLOR), a            ; save color
7B50 CD 1E 7C    10 722 call    Screen_Hexagons_Loop        ; draw tokens
7B53             10 724 ; set flash attribute of level number and three-in-a-row marks
7B53 21 0F 58    10 726 ld      hl, $580F                   ; HL points to level number attribute address
7B56 CB FE       10 727 set     7, (hl)                     ; set flash attribute
7B58 21 0F 40    10 728 ld      hl, $400F                   ; HL points to level number screen address
7B5B 3E 32       10 729 ld      a, '2'                      ; set new level
7B5D CD 20 6F    10 730 call    Print_Char                  ; print new level
7B60 DD 21 F2 5A 10 731 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7B64 DD 36 00 B8 10 732 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7B68 DD 36 01 B8 10 733 ld      (ix+1), WHITE_PAPER+FLASH
7B6C DD 36 02 B8 10 734 ld      (ix+2), WHITE_PAPER+FLASH
7B70             10 736 ; wait for "Next" or "Back" options pressed
7B70             10 738 Screen_How2Play_End
7B70 CD 80 6E    10 739 call    Input_Key_Scan              ; wait for a key pressed
7B73 FE 62       10 740 cp      'b'                         ; is it 'b'?
7B75 CA 48 7A    10 741 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7B78 FE 6E       10 742 cp      'n'                         ; is it 'n'?
7B7A 20 F4       10 743 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7B7C 21 99 61    10 745 ld      hl, GAME_LEVEL              ; HL points to game level address
7B7F 35          10 746 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7B80 C3 23 79    10 747 jp      Screen_Menu                 ; return to main menu
7B83             10 749 ; ----------------------------------------------------------------------------------------------------------------------
7B83             10 750 ; Show credits
7B83             10 751 ; ----------------------------------------------------------------------------------------------------------------------
7B83             10 752 Screen_Menu_Credits
7B83 3E 47       10 753 ld      a, WHITE_FLASH0             ; set attribute color
7B85 CD EC 7B    10 754 call    Screen_Credits_ATTR         ; apply color to credits area
7B88 11 A3 67    10 756 ld      de, STR_DESIGN              ; DE points to "Design..." string address
7B8B 21 84 48    10 757 ld      hl, $4884                   ; HL points to string screen address
7B8E CD 14 6F    10 758 call    Print_String                ; print "Design..."
7B91 11 F1 67    10 759 ld      de, STR_ANTONIO             ; move DE to "Antonio Luque" string 
7B94 CD 14 6F    10 760 call    Print_String                ; print "Antonio Luque"
7B97 11 B0 67    10 761 ld      de, STR_CODE                ; move DE to "Code..." string address
7B9A 2E C4       10 762 ld      l, $C4                      ; HL points to string screen address
7B9C CD 14 6F    10 763 call    Print_String                ; print "Code..."
7B9F 11 F1 67    10 764 ld      de, STR_ANTONIO             ; move DE to "Antonio Luque" string 
7BA2 CD 14 6F    10 765 call    Print_String                ; print "Antonio Luque"
7BA5 2E F0       10 766 ld      l, $F0                      ; HL points to string screen address
7BA7 11 D7 67    10 767 ld      de, STR_EINAR               ; move DE to "Einar Saukas" string address
7BAA CD 14 6F    10 768 call    Print_String                ; print "Einar Saukas"
7BAD 11 BD 67    10 769 ld      de, STR_FONT                ; move DE to "Font..." string address
7BB0 21 24 50    10 770 ld      hl, $5024                   ; HL points to string screen address
7BB3 CD 14 6F    10 771 call    Print_String                ; print "Font..."
7BB6 11 D7 67    10 772 ld      de, STR_EINAR               ; move DE to "Einar Saukas" string address
7BB9 CD 14 6F    10 773 call    Print_String                ; print "Einar Saukas"
7BBC 11 CA 67    10 774 ld      de, STR_GRAPHICS            ; move DE to "Graphics..." string address
7BBF 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7BC1 CD 14 6F    10 776 call    Print_String                ; print "Graphics..."
7BC4 13          10 777 inc     de                          ; move DE to "Einar Saukas" string address
7BC5 CD 14 6F    10 778 call    Print_String                ; print "Einar Saukas"
7BC8 13          10 779 inc     de                          ; move DE to Empty12 string
7BC9 2E 84       10 780 ld      l, $84                      ; HL points to string screen address
7BCB CD 14 6F    10 781 call    Print_String                ; print Empty12 string
7BCE 13          10 782 inc     de                          ; move DE to "Antonio Luque" string 
7BCF CD 14 6F    10 783 call    Print_String                ; print "Antonio Luque"
7BD2 DD 21 E9 5A 10 784 ld      ix, $5AE9                   ; IX points to "Press any key" string attributes address
7BD6 01 38 0D    10 785 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7BD9 CD 24 78    10 786 call    Screen_Apply_Color          ; apply color to string area
7BDC 13          10 787 inc     de                          ; move DE to "Press any key" string address
7BDD 2E E9       10 788 ld      l, $E9                      ; HL points to string screen address
7BDF CD 14 6F    10 789 call    Print_String                ; print "Press any key"
7BE2 CD 80 6E    10 790 call    Input_Key_Scan              ; wait for a key pressed
7BE5 AF          10 792 xor     a                           ; set attribute color (black)
7BE6 CD EC 7B    10 793 call    Screen_Credits_ATTR         ; apply color to credits area
7BE9 C3 29 79    10 794 jp      Screen_Menu_Strings         ; return to main menu
7BEC             10 796 ; ----------------------------------------------------------------------------------------------------------------------
7BEC             10 797 ; Screen_Menu_ATTR: apply an attribute color to credits area
7BEC             10 798 ;
7BEC             10 799 ; Input:    A = attribute color to apply
7BEC             10 800 ;
7BEC             10 801 ; Output:   -
7BEC             10 802 ;
7BEC             10 803 ; Destroys: BC, DE, HL
7BEC             10 804 ; ----------------------------------------------------------------------------------------------------------------------
7BEC             10 805 Screen_Credits_ATTR:
7BEC 21 80 59    10 806 ld      hl, $5980                   ; HL points to start of credits area attributes address
7BEF 11 81 59    10 807 ld      de, $5981                   ; DE points to next byte of credits area attributes address
7BF2 77          10 808 ld      (hl), a                     ; set first byte of attribute color
7BF3 01 7F 01    10 809 ld      bc, 32*12-1                 ; length of attributes area (-1 already set)
7BF6 ED B0       10 810 ldir                                ; fill the rest of attributes color of credits area
7BF8 C9          10 811 ret
7BF9             10 813 ; ----------------------------------------------------------------------------------------------------------------------
7BF9             10 814 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7BF9             10 815 ;
7BF9             10 816 ; Input:    -
7BF9             10 817 ;
7BF9             10 818 ; Output:   -
7BF9             10 819 ;
7BF9             10 820 ; Uses:     TOKEN_COLOR (current token color)
7BF9             10 821 ;
7BF9             10 822 ; Destroys: A, BC, DE, HL, IX, IY
7BF9             10 823 ; ----------------------------------------------------------------------------------------------------------------------
7BF9             10 824 Screen_Hexagons:
7BF9 FD 21 EA 66 10 825 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7BFD 3E 07       10 826 ld      a, WHITE                    ; set hexagon color
7BFF 32 9E 61    10 827 ld      (TOKEN_COLOR), a            ; save hexagon color
7C02 11 7E 65    10 828 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C05 06 1C       10 829 ld      b, 28                       ; number of empty hexagons (loop counter)
7C07 CD 1E 7C    10 830 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C0A 3E 05       10 831 ld      a, CYAN_COLOR               ; set token color
7C0C 32 9E 61    10 832 ld      (TOKEN_COLOR), a            ; save hexagon color
7C0F 11 3E 66    10 833 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C12 06 06       10 834 ld      b, 6                        ; number of cyan tokens (loop counter)
7C14 CD 1E 7C    10 835 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C17 3E 02       10 836 ld      a, RED_COLOR                ; set token color
7C19 32 9E 61    10 837 ld      (TOKEN_COLOR), a            ; save hexagon color
7C1C 06 06       10 838 ld      b, 6                        ; number of red tokens (loop counter)
7C1E             10 839 Screen_Hexagons_Loop:
7C1E FD 6E 00    10 840 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C21 FD 66 01    10 841 ld      h, (iy+1)
7C24 CD CB 6D    10 842 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C27 D5          10 843 push    de                          ; store hexagon/token sprite address
7C28 CD 9D 6D    10 844 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C2B D1          10 845 pop     de                          ; restore hexagon/token sprite address
7C2C FD 23       10 846 inc     iy                          ; move IY to next hexagon/token screen address
7C2E FD 23       10 847 inc     iy
7C30 10 EC       10 848 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C32 C9          10 849 ret
7C33             10 851 ; ----------------------------------------------------------------------------------------------------------------------
7C33             10 852 ; Screen_Clear_Text: clean a text attributes area
7C33             10 853 ;
7C33             10 854 ; Input:    HL = text area attributes address
7C33             10 855 ;
7C33             10 856 ; Output:   -
7C33             10 857 ;
7C33             10 858 ; Destroys: BC, DE, HL
7C33             10 859 ; ----------------------------------------------------------------------------------------------------------------------
7C33             10 860 Screen_Clear_Text:
7C33 01 30 00    10 861 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7C36             10 862 Screen_ClearText_Loop
7C36 11 18 00    10 863 ld      de, 24                      ; displacement for each text row
7C39 19          10 864 add     hl, de                      ; add displacement to text area attributes address
7C3A 54          10 865 ld      d, h                        ; DE points to text area attributes address
7C3B 5D          10 866 ld      e, l
7C3C 36 00       10 867 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7C3E 13          10 868 inc     de                          ; move DE to next byte attribute address
7C3F ED A0       10 869 ldi                                 ; set attributes color for the rest of bytes of current row
7C41 ED A0       10 870 ldi
7C43 ED A0       10 871 ldi
7C45 ED A0       10 872 ldi
7C47 ED A0       10 873 ldi
7C49 ED A0       10 874 ldi
7C4B ED A0       10 875 ldi
7C4D ED A0       10 876 ldi
7C4F EA 36 7C    10 877 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7C52 C9          10 878 ret

; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

7C53             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7C53             0 20 ; Credits and acknowledgements:
7C53             0 21 ;
7C53             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7C53             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7C53             0 24 ;   "King+" font and TOKEN graphics.
7C53             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7C53             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7C53             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7C53             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7C53             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7C53             0 30 ;
7C53             0 31 ; - Special thanks to my wife Sonia.
7C53             0 32 ; ----------------------------------------------------------------------------------------------------------------------
