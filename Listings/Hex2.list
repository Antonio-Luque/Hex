
; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   ORG     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         DEFS    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 DEFB      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 DEFB                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 DEFB    0                           ; board potential
6198 00          1 51 DEFB    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               DEFB    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                DEFB    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             DEFB    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             DEFB    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              DEFB    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             DEFB    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            DEFB    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 DEFB    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 DEFB    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 DEFB    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 DEFB    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 DEFB    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 DEFB    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 DEFB    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 DEFM    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;ORG     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 B1 73       1 85 DEFW    PathFinder_CYAN_Edge_0
6202 D1 73       1 86 DEFW    PathFinder_CYAN_Edge_1
6204 EC 73       1 87 DEFW    PathFinder_CYAN_Edge_2
6206 0A 74       1 88 DEFW    PathFinder_CYAN_Edge_3
6208 29 74       1 89 DEFW    PathFinder_CYAN_Edge_4
620A 47 74       1 90 DEFW    PathFinder_CYAN_Edge_5
620C 62 74       1 91 DEFW    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E 00          1 96 THREE_ROW               DEFB    0                           ; three-in-a-row counter
620F 0F 0E 0C 0B 1 97 ROW_COLOR_MAP           DEFB    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6213 0D 0A       1 97 
6215 00 2D 30 00 1 98 STR_MOVE                DEFB    0, '-', '0', 0, '\0'        ; formatted move string
6219 00          1 98 
621A 53 70 65 63 1 99 STR_SPECCY              DEFM    "Speccy\0"
621E 63 79 00    1 99 
6221 50 6C 61 79 1 100 STR_PLAYER              DEFM    "Player\0"
6225 65 72 00    1 100 
6228 4C 65 76 65 1 101 STR_LEVELTEXT           DEFM    "Level\0"
622C 6C 00       1 101 
622E 46 49 4C 4C 1 102 STR_FILLED              DEFM    "FILLED\0"
6232 45 44 00    1 102 
6235 57 41 49 54 1 103 STR_WAIT                DEFM    "WAIT\0"
6239 00          1 103 
623A 20 57 49 4E 1 104 STR_WINNER              DEFM    " WINS \0"
623E 53 20 00    1 104 
6241 20 20 20 20 1 105 STR_EMPTY4              DEFM    "    \0"
6245 00          1 105 
6246 20 20 20 20 1 106 STR_EMPTY6              DEFM    "      \0"
624A 20 20 00    1 106 
624D             1 108 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 109 ; Conversion table: from position to XY board indexes
624D             1 110 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 111 BOARD_COORDINATES:
624D 00 00 00 00 1 112 DEFB    $00, $00, $00, $00, $00, $00, $00, $00
6251 00 00 00 00 1 112 
6255 00 09 0A 0B 1 113 DEFB    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
6259 0C 0D 0E 0F 1 113 
625D 00 12 13 14 1 114 DEFB    $00, $12, $13, $14, $15, $16, $17, $18
6261 15 16 17 18 1 114 
6265 00 1B 1C 1D 1 115 DEFB    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
6269 1E 1F 20 21 1 115 
626D 00 24 25 26 1 116 DEFB    $00, $24, $25, $26, $27, $28, $29, $2A
6271 27 28 29 2A 1 116 
6275 00 2D 2E 2F 1 117 DEFB    $00, $2D, $2E, $2F, $30, $31, $32, $33
6279 30 31 32 33 1 117 
627D 00 36 37 38 1 118 DEFB    $00, $36, $37, $38, $39, $3A, $3B, $3C
6281 39 3A 3B 3C 1 118 
6285 00 3F 40 41 1 119 DEFB    $00, $3F, $40, $41, $42, $43, $44, $45
6289 42 43 44 45 1 119 
628D             1 121 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 122 ; Graphics map indexes for the frame tiles
628D             1 123 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 124 FRAME_MAP:
628D 00 01 01 01 1 125 DEFB      0,   1,   1,   1,   1,   1,   2,   3
6291 01 01 02 03 1 125 
6295 04 FF FF FF 1 126 DEFB      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
6299 FF FF FF FF 1 126 
629D 05 06 07 01 1 127 DEFB      5,   6,   7,   1,   1,   1,   1,   1
62A1 01 01 01 01 1 127 
62A5 01 01 01 01 1 128 DEFB      1,   1,   1,   1,   1,   1,   1,   8
62A9 01 01 01 08 1 128 
62AD 09 01 01 01 1 129 DEFB      9,   1,   1,   1,   1,   1,   1,   1
62B1 01 01 01 01 1 129 
62B5 01 01 01 01 1 130 DEFB      1,   1,   1,   1,   1,   1,   1,   1
62B9 01 01 01 01 1 130 
62BD 0A 06 0D 0D 1 131 DEFB     10,   6,  13,  13,  13,   3,  11,   1
62C1 0D 03 0B 01 1 131 
62C5 01 01 01 01 1 132 DEFB      1,   1,   1,   1,   1,   1,   1,  12
62C9 01 01 01 0C 1 132 
62CD             1 134 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 135 ; Definition of a small "Opening Book" for speccy first move
62CD             1 136 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 137 OPENINGS:
62CD 0F 14 16 17 1 138 DEFB    $0F, $14, $16, $17, $18, $1C, $1D
62D1 18 1C 1D    1 138 
62D4 1E 1F 20 24 1 139 DEFB    $1E, $1F, $20, $24, $25, $26, $27
62D8 25 26 27    1 139 
62DB 28 29 2A 2E 1 140 DEFB    $28, $29, $2A, $2E, $2F, $30, $31
62DF 2F 30 31    1 140 
62E2 32 36 37 38 1 141 DEFB    $32, $36, $37, $38, $3A, $3F
62E6 3A 3F       1 141 
62E8             1 143 ; ----------------------------------------------------------------------------------------------------------------------
62E8             1 144 ; Timer variables
62E8             1 145 ; ----------------------------------------------------------------------------------------------------------------------
62E8 00          1 146 TIMER_FLAG              DEFB    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62E9             1 147 ; for each timer:
62E9             1 148 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62E9             1 149 ;   2nd byte = seconds counter
62E9             1 150 ;   3th byte = minutes counter
62E9 32 00 00    1 151 CYAN_TIMER              DEFB    50, 0, 0
62EC 32 00 00    1 152 RED_TIMER               DEFB    50, 0, 0
62EF             1 154 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 155 ; Screen addresses look-up array for board numbers
62EF             1 156 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 157 NUMBER_SCREEN:
62EF A5 43 E6 43 1 158 DEFW    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F3 27 4B 68 4B 1 158 
62F7 A9 4B EA 4B 1 158 
62FB 2B 53       1 158 
62FD FF FF FF    1 160 FILLER_1                DEFB    $FF, $FF, $FF               ; filler to align next block (not used)
6300             1 162 ;ORG     $6300
6300             1 163 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 164 ; Circular queue
6300             1 165 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 166 RED_QUEUE_AREA          DEFS    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 166 
6308 00 00 00 00 1 166 
630C 00 00 00 00 1 166 
6310 00 00 00 00 1 166 
6314 00 00 00 00 1 166 
6318 00 00 00 00 1 166 
631C 00 00 00 00 1 166 
6320 00 00 00 00 1 166 
6324 00 00 00 00 1 166 
6328 00 00 00 00 1 166 
632C 00 00 00 00 1 166 
6330 00 00 00 00 1 166 
6334 00 00 00 00 1 166 
6338 00 00 00 00 1 166 
633C 00 00 00 00 1 166 
6340 00 00 00 00 1 166 
6344 00 00 00 00 1 166 
6348 00 00 00 00 1 166 
634C 00 00 00 00 1 166 
6350 00 00 00 00 1 166 
6354 00 00 00 00 1 166 
6358 00 00 00 00 1 166 
635C 00 00 00 00 1 166 
6360 00 00 00 00 1 166 
6364 00 00 00 00 1 166 
6368 00 00 00 00 1 166 
636C 00 00 00 00 1 166 
6370 00 00 00 00 1 166 
6374 00 00 00 00 1 166 
6378 00 00 00 00 1 166 
637C 00 00 00 00 1 166 
6380 00 00 00 00 1 166 
6384 00 00 00 00 1 166 
6388 00 00 00 00 1 166 
638C 00 00 00 00 1 166 
6390 00 00 00 00 1 166 
6394 00 00 00 00 1 166 
6398 00 00 00 00 1 166 
639C 00 00 00 00 1 166 
63A0 00 00 00 00 1 166 
63A4 00 00 00 00 1 166 
63A8 00 00 00 00 1 166 
63AC 00 00 00 00 1 166 
63B0 00 00 00 00 1 166 
63B4 00 00 00 00 1 166 
63B8 00 00 00 00 1 166 
63BC 00 00 00 00 1 166 
63C0 00 00 00 00 1 166 
63C4 00 00 00 00 1 166 
63C8 00 00 00 00 1 166 
63CC 00 00 00 00 1 166 
63D0 00 00 00 00 1 166 
63D4 00 00 00 00 1 166 
63D8 00 00 00 00 1 166 
63DC 00 00 00 00 1 166 
63E0 00 00 00 00 1 166 
63E4 00 00 00 00 1 166 
63E8 00 00 00 00 1 166 
63EC 00 00 00 00 1 166 
63F0 00 00 00 00 1 166 
63F4 00 00 00 00 1 166 
63F8 00 00 00 00 1 166 
63FC 00 00 00 00 1 166 
6400             1 168 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 169 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 170 ; 
6400             1 171 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 172 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 173 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 174 ; 
6400             1 175 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 176 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 177 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 178 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 179 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 180 DEFB      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 180 
6408 7F 00 00 00 1 181 DEFB    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 181 
6410 80          1 181 
6411 7F 00 00 00 1 182 DEFB       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 182 
6419 81          1 182 
641A 7F 00 00 00 1 183 DEFB          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 183 
6422 82          1 183 
6423 7F 00 00 00 1 184 DEFB             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 184 
642B 83          1 184 
642C 7F 00 00 00 1 185 DEFB                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 185 
6434 84          1 185 
6435 7F 00 00 00 1 186 DEFB                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 186 
643D 85          1 186 
643E 7F 00 00 00 1 187 DEFB                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 187 
6446 86          1 187 
6447 7F 7F 7F 7F 1 188 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 188 
644F 7F          1 188 
6450             1 189 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 190 DEFB    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 190 
6458 7F          1 190 
6459 81 00 00 00 1 191 DEFB       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 191 
6461 7F          1 191 
6462 82 00 00 00 1 192 DEFB          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 192 
646A 7F          1 192 
646B 83 00 00 00 1 193 DEFB             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 193 
6473 7F          1 193 
6474 84 00 00 00 1 194 DEFB                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 194 
647C 7F          1 194 
647D 85 00 00 00 1 195 DEFB                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 195 
6485 7F          1 195 
6486 86 00 00 00 1 196 DEFB                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 196 
648E 7F          1 196 
648F 7F 7F 7F 7F 1 197 DEFB                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 197 
6497             1 199 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 200 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 201 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 202 TIMER_DIGITS:
6497 00 0F 0B 0B 1 203 DEFB    $00, $0F, $0B, $0B, $0B, $0F, $00, $00
649B 0B 0F 00 00 1 203 
649F 00 06 0E 06 1 204 DEFB    $00, $06, $0E, $06, $06, $06, $00, $00
64A3 06 06 00 00 1 204 
64A7 00 0F 03 0F 1 205 DEFB    $00, $0F, $03, $0F, $08, $0F, $00, $00
64AB 08 0F 00 00 1 205 
64AF 00 0F 03 07 1 206 DEFB    $00, $0F, $03, $07, $03, $0F, $00, $00
64B3 03 0F 00 00 1 206 
64B7 00 0B 0B 0F 1 207 DEFB    $00, $0B, $0B, $0F, $03, $03, $00, $00
64BB 03 03 00 00 1 207 
64BF 00 0F 08 0F 1 208 DEFB    $00, $0F, $08, $0F, $03, $0F, $00, $00
64C3 03 0F 00 00 1 208 
64C7 00 0F 0C 0F 1 209 DEFB    $00, $0F, $0C, $0F, $0D, $0F, $00, $00
64CB 0D 0F 00 00 1 209 
64CF 00 0F 03 03 1 210 DEFB    $00, $0F, $03, $03, $03, $03, $00, $00
64D3 03 03 00 00 1 210 
64D7 00 0F 0B 0F 1 211 DEFB    $00, $0F, $0B, $0F, $0B, $0F, $00, $00
64DB 0B 0F 00 00 1 211 
64DF 00 0F 0B 0F 1 212 DEFB    $00, $0F, $0B, $0F, $03, $0F, $00, $00
64E3 03 0F 00 00 1 212 
64E7             1 214 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 215 ; Tone parameters for sound effects
64E7             1 216 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 217 ; for each tone (from left to right):
64E7             1 218 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 219 ;   - length of a frame (1..65536)
64E7             1 220 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 221 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 222 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 223 TOKEN_FX                DEFW       1, 1000, 1400,   0
64EB 78 05 00 00 1 223 
64EF 05 00 88 13 1 224 WINNER_FX               DEFW       5, 5000,  200, 100
64F3 C8 00 64 00 1 224 
64F7 E8 03 0A 00 1 225 FILLED_FX               DEFW    1000,   10,  100,   0
64FB 64 00 00 00 1 225 
64FF FF          1 227 FILLER_2                DEFB    $FF                         ; filler to align next block (not used)
6500             1 229 ;ORG     $6500
6500             1 230 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 231 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 232 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 233 RED_VECTOR_TABLE:
6500 97 72       1 234 DEFW    PathFinder_RED_Edge_0
6502 C5 72       1 235 DEFW    PathFinder_RED_Edge_1
6504 EB 72       1 236 DEFW    PathFinder_RED_Edge_2
6506 11 73       1 237 DEFW    PathFinder_RED_Edge_3
6508 37 73       1 238 DEFW    PathFinder_RED_Edge_4
650A 5D 73       1 239 DEFW    PathFinder_RED_Edge_5
650C 83 73       1 240 DEFW    PathFinder_RED_Edge_6
650E             1 242 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 243 ; Graphics for the screen frame
650E             1 244 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 245 FRAME_TILES:
650E 00 00 1F 3F 1 246 DEFB    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C
6512 3F 3F 3C 3C 1 246 
6516 00 00 FF FF 1 247 DEFB    $00, $00, $FF, $FF, $FF, $FF, $00, $00
651A FF FF 00 00 1 247 
651E 00 00 FF FE 1 248 DEFB    $00, $00, $FF, $FE, $FE, $FF, $00, $00
6522 FE FF 00 00 1 248 
6526 03 07 0F 0F 1 249 DEFB    $03, $07, $0F, $0F, $0F, $0F, $07, $03
652A 0F 0F 07 03 1 249 
652E FF FE FC FC 1 250 DEFB    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF
6532 FC FC FE FF 1 250 
6536 FF 7F 3F 3F 1 251 DEFB    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF
653A 3F 3F 7F FF 1 251 
653E C0 E0 F0 F0 1 252 DEFB    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0
6542 F0 F0 E0 C0 1 252 
6546 00 00 FF 7F 1 253 DEFB    $00, $00, $FF, $7F, $7F, $FF, $00, $00
654A 7F FF 00 00 1 253 
654E 00 00 F8 FC 1 254 DEFB    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C
6552 FC FC 3C 3C 1 254 
6556 3C 3C 3F 3F 1 255 DEFB    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00
655A 3F 1F 00 00 1 255 
655E 00 00 FE FF 1 256 DEFB    $00, $00, $FE, $FF, $FF, $FE, $00, $00
6562 FF FE 00 00 1 256 
6566 00 00 7F FF 1 257 DEFB    $00, $00, $7F, $FF, $FF, $7F, $00, $00
656A FF 7F 00 00 1 257 
656E 3C 3C FC FC 1 258 DEFB    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00
6572 FC F8 00 00 1 258 
6576 00 00 38 7C 1 259 DEFB    $00, $00, $38, $7C, $7C, $38, $00, $00
657A 7C 38 00 00 1 259 
657E             1 261 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 262 ; Hexagon sprites
657E             1 263 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 264 HEXAGON_EMPTY:
657E 07 E0 18 18 1 265 DEFB    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 265 
6586 48 02 48 02 1 266 DEFB    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 266 
658E 40 02 40 02 1 267 DEFB    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 267 
6596 20 24 20 04 1 268 DEFB    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 268 
659E             1 269 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 270 DEFB    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 270 
65A6 24 04 24 04 1 271 DEFB    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 271 
65AE 20 04 20 04 1 272 DEFB    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 272 
65B6 10 48 10 08 1 273 DEFB    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 273 
65BE 01 80 02 40 1 275 DEFB    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 275 
65C6 0A 10 0A 10 1 276 DEFB    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 276 
65CE 08 10 08 10 1 277 DEFB    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 277 
65D6 08 90 04 20 1 278 DEFB    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 278 
65DE 00 80 00 80 1 280 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 280 
65E6 00 80 00 80 1 281 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 281 
65EE 00 80 00 80 1 282 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 282 
65F6 00 80 00 80 1 283 DEFB    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 283 
65FE 01 80 02 40 1 285 DEFB    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 285 
6606 0B D0 0B D0 1 286 DEFB    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 286 
660E 0B D0 0B D0 1 287 DEFB    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 287 
6616 0B D0 05 A0 1 288 DEFB    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 288 
661E 03 C0 0C 30 1 290 DEFB    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 290 
6626 2F F4 2F F4 1 291 DEFB    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 291 
662E 2F F4 2F F4 1 292 DEFB    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 292 
6636 17 E8 13 C8 1 293 DEFB    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 293 
663E             1 294 HEXAGON_TOKEN:
663E 07 E0 18 18 1 295 DEFB    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 295 
6646 5F FA 5F FA 1 296 DEFB    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 296 
664E 5F FA 5F FA 1 297 DEFB    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 297 
6656 2F F4 27 E4 1 298 DEFB    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 298 
665E             1 300 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 301 ; Board letter sprites
665E             1 302 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 303 LETTER_SPRITES:
665E 3C 7E FF C3 1 304 DEFB    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C
6662 F3 C3 D3 C3 1 304 
6666 7E 3C       1 304 
6668 3C 7E CF CF 1 305 DEFB    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C
666C C3 CB CB C3 1 305 
6670 7E 3C       1 305 
6672 3C 7E FF E3 1 306 DEFB    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C
6676 CF CF CF E3 1 306 
667A 7E 3C       1 306 
667C 3C 7E F3 F3 1 307 DEFB    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C
6680 C3 D3 D3 C3 1 307 
6684 7E 3C       1 307 
6686 3C 7E FF E3 1 308 DEFB    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C
668A CB C3 CF E3 1 308 
668E 7E 3C       1 308 
6690 3C 7E E3 CF 1 309 DEFB    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C
6694 C7 CF CF CF 1 309 
6698 7E 3C       1 309 
669A 3C 7E FF E3 1 310 DEFB    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C
669E D3 D3 E3 F3 1 310 
66A2 46 3C       1 310 
66A4             1 312 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 313 ; Board number sprites
66A4             1 314 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 315 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 316 DEFB    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C
66A8 E7 E7 E7 E7 1 316 
66AC 7E 3C       1 316 
66AE 3C 7E E7 D3 1 317 DEFB    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C
66B2 F3 E7 CF C3 1 317 
66B6 7E 3C       1 317 
66B8 3C 7E C7 F3 1 318 DEFB    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C
66BC E3 F3 F3 C7 1 318 
66C0 7E 3C       1 318 
66C2 3C 7E D3 D3 1 319 DEFB    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C
66C6 C3 F3 F3 F3 1 319 
66CA 7E 3C       1 319 
66CC 3C 7E C3 CF 1 320 DEFB    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C
66D0 C7 F3 F3 C7 1 320 
66D4 7E 3C       1 320 
66D6 3C 7E E3 CF 1 321 DEFB    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C
66DA C3 CB CB C3 1 321 
66DE 7E 3C       1 321 
66E0 3C 7E C3 F3 1 322 DEFB    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C
66E4 F3 E7 E7 E7 1 322 
66E8 7E 3C       1 322 
66EA             1 324 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 325 ; Screen addresses for menu hexagons
66EA             1 326 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 327 MENU_HEXAGONS:
66EA 01 40 05 40 1 328 DEFW    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 328 
66F2 0F 40 13 40 1 328 
66F6 1A 40       1 328 
66F8 45 40 48 40 1 329 DEFW    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 329 
6700 81 40 83 40 1 329 
6704 85 40       1 329 
6706 88 40 8A 40 1 330 DEFW    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 330 
670E C1 40 D0 40 1 330 
6712 D9 40       1 330 
6714 05 48 08 48 1 331 DEFW    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 331 
671C 19 48 1B 48 1 331 
6720 1D 48       1 331 
6722 0A 40 59 40 1 332 DEFW    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 332 
672A D2 40 0C 48 1 332 
672E 1C 40       1 332 
6730 41 40 50 40 1 333 DEFW    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 333 
6738 0F 48       1 333 
673A             1 334 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 335 DEFW    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 335 
6742 EF 40 F1 40 1 335 
6746 B2 40       1 335 
6748 E9 40 6F 48 1 336 DEFW    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 336 
6750 AA 48 AC 40 1 336 
6754 EF 48       1 336 
6756 2A 48 6D 48 1 337 DEFW    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 337 
675E             1 338 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 339 DEFW    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 339 
6766 AE 48 EF 48 1 339 
676A 2E 50       1 339 
676C AC 48 B4 48 1 340 DEFW    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 340 
6774 2E 48 F1 40 1 340 
6778 F3 40       1 340 
677A 73 48 B2 48 1 341 DEFW    $4873, $48B2, $5030
677E 30 50       1 341 
6780             1 343 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 344 ; Strings
6780             1 345 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 346 STR_OPTIONS:
6780 53 74 61 72 1 347 DEFM    "Start new game\0"
6784 74 20 6E 65 1 347 
6788 77 20 67 61 1 347 
678C 6D 65 00    1 347 
678F 48 6F 77 20 1 348 DEFM    "How to play\0"
6793 74 6F 20 70 1 348 
6797 6C 61 79 00 1 348 
679B 43 72 65 64 1 349 DEFM    "Credits\0"
679F 69 74 73 00 1 349 
67A3             1 350 STR_CREDITS:
67A3 44 65 73 69 1 351 DEFM    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 351 
67AB 20 20 20 20 1 351 
67AF 41 6E 74 6F 1 351 
67B3 6E 69 6F 20 1 351 
67B7 4C 75 71 75 1 351 
67BB 65 00       1 351 
67BD 43 6F 64 65 1 352 DEFM    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 352 
67C5 20 20 20 20 1 352 
67C9 41 6E 74 6F 1 352 
67CD 6E 69 6F 20 1 352 
67D1 4C 75 71 75 1 352 
67D5 65 00       1 352 
67D7 20 20 20 20 1 353 DEFM    "            Einar Saukas\0"
67DB 20 20 20 20 1 353 
67DF 20 20 20 20 1 353 
67E3 45 69 6E 61 1 353 
67E7 72 20 53 61 1 353 
67EB 75 6B 61 73 1 353 
67EF 00          1 353 
67F0 46 6F 6E 74 1 354 DEFM    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 354 
67F8 20 20 20 20 1 354 
67FC 45 69 6E 61 1 354 
6800 72 20 53 61 1 354 
6804 75 6B 61 73 1 354 
6808 00          1 354 
6809 47 72 61 70 1 355 DEFM    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 355 
6811 3A 20 20 20 1 355 
6815 45 69 6E 61 1 355 
6819 72 20 53 61 1 355 
681D 75 6B 61 73 1 355 
6821 00          1 355 
6822 20 20 20 20 1 356 DEFM    "            Antonio Luque\0"
6826 20 20 20 20 1 356 
682A 20 20 20 20 1 356 
682E 41 6E 74 6F 1 356 
6832 6E 69 6F 20 1 356 
6836 4C 75 71 75 1 356 
683A 65 00       1 356 
683C 50 72 65 73 1 357 STR_PRESSKEY            DEFM    "Press any key\0"
6840 73 20 61 6E 1 357 
6844 79 20 6B 65 1 357 
6848 79 00       1 357 
684A             1 358 STR_BUTTONS:
684A 4E 65 78 74 1 359 DEFM    "Next\0"
684E 00          1 359 
684F 42 61 63 6B 1 360 DEFM    "Back\0"
6853 00          1 360 
6854 52 45 44 00 1 361 STR_RED                 DEFM    "RED\0"
6858 43 59 41 4E 1 362 STR_CYAN                DEFM    "CYAN\0"
685C 00          1 362 
685D 43 6F 6E 6E 1 363 STR_HELP1               DEFM    "Connect\0"
6861 65 63 74 00 1 363 
6865 6C 65 66 74 1 364 STR_HELP2_RED           DEFM    "left and\0"
6869 20 61 6E 64 1 364 
686D 00          1 364 
686E 75 70 20 61 1 365 STR_HELP2_CYAN          DEFM    "up and\0"
6872 6E 64 00    1 365 
6875 72 69 67 68 1 366 STR_HELP3_RED           DEFM    "right\0"
6879 74 00       1 366 
687B 64 6F 77 6E 1 367 STR_HELP3_CYAN          DEFM    "down\0"
687F 00          1 367 
6880 62 6F 72 64 1 368 STR_HELP4               DEFM    "borders\0"
6884 65 72 73 00 1 368 
6888 74 6F 20 77 1 369 STR_HELP5               DEFM    "to win\0"
688C 69 6E 00    1 369 
688F             1 370 STR_HELP:
688F 57 69 6E 20 1 371 DEFM    "Win three\0"
6893 74 68 72 65 1 371 
6897 65 00       1 371 
6899 74 69 6D 65 1 372 DEFM    "times in\0"
689D 73 20 69 6E 1 372 
68A1 00          1 372 
68A2 61 20 72 6F 1 373 DEFM    "a row to\0"
68A6 77 20 74 6F 1 373 
68AA 00          1 373 
68AB 6C 65 76 65 1 374 DEFM    "level up\0"
68AF 6C 20 75 70 1 374 
68B3 00          1 374 
68B4 20 43 4F 4E 1 375 STR_CONGRATS            DEFM    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 375 
68BC 55 4C 41 54 1 375 
68C0 49 4F 4E 53 1 375 
68C4 20 00       1 375 
68C6             1 376 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 377 DEFM    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 377 
68CE 65 21 20 4C 1 377 
68D2 61 73 74 20 1 377 
68D6 6C 65 76 65 1 377 
68DA 6C 20 70 61 1 377 
68DE 73 73 65 64 1 377 
68E2 00          1 377 
68E3 43 68 6F 6F 1 378 DEFM    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 378 
68EB 65 76 65 6C 1 378 
68EF 20 74 6F 20 1 378 
68F3 72 65 73 74 1 378 
68F7 61 72 74 2C 1 378 
68FB 20 31 2D 34 1 378 
68FF 00          1 378 
6900             1 380 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 381 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 382 ; this font was designed by Einar Saukas for Hex game
6900             1 383 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 384 FONT:
6900 00 00 00 00 1 385 INCLUDEBIN "King+.bin"
6904 00 00 00 00 1 385 
6908 00 18 18 18 1 385 
690C 00 18 18 00 1 385 
6910 00 24 24 00 1 385 
6914 00 00 00 00 1 385 
6918 00 24 7E 24 1 385 
691C 24 7E 24 00 1 385 
6920 00 08 3E 28 1 385 
6924 3E 0A 3E 08 1 385 
6928 00 62 64 08 1 385 
692C 10 26 46 00 1 385 
6930 00 10 28 10 1 385 
6934 2A 44 3A 00 1 385 
6938 00 18 30 00 1 385 
693C 00 00 00 00 1 385 
6940 06 0C 08 08 1 385 
6944 08 0C 06 00 1 385 
6948 60 30 10 10 1 385 
694C 10 30 60 00 1 385 
6950 00 00 14 08 1 385 
6954 3E 08 14 00 1 385 
6958 00 00 08 08 1 385 
695C 3E 08 08 00 1 385 
6960 00 00 00 00 1 385 
6964 00 0C 18 30 1 385 
6968 00 00 00 7E 1 385 
696C 7E 00 00 00 1 385 
6970 00 00 00 00 1 385 
6974 30 70 70 00 1 385 
6978 02 06 0C 18 1 385 
697C 30 60 40 00 1 385 
6980 00 7E 62 62 1 385 
6984 62 62 7E 00 1 385 
6988 00 18 38 18 1 385 
698C 18 18 3C 00 1 385 
6990 00 38 4C 4C 1 385 
6994 18 30 7C 00 1 385 
6998 00 3C 62 0C 1 385 
699C 06 66 3C 00 1 385 
69A0 00 30 30 30 1 385 
69A4 30 34 3E 04 1 385 
69A8 00 7E 60 7E 1 385 
69AC 06 66 3C 00 1 385 
69B0 00 30 60 7C 1 385 
69B4 66 66 3C 00 1 385 
69B8 00 7E 46 0C 1 385 
69BC 18 30 60 00 1 385 
69C0 00 3C 66 3C 1 385 
69C4 66 66 3C 00 1 385 
69C8 00 3C 66 66 1 385 
69CC 3E 06 3C 00 1 385 
69D0 00 00 08 18 1 385 
69D4 00 08 18 00 1 385 
69D8 00 00 04 0C 1 385 
69DC 00 0C 18 30 1 385 
69E0 00 00 04 08 1 385 
69E4 10 08 04 00 1 385 
69E8 00 00 00 3E 1 385 
69EC 00 3E 00 00 1 385 
69F0 00 00 10 08 1 385 
69F4 04 08 10 00 1 385 
69F8 00 3C 42 04 1 385 
69FC 08 00 08 00 1 385 
6A00 00 3C 4A 56 1 385 
6A04 5E 40 3C 00 1 385 
6A08 00 7E 46 46 1 385 
6A0C 7E 46 46 00 1 385 
6A10 00 7C 62 7C 1 385 
6A14 62 62 7C 00 1 385 
6A18 00 7E 66 60 1 385 
6A1C 60 66 7E 00 1 385 
6A20 00 7C 46 46 1 385 
6A24 46 46 7C 00 1 385 
6A28 00 7E 60 7C 1 385 
6A2C 60 60 7E 00 1 385 
6A30 00 7E 60 7C 1 385 
6A34 60 60 60 00 1 385 
6A38 00 3E 62 60 1 385 
6A3C 66 66 3E 00 1 385 
6A40 00 62 62 7E 1 385 
6A44 62 62 62 00 1 385 
6A48 00 18 18 18 1 385 
6A4C 18 18 18 00 1 385 
6A50 00 0C 0C 0C 1 385 
6A54 0C 4C 38 00 1 385 
6A58 00 66 64 68 1 385 
6A5C 7E 46 66 00 1 385 
6A60 00 60 60 60 1 385 
6A64 60 60 7E 00 1 385 
6A68 00 7E 56 56 1 385 
6A6C 56 56 56 00 1 385 
6A70 00 7E 46 46 1 385 
6A74 46 46 46 00 1 385 
6A78 00 7E 62 62 1 385 
6A7C 62 62 7E 00 1 385 
6A80 00 7E 62 62 1 385 
6A84 7E 60 60 00 1 385 
6A88 00 7C 64 64 1 385 
6A8C 64 64 7E 00 1 385 
6A90 00 7C 62 64 1 385 
6A94 7C 46 46 00 1 385 
6A98 00 7E 60 7E 1 385 
6A9C 06 06 7E 00 1 385 
6AA0 00 7E 18 18 1 385 
6AA4 18 18 18 00 1 385 
6AA8 00 62 62 62 1 385 
6AAC 62 62 7E 00 1 385 
6AB0 00 62 62 62 1 385 
6AB4 62 34 18 00 1 385 
6AB8 00 6A 6A 6A 1 385 
6ABC 6A 6A 7E 00 1 385 
6AC0 00 62 62 34 1 385 
6AC4 4E 46 46 00 1 385 
6AC8 00 62 62 7E 1 385 
6ACC 18 18 18 00 1 385 
6AD0 00 7E 06 1C 1 385 
6AD4 38 60 7E 00 1 385 
6AD8 00 0E 08 08 1 385 
6ADC 08 08 0E 00 1 385 
6AE0 00 00 40 20 1 385 
6AE4 10 08 04 00 1 385 
6AE8 00 70 10 10 1 385 
6AEC 10 10 70 00 1 385 
6AF0 00 08 1C 2A 1 385 
6AF4 08 08 08 08 1 385 
6AF8 00 00 00 00 1 385 
6AFC 00 00 00 FF 1 385 
6B00 0C 12 10 38 1 385 
6B04 10 10 3E 00 1 385 
6B08 00 00 3C 06 1 385 
6B0C 7E 46 7E 00 1 385 
6B10 00 60 60 7E 1 385 
6B14 62 62 7E 00 1 385 
6B18 00 00 7E 62 1 385 
6B1C 60 62 7E 00 1 385 
6B20 00 06 06 7E 1 385 
6B24 46 46 7E 00 1 385 
6B28 00 00 7E 46 1 385 
6B2C 7E 60 7E 00 1 385 
6B30 00 1E 30 3C 1 385 
6B34 30 30 30 00 1 385 
6B38 00 00 7E 46 1 385 
6B3C 46 3E 06 3E 1 385 
6B40 00 60 60 7C 1 385 
6B44 66 66 66 00 1 385 
6B48 00 18 00 38 1 385 
6B4C 18 18 3C 00 1 385 
6B50 00 0C 00 0C 1 385 
6B54 0C 0C 4C 38 1 385 
6B58 00 20 2C 38 1 385 
6B5C 38 2C 26 00 1 385 
6B60 00 18 18 18 1 385 
6B64 18 18 0E 00 1 385 
6B68 00 00 6C 56 1 385 
6B6C 56 56 46 00 1 385 
6B70 00 00 7C 46 1 385 
6B74 46 46 46 00 1 385 
6B78 00 00 3C 46 1 385 
6B7C 46 46 3C 00 1 385 
6B80 00 00 7C 66 1 385 
6B84 66 7C 60 60 1 385 
6B88 00 00 3E 46 1 385 
6B8C 46 3E 06 06 1 385 
6B90 00 00 3C 62 1 385 
6B94 60 60 60 00 1 385 
6B98 00 00 3C 60 1 385 
6B9C 3C 06 3C 00 1 385 
6BA0 00 30 78 30 1 385 
6BA4 30 30 1C 00 1 385 
6BA8 00 00 46 46 1 385 
6BAC 46 46 3C 00 1 385 
6BB0 00 00 46 46 1 385 
6BB4 2C 3C 18 00 1 385 
6BB8 00 00 46 56 1 385 
6BBC 56 56 2C 00 1 385 
6BC0 00 00 46 2C 1 385 
6BC4 18 2C 46 00 1 385 
6BC8 00 00 46 46 1 385 
6BCC 46 3E 06 3C 1 385 
6BD0 00 00 7E 0C 1 385 
6BD4 18 30 7E 00 1 385 
6BD8 00 0E 08 30 1 385 
6BDC 08 08 0E 00 1 385 
6BE0 00 08 08 08 1 385 
6BE4 08 2A 1C 08 1 385 
6BE8 00 70 10 0C 1 385 
6BEC 10 10 70 00 1 385 
6BF0 00 14 28 00 1 385 
6BF4 00 00 00 00 1 385 
6BF8 FF 81 81 81 1 385 
6BFC 81 81 81 FF 1 385 

; File #2: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Main.z80asm

6C00             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 2 ; Main.z80asm
6C00             2 3 ; Coded by Antonio Luque
6C00             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 6 CYAN_COLOR              EQU     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6C00             2 7 RED_COLOR               EQU     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6C00             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 10 ; Entry point of the program - Initialization
6C00             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 12 Main                    ENT     $                           ; SpectNet IDE pragma: defines the entry code of the program
6C00 F3          2 14 di                                  ; disable interrupts
6C01             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6C01 21 2E 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6C04 FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C08 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C0B FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C0E 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C10 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C12 ED 5E       2 24 im      2                           ; set interrupt mode 2
6C14             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C14             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C14             2 28 ; resultant vector address is formed as follows:
6C14             2 29 ;
6C14             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C14             2 31 ; Source: 
6C14             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#modo-im-2-en-spectrum-16k
6C14             2 33 ;
6C14             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C14             2 35 ; memory area and it is used by some ROM routines, but none of them are called by HEX2 program.
6C14 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C17 AF          2 39 xor     a                           ; set border color (black)
6C18 D3 FE       2 40 out     ($FE), a
6C1A CD 85 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C1D             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 44 ; Start new game
6C1D             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 46 Main_Start
6C1D CD 1A 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C20 CD 27 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C23 CD 53 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C26 CD 92 77    2 50 call    Screen_Frame                ; draw the screen frame
6C29 CD EA 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C2C CD 09 78    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C2F CD 4C 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C32 FB          2 55 ei                                  ; enable interrupts
6C33             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 58 ; New level
6C33             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 60 Main_New_Level
6C33 3E 04       2 61 ld      a, 4                        ; maximum level
6C35 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C38 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C39 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C3B CD 86 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C3E 18 DD       2 66 jr      Main_Start                  ; start a new game
6C40             2 67 Main_Increment_Level
6C40 34          2 68 inc     (hl)                        ; increment game level
6C41 CD 29 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C44 CD 18 79    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C47 AF          2 71 xor     a                           ; initialize three-in-a-row counter
6C48 32 0E 62    2 72 ld      (THREE_ROW), a
6C4B             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 75 ; Start new match
6C4B             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 77 Main_Start_Match
6C4B             2 78 ; set up timers and clear last messages
6C4B CD C3 76    2 80 call    Timer_Reset                 ; reset timers
6C4E CD AE 76    2 81 call    Timer_Display_All           ; display timers
6C51 CD 10 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C54 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C56 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C59 CD 3A 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C5C             2 87 ; swap players' colors
6C5C 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C5F EE 07       2 90 xor     %00000111                   ; swap color
6C61 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C64 CD F2 6E    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C67             2 94 ; initialize positions and draw empty board
6C67 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C6A 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C6D 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C6F 01 FF 01    2 99 ld      bc, 256*2-1                 ; length of cyan + red positions areas (-1 already set)
6C72 ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C74 CD A2 6D    2 101 call    Draw_Board                  ; draw an empty hexagons board
6C77             2 103 ; initialize draw token delay, move number and token color
6C77 3E 0A       2 105 ld      a, 10                       ; set delay duration in 'Draw_Token' routine
6C79 32 D1 6D    2 106 ld      (@Token_Delay+1), a
6C7C 3E 01       2 107 ld      a, 1                        ; initialize move number
6C7E 32 9B 61    2 108 ld      (MOVE_NUMBER), a
6C81 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C83             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 112 ; Process players moves - Match loop
6C83             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 114 Main_Match_Loop
6C83             2 115 ; check player turn
6C83 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C86 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C89 BE          2 119 cp      (hl)                        ; check player color
6C8A CC 33 6D    2 120 call    z, Main_GetPlayer_Move      ; if player color = current token color, get player move
6C8D C4 E8 6C    2 121 call    nz, Main_GetSpeccy_Move     ; else, get speccy move (previous call always set Z flag)
6C90             2 123 ; update positions with player/speccy move
6C90 CD FA 70    2 125 call    PathFinder_Friend           ; get player/speccy side
6C93 CD 03 71    2 126 call    PathFinder_PutToken         ; put token on cyan and red positions
6C96             2 128 ; draw token on the board
6C96 AF          2 130 xor     a                           ; stop timers
6C97 32 E8 62    2 131 ld      (TIMER_FLAG), a
6C9A CD BD 6D    2 132 call    Draw_Token                  ; animate hexagon sprite on the screen
6C9D DD 21 E7 64 2 133 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6CA1 CD D8 76    2 134 call    Sound_FX                    ; play sound effect
6CA4             2 136 ; check for a winner
6CA4 CD AA 75    2 138 call    PathFinder_VictoryPath      ; check current player victory path
6CA7 3C          2 139 inc     a                           ; is there a victory path?
6CA8 20 0C       2 140 jr      nz, Main_Match_End          ; yes, match ends
6CAA 21 9B 61    2 142 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CAD 34          2 143 inc     (hl)                        ; increment move number
6CAE             2 145 ; swap players' token color
6CAE 3A 9E 61    2 147 ld      a, (TOKEN_COLOR)            ; get current token color
6CB1 EE 07       2 148 xor     %00000111                   ; swap token color
6CB3 C3 83 6C    2 149 jp      Main_Match_Loop             ; repeat match loop
6CB6             2 151 ; ----------------------------------------------------------------------------------------------------------------------
6CB6             2 152 ; Current player wins the match
6CB6             2 153 ; ----------------------------------------------------------------------------------------------------------------------
6CB6             2 154 Main_Match_End
6CB6 CD E0 75    2 155 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CB9 11 3A 62    2 157 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CBC CD 18 6F    2 158 call    Print_Alert                 ; print string
6CBF DD 21 EF 64 2 159 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
6CC3 CD D8 76    2 160 call    Sound_FX                    ; play sound fx
6CC6 3A 9E 61    2 162 ld      a, (TOKEN_COLOR)            ; get current token color
6CC9 21 9F 61    2 163 ld      hl, PLAYER_COLOR            ; get player color
6CCC BE          2 164 cp      (hl)                        ; check player color
6CCD 21 0E 62    2 165 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CD0 28 04       2 166 jr      z, Main_ThreeRow_Increment  ; if player color = current token color, increment counter
6CD2 35          2 167 dec     (hl)                        ; decrement three-in-a-row counter
6CD3 F2 D7 6C    2 168 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CD6             2 169 Main_ThreeRow_Increment
6CD6 34          2 170 inc     (hl)                        ; increment three-in-a-row counter
6CD7             2 171 Main_ThreeRow_Show
6CD7 CD FC 78    2 172 call    Screen_ThreeRow             ; show three-in-a-row marks
6CDA 3E FF       2 173 ld      a, 255                      ; set delay duration
6CDC CD 92 6D    2 174 call    Main_Delay                  ; execute delay
6CDF 3E 03       2 175 ld      a, 3                        ; check three row counter
6CE1 BE          2 176 cp      (hl)                        ; is it 3?
6CE2 CA 33 6C    2 177 jp      z, Main_New_Level           ; yes, start a new level
6CE5 C3 4B 6C    2 178 jp      Main_Start_Match            ; start a new match
6CE8             2 180 ; ----------------------------------------------------------------------------------------------------------------------
6CE8             2 181 ; Main_GetSpeccy_Move: get the speccy move
6CE8             2 182 ;
6CE8             2 183 ; Input:     A = current token color
6CE8             2 184 ;
6CE8             2 185 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CE8             2 186 ;           HL = CYAN_POSITIONS move address
6CE8             2 187 ;
6CE8             2 188 ; Uses:     MOVE_NUMBER (current move number)
6CE8             2 189 ;           GAME_LEVEL (current game level)
6CE8             2 190 ;           AI_DEPTH (recursion depth level)
6CE8             2 191 ;           STR_MOVE (formatted move string)
6CE8             2 192 ;
6CE8             2 193 ; Destroys: A, DE, IX, IY
6CE8             2 194 ; ----------------------------------------------------------------------------------------------------------------------
6CE8             2 195 Main_GetSpeccy_Move:
6CE8 E6 03       2 196 and     %00000011                   ; calculate speccy's timer flag based on current token color
6CEA 32 E8 62    2 197 ld      (TIMER_FLAG), a             ; (re)start speccy timer
6CED CD 32 6F    2 199 call    Print_Wait                  ; print "WAIT" message
6CF0 3A 9B 61    2 200 ld      a, (MOVE_NUMBER)            ; get move number
6CF3 3D          2 201 dec     a                           ; is it cyan first move?
6CF4 28 2A       2 202 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CF6 DD 21 00 7F 2 204 ld      ix, CANDIDATES              ; IX points to candidates list address
6CFA 3A 9D 61    2 205 ld      a, (GAME_LEVEL)             ; get game level
6CFD 32 9A 61    2 206 ld      (AI_DEPTH), a               ; save recursion depth level
6D00 CD FA 70    2 207 call    PathFinder_Friend           ; get speccy side
6D03 CD 86 6F    2 208 call    BRAINIAC_best_move          ; get speccy best move
6D06 6B          2 209 ld      l, e                        ; set node index in L
6D07             2 210 Main_GetSpeccy_Positions
6D07 26 7D       2 211 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D09 E5          2 212 push    hl                          ; store CYAN_POSITIONS move address
6D0A CD 80 6D    2 213 call    Main_Board2Indexes          ; convert board position to indexes
6D0D 78          2 214 ld      a, b                        ; get 1..7 column
6D0E C6 60       2 215 add     a, $60                      ; adjust to charset ('a'..'g')
6D10 32 15 62    2 216 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D13 79          2 217 ld      a, c                        ; get 1..7 row
6D14 C6 30       2 218 add     a, $30                      ; adjust to charset ('1'..'7')
6D16 32 18 62    2 219 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D19 C5          2 220 push    bc                          ; store hexagon board indexes
6D1A CD 42 6F    2 221 call    Print_Move                  ; print Speccy move
6D1D C1          2 222 pop     bc                          ; restore hexagon board indexes
6D1E E1          2 223 pop     hl                          ; restore CYAN_POSITIONS move address
6D1F C9          2 224 ret
6D20             2 225 Main_GetSpeccy_Book
6D20 ED 5F       2 226 ld      a, r                        ; get a pseudo-random number (0..127)
6D22 E6 1F       2 227 and     %00011111                   ; number is in range (0..31)
6D24 FE 1B       2 228 cp      27                          ; is it >= 27?
6D26 30 F8       2 229 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D28 21 CD 62    2 230 ld      hl, OPENINGS                ; HL points to opening book address
6D2B 16 00       2 231 ld      d, 0                        ; set index in DE
6D2D 5F          2 232 ld      e, a
6D2E 19          2 233 add     hl, de                      ; HL points to move index address
6D2F 6E          2 234 ld      l, (hl)                     ; get move from opening book
6D30 C3 07 6D    2 235 jp      Main_GetSpeccy_Positions    ; get speccy move positions
6D33             2 237 ; ----------------------------------------------------------------------------------------------------------------------
6D33             2 238 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D33             2 239 ;
6D33             2 240 ; Input:     A = current token color
6D33             2 241 ;
6D33             2 242 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D33             2 243 ;           HL = CYAN_POSITIONS move address
6D33             2 244 ;           Z  = flag set
6D33             2 245 ;
6D33             2 246 ; Uses:     STR_MOVE (formatted move string)
6D33             2 247 ;
6D33             2 248 ; Destroys: A, DE, IX
6D33             2 249 ; ----------------------------------------------------------------------------------------------------------------------
6D33             2 250 Main_GetPlayer_Move:
6D33 E6 03       2 251 and     %00000011                   ; calculate player's timer flag based on current token color
6D35 32 E8 62    2 252 ld      (TIMER_FLAG), a             ; (re)start player timer
6D38             2 253 Main_GetPlayer_Input
6D38 CD 3A 6F    2 254 call    Print_Clear_Move            ; clear player last move
6D3B CD 2C 6E    2 255 call    Input_Move                  ; wait for input player move
6D3E CD 42 6F    2 256 call    Print_Move                  ; print player move
6D41 3A 15 62    2 258 ld      a, (STR_MOVE+0)             ; get column ('a'..'g')
6D44 D6 60       2 259 sub     $60                         ; convert to number (1..7)
6D46 47          2 260 ld      b, a                        ; set column index in B
6D47 3A 18 62    2 261 ld      a, (STR_MOVE+3)             ; get row ('1'..'7')
6D4A D6 30       2 262 sub     $30                         ; convert to number (1..7)
6D4C 4F          2 263 ld      c, a                        ; set row index in C
6D4D 11 4D 62    2 264 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D50 CD 72 6D    2 265 call    Main_Search_Table           ; search board position in board coordinates
6D53 6E          2 266 ld      l, (hl)                     ; set board position of player move
6D54 26 7D       2 267 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D56 3E 00       2 268 ld      a, EMPTY                    ; check position
6D58 BE          2 269 cp      (hl)                        ; is position empty?
6D59 C8          2 270 ret     z                           ; yes, return with Z flag set
6D5A             2 272 ; illegal player move (position not empty)
6D5A 11 2E 62    2 274 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D5D CD 18 6F    2 275 call    Print_Alert                 ; print string
6D60 DD 21 F7 64 2 276 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D64 CD D8 76    2 277 call    Sound_FX                    ; play sound fx
6D67 3E 50       2 278 ld      a, 80                       ; set delay counter
6D69 CD 92 6D    2 279 call    Main_Delay                  ; execute delay
6D6C CD 10 6F    2 280 call    Print_Clear_Alert           ; clear alert message
6D6F C3 38 6D    2 281 jp      Main_GetPlayer_Input        ; repeat player input until move is legal
6D72             2 283 ; ----------------------------------------------------------------------------------------------------------------------
6D72             2 284 ; Main_Search_Table: search an element in a 8x8 bytes table
6D72             2 285 ;
6D72             2 286 ; Input:    BC = element indexes (B = column, C = row)
6D72             2 287 ;           DE = table address in which to search for the element
6D72             2 288 ;
6D72             2 289 ; Output:   DE = address of first element in the C row of the table
6D72             2 290 ;           HL = address of the element in the BC indexes of the table
6D72             2 291 ;
6D72             2 292 ; Destroys: A
6D72             2 293 ; ----------------------------------------------------------------------------------------------------------------------
6D72             2 294 Main_Search_Table:
6D72 79          2 295 ld      a, c                        ; first, get the C row in table
6D73 87          2 296 add     a, a                        ; a row is 8 bytes long
6D74 87          2 297 add     a, a
6D75 87          2 298 add     a, a
6D76 6F          2 299 ld      l, a                        ; set index in HL
6D77 26 00       2 300 ld      h, 0
6D79 19          2 301 add     hl, de                      ; HL points to the address of C row 
6D7A EB          2 302 ex      de, hl                      ; put it on DE
6D7B 68          2 303 ld      l, b                        ; set B index in HL
6D7C 26 00       2 304 ld      h, 0
6D7E 19          2 305 add     hl, de                      ; HL points to the address of BC indexes
6D7F C9          2 306 ret
6D80             2 308 ; ----------------------------------------------------------------------------------------------------------------------
6D80             2 309 ; Main_Board2Indexes: convert a board position into a board indexes
6D80             2 310 ;
6D80             2 311 ; Input:    L  = board position
6D80             2 312 ;
6D80             2 313 ; Output:   BC = board indexes (B = column, C = row)
6D80             2 314 ;
6D80             2 315 ; Destroys: HL
6D80             2 316 ; ----------------------------------------------------------------------------------------------------------------------
6D80             2 317 Main_Board2Indexes:
6D80 7D          2 318 ld      a, l                        ; set board position in A to compare later
6D81 21 8D 62    2 320 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D84 0E 07       2 321 ld      c, 7                        ; 7 rows
6D86             2 322 Main_Board2Indexes_Row
6D86 06 07       2 323 ld      b, 7                        ; 7 columns
6D88             2 324 Main_Board2Indexes_Col
6D88 2B          2 325 dec     hl                          ; move HL to next board position address
6D89 BE          2 326 cp      (hl)                        ; is A the position?
6D8A C8          2 327 ret     z                           ; yes, return board indexes
6D8B 10 FB       2 328 djnz    Main_Board2Indexes_Col      ; repeat for each column
6D8D 2B          2 329 dec     hl                          ; skip borders
6D8E 0D          2 330 dec     c                           ; decrement row
6D8F C3 86 6D    2 331 jp      Main_Board2Indexes_Row      ; loop until find position
6D92             2 333 ; ----------------------------------------------------------------------------------------------------------------------
6D92             2 334 ; Main_Delay: execute a delay
6D92             2 335 ;
6D92             2 336 ; Input:    A = delay counter
6D92             2 337 ;
6D92             2 338 ; Output:   -
6D92             2 339 ;
6D92             2 340 ; Destroys: A
6D92             2 341 ; ----------------------------------------------------------------------------------------------------------------------
6D92             2 342 Main_Delay:
6D92 C5          2 343 push    bc                          ; store BC register
6D93             2 344 Main_Delay_Outer
6D93 F5          2 345 push    af                          ; store delay counter (outer loop)
6D94 01 B0 04    2 346 ld      bc, 1200                    ; set inner loop counter in BC
6D97             2 347 Main_Delay_Inner
6D97 0B          2 348 dec     bc                          ; decrement inner loop counter
6D98 78          2 349 ld      a, b                        ; check inner loop counter
6D99 B1          2 350 or      c
6D9A 20 FB       2 351 jr      nz, Main_Delay_Inner        ; repeat until inner loop counter = 0
6D9C F1          2 352 pop     af                          ; restore delay counter
6D9D 3D          2 353 dec     a                           ; decrement delay counter
6D9E 20 F3       2 354 jr      nz, Main_Delay_Outer        ; repeat until delay counter = 0
6DA0 C1          2 355 pop     bc                          ; restore BC register
6DA1 C9          2 356 ret

; File #3: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Draw.z80asm

6DA2             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6DA2             3 2 ; Draw.z80asm
6DA2             3 3 ; Coded by Antonio Luque
6DA2             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6DA2             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6DA2             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6DA2             3 8 ;
6DA2             3 9 ; Input:    -
6DA2             3 10 ;
6DA2             3 11 ; Output:   -
6DA2             3 12 ;
6DA2             3 13 ; Uses:     TOKEN_COLOR (current token color)
6DA2             3 14 ;
6DA2             3 15 ; Destroys: A, BC, DE, HL, IXL
6DA2             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6DA2             3 17 Draw_Board:
6DA2 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6DA4 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6DA7 0E 07       3 20 ld      c, 7                        ; 7 rows
6DA9             3 21 Draw_Board_Row
6DA9 06 07       3 22 ld      b, 7                        ; 7 columns
6DAB             3 23 Draw_Board_Column
6DAB CD D8 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DAE CD 10 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DB1 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DB4 CD E2 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DB7 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DB9 0D          3 29 dec     c                           ; decrement row
6DBA 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DBC C9          3 31 ret
6DBD             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DBD             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DBD             3 35 ;
6DBD             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DBD             3 37 ;
6DBD             3 38 ; Output:   -
6DBD             3 39 ;
6DBD             3 40 ; Destroys: A, BC, DE, HL, IXL
6DBD             3 41 ; ----------------------------------------------------------------------------------------------------------------------
6DBD             3 42 Draw_Token:
6DBD CD D8 6D    3 43 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DC0 01 04 06    3 44 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DC3 11 9E 65    3 45 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DC6             3 46 Draw_Token_Loop
6DC6 E5          3 47 push    hl                          ; store hexagon screen address
6DC7 CD E2 6D    3 48 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DCA E1          3 49 pop     hl                          ; restore hexagon screen address
6DCB 78          3 50 ld      a, b                        ; check loop counter
6DCC B9          3 51 cp      c                           ; is it 4?
6DCD CC 10 6E    3 52 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DD0             3 53 @Token_Delay
6DD0 3E 00       3 54 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DD2 CD 92 6D    3 55 call    Main_Delay                  ; execute delay
6DD5 10 EF       3 56 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DD7 C9          3 57 ret
6DD8             3 59 ; ----------------------------------------------------------------------------------------------------------------------
6DD8             3 60 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DD8             3 61 ;
6DD8             3 62 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DD8             3 63 ;
6DD8             3 64 ; Output:   HL = hexagon screen address 
6DD8             3 65 ;
6DD8             3 66 ; Destroys: A, DE
6DD8             3 67 ; ----------------------------------------------------------------------------------------------------------------------
6DD8             3 68 Draw_GetHEX_Screen:
6DD8 11 98 61    3 69 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DDB CD 72 6D    3 70 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DDE 6E          3 71 ld      l, (hl)                     ; set the low byte of the screen address in L
6DDF 1A          3 72 ld      a, (de)                     ; set the high byte of the screen address in H
6DE0 67          3 73 ld      h, a
6DE1 C9          3 74 ret
6DE2             3 76 ; ----------------------------------------------------------------------------------------------------------------------
6DE2             3 77 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DE2             3 78 ;
6DE2             3 79 ; Input:    DE = hexagon sprite address
6DE2             3 80 ;           HL = hexagon screen address
6DE2             3 81 ;
6DE2             3 82 ; Output:   DE = next hexagon sprite address
6DE2             3 83 ;
6DE2             3 84 ; Destroys: A, HL, IXL
6DE2             3 85 ; ----------------------------------------------------------------------------------------------------------------------
6DE2             3 86 Draw_Sprite_Hexagon:
6DE2 DD 2E 10    3 87 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DE5             3 88 Draw_Sprite_HexLoop
6DE5 1A          3 89 ld      a, (de)                     ; get sprite byte
6DE6 77          3 90 ld      (hl), a                     ; put sprite byte on screen
6DE7 13          3 91 inc     de                          ; move DE to next sprite byte address
6DE8 2C          3 92 inc     l                           ; move HL to next screen column
6DE9 1A          3 93 ld      a, (de)                     ; get sprite byte
6DEA 77          3 94 ld      (hl), a                     ; put sprite byte on screen
6DEB 13          3 95 inc     de                          ; move DE to next sprite byte
6DEC 2D          3 96 dec     l                           ; move HL to previous screen column
6DED CD 01 6E    3 97 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DF0 DD 2D       3 98 dec     ixl                         ; decrement sprite height
6DF2 20 F1       3 99 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6DF4 C9          3 100 ret
6DF5             3 102 ; ----------------------------------------------------------------------------------------------------------------------
6DF5             3 103 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6DF5             3 104 ;
6DF5             3 105 ; Input:    DE = letter/number sprite address
6DF5             3 106 ;           HL = letter/number screen address
6DF5             3 107 ;
6DF5             3 108 ; Output:   DE = next letter/number sprite address
6DF5             3 109 ;
6DF5             3 110 ; Destroys: A, C, HL
6DF5             3 111 ; ----------------------------------------------------------------------------------------------------------------------
6DF5             3 112 Draw_Sprite_LetterNum:
6DF5 0E 0A       3 113 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6DF7             3 114 Draw_Sprite_Loop
6DF7 1A          3 115 ld      a, (de)                     ; get sprite byte
6DF8 77          3 116 ld      (hl), a                     ; put sprite byte on screen
6DF9 13          3 117 inc     de                          ; move DE to next sprite byte address
6DFA CD 01 6E    3 118 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DFD 0D          3 119 dec     c                           ; decrement sprite height
6DFE 20 F7       3 120 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6E00 C9          3 121 ret
6E01             3 123 ; ----------------------------------------------------------------------------------------------------------------------
6E01             3 124 ; Draw_Down_PixelLine: move HL down one pixel-line
6E01             3 125 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6E01             3 126 ;
6E01             3 127 ; The screen address of a pixel-line is encoded as follows:
6E01             3 128 ;
6E01             3 129 ;             H           |           L
6E01             3 130 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E01             3 131 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E01             3 132 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E01             3 133 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6E01             3 134 ;
6E01             3 135 ; where:
6E01             3 136 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E01             3 137 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E01             3 138 ;
6E01             3 139 ; Input:    HL = pixel-line address
6E01             3 140 ;
6E01             3 141 ; Output:   HL = next (down) pixel-line address
6E01             3 142 ;
6E01             3 143 ; Destroys: A
6E01             3 144 ; ----------------------------------------------------------------------------------------------------------------------
6E01             3 145 Draw_Down_PixelLine:
6E01 24          3 146 inc     h                           ; move HL down one pixel-line
6E02 7C          3 147 ld      a, h                        ; get high byte of pixel-line address
6E03 E6 07       3 148 and     %00000111                   ; is pixel-line address inside a character line?
6E05 C0          3 149 ret     nz                          ; yes, return
6E06 7D          3 150 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6E07 C6 20       3 151 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E09 6F          3 152 ld      l, a                        ; move HL down one character line
6E0A D8          3 153 ret     c                           ; a third was crossed? yes, return
6E0B 7C          3 154 ld      a, h                        ; get high byte of pixel-line address
6E0C D6 08       3 155 sub     8                           ; clean up the bit from Y6
6E0E 67          3 156 ld      h, a                        ; HL points to next (down) pixel-line address
6E0F C9          3 157 ret
6E10             3 159 ; ----------------------------------------------------------------------------------------------------------------------
6E10             3 160 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E10             3 161 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E10             3 162 ;
6E10             3 163 ; This routine converts a screen address (HL) into an attribute address (IX):
6E10             3 164 ;
6E10             3 165 ;             H           |           L
6E10             3 166 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E10             3 167 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E10             3 168 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E10             3 169 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E10             3 170 ;
6E10             3 171 ;            IXH          |          IXL
6E10             3 172 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E10             3 173 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E10             3 174 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E10             3 175 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E10             3 176 ;
6E10             3 177 ; where:
6E10             3 178 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E10             3 179 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E10             3 180 ;
6E10             3 181 ; Input:    HL = screen address of the hexagon
6E10             3 182 ;
6E10             3 183 ; Output:   IX = attribute address of the hexagon
6E10             3 184 ;
6E10             3 185 ; Uses:     TOKEN_COLOR (current token color)
6E10             3 186 ;
6E10             3 187 ; Destroys: A
6E10             3 188 ; ----------------------------------------------------------------------------------------------------------------------
6E10             3 189 Draw_Hexagon_Color:
6E10 7C          3 190 ld      a, h                        ; get high byte of screen address
6E11 F6 87       3 191 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E13 1F          3 192 rra                                 ; shift Y7-Y6 two positions
6E14 1F          3 193 rra
6E15 CB 3F       3 194 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E17 DD 67       3 195 ld      ixh, a                      ; set high byte of attribute address in IXH
6E19 7D          3 196 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E1A DD 6F       3 197 ld      ixl, a                      ; set low byte of attribute address in IXL
6E1C 3A 9E 61    3 198 ld      a, (TOKEN_COLOR)            ; get current token color
6E1F DD 77 00    3 199 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E22 DD 77 01    3 200 ld      (ix+1), a
6E25 DD 77 20    3 201 ld      (ix+32), a
6E28 DD 77 21    3 202 ld      (ix+33), a
6E2B C9          3 203 ret

; File #4: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Input.z80asm

6E2C             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E2C             4 2 ; Input.z80asm
6E2C             4 3 ; Coded by Antonio Luque
6E2C             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E2C             4 6 MAX_CHARS               EQU     2                           ; maximum of input chars
6E2C             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E2C             4 9 ; Input_Move: wait for input a move from keyboard
6E2C             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E2C             4 11 ;
6E2C             4 12 ; Input:    -
6E2C             4 13 ;
6E2C             4 14 ; Output:   -
6E2C             4 15 ;
6E2C             4 16 ; Uses:     TOKEN_COLOR (current token color)
6E2C             4 17 ;           STR_MOVE (formatted move string)
6E2C             4 18 ;
6E2C             4 19 ; Destroys: A, A', BC, DE, HL, IX
6E2C             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E2C             4 21 Input_Move:
6E2C 01 00 02    4 22 ld      bc, MAX_CHARS*256           ; B = maximum of input chars, C = chars counter
6E2F DD 21 83 5A 4 24 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E33 21 83 50    4 25 ld      hl, $5083                   ; HL points to screen address of RED input text
6E36 3A 9E 61    4 26 ld      a, (TOKEN_COLOR)            ; check current player color
6E39 FE 02       4 27 cp      RED_COLOR                   ; is RED the current token color?
6E3B 28 07       4 28 jr      z, Input_Start              ; yes, start input
6E3D DD 21 19 59 4 29 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E41 21 19 48    4 30 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E44             4 31 Input_Start
6E44 DD 36 00 C7 4 32 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E48 3E 5F       4 33 ld      a, '_'                      ; text input cursor
6E4A CD 6C 6F    4 34 call    Print_Char                  ; print cursor
6E4D             4 35 Input_Loop
6E4D CD C6 6E    4 36 call    Input_Key_Scan              ; scan for a key pressed
6E50 FE 0D       4 38 cp      $0D                         ; is it ENTER?
6E52 28 64       4 39 jr      z, Input_Enter              ; yes, perform enter pressed
6E54 FE 30       4 40 cp      '0'                         ; is it "delete"? (char '0' acts as delete, without Shift)
6E56 28 42       4 41 jr      z, Input_Delete             ; yes, perform delete char
6E58 08          4 42 ex      af, af'                     ; store char in A'
6E59 79          4 43 ld      a, c                        ; check number of chars inserted
6E5A B8          4 44 cp      b                           ; chars limit reached?
6E5B 28 F0       4 45 jr      z, Input_Loop               ; yes, repeat input loop
6E5D B7          4 47 or      a                           ; is it the first char?
6E5E 20 21       4 48 jr      nz, Input_Numbers           ; no, perform input of 2nd char
6E60             4 50 ; restrict first char to 'a'-'g'
6E60 08          4 52 ex      af, af'                     ; restore char
6E61 FE 61       4 53 cp      'a'                         ; is it < 'a'?
6E63 38 E8       4 54 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E65 FE 68       4 55 cp      'h'                         ; is it >= 'g'?
6E67 30 E4       4 56 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E69             4 58 ; char is valid as column
6E69 32 15 62    4 60 ld      (STR_MOVE+0), a             ; save char in player move
6E6C DD 36 00 47 4 61 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E70 CD 6C 6F    4 62 call    Print_Char                  ; print key pressed
6E73 0C          4 63 inc     c                           ; increment chars counter
6E74 2C          4 64 inc     l                           ; increment X position of current input screen location
6E75 DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E77 3E 2D       4 66 ld      a, '-'                      ; set dash char
6E79 CD 6C 6F    4 67 call    Print_Char                  ; print key pressed
6E7C 2C          4 68 inc     l                           ; increment X position of current input screen location
6E7D DD 2C       4 69 inc     ixl                         ; increment X position of current input attr location
6E7F 18 C3       4 70 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E81             4 71 Input_Numbers
6E81             4 72 ; restrict second char to '1'-'7'
6E81 08          4 74 ex      af, af'                     ; restore char
6E82 FE 31       4 75 cp      '1'                         ; is it < '1'?
6E84 38 C7       4 76 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E86 FE 38       4 77 cp      '8'                         ; is it >= '8'?
6E88 30 C3       4 78 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E8A             4 80 ; char is valid as row
6E8A 32 18 62    4 82 ld      (STR_MOVE+3), a             ; save char in player move
6E8D DD 36 00 47 4 83 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E91 CD 6C 6F    4 84 call    Print_Char                  ; print key pressed
6E94 0C          4 85 inc     c                           ; increment chars counter
6E95 2C          4 86 inc     l                           ; increment X position of current input screen location
6E96 DD 2C       4 87 inc     ixl                         ; increment X position of current input attr location
6E98 18 AA       4 88 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E9A             4 90 ; player pressed "delete" (char '0')
6E9A             4 91 Input_Delete
6E9A 79          4 92 ld      a, c                        ; get char counter
6E9B B7          4 93 or      a                           ; is it 0?
6E9C 28 AF       4 94 jr      z, Input_Loop               ; repeat input loop (no chars to delete)
6E9E DD 36 00 47 4 96 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EA2 B8          4 97 cp      b                           ; is it the first char?
6EA3 28 08       4 98 jr      z, Input_Delete_Char        ; yes, continue delete
6EA5 3E 20       4 99 ld      a, ' '                      ; empty char
6EA7 CD 6C 6F    4 100 call    Print_Char                  ; delete cursor and last char
6EAA 2D          4 101 dec     l                           ; decrement X position of input screen location
6EAB DD 2D       4 102 dec     ixl                         ; decrement X position of input attr location
6EAD             4 103 Input_Delete_Char
6EAD 0D          4 104 dec     c                           ; decrement char counter
6EAE 3E 20       4 105 ld      a, ' '                      ; empty char
6EB0 CD 6C 6F    4 106 call    Print_Char                  ; delete cursor and last char
6EB3 2D          4 107 dec     l                           ; decrement X position of player input screen location
6EB4 DD 2D       4 108 dec     ixl                         ; decrement X position of player input attr location
6EB6 18 8C       4 109 jr      Input_Start                 ; get next char
6EB8             4 111 ; player pressed ENTER
6EB8             4 112 Input_Enter
6EB8 79          4 113 ld      a, c                        ; check char counter  
6EB9 B8          4 114 cp      b                           ; is it < MAX_CHARS?
6EBA 38 91       4 115 jr      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EBC DD 36 00 47 4 117 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EC0 3E 20       4 118 ld      a, ' '                      ; empty char
6EC2 CD 6C 6F    4 119 call    Print_Char                  ; delete cursor
6EC5 C9          4 120 ret
6EC6             4 122 ; ----------------------------------------------------------------------------------------------------------------------
6EC6             4 123 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EC6             4 124 ;
6EC6             4 125 ;                           Bit
6EC6             4 126 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EC6             4 127 ;  ------+-------+-------+-------+-------+-------+
6EC6             4 128 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EC6             4 129 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EC6             4 130 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EC6             4 131 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EC6             4 132 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EC6             4 133 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EC6             4 134 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EC6             4 135 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EC6             4 136 ;
6EC6             4 137 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EC6             4 138 ;
6EC6             4 139 ; Input:    -
6EC6             4 140 ;
6EC6             4 141 ; Output:   A = ASCII code of key pressed
6EC6             4 142 ;
6EC6             4 143 ; Destroys: DE
6EC6             4 144 ; ----------------------------------------------------------------------------------------------------------------------
6EC6             4 145 Input_Key_Scan:
6EC6 C5          4 146 push    bc                          ; store registers
6EC7 E5          4 147 push    hl
6EC8             4 148 Input_Key_Released
6EC8 01 FE FE    4 149 ld      bc, $FEFE                   ; set keyboard port (see above)
6ECB             4 150 Input_Key_Released_Line
6ECB ED 78       4 151 in      a, (c)                      ; read port
6ECD 2F          4 152 cpl                                 ; invert bits
6ECE E6 1F       4 153 and     %00011111                   ; check 0 to 4 bits
6ED0 20 F6       4 154 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6ED2 CB 00       4 155 rlc     b                           ; move BC to the next port
6ED4 38 F5       4 156 jr      c, Input_Key_Released_Line  ; repeat for each port
6ED6 11 05 00    4 157 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6ED9             4 158 Input_Key_Pressed_Begin
6ED9 21 D8 61    4 159 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6EDC             4 160 Input_Key_Pressed_Line
6EDC ED 78       4 161 in      a, (c)                      ; read port
6EDE 2F          4 162 cpl                                 ; invert bits
6EDF E6 1F       4 163 and     %00011111                   ; check 0 to 4 bits
6EE1 20 08       4 164 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6EE3 19          4 165 add     hl, de                      ; HL points to the next KEY_MAP block
6EE4 CB 00       4 166 rlc     b                           ; move BC to the next port
6EE6 38 F4       4 167 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6EE8 18 EF       4 168 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6EEA             4 169 Input_Key_Next
6EEA 23          4 170 inc     hl                          ; move HL to the next character
6EEB             4 171 Input_Key_Pressed
6EEB 1F          4 172 rra                                 ; rotate bits of port readed
6EEC 30 FC       4 173 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6EEE 7E          4 174 ld      a, (hl)                     ; return key pressed (ASCII) in A
6EEF E1          4 175 pop     hl                          ; restore registers
6EF0 C1          4 176 pop     bc
6EF1 C9          4 177 ret

; File #5: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Print.z80asm

6EF2             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6EF2             5 2 ; Print.z80asm
6EF2             5 3 ; Coded by Antonio Luque
6EF2             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6EF2             5 6 CHAR_SET                EQU     FONT-256                    ; address of character set data, adjusted for ASCII codes
6EF2             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6EF2             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6EF2             5 10 ;
6EF2             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6EF2             5 12 ;
6EF2             5 13 ; Output:   -
6EF2             5 14 ;
6EF2             5 15 ; Destroys: A, BC, DE, HL
6EF2             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6EF2             5 17 Print_Players:
6EF2 11 21 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6EF5 01 1A 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6EF8 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6EFB FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6EFD 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6EFF 11 1A 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6F02 01 21 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6F05             5 25 Print_Players_Strings
6F05 CD 5F 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6F08 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F09 59          5 28 ld      e, c
6F0A 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F0D C3 5F 6F    5 30 jp      Print_String                ; print "Player" or "Speccy"
6F10             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F10             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F10             5 34 ;
6F10             5 35 ; Input:    -
6F10             5 36 ; Output:   -
6F10             5 37 ; Destroys: A, BC, DE, HL, IX
6F10             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F10             5 39 Print_Clear_Alert:
6F10 11 46 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F13 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F15 C3 1A 6F    5 42 jp      Print_Alert_XY              ; print (clear) alert string
6F18             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F18             5 45 ; Print_Alert: print an alert message below the current player input move
6F18             5 46 ;
6F18             5 47 ; Input:    DE = alert message string address
6F18             5 48 ;
6F18             5 49 ; Output:   -
6F18             5 50 ;
6F18             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F18             5 52 ;
6F18             5 53 ; Destroys: A, BC, DE, HL, IX
6F18             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F18             5 55 Print_Alert:
6F18 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F1A             5 57 Print_Alert_XY
6F1A DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F1E 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F21 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F24 FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F26 28 34       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F28 DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F2C 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F2F C3 5C 6F    5 65 jp      Print_String_Color          ; print alert string with color
6F32             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F32             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F32             5 69 ;
6F32             5 70 ; Input:    -
6F32             5 71 ;
6F32             5 72 ; Output:   -
6F32             5 73 ;
6F32             5 74 ; Destroys: A, BC, DE, HL, IX
6F32             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F32             5 76 Print_Wait:
6F32 11 35 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F35 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F37 C3 47 6F    5 79 jp      Print_Move_XY               ; print wait string
6F3A             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F3A             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F3A             5 83 ;
6F3A             5 84 ; Input:    -
6F3A             5 85 ;
6F3A             5 86 ; Output:   -
6F3A             5 87 ;
6F3A             5 88 ; Destroys: A, BC, DE, HL, IX
6F3A             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F3A             5 90 Print_Clear_Move:
6F3A 11 41 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F3D 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F3F C3 47 6F    5 93 jp      Print_Move_XY               ; print (clear) move string
6F42             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F42             5 96 ; Print_Move: print a formatted move at current player input move location 
6F42             5 97 ;
6F42             5 98 ; Input:    -
6F42             5 99 ;
6F42             5 100 ; Output:   -
6F42             5 101 ;
6F42             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F42             5 103 ;
6F42             5 104 ; Destroys: A, BC, DE, HL, IX
6F42             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F42             5 106 Print_Move:
6F42 11 15 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F45 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F47             5 109 Print_Move_XY
6F47 DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F4B 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F4E 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F51 FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F53 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F55 DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F59 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F5C             5 117 Print_String_Color
6F5C CD 7C 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F5F             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F5F             5 120 ; Print_String: print a string on the screen
6F5F             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F5F             5 122 ;
6F5F             5 123 ; Input:    DE = string address (ending with 0)
6F5F             5 124 ;           HL = string screen address
6F5F             5 125 ;
6F5F             5 126 ; Output:   -
6F5F             5 127 ;
6F5F             5 128 ; Destroys: A, DE, HL
6F5F             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F5F             5 130 Print_String:
6F5F 1A          5 131 ld      a, (de)                     ; get string character
6F60 B7          5 132 or      a                           ; is it 0? (end of string)
6F61 C8          5 133 ret     z                           ; yes, return
6F62 D5          5 134 push    de                          ; store pointer to string address
6F63 CD 6C 6F    5 135 call    Print_Char                  ; print character
6F66 D1          5 136 pop     de                          ; restore pointer to string address
6F67 13          5 137 inc     de                          ; move DE to next string character
6F68 2C          5 138 inc     l                           ; move HL to next screen column
6F69 C3 5F 6F    5 139 jp      Print_String                ; repeat until end of string
6F6C             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F6C             5 142 ; Print_Char: print a character on the screen
6F6C             5 143 ;
6F6C             5 144 ; Input:    A  = character to print (ASCII)
6F6C             5 145 ;           HL = character screen address
6F6C             5 146 ;
6F6C             5 147 ; Output:   -
6F6C             5 148 ;
6F6C             5 149 ; Destroys: A, DE
6F6C             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F6C             5 151 Print_Char:
6F6C 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F6F             5 153 Print_Tile:
6F6F E5          5 154 push    hl                          ; store pointer to character/tile screen address
6F70 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F72 6F          5 156 ld      l, a
6F73 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6F74 29          5 158 add     hl, hl
6F75 29          5 159 add     hl, hl
6F76 19          5 160 add     hl, de                      ; move HL to character/tile address
6F77 EB          5 161 ex      de, hl                      ; DE points to character/tile address
6F78 E1          5 162 pop     hl                          ; restore pointer to character/tile screen address
6F79 C5          5 163 push    bc                          ; store BC register
6F7A 4C          5 164 ld      c, h                        ; save high byte of character/tile screen address
6F7B 06 08       5 165 ld      b, 8                        ; number of character/tile bytes (loop counter)
6F7D             5 166 Print_Tile_Pixels
6F7D 1A          5 167 ld      a, (de)                     ; get character/tile byte
6F7E 77          5 168 ld      (hl), a                     ; put character/tile byte on screen
6F7F 13          5 169 inc     de                          ; move DE to next character/tile byte
6F80 24          5 170 inc     h                           ; move HL down one pixel-line
6F81 10 FA       5 171 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6F83 61          5 172 ld      h, c                        ; restore high byte of character/tile screen address
6F84 C1          5 173 pop     bc                          ; restore BC register
6F85 C9          5 174 ret

; File #6: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Brainiac.z80asm

6F86             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6F86             6 2 ; Brainiac.z80asm
6F86             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F86             6 4 ;
6F86             6 5 ; Adapted for Hex game by Einar Saukas
6F86             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6F86             6 8 MIN_VALUE               EQU     0                           ; alphaBeta pruning minimum value
6F86             6 9 MAX_VALUE               EQU     255                         ; alphaBeta pruning maximum value
6F86             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6F86             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6F86             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6F86             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6F86             6 15 ; depth.
6F86             6 16 ;
6F86             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F86             6 18 ;
6F86             6 19 ; Input:    A   = speccy side (FRIEND or ENEMY)
6F86             6 20 ;           IX  = candidates vector address
6F86             6 21 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
6F86             6 22 ;
6F86             6 23 ; Output:   E  = selected position (speccy move)
6F86             6 24 ;
6F86             6 25 ; Uses:     AI_PLAYER (speccy side)
6F86             6 26 ;           AI_DEPTH (recursion depth level)
6F86             6 27 ;
6F86             6 28 ; Destroys: A, A', BC, D, HL, IX, IY
6F86             6 29 ; ----------------------------------------------------------------------------------------------------------------------
6F86             6 30 BRAINIAC_best_move:
6F86 32 99 61    6 31 ld      (AI_PLAYER), a              ; save speccy side
6F89 CD 82 74    6 33 call    PathFinder_Score            ; get board score (needed to get candidates)
6F8C CD 25 75    6 34 call    PathFinder_Candidates       ; get candidates from board potentials
6F8F             6 36 ; BRAINIAC start
6F8F             6 37 AI_First_Candidate
6F8F DD 7E 00    6 38 ld      a, (ix+0)                   ; A is our first candidate
6F92 5F          6 40 ld      e, a                        ; E = best speccy move (initialization)
6F93 16 00       6 41 ld      d, MIN_VALUE                ; D = alphaMax
6F95             6 43 AI_Main_Loop                                                ; for each candidate {
6F95 D5          6 44 push    de                          ;       store alphaMax and best speccy move
6F96 26 7D       6 46 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F98 6F          6 47 ld      l, a
6F99 E5          6 48 push    hl
6F9A 3A 99 61    6 50 ld      a, (AI_PLAYER)              ;       get speccy side
6F9D CD 03 71    6 51 call    PathFinder_PutToken         ;       BRAINIAC_play
6FA0 EE 7C       6 52 xor     $7C                         ;       restore speccy side
6FA2 1E FF       6 53 ld      e, MAX_VALUE                ;       E = betaMin
6FA4 CD BD 6F    6 54 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6FA7 E1          6 56 pop     hl                          ;       restore candidate position
6FA8 CD 09 71    6 57 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FAB D1          6 59 pop     de                          ;       restore alphaMax and best player node
6FAC BA          6 61 cp      d
6FAD 38 04       6 62 jr      c, AI_Main_Next
6FAF 28 02       6 63 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FB1 57          6 65 ld      d, a                        ;       alphaMax = A
6FB2 5D          6 66 ld      e, l                        ;       best move = E
6FB3             6 68 AI_Main_Next
6FB3 DD 2D       6 69 dec     ixl
6FB5 DD 7E 00    6 70 ld      a, (ix+0)                   ;       A is our next candidate
6FB8 B7          6 71 or      a                           ;       repeat until no more candidates
6FB9 C2 95 6F    6 72 jp      nz, AI_Main_Loop            ; }
6FBC C9          6 73 ret
6FBD             6 75 ; ----------------------------------------------------------------------------------------------------------------------
6FBD             6 76 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FBD             6 77 ; Speccy's score.
6FBD             6 78 ;
6FBD             6 79 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FBD             6 80 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FBD             6 81 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FBD             6 82 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FBD             6 83 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FBD             6 84 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FBD             6 85 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FBD             6 86 ; could be just reproducing the best score from its sibling.
6FBD             6 87 ;
6FBD             6 88 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FBD             6 89 ;
6FBD             6 90 ; Input:    A   = speccy side (FRIEND or ENEMY)
6FBD             6 91 ;           D   = alphaMax
6FBD             6 92 ;           E   = betaMin
6FBD             6 93 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
6FBD             6 94 ;
6FBD             6 95 ; Output:   A = "improved" betaMin
6FBD             6 96 ;           D = alphaMax
6FBD             6 97 ;           E = "improved" betaMin
6FBD             6 98 ;
6FBD             6 99 ; Uses:     AI_PLAYER (speccy side)
6FBD             6 100 ;           AI_DEPTH (recursion depth level)
6FBD             6 101 ;
6FBD             6 102 ; Destroys: BC, HL, IX, IY
6FBD             6 103 ; ----------------------------------------------------------------------------------------------------------------------
6FBD             6 104 Alphabeta_Min:
6FBD D5          6 105 push    de
6FBE             6 107 ; check if last speccy move is a winner one
6FBE CD 82 74    6 109 call    PathFinder_Score            ; if (speccy won)
6FC1 B7          6 110 or      a
6FC2 C2 CC 6F    6 111 jp      nz, Alphabeta_Min_Candidates
6FC5 3A 9A 61    6 112 ld      a, (AI_DEPTH)
6FC8 C6 E0       6 113 add     a, 224                      ;     return 224+depth
6FCA D1          6 114 pop     de
6FCB C9          6 115 ret
6FCC             6 117 Alphabeta_Min_Candidates
6FCC CD 25 75    6 118 call    PathFinder_Candidates       ; find candidates for next move
6FCF D1          6 119 pop     de
6FD0 DD 7E 00    6 121 ld      a, (ix+0)                   ; A is our first candidate
6FD3 21 9A 61    6 123 ld      hl, AI_DEPTH
6FD6 35          6 124 dec     (hl)                        ; depth--
6FD7 CA 17 70    6 125 jp      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
6FDA             6 127 Alphabeta_Min_Loop                                          ; for each candidate {
6FDA D5          6 128 push    de                          ;       store alphaMax and betaMin
6FDB 26 7D       6 130 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FDD 6F          6 131 ld      l, a
6FDE E5          6 132 push    hl
6FDF 3A 99 61    6 134 ld      a, (AI_PLAYER)              ;       get speccy side
6FE2 EE 7C       6 135 xor     $7C                         ;       switch to player side
6FE4 CD 03 71    6 136 call    PathFinder_PutToken         ;       BRAINIAC_play
6FE7 CD 5B 70    6 137 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
6FEA E1          6 139 pop     hl                          ;       restore candidate position
6FEB CD 09 71    6 140 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FEE D1          6 142 pop     de                          ;       restore alphaMax and betaMin
6FEF BB          6 144 cp      e
6FF0 30 06       6 145 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
6FF2 BA          6 147 cp      d
6FF3 38 12       6 148 jr      c, Alphabeta_Min_Exit
6FF5 28 10       6 149 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FF7 5F          6 151 ld      e, a                        ;       betaMin = A
6FF8             6 153 Alphabeta_Min_Next
6FF8 DD 2D       6 154 dec     ixl
6FFA DD 7E 00    6 155 ld      a, (ix+0)                   ;       A is our next candidate
6FFD B7          6 156 or      a                           ;       repeat until no more candidates
6FFE C2 DA 6F    6 157 jp      nz, Alphabeta_Min_Loop      ; }
7001 7B          6 159 ld      a, e                        ; return betaMin
7002 21 9A 61    6 161 ld      hl, AI_DEPTH
7005 34          6 162 inc     (hl)                        ; depth++
7006 C9          6 163 ret
7007             6 165 Alphabeta_Min_Exit
7007 5F          6 166 ld      e, a                        ; (discard remaining candidates)
7008 AF          6 167 xor     a
7009             6 168 Alphabeta_Min_Skip
7009 DD 2D       6 169 dec     ixl
700B DD BE 00    6 170 cp      (ix+0)
700E C2 09 70    6 171 jp      nz, Alphabeta_Min_Skip
7011 7B          6 172 ld      a, e
7012 21 9A 61    6 174 ld      hl, AI_DEPTH
7015 34          6 175 inc     (hl)                        ; (depth++)
7016 C9          6 176 ret
7017             6 178 ; ----------------------------------------------------------------------------------------------------------------------
7017             6 179 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
7017             6 180 ; beta pruning, when it requires MINIMIZING Speccy's score.
7017             6 181 ;
7017             6 182 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
7017             6 183 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
7017             6 184 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
7017             6 185 ; faster.
7017             6 186 ;
7017             6 187 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7017             6 188 ;
7017             6 189 ; Input:    A = first candidate
7017             6 190 ;           D = alphaMax
7017             6 191 ;           E = betaMin
7017             6 192 ;
7017             6 193 ; Output:   A = "improved" betaMin
7017             6 194 ;           D = alphaMax
7017             6 195 ;           E = "improved" betaMin
7017             6 196 ;
7017             6 197 ; Uses:     AI_PLAYER (speccy side)
7017             6 198 ;           AI_DEPTH (recursion depth level)
7017             6 199 ;
7017             6 200 ; Destroys: BC, HL, IX, IY
7017             6 201 ; ----------------------------------------------------------------------------------------------------------------------
7017             6 202 Heuristic_Min:                                              ; for each candidate {
7017 D5          6 203 push    de                          ;       store alphaMax and betaMin
7018 26 7D       6 205 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
701A 6F          6 206 ld      l, a
701B E5          6 207 push    hl
701C 3A 99 61    6 209 ld      a, (AI_PLAYER)              ;       get speccy side
701F EE 7C       6 210 xor     $7C                         ;       switch to player side
7021 CD 03 71    6 211 call    PathFinder_PutToken         ;       BRAINIAC_play
7024 CD 82 74    6 213 call    PathFinder_Score            ;       if (player won)
7027 FE FF       6 214 cp      -1
7029 C2 2E 70    6 215 jp      nz, Heuristic_Min_Continue
702C 3E 20       6 216 ld      a, 32                       ;           A = 32
702E             6 217 Heuristic_Min_Continue
702E E1          6 218 pop     hl
702F CD 09 71    6 219 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7032 D1          6 221 pop     de
7033 BB          6 223 cp      e
7034 30 06       6 224 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
7036 BA          6 226 cp      d
7037 38 12       6 227 jr      c, Heuristic_Min_Exit
7039 28 10       6 228 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
703B 5F          6 230 ld      e, a                        ;       betaMin = A
703C             6 232 Heuristic_Min_Next
703C DD 2D       6 233 dec     ixl
703E DD 7E 00    6 234 ld      a, (ix+0)                   ;       A is our next candidate
7041 B7          6 235 or      a                           ;       repeat until no more candidates
7042 C2 17 70    6 236 jp      nz, Heuristic_Min           ; }
7045 7B          6 238 ld      a, e                        ; return betaMin
7046 21 9A 61    6 240 ld      hl, AI_DEPTH
7049 34          6 241 inc     (hl)                        ; depth++
704A C9          6 242 ret
704B             6 244 Heuristic_Min_Exit
704B 5F          6 245 ld      e, a                        ; (discard remaining candidates)
704C AF          6 246 xor     a
704D             6 247 Heuristic_Min_Skip
704D DD 2D       6 248 dec     ixl
704F DD BE 00    6 249 cp      (ix+0)
7052 C2 4D 70    6 250 jp      nz, Heuristic_Min_Skip
7055 7B          6 251 ld      a, e
7056 21 9A 61    6 253 ld      hl, AI_DEPTH
7059 34          6 254 inc     (hl)                        ; (depth++)
705A C9          6 255 ret
705B             6 257 ; ----------------------------------------------------------------------------------------------------------------------
705B             6 258 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
705B             6 259 ; Speccy's score.
705B             6 260 ;
705B             6 261 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
705B             6 262 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
705B             6 263 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
705B             6 264 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
705B             6 265 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
705B             6 266 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
705B             6 267 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
705B             6 268 ; the same score and could be just reproducing the best score from its sibling.
705B             6 269 ;
705B             6 270 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
705B             6 271 ;
705B             6 272 ; Input:    A   = speccy side (FRIEND or ENEMY)
705B             6 273 ;           D   = alphaMax
705B             6 274 ;           E   = betaMin
705B             6 275 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
705B             6 276 ;
705B             6 277 ; Output:   A = "improved" alphaMax
705B             6 278 ;           D = "improved" alphaMax
705B             6 279 ;           E = betaMin
705B             6 280 ;
705B             6 281 ; Uses:     AI_PLAYER (speccy side)
705B             6 282 ;           AI_DEPTH (recursion depth level)
705B             6 283 ;
705B             6 284 ; Destroys: BC, HL, IX, IY
705B             6 285 ; ----------------------------------------------------------------------------------------------------------------------
705B             6 286 Alphabeta_Max:
705B D5          6 287 push    de
705C             6 289 ; check if last player move is a winner one
705C CD 82 74    6 291 call    PathFinder_Score            ; if (player won)
705F FE FF       6 292 cp      -1
7061 C2 6C 70    6 293 jp      nz, Alphabeta_Max_Candidates
7064 3A 9A 61    6 294 ld      a, (AI_DEPTH)
7067 2F          6 295 cpl
7068 C6 21       6 296 add     a, 32+1                     ;     return 32-depth
706A D1          6 297 pop     de
706B C9          6 298 ret
706C             6 300 Alphabeta_Max_Candidates
706C CD 25 75    6 301 call    PathFinder_Candidates       ; find candidates for next move
706F D1          6 302 pop     de
7070 DD 7E 00    6 304 ld      a, (ix+0)                   ; A is our first candidate
7073 21 9A 61    6 306 ld      hl, AI_DEPTH
7076 35          6 307 dec     (hl)                        ; depth--
7077 CA B7 70    6 308 jp      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
707A             6 310 Alphabeta_Max_Loop                                          ; for each candidate {
707A D5          6 311 push    de                          ;       store alphaMax and betaMin
707B 26 7D       6 313 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
707D 6F          6 314 ld      l, a
707E E5          6 315 push    hl
707F 3A 99 61    6 317 ld      a, (AI_PLAYER)              ;       get speccy side
7082 CD 03 71    6 318 call    PathFinder_PutToken         ;       BRAINIAC_play
7085 EE 7C       6 319 xor     $7C                         ;       restore speccy side
7087 CD BD 6F    6 320 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
708A E1          6 322 pop     hl                          ;       restore candidate position
708B CD 09 71    6 323 call    PathFinder_EraseToken       ;       BRAINIAC_undo
708E D1          6 325 pop     de                          ;       restore alphaMax and betaMin
708F BA          6 327 cp      d
7090 38 06       6 328 jr      c, Alphabeta_Max_Next
7092 28 04       6 329 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
7094 BB          6 331 cp      e
7095 30 10       6 332 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
7097 57          6 334 ld      d, a                        ;       alphaMax = A
7098             6 336 Alphabeta_Max_Next
7098 DD 2D       6 337 dec     ixl
709A DD 7E 00    6 338 ld      a, (ix+0)                   ;       A is our next candidate
709D B7          6 339 or      a                           ;       repeat until no more candidates
709E C2 7A 70    6 340 jp      nz, Alphabeta_Max_Loop      ; }
70A1 7A          6 342 ld      a, d                        ; return alphaMax
70A2 21 9A 61    6 344 ld      hl, AI_DEPTH
70A5 34          6 345 inc     (hl)                        ; depth++
70A6 C9          6 346 ret
70A7             6 348 Alphabeta_Max_Exit
70A7 57          6 349 ld      d, a                        ; (discard remaining candidates)
70A8 AF          6 350 xor     a
70A9             6 351 Alphabeta_Max_Skip
70A9 DD 2D       6 352 dec     ixl
70AB DD BE 00    6 353 cp      (ix+0)
70AE C2 A9 70    6 354 jp      nz, Alphabeta_Max_Skip
70B1 7A          6 355 ld      a, d
70B2 21 9A 61    6 357 ld      hl, AI_DEPTH
70B5 34          6 358 inc     (hl)                        ; (depth++)
70B6 C9          6 359 ret
70B7             6 361 ; ----------------------------------------------------------------------------------------------------------------------
70B7             6 362 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70B7             6 363 ; beta pruning, when it requires MAXIMIZING Speccy's score.
70B7             6 364 ;
70B7             6 365 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70B7             6 366 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70B7             6 367 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70B7             6 368 ; faster.
70B7             6 369 ;
70B7             6 370 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70B7             6 371 ;
70B7             6 372 ; Input:    A = first candidate
70B7             6 373 ;           D = alphaMax
70B7             6 374 ;           E = betaMin
70B7             6 375 ;
70B7             6 376 ; Returns:  A = "improved" alphaMax
70B7             6 377 ;           D = "improved" alphaMax
70B7             6 378 ;           E = betaMin
70B7             6 379 ;
70B7             6 380 ; Uses:     AI_PLAYER (speccy side)
70B7             6 381 ;           AI_DEPTH (recursion depth level)
70B7             6 382 ;
70B7             6 383 ; Destroys: BC, HL, IX, IY
70B7             6 384 ; ----------------------------------------------------------------------------------------------------------------------
70B7             6 385 Heuristic_Max:                                              ; for each candidate {
70B7 D5          6 386 push    de                          ;       store alphaMax and betaMin
70B8 26 7D       6 388 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70BA 6F          6 389 ld      l, a
70BB E5          6 390 push    hl
70BC 3A 99 61    6 392 ld      a, (AI_PLAYER)              ;       get speccy side
70BF CD 03 71    6 393 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70C2 EE 7C       6 394 xor     $7C                         ;       restore speccy side
70C4 CD 82 74    6 396 call    PathFinder_Score            ;       if (speccy won)
70C7 B7          6 397 or      a
70C8 C2 CD 70    6 398 jp      nz, Heuristic_Max_Continue
70CB 3E E0       6 399 ld      a, 224                      ;           A = 224
70CD             6 400 Heuristic_Max_Continue
70CD E1          6 401 pop     hl                          ;       restore candidate position
70CE CD 09 71    6 402 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70D1 D1          6 404 pop     de                          ;       restore alphaMax and betaMin
70D2 BA          6 406 cp      d
70D3 38 06       6 407 jr      c, Heuristic_Max_Next
70D5 28 04       6 408 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
70D7 BB          6 410 cp      e
70D8 30 10       6 411 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70DA 57          6 413 ld      d, a                        ;       alphaMax = A
70DB             6 415 Heuristic_Max_Next
70DB DD 2D       6 416 dec     ixl
70DD DD 7E 00    6 417 ld      a, (ix+0)                   ;       A is our next candidate
70E0 B7          6 418 or      a                           ;       repeat until no more candidates
70E1 C2 B7 70    6 419 jp      nz, Heuristic_Max           ; }
70E4 7A          6 421 ld      a, d                        ; return alphaMax
70E5 21 9A 61    6 423 ld      hl, AI_DEPTH
70E8 34          6 424 inc     (hl)                        ; depth++
70E9 C9          6 425 ret
70EA             6 427 Heuristic_Max_Exit
70EA 57          6 428 ld      d, a                        ; (discard remaining candidates)
70EB AF          6 429 xor     a
70EC             6 430 Heuristic_Max_Skip
70EC DD 2D       6 431 dec     ixl
70EE DD BE 00    6 432 cp      (ix+0)
70F1 C2 EC 70    6 433 jp      nz, Heuristic_Max_Skip
70F4 7A          6 434 ld      a, d
70F5 21 9A 61    6 436 ld      hl, AI_DEPTH
70F8 34          6 437 inc     (hl)                        ; (depth++)
70F9 C9          6 438 ret

; File #7: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\PathFinder.z80asm

70FA             7 1 ; ----------------------------------------------------------------------------------------------------------------------
70FA             7 2 ; PathFinder.z80asm
70FA             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
70FA             7 4 ;
70FA             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
70FA             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
70FA             7 7 ; ----------------------------------------------------------------------------------------------------------------------
70FA             7 9 EMPTY                   EQU     $00                         ; empty positions on the board
70FA             7 10 SKIPPED                 EQU     $01                         ; skipped positions on the board
70FA             7 11 FRIEND                  EQU     $02                         ; positions occupied by friendly tokens on the board
70FA             7 12 ENEMY                   EQU     $7E                         ; positions occupied by opponent tokens on the board
70FA             7 13 VICTORY                 EQU     $03                         ; internal value if victory
70FA             7 14 WIDTH                   EQU     $08                         ; distance to up-left/down-right neighbor
70FA             7 16 CYAN_POSITIONS          EQU     $7D00                       ; a 256-aligned memory area reserved for cyan positions
70FA             7 17 RED_POSITIONS           EQU     $7E00                       ; a 256-aligned memory area reserved for red positions
70FA             7 18 CANDIDATES              EQU     $7F00                       ; a 256-aligned memory area reserved to store candidates
70FA             7 20 ; ----------------------------------------------------------------------------------------------------------------------
70FA             7 21 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
70FA             7 22 ;
70FA             7 23 ; Input:    -
70FA             7 24 ;
70FA             7 25 ; Output:   A   = FRIEND if current token color is cyan, or A = ENEMY if current token color is red
70FA             7 26 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70FA             7 27 ;
70FA             7 28 ; Uses:     TOKEN_COLOR (current token color)
70FA             7 29 ;
70FA             7 30 ; Destroys: -
70FA             7 31 ; ----------------------------------------------------------------------------------------------------------------------
70FA             7 32 PathFinder_Friend:
70FA 3A 9E 61    7 33 ld      a, (TOKEN_COLOR)            ; get current player color
70FD EE 07       7 34 xor     $07                         ; is current player color cyan?
70FF E0          7 35 ret     po                          ; yes, return FRIEND 
7100 3E 7E       7 36 ld      a, ENEMY                    ; no, return ENEMY
7102 C9          7 37 ret
7103             7 39 ; ----------------------------------------------------------------------------------------------------------------------
7103             7 40 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
7103             7 41 ;
7103             7 42 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
7103             7 43 ;           HL = CYAN_POSITIONS token address
7103             7 44 ;
7103             7 45 ; Output:   A   = inverted side (FRIEND or ENEMY)
7103             7 46 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
7103             7 47 ;
7103             7 48 ; Destroys: -
7103             7 49 ; ----------------------------------------------------------------------------------------------------------------------
7103             7 50 PathFinder_PutToken:
7103 77          7 51 ld      (hl), a                     ; put token at cyan position
7104 24          7 52 inc     h                           ; move HL to red position address
7105 EE 7C       7 53 xor     $7C                         ; invert side
7107 77          7 54 ld      (hl), a                     ; put token at red position
7108 C9          7 55 ret
7109             7 57 ; ----------------------------------------------------------------------------------------------------------------------
7109             7 58 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
7109             7 59 ;
7109             7 60 ; Input:    HL = CYAN_POSITIONS token address
7109             7 61 ;
7109             7 62 ; Output:   -
7109             7 63 ;
7109             7 64 ; Destroys: -
7109             7 65 ; ----------------------------------------------------------------------------------------------------------------------
7109             7 66 PathFinder_EraseToken:
7109 36 00       7 67 ld      (hl), EMPTY                 ; erase token at cyan position
710B 24          7 68 inc     h                           ; move HL to red position address
710C 36 00       7 69 ld      (hl), EMPTY                 ; erase token at red position
710E C9          7 70 ret
710F             7 72 ; ----------------------------------------------------------------------------------------------------------------------
710F             7 73 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
710F             7 74 ;
710F             7 75 ; Input:    DE = cyan or red board address (destiny)
710F             7 76 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
710F             7 77 ;
710F             7 78 ; Output:   DE = cyan or red board address (last position+1)
710F             7 79 ;
710F             7 80 ; Destroys: BC, HL
710F             7 81 ; ----------------------------------------------------------------------------------------------------------------------
710F             7 82 PathFinder_CopyPositions:
710F 01 31 00    7 83 ld      bc, 7*7                     ; number of positions to be copied
7112             7 84 PathFinder_CopyLoop
7112 2C          7 85 inc     l                           ; skip borders on positions
7113 2C          7 86 inc     l
7114 1C          7 87 inc     e                           ; skip borders on board
7115 1C          7 88 inc     e
7116 ED A0       7 89 ldi                                 ; copy a row of 7 positions
7118 ED A0       7 90 ldi
711A ED A0       7 91 ldi
711C ED A0       7 92 ldi
711E ED A0       7 93 ldi
7120 ED A0       7 94 ldi
7122 ED A0       7 95 ldi
7124 EA 12 71    7 96 jp      pe, PathFinder_CopyLoop     ; repeat for each row
7127 C9          7 97 ret
7128             7 99 ; ----------------------------------------------------------------------------------------------------------------------
7128             7 100 ; PathFinder_Update: update current board position during heuristic function evaluation
7128             7 101 ;
7128             7 102 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
7128             7 103 ; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
7128             7 104 ; adjacent".
7128             7 105 ;
7128             7 106 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
7128             7 107 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
7128             7 108 ; follows, depending on current content:
7128             7 109 ;
7128             7 110 ; * SKIPPED: 1 + distance of neighbor closest to goal
7128             7 111 ; * FRIEND:  distance of neighbor closest to goal
7128             7 112 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
7128             7 113 ;
7128             7 114 ; Input:    Z    = flag set when (HL) is FRIEND
7128             7 115 ;           C    = current distance (also with a flag at 6th bit that indicates a friendly position)
7128             7 116 ;           HL   = current position address (on either cyan boards or red boards)
7128             7 117 ;           SP+2 = queue head address (on either cyan queue or red queue areas)
7128             7 118 ;
7128             7 119 ; Output:   -
7128             7 120 ;
7128             7 121 ; Destroys: B, DE
7128             7 122 ; ----------------------------------------------------------------------------------------------------------------------
7128             7 123 PathFinder_Update:
7128 28 12       7 124 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
712A 46          7 125 ld      b, (hl)                     ; check current position
712B 10 1A       7 126 djnz    PathFinder_EMPTY            ; if (hl) = EMPTY, jump below
712D             7 127 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
712D             7 128 PathFinder_Skipped:
712D 71          7 129 ld      (hl), c                     ; save current distance in current position
712E 34          7 130 inc     (hl)                        ; increment distance of current position
712F CB B6       7 131 res     6, (hl)                     ; reset friendly token flag
7131 EB          7 132 ex      de, hl                      ; store current position in DE
7132             7 133 @Queue_Tail
7132 21 00 00    7 134 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
7135 2C          7 135 inc     l                           ; move queue tail down
7136 73          7 136 ld      (hl), e                     ; store position into queue tail
7137 22 33 71    7 137 ld      (@Queue_Tail+1), hl         ; update queue tail
713A EB          7 138 ex      de, hl                      ; restore current position
713B C9          7 139 ret
713C             7 140 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
713C             7 141 PathFinder_Friendly
713C 71          7 142 ld      (hl), c                     ; save current distance in current position
713D CB F6       7 143 set     6, (hl)                     ; set friendly token flag
713F 45          7 144 ld      b, l                        ; save current position in B
7140 D1          7 145 pop     de                          ; preserve RET address
7141 E3          7 146 ex      (sp), hl                    ; retrieve queue head
7142 70          7 147 ld      (hl), b                     ; push this position into queue head
7143 2D          7 148 dec     l                           ; move queue head up
7144 E3          7 149 ex      (sp), hl                    ; update queue head
7145 D5          7 150 push    de                          ; restore RET address
7146 C9          7 151 ret
7147             7 152 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
7147             7 153 PathFinder_EMPTY
7147 CB 71       7 154 bit     6, c                        ; is current distance friendly?
7149 20 E2       7 155 jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
714B 34          7 156 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
714C C9          7 157 ret
714D             7 159 ; ----------------------------------------------------------------------------------------------------------------------
714D             7 160 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
714D             7 161 ;
714D             7 162 ; Input:    -
714D             7 163 ;
714D             7 164 ; Output:   A  = -1, if down edge couldn't be reached
714D             7 165 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
714D             7 166 ;           A  = last edge position visited (-1), otherwise
714D             7 167 ;           HL = cyan queue head address
714D             7 168 ;
714D             7 169 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
714D             7 170 ;
714D             7 171 ; Destroys: BC, DE, IY
714D             7 172 ; ----------------------------------------------------------------------------------------------------------------------
714D             7 173 PathFinder_Cyan_UpDown:
714D 21 07 7D    7 174 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7150 11 07 61    7 175 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
7153 CD 0F 71    7 176 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
7156             7 178 ; entry point for PathFinder_VictoryPath
7156             7 179 PathFinder_Cyan_CheckPath:
7156 FD 21 00 09 7 180 ld      iy, $0900                   ; IYH = distance to check edge positions
715A             7 181 ; IYL = last edge position visited
715A 26 60       7 182 ld      h, CYAN_QUEUE_AREA/256      ; HL points to cyan queue area address
715C 22 33 71    7 183 ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
715F E5          7 184 push    hl                          ; store cyan queue head
7160             7 186 ; set up cyan board (up-down) start positions distances
7160 21 09 61    7 188 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7163 0E 43       7 189 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7165 3E 02       7 190 ld      a, FRIEND                   ; set distance to compare with
7167 BE          7 191 cp      (hl)                        ; check 1st start position distance
7168 D4 28 71    7 192 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
716B 2C          7 193 inc     l                           ; move HL to next start position address
716C BE          7 194 cp      (hl)                        ; check 2nd start position distance
716D D4 28 71    7 195 call    nc, PathFinder_Update       ; (repeat for each start position)
7170 2C          7 196 inc     l
7171 BE          7 197 cp      (hl)                        ; check 3rd start position distance
7172 D4 28 71    7 198 call    nc, PathFinder_Update
7175 2C          7 199 inc     l
7176 BE          7 200 cp      (hl)                        ; check 4th start position distance
7177 D4 28 71    7 201 call    nc, PathFinder_Update
717A 2C          7 202 inc     l
717B BE          7 203 cp      (hl)                        ; check 5th start position distance
717C D4 28 71    7 204 call    nc, PathFinder_Update
717F 2C          7 205 inc     l
7180 BE          7 206 cp      (hl)                        ; check 6th start position distance
7181 D4 28 71    7 207 call    nc, PathFinder_Update
7184 2C          7 208 inc     l
7185 C3 71 72    7 209 jp      PathFinder_First            ; calculate two-distances of cyan board (up-down)
7188             7 211 ; ----------------------------------------------------------------------------------------------------------------------
7188             7 212 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
7188             7 213 ;
7188             7 214 ; Input:    -
7188             7 215 ;
7188             7 216 ; Output:   A  = -1, if up edge couldn't be reached
7188             7 217 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
7188             7 218 ;           A  = last edge position visited (-1), otherwise
7188             7 219 ;           HL = cyan queue head address
7188             7 220 ;
7188             7 221 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7188             7 222 ;
7188             7 223 ; Destroys: BC, DE, IY
7188             7 224 ; ----------------------------------------------------------------------------------------------------------------------
7188             7 225 PathFinder_Cyan_DownUp:
7188 21 07 7D    7 226 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
718B 11 4F 61    7 227 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
718E CD 0F 71    7 228 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
7191 FD 21 00 F7 7 230 ld      iy, $F700                   ; IYH = distance to check edge positions
7195             7 231 ; IYL = last edge position visited
7195 2A 33 71    7 232 ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
7198 E5          7 233 push    hl                          ; initialize cyan queue head
7199             7 235 ; set up cyan board (down-up) start positions distances
7199 EB          7 237 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
719A 2D          7 238 dec     l                           ; move HL to cyan boad down-up address (last position)
719B 0E 43       7 239 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
719D 3E 02       7 240 ld      a, FRIEND                   ; set distance to compare with
719F BE          7 241 cp      (hl)                        ; check 1st start position distance
71A0 D4 28 71    7 242 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71A3 2D          7 243 dec     l                           ; move HL to next start position address
71A4 BE          7 244 cp      (hl)                        ; check 2nd start position distance
71A5 D4 28 71    7 245 call    nc, PathFinder_Update       ; (repeat for each start position)
71A8 2D          7 246 dec     l
71A9 BE          7 247 cp      (hl)                        ; check 3rd start position distance
71AA D4 28 71    7 248 call    nc, PathFinder_Update
71AD 2D          7 249 dec     l
71AE BE          7 250 cp      (hl)                        ; check 4th start position distance
71AF D4 28 71    7 251 call    nc, PathFinder_Update
71B2 2D          7 252 dec     l
71B3 BE          7 253 cp      (hl)                        ; check 5th start position distance
71B4 D4 28 71    7 254 call    nc, PathFinder_Update
71B7 2D          7 255 dec     l
71B8 BE          7 256 cp      (hl)                        ; check 6th start position distance
71B9 D4 28 71    7 257 call    nc, PathFinder_Update
71BC 2D          7 258 dec     l
71BD C3 71 72    7 259 jp      PathFinder_First            ; calculate two-distances of cyan board (down-up)
71C0             7 261 ; ----------------------------------------------------------------------------------------------------------------------
71C0             7 262 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71C0             7 263 ;
71C0             7 264 ; Input:    -
71C0             7 265 ;
71C0             7 266 ; Output:   A  = -1, if right edge couldn't be reached
71C0             7 267 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
71C0             7 268 ;           A  = last edge position visited (-1), otherwise
71C0             7 269 ;           HL = red queue head address
71C0             7 270 ;
71C0             7 271 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71C0             7 272 ;
71C0             7 273 ; Destroys: BC, DE, IY
71C0             7 274 ; ----------------------------------------------------------------------------------------------------------------------
71C0             7 275 PathFinder_Red_LeftRight:
71C0 21 07 7E    7 276 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71C3 11 07 64    7 277 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71C6 CD 0F 71    7 278 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71C9             7 280 ; entry point for PathFinder_VictoryPath
71C9             7 281 PathFinder_Red_CheckPath
71C9 FD 21 00 01 7 282 ld      iy, $0100                   ; IYH = distance to check edge positions
71CD             7 283 ; IYL = last edge position visited
71CD 26 63       7 284 ld      h, RED_QUEUE_AREA/256       ; HL points to red queue area address
71CF 22 33 71    7 285 ld      (@Queue_Tail+1), hl         ; initialize red queue tail
71D2 E5          7 286 push    hl                          ; store red queue head
71D3             7 288 ; set up red board (left-right) start positions distances
71D3 21 09 64    7 290 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
71D6 0E 43       7 291 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71D8 3E 02       7 292 ld      a, FRIEND                   ; set distance to compare with
71DA BE          7 293 cp      (hl)                        ; check 1st start position distance
71DB D4 28 71    7 294 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71DE 2E 12       7 295 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
71E0 BE          7 296 cp      (hl)                        ; check 2nd start position distance
71E1 D4 28 71    7 297 call    nc, PathFinder_Update       ; (repeat for each start position)
71E4 2E 1B       7 298 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
71E6 BE          7 299 cp      (hl)                        ; check 3rd start position distance
71E7 D4 28 71    7 300 call    nc, PathFinder_Update
71EA 2E 24       7 301 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
71EC BE          7 302 cp      (hl)                        ; check 4th start position distance
71ED D4 28 71    7 303 call    nc, PathFinder_Update
71F0 2E 2D       7 304 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
71F2 BE          7 305 cp      (hl)                        ; check 5th start position distance
71F3 D4 28 71    7 306 call    nc, PathFinder_Update
71F6 2E 36       7 307 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
71F8 BE          7 308 cp      (hl)                        ; check 6th start position distance
71F9 D4 28 71    7 309 call    nc, PathFinder_Update
71FC 2E 3F       7 310 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
71FE C3 71 72    7 311 jp      PathFinder_First            ; calculate two-distances of red board (left-right)
7201             7 313 ; ----------------------------------------------------------------------------------------------------------------------
7201             7 314 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
7201             7 315 ;
7201             7 316 ; Input:    -
7201             7 317 ;
7201             7 318 ; Output:   A  = -1, if left edge couldn't be reached
7201             7 319 ;           A  =  0, if there is chain of connected cyan tokens between the two edges
7201             7 320 ;           A  = last edge position visited (-1), otherwise
7201             7 321 ;           HL = red queue head address
7201             7 322 ;
7201             7 323 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7201             7 324 ;
7201             7 325 ; Destroys: BC, DE, IY
7201             7 326 ; ----------------------------------------------------------------------------------------------------------------------
7201             7 327 PathFinder_Red_RightLeft:
7201 21 07 7E    7 328 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
7204 11 4F 64    7 329 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
7207 CD 0F 71    7 330 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
720A FD 21 00 FF 7 332 ld      iy, $FF00                   ; IYH = distance to check edge positions
720E             7 333 ; IYL = last edge position visited
720E 2A 33 71    7 334 ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
7211 E5          7 335 push    hl                          ; initialize red queue head
7212             7 337 ; set up red board (right-left) start positions distances
7212 EB          7 339 ex      de, hl                      ; take advantage of last "CopyPositions" execution
7213 2D          7 340 dec     l                           ; move HL to red board right-left address (last position)
7214 0E 43       7 341 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7216 3E 02       7 342 ld      a, FRIEND                   ; set distance to compare with
7218 BE          7 343 cp      (hl)                        ; check 1st start position distance
7219 D4 28 71    7 344 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
721C 2E 84       7 345 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
721E BE          7 346 cp      (hl)                        ; check 2nd start position distance
721F D4 28 71    7 347 call    nc, PathFinder_Update       ; (repeat for each start position)
7222 2E 7B       7 348 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
7224 BE          7 349 cp      (hl)                        ; check 3rd start position distance
7225 D4 28 71    7 350 call    nc, PathFinder_Update
7228 2E 72       7 351 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
722A BE          7 352 cp      (hl)                        ; check 4th start position distance
722B D4 28 71    7 353 call    nc, PathFinder_Update
722E 2E 69       7 354 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
7230 BE          7 355 cp      (hl)                        ; check 5th start position distance
7231 D4 28 71    7 356 call    nc, PathFinder_Update
7234 2E 60       7 357 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
7236 BE          7 358 cp      (hl)                        ; check 6th start position distance
7237 D4 28 71    7 359 call    nc, PathFinder_Update
723A 2E 57       7 360 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
723C C3 71 72    7 361 jp      PathFinder_First            ; calculate red two-distance (right-left)
723F             7 363 ; ----------------------------------------------------------------------------------------------------------------------
723F             7 364 ; PathFinder: calculate two-distance metric for each board position
723F             7 365 ;
723F             7 366 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
723F             7 367 ;
723F             7 368 ; Input:    HL  = cyan or red queue area address
723F             7 369 ;           IYH = distance to check edge positions
723F             7 370 ;           IYL = 0
723F             7 371 ;
723F             7 372 ; Output:   A   = -1, if corresponding edge couldn't be reached
723F             7 373 ;           A   =  0, if there is chain of connected (color) tokens between the two edges
723F             7 374 ;           A   = last edge position visited (-1), otherwise
723F             7 375 ;           HL  = cyan or red queue head address
723F             7 376 ;
723F             7 377 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
723F             7 378 ;
723F             7 379 ; Destroys: BC, DE, IY
723F             7 380 ; ----------------------------------------------------------------------------------------------------------------------
723F             7 381 PathFinder:
723F 2C          7 382 inc     l                           ; move queue head down
7240 E5          7 383 push    hl                          ; preserve queue head address
7241 6E          7 384 ld      l, (hl)                     ; retrieve next position to be checked
7242 24          7 385 inc     h                           ; move HL to corresponding board address
7243 4E          7 386 ld      c, (hl)                     ; retrieve distance from this position to start
7244 5D          7 387 ld      e, l                        ; store current position
7245             7 389 ; look for adjacent positions
7245 7D          7 391 ld      a, l                        ; get current position
7246 FD 84       7 392 add     a, iyh                      ; add distance to check edge positions
7248 6F          7 393 ld      l, a                        ; move HL to calculated position address
7249 CB 7E       7 394 bit     7, (hl)                     ; is it an edge?
724B 20 34       7 395 jr      nz, PathFinder_Adjacent     ; yes, process adjacent positions
724D 3E 02       7 397 ld      a, FRIEND                   ; set distance to compare with
724F             7 398 ; return point from PathFinder_Adjacent
724F             7 399 PathFinder_Neighbors
724F 6B          7 400 ld      l, e                        ; restore current position to be checked
7250 2C          7 401 inc     l                           ; move HL to right neighbor address
7251 BE          7 402 cp      (hl)                        ; check right neighbor distance
7252 D4 28 71    7 403 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7255 2D          7 404 dec     l                           ; move HL to left neighbor address
7256 2D          7 405 dec     l
7257 BE          7 406 cp      (hl)                        ; check left neighbor distance
7258 D4 28 71    7 407 call    nc, PathFinder_Update       ; (repeat for each neighbor)
725B 11 F8 FF    7 408 ld      de, -WIDTH
725E 19          7 409 add     hl, de
725F BE          7 410 cp      (hl)                        ; check upper-left neighbor distance
7260 D4 28 71    7 411 call    nc, PathFinder_Update
7263 2C          7 412 inc     l
7264 BE          7 413 cp      (hl)                        ; check upper-right neighbor distance
7265 D4 28 71    7 414 call    nc, PathFinder_Update
7268 11 10 00    7 415 ld      de, WIDTH*2
726B 19          7 416 add     hl, de
726C BE          7 417 cp      (hl)                        ; check lower-left neighbor distance
726D D4 28 71    7 418 call    nc, PathFinder_Update
7270 2C          7 419 inc     l
7271             7 420 PathFinder_First
7271 BE          7 421 cp      (hl)                        ; check lower-right neighbor distance
7272 D4 28 71    7 422 call    nc, PathFinder_Update
7275 E1          7 423 pop     hl                          ; retreive queue head address
7276 3A 33 71    7 424 ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
7279 BD          7 425 cp      l                           ; is queue empty?
727A C2 3F 72    7 426 jp      nz, PathFinder              ; no, repeat until queue is empty
727D FD 7D       7 428 ld      a, iyl                      ; get last edge position visited
727F 3D          7 429 dec     a                           ; return A = -1, if the edge couldn't be reached
7280 C9          7 430 ret
7281             7 432 ; ----------------------------------------------------------------------------------------------------------------------
7281             7 433 ; Check adjacent hexagons.
7281             7 434 ;
7281             7 435 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
7281             7 436 ; "two cells are adjacent if they share a common edge on the board."
7281             7 437 ;
7281             7 438 ; Input:    E  = current position
7281             7 439 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
7281             7 440 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
7281             7 441 ;                edge number)
7281             7 442 ;
7281             7 443 ; Output:   A  = 0 and HL = cyan or red queue head address, if there is a chain of connected tokens of the same color
7281             7 444 ;                between the two edges.
7281             7 445 ;           A  = FRIEND and E = current position, otherwise.
7281             7 446 ;
7281             7 447 ; Destroys: BC, D
7281             7 448 ; ----------------------------------------------------------------------------------------------------------------------
7281             7 449 PathFinder_Adjacent
7281 3E 43       7 450 ld      a, VICTORY+$40              ; set victory distance + friendly flag
7283 B9          7 451 cp      c                           ; is current distance victory and friendly?
7284 28 0E       7 452 jr      z, PathFinder_Abort         ; yes, abort path_finder
7286 FD 6B       7 454 ld      iyl, e                      ; update last edge position visited
7288 54          7 455 ld      d, h                        ; store pointer to current position address in DE
7289 6E          7 456 ld      l, (hl)                     ; get current edge position
728A CB 25       7 457 sla     l                           ; calculate vector table routine index
728C 24          7 458 inc     h                           ; move HL to (cyan or red) vector table routine address
728D 7E          7 459 ld      a, (hl)                     ; get low byte of vector table routine address
728E 2C          7 460 inc     l                           ; move HL to high byte of vector table routine address
728F 66          7 461 ld      h, (hl)                     ; get high byte of vector table routine address
7290 6F          7 462 ld      l, a                        ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
7291 3E 02       7 463 ld      a, FRIEND                   ; set distance to compare with
7293 E9          7 464 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
7294             7 465 PathFinder_Abort
7294 E1          7 466 pop     hl                          ; restore queue head address
7295 AF          7 467 xor     a                           ; return A = 0
7296 C9          7 468 ret
7297             7 470 ; ----------------------------------------------------------------------------------------------------------------------
7297             7 471 ;  Check two-distance of RED adjacents
7297             7 472 ; ----------------------------------------------------------------------------------------------------------------------
7297             7 473 PathFinder_RED_Edge_0
7297 EB          7 474 ex      de, hl                      ; restore pointer to current position address
7298 11 12 00    7 475 ld      de, 9*2                     ; calculate distance to adjacent #2
729B 19          7 476 add     hl, de                      ; move HL to adjacent #2 address
729C BE          7 477 cp      (hl)                        ; check adjacent #2 distance
729D D4 28 71    7 478 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
72A0 11 09 00    7 479 ld      de, 9                       ; calculate distance to adjacent #3
72A3 19          7 480 add     hl, de                      ; move HL to adjacent #3 address
72A4 BE          7 481 cp      (hl)                        ; check adjacent #3 distance
72A5 D4 28 71    7 482 call    nc, PathFinder_Update       ; (repeat for each adjacent)
72A8 11 09 00    7 483 ld      de, 9
72AB 19          7 484 add     hl, de
72AC BE          7 485 cp      (hl)                        ; check adjacent #4 distance
72AD D4 28 71    7 486 call    nc, PathFinder_Update
72B0 11 09 00    7 487 ld      de, 9
72B3 19          7 488 add     hl, de
72B4 BE          7 489 cp      (hl)                        ; check adjacent #5 distance
72B5 D4 28 71    7 490 call    nc, PathFinder_Update
72B8 11 09 00    7 491 ld      de, 9
72BB 19          7 492 add     hl, de
72BC BE          7 493 cp      (hl)                        ; check adjacent #6 distance
72BD D4 28 71    7 494 call    nc, PathFinder_Update
72C0 FD 5D       7 495 ld      e, iyl                      ; restore current position
72C2 C3 4F 72    7 496 jp      PathFinder_Neighbors        ; continue processing neighbors
72C5             7 498 PathFinder_RED_Edge_1
72C5 EB          7 499 ex      de, hl                      ; restore pointer to current position address
72C6 11 12 00    7 500 ld      de, 9*2
72C9 19          7 501 add     hl, de
72CA BE          7 502 cp      (hl)                        ; check adjacent #3 distance
72CB D4 28 71    7 503 call    nc, PathFinder_Update
72CE 11 09 00    7 504 ld      de, 9
72D1 19          7 505 add     hl, de
72D2 BE          7 506 cp      (hl)                        ; check adjacent #4 distance
72D3 D4 28 71    7 507 call    nc, PathFinder_Update
72D6 11 09 00    7 508 ld      de, 9
72D9 19          7 509 add     hl, de
72DA BE          7 510 cp      (hl)                        ; check adjacent #5 distance
72DB D4 28 71    7 511 call    nc, PathFinder_Update
72DE 11 09 00    7 512 ld      de, 9
72E1 19          7 513 add     hl, de
72E2 BE          7 514 cp      (hl)                        ; check adjacent #6 distance
72E3 D4 28 71    7 515 call    nc, PathFinder_Update
72E6 FD 5D       7 516 ld      e, iyl                      ; restore current position
72E8 C3 4F 72    7 517 jp      PathFinder_Neighbors        ; continue processing neighbors
72EB             7 519 PathFinder_RED_Edge_2
72EB EB          7 520 ex      de, hl                      ; restore pointer to current position address
72EC 11 12 00    7 521 ld      de, 9*2
72EF 19          7 522 add     hl, de
72F0 BE          7 523 cp      (hl)                        ; check adjacent #4 distance
72F1 D4 28 71    7 524 call    nc, PathFinder_Update
72F4 11 09 00    7 525 ld      de, 9
72F7 19          7 526 add     hl, de
72F8 BE          7 527 cp      (hl)                        ; check adjacent #5 distance
72F9 D4 28 71    7 528 call    nc, PathFinder_Update
72FC 11 09 00    7 529 ld      de, 9
72FF 19          7 530 add     hl, de
7300 BE          7 531 cp      (hl)                        ; check adjacent #6 distance
7301 D4 28 71    7 532 call    nc, PathFinder_Update
7304 11 CA FF    7 533 ld      de, -9*6
7307 19          7 534 add     hl, de
7308 BE          7 535 cp      (hl)                        ; check adjacent #0 distance
7309 D4 28 71    7 536 call    nc, PathFinder_Update
730C FD 5D       7 537 ld      e, iyl                      ; restore current position
730E C3 4F 72    7 538 jp      PathFinder_Neighbors        ; continue processing neighbors
7311             7 540 PathFinder_RED_Edge_3
7311 EB          7 541 ex      de, hl                      ; restore pointer to current position address
7312 11 E5 FF    7 542 ld      de, -9*3
7315 19          7 543 add     hl, de
7316 BE          7 544 cp      (hl)                        ; check adjacent #0 distance
7317 D4 28 71    7 545 call    nc, PathFinder_Update
731A 11 09 00    7 546 ld      de, 9
731D 19          7 547 add     hl, de
731E BE          7 548 cp      (hl)                        ; check adjacent #1 distance
731F D4 28 71    7 549 call    nc, PathFinder_Update
7322 11 24 00    7 550 ld      de, 9*4
7325 19          7 551 add     hl, de
7326 BE          7 552 cp      (hl)                        ; check adjacent #5 distance
7327 D4 28 71    7 553 call    nc, PathFinder_Update
732A 11 09 00    7 554 ld      de, 9
732D 19          7 555 add     hl, de
732E BE          7 556 cp      (hl)                        ; check adjacent #6 distance
732F D4 28 71    7 557 call    nc, PathFinder_Update
7332 FD 5D       7 558 ld      e, iyl                      ; restore current position
7334 C3 4F 72    7 559 jp      PathFinder_Neighbors        ; continue processing neighbors
7337             7 561 PathFinder_RED_Edge_4
7337 EB          7 562 ex      de, hl                      ; restore pointer to current position address
7338 11 12 00    7 563 ld      de, 9*2
733B 19          7 564 add     hl, de
733C BE          7 565 cp      (hl)                        ; check adjacent #6 distance
733D D4 28 71    7 566 call    nc, PathFinder_Update
7340 11 CA FF    7 567 ld      de, -9*6
7343 19          7 568 add     hl, de
7344 BE          7 569 cp      (hl)                        ; check adjacent #0 distance
7345 D4 28 71    7 570 call    nc, PathFinder_Update
7348 11 09 00    7 571 ld      de, 9
734B 19          7 572 add     hl, de
734C BE          7 573 cp      (hl)                        ; check adjacent #1 distance
734D D4 28 71    7 574 call    nc, PathFinder_Update
7350 11 09 00    7 575 ld      de, 9
7353 19          7 576 add     hl, de
7354 BE          7 577 cp      (hl)                        ; check adjacent #2 distance
7355 D4 28 71    7 578 call    nc, PathFinder_Update
7358 FD 5D       7 579 ld      e, iyl                      ; restore current position
735A C3 4F 72    7 580 jp      PathFinder_Neighbors        ; continue processing neighbors
735D             7 582 PathFinder_RED_Edge_5
735D EB          7 583 ex      de, hl                      ; restore pointer to current position address
735E 11 D3 FF    7 584 ld      de, -9*5
7361 19          7 585 add     hl, de
7362 BE          7 586 cp      (hl)                        ; check adjacent #0 distance
7363 D4 28 71    7 587 call    nc, PathFinder_Update
7366 11 09 00    7 588 ld      de, 9
7369 19          7 589 add     hl, de
736A BE          7 590 cp      (hl)                        ; check adjacent #1 distance
736B D4 28 71    7 591 call    nc, PathFinder_Update
736E 11 09 00    7 592 ld      de, 9
7371 19          7 593 add     hl, de
7372 BE          7 594 cp      (hl)                        ; check adjacent #2 distance
7373 D4 28 71    7 595 call    nc, PathFinder_Update
7376 11 09 00    7 596 ld      de, 9
7379 19          7 597 add     hl, de
737A BE          7 598 cp      (hl)                        ; check adjacent #3 distance
737B D4 28 71    7 599 call    nc, PathFinder_Update
737E FD 5D       7 600 ld      e, iyl                      ; restore current position
7380 C3 4F 72    7 601 jp      PathFinder_Neighbors        ; continue processing neighbors
7383             7 603 PathFinder_RED_Edge_6
7383 EB          7 604 ex      de, hl                      ; restore pointer to current position address
7384 11 CA FF    7 605 ld      de, -9*6
7387 19          7 606 add     hl, de
7388 BE          7 607 cp      (hl)                        ; check adjacent #0 distance
7389 D4 28 71    7 608 call    nc, PathFinder_Update
738C 11 09 00    7 609 ld      de, 9
738F 19          7 610 add     hl, de
7390 BE          7 611 cp      (hl)                        ; check adjacent #1 distance
7391 D4 28 71    7 612 call    nc, PathFinder_Update
7394 11 09 00    7 613 ld      de, 9
7397 19          7 614 add     hl, de
7398 BE          7 615 cp      (hl)                        ; check adjacent #2 distance
7399 D4 28 71    7 616 call    nc, PathFinder_Update
739C 11 09 00    7 617 ld      de, 9
739F 19          7 618 add     hl, de
73A0 BE          7 619 cp      (hl)                        ; check adjacent #3 distance
73A1 D4 28 71    7 620 call    nc, PathFinder_Update
73A4 11 09 00    7 621 ld      de, 9
73A7 19          7 622 add     hl, de
73A8 BE          7 623 cp      (hl)                        ; check adjacent #4 distance
73A9 D4 28 71    7 624 call    nc, PathFinder_Update
73AC FD 5D       7 625 ld      e, iyl                      ; restore current position
73AE C3 4F 72    7 626 jp      PathFinder_Neighbors        ; continue processing neighbors
73B1             7 628 ; ----------------------------------------------------------------------------------------------------------------------
73B1             7 629 ;  Check two-distance of CYAN adjacents
73B1             7 630 ; ----------------------------------------------------------------------------------------------------------------------
73B1             7 631 PathFinder_CYAN_Edge_0
73B1 EB          7 632 ex      de, hl                      ; restore pointer to current position address
73B2 2C          7 633 inc     l
73B3 2C          7 634 inc     l
73B4 BE          7 635 cp      (hl)                        ; check adjacent #2 distance
73B5 D4 28 71    7 636 call    nc, PathFinder_Update
73B8 2C          7 637 inc     l
73B9 BE          7 638 cp      (hl)                        ; check adjacent #3 distance
73BA D4 28 71    7 639 call    nc, PathFinder_Update
73BD 2C          7 640 inc     l
73BE BE          7 641 cp      (hl)                        ; check adjacent #4 distance
73BF D4 28 71    7 642 call    nc, PathFinder_Update
73C2 2C          7 643 inc     l
73C3 BE          7 644 cp      (hl)                        ; check adjacent of edge number 5
73C4 D4 28 71    7 645 call    nc, PathFinder_Update
73C7 2C          7 646 inc     l
73C8 BE          7 647 cp      (hl)                        ; check adjacent of edge number 6
73C9 D4 28 71    7 648 call    nc, PathFinder_Update
73CC FD 5D       7 649 ld      e, iyl                      ; restore current position
73CE C3 4F 72    7 650 jp      PathFinder_Neighbors        ; continue processing neighbors
73D1             7 652 PathFinder_CYAN_Edge_1
73D1 EB          7 653 ex      de, hl                      ; restore pointer to current position address
73D2 2C          7 654 inc     l
73D3 2C          7 655 inc     l
73D4 BE          7 656 cp      (hl)                        ; check adjacent #3 distance
73D5 D4 28 71    7 657 call    nc, PathFinder_Update
73D8 2C          7 658 inc     l
73D9 BE          7 659 cp      (hl)                        ; check adjacent #4 distance
73DA D4 28 71    7 660 call    nc, PathFinder_Update
73DD 2C          7 661 inc     l
73DE BE          7 662 cp      (hl)                        ; check adjacent #5 distance
73DF D4 28 71    7 663 call    nc, PathFinder_Update
73E2 2C          7 664 inc     l
73E3 BE          7 665 cp      (hl)                        ; check adjacent #6 distance
73E4 D4 28 71    7 666 call    nc, PathFinder_Update
73E7 FD 5D       7 667 ld      e, iyl                      ; restore current position
73E9 C3 4F 72    7 668 jp      PathFinder_Neighbors        ; continue processing neighbors
73EC             7 670 PathFinder_CYAN_Edge_2
73EC EB          7 671 ex      de, hl                      ; restore pointer to current position address
73ED 2D          7 672 dec     l
73EE 2D          7 673 dec     l
73EF BE          7 674 cp      (hl)                        ; check adjacent #0 distance
73F0 D4 28 71    7 675 call    nc, PathFinder_Update
73F3 2C          7 676 inc     l
73F4 2C          7 677 inc     l
73F5 2C          7 678 inc     l
73F6 2C          7 679 inc     l
73F7 BE          7 680 cp      (hl)                        ; check adjacent #4 distance
73F8 D4 28 71    7 681 call    nc, PathFinder_Update
73FB 2C          7 682 inc     l
73FC BE          7 683 cp      (hl)                        ; check adjacent #5 distance
73FD D4 28 71    7 684 call    nc, PathFinder_Update
7400 2C          7 685 inc     l
7401 BE          7 686 cp      (hl)                        ; check adjacent #6 distance
7402 D4 28 71    7 687 call    nc, PathFinder_Update
7405 FD 5D       7 688 ld      e, iyl                      ; restore current position
7407 C3 4F 72    7 689 jp      PathFinder_Neighbors        ; continue processing neighbors
740A             7 691 PathFinder_CYAN_Edge_3
740A EB          7 692 ex      de, hl                      ; restore pointer to current position address
740B 2D          7 693 dec     l
740C 2D          7 694 dec     l
740D 2D          7 695 dec     l
740E BE          7 696 cp      (hl)                        ; check adjacent #0 distance
740F D4 28 71    7 697 call    nc, PathFinder_Update
7412 2C          7 698 inc     l
7413 BE          7 699 cp      (hl)                        ; check adjacent #1 distance
7414 D4 28 71    7 700 call    nc, PathFinder_Update
7417 2C          7 701 inc     l
7418 2C          7 702 inc     l
7419 2C          7 703 inc     l
741A 2C          7 704 inc     l
741B BE          7 705 cp      (hl)                        ; check adjacent #5 distance
741C D4 28 71    7 706 call    nc, PathFinder_Update
741F 2C          7 707 inc     l
7420 BE          7 708 cp      (hl)                        ; check adjacent #6 distance
7421 D4 28 71    7 709 call    nc, PathFinder_Update
7424 FD 5D       7 710 ld      e, iyl                      ; restore current position
7426 C3 4F 72    7 711 jp      PathFinder_Neighbors        ; continue processing neighbors
7429             7 713 PathFinder_CYAN_Edge_4
7429 EB          7 714 ex      de, hl                      ; restore pointer to current position address
742A 2C          7 715 inc     l
742B 2C          7 716 inc     l
742C BE          7 717 cp      (hl)                        ; check adjacent #6 distance
742D D4 28 71    7 718 call    nc, PathFinder_Update
7430 2D          7 719 dec     l
7431 2D          7 720 dec     l
7432 2D          7 721 dec     l
7433 2D          7 722 dec     l
7434 BE          7 723 cp      (hl)                        ; check adjacent #2 distance
7435 D4 28 71    7 724 call    nc, PathFinder_Update
7438 2D          7 725 dec     l
7439 BE          7 726 cp      (hl)                        ; check adjacent #1 distance
743A D4 28 71    7 727 call    nc, PathFinder_Update
743D 2D          7 728 dec     l
743E BE          7 729 cp      (hl)                        ; check adjacent #0 distance
743F D4 28 71    7 730 call    nc, PathFinder_Update
7442 FD 5D       7 731 ld      e, iyl                      ; restore current position
7444 C3 4F 72    7 732 jp      PathFinder_Neighbors        ; continue processing neighbors
7447             7 734 PathFinder_CYAN_Edge_5
7447 EB          7 735 ex      de, hl                      ; restore pointer to current position address
7448 2D          7 736 dec     l
7449 2D          7 737 dec     l
744A BE          7 738 cp      (hl)                        ; check adjacent #3 distance
744B D4 28 71    7 739 call    nc, PathFinder_Update
744E 2D          7 740 dec     l
744F BE          7 741 cp      (hl)                        ; check adjacent #2 distance
7450 D4 28 71    7 742 call    nc, PathFinder_Update
7453 2D          7 743 dec     l
7454 BE          7 744 cp      (hl)                        ; check adjacent #1 distance
7455 D4 28 71    7 745 call    nc, PathFinder_Update
7458 2D          7 746 dec     l
7459 BE          7 747 cp      (hl)                        ; check adjacent #0 distance
745A D4 28 71    7 748 call    nc, PathFinder_Update
745D FD 5D       7 749 ld      e, iyl                      ; restore current position
745F C3 4F 72    7 750 jp      PathFinder_Neighbors        ; continue processing neighbors
7462             7 752 PathFinder_CYAN_Edge_6
7462 EB          7 753 ex      de, hl                      ; restore pointer to current position address
7463 2D          7 754 dec     l
7464 2D          7 755 dec     l
7465 BE          7 756 cp      (hl)                        ; check adjacent #4 distance
7466 D4 28 71    7 757 call    nc, PathFinder_Update
7469 2D          7 758 dec     l
746A BE          7 759 cp      (hl)                        ; check adjacent #3 distance
746B D4 28 71    7 760 call    nc, PathFinder_Update
746E 2D          7 761 dec     l
746F BE          7 762 cp      (hl)                        ; check adjacent #2 distance
7470 D4 28 71    7 763 call    nc, PathFinder_Update
7473 2D          7 764 dec     l
7474 BE          7 765 cp      (hl)                        ; check adjacent #1 distance
7475 D4 28 71    7 766 call    nc, PathFinder_Update
7478 2D          7 767 dec     l
7479 BE          7 768 cp      (hl)                        ; check adjacent #0 distance
747A D4 28 71    7 769 call    nc, PathFinder_Update
747D FD 5D       7 770 ld      e, iyl                      ; restore current position
747F C3 4F 72    7 771 jp      PathFinder_Neighbors        ; continue processing neighbors
7482             7 773 ; ----------------------------------------------------------------------------------------------------------------------
7482             7 774 ; PathFinder_Score: calculate board score depending on speccy color
7482             7 775 ;
7482             7 776 ; Input:    P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
7482             7 777 ;
7482             7 778 ; Output:   A = -1, if speccy can't reach his opposite edge
7482             7 779 ;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
7482             7 780 ;           A = speccy heuristic evaluation, otherwise
7482             7 781 ;
7482             7 782 ; Uses:     -
7482             7 783 ;
7482             7 784 ; Destroys: A', BC, DE, HL, IY
7482             7 785 ; ----------------------------------------------------------------------------------------------------------------------
7482             7 786 PathFinder_Score:
7482 E2 B6 74    7 787 jp      po, PathFinder_CyanScore    ; if speccy side is FRIEND, calculate CYAN score
7485             7 789 ; ----------------------------------------------------------------------------------------------------------------------
7485             7 790 ; PathFinder_RedScore: calculate red score
7485             7 791 ;
7485             7 792 ; Input:    -
7485             7 793 ;
7485             7 794 ; Output:   A = -1, if red can't reach his opposite edge
7485             7 795 ;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
7485             7 796 ;           A = red heuristic evaluation, otherwise
7485             7 797 ;
7485             7 798 ; Uses:     POTENTIALS (board potential and attack mobility)
7485             7 799 ;
7485             7 800 ; Destroys: A', BC, DE, HL, IY
7485             7 801 ; ----------------------------------------------------------------------------------------------------------------------
7485             7 802 PathFinder_RedScore
7485 CD C0 71    7 803 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
7488 C8          7 804 ret     z                           ; if red has a chain of connected tokens, return A = 0
7489 08          7 805 ex      af, af'                     ; save first result
748A CD 01 72    7 806 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
748D 47          7 807 ld      b, a                        ; save second result
748E 08          7 808 ex      af, af'                     ; restore first result
748F 90          7 809 sub     b                           ; subtract both results
7490 78          7 810 ld      a, b                        ; restore second result
7491 C8          7 811 ret     z                           ; if red can't reach his opposite edge, return A = -1
7492 CD 4D 71    7 813 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
7495 08          7 814 ex      af, af'                     ; save result
7496 CD 88 71    7 815 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
7499 47          7 816 ld      b, a                        ; save second result
749A 08          7 817 ex      af, af'                     ; restore first result
749B 90          7 818 sub     b                           ; subtract both results
749C C8          7 819 ret     z                           ; if cyan can't reach his opposite edge, return A = 0
749D 21 09 64    7 821 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74A0 11 51 64    7 822 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74A3 CD F4 74    7 823 call    PathFinder_Potentials       ; calculate RED potentials
74A6 ED 43 97 61 7 824 ld      (POTENTIALS), bc            ; store RED potentials
74AA 21 09 61    7 826 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74AD 11 51 61    7 827 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74B0 CD F4 74    7 828 call    PathFinder_Potentials       ; calculate cyan potentials
74B3 C3 E4 74    7 829 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74B6             7 831 ; ----------------------------------------------------------------------------------------------------------------------
74B6             7 832 ; PathFinder_CyanScore: calculate cyan score
74B6             7 833 ;
74B6             7 834 ; Input:    -
74B6             7 835 ;
74B6             7 836 ; Output:   A = -1, if cyan can't reach his opposite edge
74B6             7 837 ;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
74B6             7 838 ;           A = cyan heuristic evaluation, otherwise
74B6             7 839 ;
74B6             7 840 ; Uses:     POTENTIALS (board potential and attack mobility)
74B6             7 841 ;
74B6             7 842 ; Destroys: A', BC, DE, HL
74B6             7 843 ; ----------------------------------------------------------------------------------------------------------------------
74B6             7 844 PathFinder_CyanScore
74B6 CD 4D 71    7 845 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74B9 C8          7 846 ret     z                           ; if cyan has a chain of connected tokens, return A = 0
74BA 08          7 847 ex      af, af'                     ; save result
74BB CD 88 71    7 848 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74BE 47          7 849 ld      b, a                        ; save second result
74BF 08          7 850 ex      af, af'                     ; restore first result
74C0 90          7 851 sub     b                           ; subtract both results
74C1 78          7 852 ld      a, b                        ; restore second result
74C2 C8          7 853 ret     z                           ; if cyan can't reach his opposite edge, return A = -1
74C3 CD C0 71    7 855 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74C6 08          7 856 ex      af, af'                     ; save result
74C7 CD 01 72    7 857 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74CA 47          7 858 ld      b, a                        ; save second result
74CB 08          7 859 ex      af, af'                     ; restore first result
74CC 90          7 860 sub     b                           ; subtract both results
74CD C8          7 861 ret     z                           ; if red can't reach his opposite edge, return A = 0
74CE 21 09 61    7 863 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74D1 11 51 61    7 864 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74D4 CD F4 74    7 865 call    PathFinder_Potentials       ; calculate cyan potentials
74D7 ED 43 97 61 7 866 ld      (POTENTIALS), bc            ; save cyan potentials
74DB 21 09 64    7 868 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74DE 11 51 64    7 869 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74E1 CD F4 74    7 870 call    PathFinder_Potentials       ; calculate red potentials
74E4             7 871 ; ----------------------------------------------------------------------------------------------------------------------
74E4             7 872 ; PathFinder_Evaluation: calculate heuristic evaluation.
74E4             7 873 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
74E4             7 874 ;
74E4             7 875 ;                                       e = M (pC - pR) - (aC - aR)
74E4             7 876 ; where:
74E4             7 877 ;   pC = cyan board potential
74E4             7 878 ;   pR = red board potential
74E4             7 879 ;   aC = cyan attack mobility
74E4             7 880 ;   aR = red attack mobility
74E4             7 881 ;    M = a large number
74E4             7 882 ;
74E4             7 883 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
74E4             7 884 ;
74E4             7 885 ; Input:    B = opponent attack mobility
74E4             7 886 ;           C = opponent board potential
74E4             7 887 ;
74E4             7 888 ; Output:   A = heuristic evaluation
74E4             7 889 ;
74E4             7 890 ; Destroys: E, HL
74E4             7 891 ; ----------------------------------------------------------------------------------------------------------------------
74E4             7 892 PathFinder_Evaluation:
74E4 21 98 61    7 893 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
74E7 78          7 894 ld      a, b                        ; get opponent's attack mobility
74E8 96          7 895 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
74E9 5F          7 896 ld      e, a                        ; save the result in E
74EA 2D          7 897 dec     l                           ; move HL to player's board potential address
74EB 79          7 898 ld      a, c                        ; get opponent's board potential
74EC 96          7 899 sub     (hl)                        ; subtract potentials -> (pC - pR)
74ED 87          7 900 add     a, a                        ; multiply by 8 -> M (pC - pR)
74EE 87          7 901 add     a, a
74EF 87          7 902 add     a, a
74F0 93          7 903 sub     e                           ; subtract result of attack mobilities subtraction
74F1             7 904 ; -> M (pC - pR) - (aC - aR)
74F1 EE 80       7 905 xor     $80                         ; invert sign for easier further comparative
74F3 C9          7 906 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
74F4             7 908 ; ----------------------------------------------------------------------------------------------------------------------
74F4             7 909 ; PathFinder_Potentials: calculate board potential and attack mobility
74F4             7 910 ;
74F4             7 911 ; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
74F4             7 912 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
74F4             7 913 ;   the board.
74F4             7 914 ; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
74F4             7 915 ;
74F4             7 916 ; Input:    HL = cyan board or red board address
74F4             7 917 ;           DE = cyan board or red board address
74F4             7 918 ;
74F4             7 919 ; Output:   B = attack mobility
74F4             7 920 ;           C = board potential
74F4             7 921 ;
74F4             7 922 ; Destroys: A, DE, HL, IYL
74F4             7 923 ; ----------------------------------------------------------------------------------------------------------------------
74F4             7 924 PathFinder_Potentials:
74F4 01 FF 00    7 925 ld      bc, $00FF                   ; initialize attack mobility and board potential
74F7 FD 2E 3D    7 926 ld      iyl, 61                     ; number of cells to be checked (loop counter)
74FA             7 927 Potentials_Loop
74FA 7E          7 928 ld      a, (hl)                     ; get cell's two-distance pointed by HL
74FB FE 40       7 929 cp      $40                         ; is cell occupied or border?
74FD 30 14       7 930 jr      nc, Potentials_Next         ; yes, skip to next cell
74FF FE 04       7 931 cp      $04                         ; cell distance was not updated?
7501 38 18       7 932 jr      c, Potentials_Infinite      ; yes, set cell potential as infinite and skip
7503 1A          7 933 ld      a, (de)                     ; get cell's two-distance pointed by DE
7504 FE 04       7 934 cp      $04                         ; cell distance was not updated?
7506 38 13       7 935 jr      c, Potentials_Infinite      ; yes, set cell potential as infinite and skip
7508 86          7 936 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
7509 B9          7 937 cp      c                           ; is the new potential = board potential?
750A 28 05       7 938 jr      z, Potentials_Increment     ; yes, increment attack mobility
750C 30 04       7 939 jr      nc, Potentials_Update       ; if (new potential > board potential) update and skip
750E 4F          7 940 ld      c, a                        ; board potential = new potential
750F 06 00       7 941 ld      b, 0                        ; restart attack mobility
7511             7 942 Potentials_Increment
7511 04          7 943 inc     b                           ; increment attack mobility
7512             7 944 Potentials_Update
7512 77          7 945 ld      (hl), a                     ; save potential in the cell pointed by HL
7513             7 946 Potentials_Next
7513 1C          7 947 inc     e                           ; move to next cell of each board
7514 2C          7 948 inc     l
7515 FD 2D       7 949 dec     iyl                         ; decrement loop counter
7517 C2 FA 74    7 950 jp      nz, Potentials_Loop         ; repeat until end of boards
751A C9          7 951 ret
751B             7 952 Potentials_Infinite
751B 1F          7 953 rra                                 ; as carry flag is set, the 7th bit of A is set
751C 77          7 954 ld      (hl), a                     ; save potential as infinite in the cell pointed by HL
751D 1C          7 955 inc     e                           ; move to next cell of each board
751E 2C          7 956 inc     l
751F FD 2D       7 957 dec     iyl                         ; decrement loop counter
7521 C2 FA 74    7 958 jp      nz, Potentials_Loop         ; repeat until end of boards
7524 C9          7 959 ret
7525             7 961 ; ----------------------------------------------------------------------------------------------------------------------
7525             7 962 ; PathFinder_Candidates: search candidates based on score result and boards potentials
7525             7 963 ;
7525             7 964 ; Input:    A  = -1, 0 or heuristic result
7525             7 965 ;           IX = candidates area address
7525             7 966 ;
7525             7 967 ; Output:   IX = first candidate address
7525             7 968 ;
7525             7 969 ; Uses:     AI_PLAYER (speccy side)
7525             7 970 ;
7525             7 971 ; Destroys: A, A', BC, DE, HL
7525             7 972 ; ----------------------------------------------------------------------------------------------------------------------
7525             7 973 PathFinder_Candidates:
7525 DD 36 00 00 7 974 ld      (ix+0), 0                   ; set candidates endmarker
7529 B7          7 976 or      a                           ; is speccy the winner?
752A 28 3D       7 977 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
752C 3C          7 978 inc     a                           ; is speccy defeated?
752D 28 4E       7 979 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
752F             7 981 ; if score is not -1 nor 0, fill candidates from total potentials
752F 21 09 61    7 983 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7532 11 09 64    7 984 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
7535 CD F4 74    7 985 call    PathFinder_Potentials       ; process candidates from total potentials
7538 79          7 987 ld      a, c                        ; set board potential in A
7539 08          7 988 ex      af, af'                     ; save board potential
753A 50          7 989 ld      d, b                        ; store attack mobility
753B DD 5D       7 990 ld      e, ixl                      ; store candidates position
753D             7 992 ; insert the second best board potentials in candidates area
753D             7 993 Candidates_2ndBest
753D 2E 09       7 994 ld      l, 9                        ; HL points to board potentials address (1st position)
753F 0C          7 995 inc     c                           ; increment board potential
7540 79          7 996 ld      a, c                        ; A = second best potential
7541 FE 20       7 997 cp      $20                         ; is potential >= $20? (2nd best max potential)
7543 30 13       7 998 jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential
7545 06 3D       7 1000 ld      b, 61                       ; number of cells to be checked (loop counter)
7547             7 1001 Candidates_2ndBest_Loop
7547 BE          7 1002 cp      (hl)                        ; is current board potential = 2nd best board potential?
7548 C2 50 75    7 1003 jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
754B DD 2C       7 1004 inc     ixl                         ; yes, insert candidate
754D DD 75 00    7 1005 ld      (ix+0), l
7550             7 1006 Candidates_2ndBest_Next
7550 2C          7 1007 inc     l                           ; move HL to next board potential address
7551 10 F4       7 1008 djnz    Candidates_2ndBest_Loop     ; repeat for each cell
7553 DD 7D       7 1009 ld      a, ixl                      ; A = current candidates position
7555 BB          7 1010 cp      e                           ; new candidates inserted?
7556 28 E5       7 1011 jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted
7558             7 1013 Candidates_2ndBest_Exit
7558 42          7 1014 ld      b, d                        ; restore attack mobility
7559 08          7 1015 ex      af, af'                     ; restore board potential
755A             7 1017 ; insert the best board potentials in candidates area
755A             7 1018 Candidates_Best
755A 2E 08       7 1019 ld      l, 8                        ; HL points to board potential address (1st position -1)
755C             7 1020 Candidates_Best_Loop
755C 2C          7 1021 inc     l                           ; move HL to next board potential address
755D BE          7 1022 cp      (hl)                        ; is current board potential equal to best board potential?
755E C2 5C 75    7 1023 jp      nz, Candidates_Best_Loop    ; no, next potential
7561 DD 2C       7 1024 inc     ixl                         ; yes, insert candidate
7563 DD 75 00    7 1025 ld      (ix+0), l
7566 10 F4       7 1026 djnz    Candidates_Best_Loop        ; repeat for each cell
7568 C9          7 1027 ret
7569             7 1029 ; ----------------------------------------------------------------------------------------------------------------------
7569             7 1030 ; Fill candidates for winner color
7569             7 1031 ; ----------------------------------------------------------------------------------------------------------------------
7569             7 1032 Candidates_Winner
7569 3A 99 61    7 1033 ld      a, (AI_PLAYER)              ; check speccy side
756C B7          7 1034 or      a                           ; is it FRIEND?
756D E2 8A 75    7 1035 jp      po, Candidates_Winner_Cyan  ; yes, fill candidates from cyan potentials
7570 21 09 64    7 1037 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
7573 11 51 64    7 1038 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7576 CD F4 74    7 1039 call    PathFinder_Potentials       ; calculate red potentials
7579 79          7 1040 ld      a, c                        ; set board potential in A
757A C3 5A 75    7 1041 jp      Candidates_Best             ; fill only the best candidates
757D             7 1043 ; ----------------------------------------------------------------------------------------------------------------------
757D             7 1044 ; Fill candidates for defeated color
757D             7 1045 ; ----------------------------------------------------------------------------------------------------------------------
757D             7 1046 Candidates_Defeat
757D 3A 99 61    7 1047 ld      a, (AI_PLAYER)              ; check speccy side
7580 B7          7 1048 or      a                           ; is it FRIEND?
7581 E2 97 75    7 1049 jp      po, Candidates_Defeat_Red   ; yes, fill candidates from red potentials
7584             7 1051 ; if RED is defeated, candidates are chosen from cyan board potentials
7584 CD 4D 71    7 1053 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
7587 CD 88 71    7 1054 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
758A             7 1055 Candidates_Winner_Cyan
758A 21 09 61    7 1056 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
758D 11 51 61    7 1057 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7590 CD F4 74    7 1058 call    PathFinder_Potentials       ; calculate cyan potentials
7593 79          7 1059 ld      a, c                        ; set board potential in A
7594 C3 5A 75    7 1060 jp      Candidates_Best             ; fill only the best candidates
7597             7 1062 ; if CYAN is defeated, candidates are chosen from red board potentials
7597             7 1063 Candidates_Defeat_Red
7597 CD C0 71    7 1064 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
759A CD 01 72    7 1065 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
759D 21 09 64    7 1066 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
75A0 11 51 64    7 1067 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
75A3 CD F4 74    7 1068 call    PathFinder_Potentials       ; calculate red potentials
75A6 79          7 1069 ld      a, c                        ; set board potential in A
75A7 C3 5A 75    7 1070 jp      Candidates_Best             ; fill only the best candidates
75AA             7 1072 ; ----------------------------------------------------------------------------------------------------------------------
75AA             7 1073 ; PathFinder_VictoryPath: calculate current player victory path
75AA             7 1074 ;
75AA             7 1075 ; Input:    -
75AA             7 1076 ;
75AA             7 1077 ; Output:   A   = -1, if there isn't a victory path
75AA             7 1078 ;           A   = start position (-1) of the victory path, otherwise
75AA             7 1079 ;           HL  = cyan or red queue head address
75AA             7 1080 ;
75AA             7 1081 ; Uses:     TOKEN_COLOR (current token color)
75AA             7 1082 ;
75AA             7 1083 ; Destroys: BC, DE, HL, IY
75AA             7 1084 ; ----------------------------------------------------------------------------------------------------------------------
75AA             7 1085 PathFinder_VictoryPath:
75AA 3A 9E 61    7 1086 ld      a, (TOKEN_COLOR)            ; get current token color
75AD FE 05       7 1087 cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
75AF 28 0C       7 1088 jr      z, PathFinder_VictoryPath_Cyan
75B1 CD C0 71    7 1090 call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
75B4 21 45 64    7 1091 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75B7 CD C9 75    7 1092 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75BA C3 C9 71    7 1093 jp      PathFinder_Red_CheckPath    ; calculate RED victory path
75BD             7 1095 PathFinder_VictoryPath_Cyan
75BD CD 4D 71    7 1096 call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
75C0 21 45 61    7 1097 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75C3 CD C9 75    7 1098 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75C6 C3 56 71    7 1099 jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path
75C9             7 1101 ; ----------------------------------------------------------------------------------------------------------------------
75C9             7 1102 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to 1, everything else to ENEMY.
75C9             7 1103 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
75C9             7 1104 ; [color]' again to find a victory path.
75C9             7 1105 ;
75C9             7 1106 ; Coded by Einar Saukas
75C9             7 1107 ;
75C9             7 1108 ; Input:    HL = pointer to last position of [color]_BOARD
75C9             7 1109 ;
75C9             7 1110 ; Output:   -
75C9             7 1111 ;
75C9             7 1112 ; Destroys: A, BC, HL
75C9             7 1113 ; ----------------------------------------------------------------------------------------------------------------------
75C9             7 1114 PathFinder_PrepareBoard:
75C9 3E 43       7 1115 ld      a, VICTORY+$40              ; set victory distance + friendly flag
75CB 0E 07       7 1116 ld      c, 7                        ; 7 rows
75CD             7 1117 PrepareBoard_Row
75CD 06 07       7 1118 ld      b, 7                        ; 7 columns
75CF             7 1119 PrepareBoard_Column
75CF BE          7 1120 cp      (hl)                        ; check win condition
75D0 36 01       7 1121 ld      (hl), 1                     ; save 1 by default
75D2 28 02       7 1122 jr      z, PrepareBoard_Next        ; if win condition, skip to position
75D4 36 7E       7 1123 ld      (hl), ENEMY                 ; else, save ENEMY
75D6             7 1124 PrepareBoard_Next
75D6 2D          7 1125 dec     l                           ; HL points to next board position
75D7 10 F6       7 1126 djnz    PrepareBoard_Column         ; repeat for each column
75D9 2D          7 1128 dec     l                           ; skip borders
75DA 2D          7 1129 dec     l
75DB 0D          7 1130 dec     c                           ; decrement rows
75DC C2 CD 75    7 1131 jp      nz, PrepareBoard_Row        ; repeat for each row
75DF C9          7 1132 ret
75E0             7 1134 ; ----------------------------------------------------------------------------------------------------------------------
75E0             7 1135 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75E0             7 1136 ;
75E0             7 1137 ; Input:    A  = start position of the victory path
75E0             7 1138 ;           HL = cyan or red queue head address
75E0             7 1139 ;
75E0             7 1140 ; Output:   -
75E0             7 1141 ;
75E0             7 1142 ; Uses:     TOKEN_COLOR (current token color)
75E0             7 1143 ;
75E0             7 1144 ; Destroys: A, BC, DE, HL, IX
75E0             7 1145 ; ----------------------------------------------------------------------------------------------------------------------
75E0             7 1146 PathFinder_BrightPath:
75E0 6F          7 1147 ld      l, a                        ; move HL to the start position of the victory path
75E1 24          7 1148 inc     h
75E2 4E          7 1149 ld      c, (hl)                     ; set current victory path length in C
75E3 06 03       7 1150 ld      b, VICTORY                  ; set victory length in B
75E5 3A 9E 61    7 1152 ld      a, (TOKEN_COLOR)            ; get current token color
75E8 C6 40       7 1153 add     a, $40                      ; switch on bright attribute
75EA 32 9E 61    7 1154 ld      (TOKEN_COLOR), a
75ED 3E 04       7 1155 ld      a, 4                        ; set delay duration for animate hexagons
75EF 32 D1 6D    7 1156 ld      (@Token_Delay+1), a
75F2 C3 11 76    7 1158 jp      BrightPath_Position         ; animate and highlight the hexagon position
75F5             7 1159 BrightPath_Neighbor
75F5 2C          7 1160 inc     l                           ; move HL to left neighbor address
75F6 BE          7 1161 cp      (hl)                        ; is it the same as current victory path length?
75F7 28 18       7 1162 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F9 2D          7 1163 dec     l                           ; move HL to right neighbor address
75FA 2D          7 1164 dec     l
75FB BE          7 1165 cp      (hl)                        ; is it the same as current victory path length?
75FC 28 13       7 1166 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75FE 11 F8 FF    7 1167 ld      de, -WIDTH                  ; move HL to upper-right neighbor address
7601 19          7 1168 add     hl, de
7602 BE          7 1169 cp      (hl)                        ; is it the same as current victory path length?
7603 28 0C       7 1170 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7605 2C          7 1171 inc     l                           ; move HL to upper-left neighbor address
7606 BE          7 1172 cp      (hl)                        ; is it the same as current victory path length?
7607 28 08       7 1173 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7609 11 10 00    7 1174 ld      de, WIDTH*2                 ; move HL to lower-right neighbor address
760C 19          7 1175 add     hl, de
760D BE          7 1176 cp      (hl)                        ; is it the same as current victory path length?
760E 28 01       7 1177 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7610 2C          7 1178 inc     l                           ; move HL to lower-left neighbor address
7611             7 1179 BrightPath_Position
7611 C5          7 1180 push    bc                          ; store current victory path length
7612 E5          7 1181 push    hl                          ; store current position pointer
7613 CD 80 6D    7 1182 call    Main_Board2Indexes          ; convert a board position into a board indexes
7616 CD BD 6D    7 1183 call    Draw_Token                  ; animate hexagon sprite on the screen
7619 DD 21 E7 64 7 1184 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
761D CD D8 76    7 1185 call    Sound_FX                    ; play sound effect
7620 E1          7 1186 pop     hl                          ; restore current position pointer
7621 C1          7 1187 pop     bc                          ; restore current victory path length
7622 0D          7 1188 dec     c                           ; decrement current victory path length
7623 79          7 1189 ld      a, c                        ; set current victory path length in A
7624 B8          7 1190 cp      b                           ; has reached victory length?
7625 C2 F5 75    7 1191 jp      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach victory length
7628 21 9E 61    7 1193 ld      hl, TOKEN_COLOR             ; get current token color address
762B CB B6       7 1194 res     6, (hl)                     ; switch off bright attribute
762D C9          7 1195 ret

; File #8: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Timer.z80asm

762E             8 1 ; ----------------------------------------------------------------------------------------------------------------------
762E             8 2 ; Timer.z80asm
762E             8 3 ; Coded by Antonio Luque
762E             8 4 ;
762E             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
762E             8 6 ; ----------------------------------------------------------------------------------------------------------------------
762E             8 8 ; ----------------------------------------------------------------------------------------------------------------------
762E             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
762E             8 10 ;
762E             8 11 ; Input:    -
762E             8 12 ;
762E             8 13 ; Output:   -
762E             8 14 ;
762E             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
762E             8 16 ;
762E             8 17 ; Destroys: BC', DE', HL'
762E             8 18 ; ----------------------------------------------------------------------------------------------------------------------
762E             8 19 Timer_Interrupt:
762E F5          8 20 push    af                          ; store AF register
762F D9          8 21 exx                                 ; store BC, DE and HL registers
7630 3A E8 62    8 23 ld      a, (TIMER_FLAG)             ; check timer flag
7633 B7          8 24 or      a                           ; is timer stopped?
7634 CA 5D 76    8 25 jp      z, Timer_Exit               ; yes, exit routine
7637 21 EC 62    8 27 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
763A 3D          8 28 dec     a                           ; is red timer on?
763B C2 41 76    8 29 jp      nz, Timer_Counters          ; yes, check interrupt counter 
763E 21 E9 62    8 30 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
7641             8 31 Timer_Counters
7641 35          8 32 dec     (hl)                        ; decrement interrupt counter
7642 C2 5D 76    8 33 jp      nz, Timer_Exit              ; if not 0, exit routine
7645 36 32       8 35 ld      (hl), 50                    ; restart interrupt counter
7647 23          8 36 inc     hl                          ; move HL to seconds counter address
7648 3E 01       8 37 ld      a, 1                        ; increment seconds counter
764A 86          8 38 add     a, (hl)
764B 27          8 39 daa                                 ; convert to BCD (Binary-Coded-Decimal)
764C 77          8 40 ld      (hl), a                     ; store seconds
764D FE 60       8 41 cp      $60                         ; 60 seconds reached?
764F C2 5A 76    8 42 jp      nz, Timer_Show              ; no, show timer
7652 36 00       8 43 ld      (hl), 0                     ; restart seconds counter
7654 23          8 44 inc     hl                          ; move HL to minutes counter address
7655 3E 01       8 45 ld      a, 1                        ; increment minutes counter
7657 86          8 46 add     a, (hl)
7658 27          8 47 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7659 77          8 48 ld      (hl), a                     ; store minutes
765A             8 49 Timer_Show
765A CD 61 76    8 50 call    Timer_Display               ; display timer on the screen
765D             8 51 Timer_Exit
765D D9          8 52 exx                                 ; restore BC, DE and HL registers
765E F1          8 53 pop     af                          ; restore AF register
765F FB          8 55 ei                                  ; enable interrupts
7660 C9          8 56 ret
7661             8 58 ; ----------------------------------------------------------------------------------------------------------------------
7661             8 59 ; Timer_Display: display a timer on the screen
7661             8 60 ;
7661             8 61 ; Input:    -
7661             8 62 ;
7661             8 63 ; Output:   -
7661             8 64 ;
7661             8 65 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7661             8 66 ;
7661             8 67 ; Destroys: A, BC, DE, HL
7661             8 68 ; ----------------------------------------------------------------------------------------------------------------------
7661             8 69 Timer_Display:
7661 01 EE 62    8 70 ld      bc, RED_TIMER+2             ; BC points to red's minutes counter address
7664 11 E2 48    8 71 ld      de, $48E2                   ; DE points to red's minutes screen address
7667 3A E8 62    8 72 ld      a, (TIMER_FLAG)             ; check timer flag
766A 3D          8 73 dec     a                           ; is cyan timer on?
766B C2 74 76    8 74 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
766E 01 EB 62    8 75 ld      bc, CYAN_TIMER+2            ; BC points to cyan's minutes counter address
7671 11 78 40    8 76 ld      de, $4078                   ; DE points to cyan's minutes screen address
7674             8 77 Timer_Display_Min
7674 CD 79 76    8 78 call    Timer_Display_MinSec        ; display minutes counter on screen
7677 0B          8 79 dec     bc                          ; BC points to seconds counter address
7678 1C          8 80 inc     e                           ; DE points to seconds screen address
7679             8 81 Timer_Display_MinSec:
7679 0A          8 82 ld      a, (bc)                     ; set min/sec counter in A
767A 1F          8 83 rra                                 ; move tens digit to the first 4th bits of A
767B 1F          8 84 rra
767C 1F          8 85 rra
767D 1F          8 86 rra
767E CD 82 76    8 87 call    Timer_Display_Digit         ; display tens digit on screen
7681 0A          8 88 ld      a, (bc)                     ; set min/sec counter in A 
7682             8 89 Timer_Display_Digit:
7682 E6 0F       8 90 and     %00001111                   ; discard the last 4th bits of the digit
7684 D5          8 91 push    de                          ; store digit screen address
7685 21 97 64    8 93 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
7688 87          8 94 add     a, a                        ; a digit is 8 bytes long
7689 87          8 95 add     a, a
768A 87          8 96 add     a, a
768B 85          8 97 add     a, l                        ; set digit index in HL
768C 6F          8 98 ld      l, a
768D 7E          8 100 ld      a, (hl)                     ; get digit tile
768E 12          8 101 ld      (de), a                     ; put it on screen address
768F 14          8 102 inc     d                           ; move DE to next pixel-line address
7690 2C          8 103 inc     l                           ; move HL to next digit tile address
7691 7E          8 104 ld      a, (hl)                     ; (repeat 7 more times)
7692 12          8 105 ld      (de), a
7693 14          8 106 inc     d
7694 2C          8 107 inc     l
7695 7E          8 108 ld      a, (hl)
7696 12          8 109 ld      (de), a
7697 14          8 110 inc     d
7698 2C          8 111 inc     l
7699 7E          8 112 ld      a, (hl)
769A 12          8 113 ld      (de), a
769B 14          8 114 inc     d
769C 2C          8 115 inc     l
769D 7E          8 116 ld      a, (hl)
769E 12          8 117 ld      (de), a
769F 14          8 118 inc     d
76A0 2C          8 119 inc     l
76A1 7E          8 120 ld      a, (hl)
76A2 12          8 121 ld      (de), a
76A3 14          8 122 inc     d
76A4 2C          8 123 inc     l
76A5 7E          8 124 ld      a, (hl)
76A6 12          8 125 ld      (de), a
76A7 14          8 126 inc     d
76A8 2C          8 127 inc     l
76A9 7E          8 128 ld      a, (hl)
76AA 12          8 129 ld      (de), a
76AB D1          8 131 pop     de                          ; restore digit screen address
76AC 1C          8 132 inc     e                           ; move screen address to next column
76AD C9          8 133 ret
76AE             8 135 ; ----------------------------------------------------------------------------------------------------------------------
76AE             8 136 ; Timer_Display_All: display cyan and red timers
76AE             8 137 ;
76AE             8 138 ; Input:    -
76AE             8 139 ;
76AE             8 140 ; Output:   -
76AE             8 141 ;
76AE             8 142 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
76AE             8 143 ;
76AE             8 144 ; Destroys: BC, DE, HL
76AE             8 145 ; ----------------------------------------------------------------------------------------------------------------------
76AE             8 146 Timer_Display_All:
76AE 3E 01       8 147 ld      a, 1                        ; set cyan timer on
76B0 32 E8 62    8 148 ld      (TIMER_FLAG), a
76B3 CD 61 76    8 149 call    Timer_Display               ; display cyan timer
76B6 3E 02       8 151 ld      a, 2                        ; set red timer on
76B8 32 E8 62    8 152 ld      (TIMER_FLAG), a
76BB CD 61 76    8 153 call    Timer_Display               ; display red timer
76BE AF          8 155 xor     a                           ; stop timers
76BF 32 E8 62    8 156 ld      (TIMER_FLAG), a
76C2 C9          8 157 ret
76C3             8 159 ; ----------------------------------------------------------------------------------------------------------------------
76C3             8 160 ; Timer_Reset: initialize cyan and red timers
76C3             8 161 ;
76C3             8 162 ; Input:    -
76C3             8 163 ;
76C3             8 164 ; Output:   -
76C3             8 165 ;
76C3             8 166 ; Destroys: HL
76C3             8 167 ; ----------------------------------------------------------------------------------------------------------------------
76C3             8 168 Timer_Reset:
76C3 21 E9 62    8 169 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76C6 36 32       8 171 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76C8 23          8 172 inc     hl                          ; move HL to cyan's seconds counter address
76C9 36 00       8 173 ld      (hl), 0                     ; reset seconds counter
76CB 23          8 174 inc     hl                          ; move HL to cyan's minutes counter address
76CC 36 00       8 175 ld      (hl), 0                     ; reset minutes counter
76CE 23          8 176 inc     hl                          ; move HL to red's interrupt counter
76CF 36 32       8 178 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76D1 23          8 179 inc     hl                          ; move HL to red's seconds counter address
76D2 36 00       8 180 ld      (hl), 0                     ; reset seconds counter
76D4 23          8 181 inc     hl                          ; move HL to red's minutes counter address
76D5 36 00       8 182 ld      (hl), 0                     ; reset minutes counter
76D7 C9          8 183 ret

; File #9: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Sound.z80asm

76D8             9 1 ; ----------------------------------------------------------------------------------------------------------------------
76D8             9 2 ; Sound.z80asm
76D8             9 3 ; Coded with BeepFX player tool by Shiru: https://shiru.untergrund.net/software.shtml
76D8             9 4 ;
76D8             9 5 ; Adapted for Hex game by Antonio Luque
76D8             9 6 ; ----------------------------------------------------------------------------------------------------------------------
76D8             9 8 ; ----------------------------------------------------------------------------------------------------------------------
76D8             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
76D8             9 10 ; 
76D8             9 11 ; Input:    IX = tone parameters address
76D8             9 12 ;
76D8             9 13 ; Output:   -
76D8             9 14 ;
76D8             9 15 ; Destroys: A, BC, DE, HL, IY
76D8             9 16 ; ----------------------------------------------------------------------------------------------------------------------
76D8             9 17 Sound_FX:
76D8 F3          9 18 di                                  ; disable interrupts
76D9 DD 4E 00    9 20 ld      c, (ix+0)                   ; BC = frames
76DC DD 46 01    9 21 ld      b, (ix+1)
76DF DD 5E 02    9 22 ld      e, (ix+2)                   ; DE = frame length
76E2 DD 56 03    9 23 ld      d, (ix+3)
76E5 D5          9 24 push    de                          ; store frame length in IY
76E6 FD E1       9 25 pop     iy
76E8 DD 5E 04    9 26 ld      e, (ix+4)                   ; DE = pitch
76EB DD 56 05    9 27 ld      d, (ix+5)
76EE 21 00 00    9 28 ld      hl, 0                       ; reset HL
76F1             9 30 Sound_FX_Frames
76F1 C5          9 31 push    bc                          ; store frames
76F2 FD E5       9 32 push    iy                          ; restore frame length in BC
76F4 C1          9 33 pop     bc
76F5             9 34 Sound_FX_FrameLength
76F5 19          9 35 add     hl, de                      ; HL = incremented pitch
76F6 7C          9 36 ld      a, h                        ; compares with fixed duty cycle ($80 for 50% square wave)
76F7 FE 80       9 37 cp      $80                         ; if (incremented pitch < duty cycle)
76F9 9F          9 38 sbc     a, a                        ;    { A = %11111111 } else { A = %00000000 }
76FA E6 10       9 39 and     %00010000                   ; toggling bit 4 controls the internal speaker
76FC F6 00       9 40 or      0                           ; keep border unchanged, dummy (7t)
76FE D3 FE       9 41 out     ($FE), a                    ; send bit to internal speaker
7700 3A 00 00    9 42 ld      a, (0)                      ; dummy (13t)
7703 0B          9 43 dec     bc                          ; decrement frame length
7704 78          9 44 ld      a, b                        ; check frame length
7705 B1          9 45 or      c                           ; frame length = 0?
7706 C2 F5 76    9 46 jp      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times (loop = 88t)
7709 DD 4E 06    9 48 ld      c, (ix+6)                   ; BC = pitch slide
770C DD 46 07    9 49 ld      b, (ix+7)
770F EB          9 50 ex      de, hl                      ; HL = current pitch
7710 09          9 51 add     hl, bc                      ; increment pitch with pitch slide
7711 EB          9 52 ex      de, hl                      ; DE = new pitch
7712 C1          9 54 pop     bc                          ; restore frames
7713 0B          9 55 dec     bc                          ; decrement frames
7714 78          9 56 ld      a, b                        ; check frames
7715 B1          9 57 or      c                           ; frames = 0?
7716 20 D9       9 58 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
7718 FB          9 60 ei                                  ; enable interrupts
7719 C9          9 61 ret

; File #10: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Screen.z80asm

771A             10 1 ; ----------------------------------------------------------------------------------------------------------------------
771A             10 2 ; Screen.z80asm
771A             10 3 ; Coded by Antonio Luque
771A             10 4 ; ----------------------------------------------------------------------------------------------------------------------
771A             10 6 BLUE_INK                EQU     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
771A             10 7 BLUE_PAPER              EQU     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
771A             10 8 WHITE_PAPER             EQU     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
771A             10 9 WHITE                   EQU     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
771A             10 10 BRIGHT                  EQU     %01000000                   ; mask to apply bright to attributes
771A             10 11 FLASH                   EQU     %10000000                   ; mask to apply flash to attributes
771A             10 12 WHITE_FLASH0            EQU     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
771A             10 13 WHITE_FLASH1            EQU     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
771A             10 15 ; ----------------------------------------------------------------------------------------------------------------------
771A             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
771A             10 17 ;
771A             10 18 ; Input:    -
771A             10 19 ;
771A             10 20 ; Output:   -
771A             10 21 ;
771A             10 22 ; Destroys: BC, DE, HL
771A             10 23 ; ----------------------------------------------------------------------------------------------------------------------
771A             10 24 Screen_Clear:
771A 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
771D 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
7720 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
7721 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
7724 ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
7726 C9          10 30 ret
7727             10 32 ; ----------------------------------------------------------------------------------------------------------------------
7727             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
7727             10 34 ;
7727             10 35 ; Input:    -
7727             10 36 ;
7727             10 37 ; Output:   -
7727             10 38 ;
7727             10 39 ; Destroys: A, BC, DE, HL, IX
7727             10 40 ; ----------------------------------------------------------------------------------------------------------------------
7727             10 41 Screen_Letters:
7727 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
772A DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
772E CD 38 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
7731 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
7734 DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
7738             10 47 Screen_Letters_Row:
7738 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
773B 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
773D             10 50 Screen_Letter_Loop
773D E5          10 51 push    hl                          ; store letter screen address
773E CD F5 6D    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
7741 E1          10 53 pop     hl                          ; restore letter screen address
7742 2C          10 54 inc     l                           ; move HL to next screen address
7743 2C          10 55 inc     l
7744 DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
7748 DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
774C DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
774E DD 2C       10 59 inc     ixl
7750 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
7752 C9          10 61 ret
7753             10 63 ; ----------------------------------------------------------------------------------------------------------------------
7753             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
7753             10 65 ;
7753             10 66 ; Input:    -
7753             10 67 ;
7753             10 68 ; Output:   -
7753             10 69 ;
7753             10 70 ; Destroys: A, BC, DE, HL, IX, IY
7753             10 71 ; ----------------------------------------------------------------------------------------------------------------------
7753             10 72 Screen_Numbers:
7753 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
7756 FD 21 EF 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
775A DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
775E 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
7760             10 77 Screen_Number_Loop
7760 FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
7763 FD 66 01    10 79 ld      h, (iy+1)
7766 E5          10 80 push    hl                          ; store pointer to number screen address
7767 D5          10 81 push    de                          ; store pointer to sprite address
7768 CD F5 6D    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
776B D1          10 83 pop     de                          ; restore pointer to sprite address
776C E1          10 84 pop     hl                          ; restore pointer to number screen address
776D DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7771 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
7775 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
7776 C6 0F       10 88 add     a, 15
7778 6F          10 89 ld      l, a
7779 CD F5 6D    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
777C DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
7780 DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
7784 78          10 93 ld      a, b                        ; save loop counter
7785 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
7788 DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
778A FD 23       10 96 inc     iy                          ; move IY to next number screen address
778C FD 23       10 97 inc     iy
778E 47          10 98 ld      b, a                        ; restore loop counter
778F 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
7791 C9          10 100 ret
7792             10 102 ; ----------------------------------------------------------------------------------------------------------------------
7792             10 103 ; Screen_Frame: draw the screen frame on the screen
7792             10 104 ;
7792             10 105 ; Input:    -
7792             10 106 ;
7792             10 107 ; Output:   -
7792             10 108 ;
7792             10 109 ; Destroys: A, BC, DE, HL, IX
7792             10 110 ; ----------------------------------------------------------------------------------------------------------------------
7792             10 111 Screen_Frame:
7792 11 28 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
7795 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
7798 CD 5F 6F    10 114 call    Print_String                ; print "Level"
779B CD D7 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
779E 01 8D 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
77A1 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
77A4 CD AA 77    10 119 call    Screen_Frame_Border         ; draw up-border
77A7 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
77AA             10 121 Screen_Frame_Border:
77AA DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
77AD             10 123 Screen_Frame_Loop
77AD 0A          10 124 ld      a, (bc)                     ; get tile index
77AE FE FF       10 125 cp      -1                          ; is it -1?
77B0 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
77B2 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
77B5 CD 6F 6F    10 128 call    Print_Tile                  ; print frame tile
77B8             10 129 Screen_Frame_Next
77B8 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77B9 03          10 131 inc     bc                          ; BC points to the next tile index
77BA DD 2D       10 132 dec     ixl                         ; decrement loop counter
77BC 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77BE DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77C2 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77C6 DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77CA DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77CE DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77D2 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77D6 C9          10 141 ret
77D7             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77D7             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77D7             10 145 ;
77D7             10 146 ; Input:    -
77D7             10 147 ;
77D7             10 148 ; Output:   -
77D7             10 149 ;
77D7             10 150 ; Destroys: A, BC, HL
77D7             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77D7             10 152 Screen_Vertical_Bars:
77D7 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
77DA CD E0 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
77DD 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
77E0             10 156 Screen_Vertical_Bar:
77E0 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
77E2             10 158 Screen_Vertical_Loop
77E2 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
77E4 CD 01 6E    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
77E7 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
77E9 C9          10 162 ret
77EA             10 164 ; ----------------------------------------------------------------------------------------------------------------------
77EA             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
77EA             10 166 ;
77EA             10 167 ; Input:    -
77EA             10 168 ;
77EA             10 169 ; Output:   -
77EA             10 170 ;
77EA             10 171 ; Uses:     TOKEN_COLOR (current token color)
77EA             10 172 ;
77EA             10 173 ; Destroys: A, BC, DE, HL, IX
77EA             10 174 ; ----------------------------------------------------------------------------------------------------------------------
77EA             10 175 Screen_Tokens:
77EA 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
77EC 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
77EF CD F7 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
77F2 3E 02       10 180 ld      a, RED_COLOR                ; set token color
77F4 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
77F7             10 182 Screen_Tokens_Draw:
77F7 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77FA CD 10 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
77FD DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
7800 DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
7803 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7806 C3 E2 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
7809             10 190 ; ----------------------------------------------------------------------------------------------------------------------
7809             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
7809             10 192 ;
7809             10 193 ; Input:    -
7809             10 194 ;
7809             10 195 ; Output:   -
7809             10 196 ;
7809             10 197 ; Destroys: IX
7809             10 198 ; ----------------------------------------------------------------------------------------------------------------------
7809             10 199 Screen_Timer_Quotes:
7809 DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
780D DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7811 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7815 DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
7817 DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
781B DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
781F DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
7822 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
7826 DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
782A DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
782E DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7832 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7836 DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
7838 DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
783C DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7840 DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
7843 DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
7847 DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
784B C9          10 219 ret
784C             10 221 ; ----------------------------------------------------------------------------------------------------------------------
784C             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
784C             10 223 ;
784C             10 224 ; Input:    -
784C             10 225 ;
784C             10 226 ; Output:   -
784C             10 227 ;
784C             10 228 ; Destroys: BC, IX
784C             10 229 ; ----------------------------------------------------------------------------------------------------------------------
784C             10 230 Screen_Color_Statics:
784C DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
7850 0E 07       10 232 ld      c, WHITE                    ; set color in C
7852 CD 7C 78    10 233 call    Screen_Apply_Color          ; apply color
7855 DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
7858 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
785A CD 7C 78    10 236 call    Screen_Apply_Color          ; apply color
785D DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7861 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
7863 CD 7C 78    10 239 call    Screen_Apply_Color          ; apply color
7866 DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
7869 0E 07       10 241 ld      c, WHITE                    ; set color in C
786B CD 7C 78    10 242 call    Screen_Apply_Color          ; apply color
786E DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7872 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
7874 CD 7C 78    10 245 call    Screen_Apply_Color          ; apply color
7877 DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
787A 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
787C             10 248 Screen_Apply_Color:
787C 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
787E             10 250 Screen_Apply_Color_Loop:
787E DD 71 00    10 251 ld      (ix+0), c                   ; apply color
7881 DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
7883 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
7885 C9          10 254 ret
7886             10 256 ; ----------------------------------------------------------------------------------------------------------------------
7886             10 257 ; Screen_Last_Level: show last level screen and input game level
7886             10 258 ;
7886             10 259 ; Input:    -
7886             10 260 ;
7886             10 261 ; Output:   -
7886             10 262 ;
7886             10 263 ; Uses:     GAME_LEVEL (current game level)
7886             10 264 ;
7886             10 265 ; Destroys: A, BC, DE, HL, IX, IY
7886             10 266 ; ----------------------------------------------------------------------------------------------------------------------
7886             10 267 Screen_Last_Level:
7886 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
7889 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
788C CD 5F 6F    10 270 call    Print_String                ; print "Press any key"
788F DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
7893 01 38 0D    10 272 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7896 CD 7E 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
7899 CD C6 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
789C CD 1A 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
789F CD 5F 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
78A2 DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
78A6 01 C7 11    10 279 ld      bc, 17*256+WHITE_FLASH1     ; B = string length (loop counter), C = color attributes
78A9 CD 7E 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
78AC 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
78AF 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
78B2 CD 5F 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
78B5 DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78B9 CD D8 76    10 285 call    Sound_FX                    ; play sound fx
78BC F3          10 287 di                                  ; disable interrupts
78BD DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78C1 01 07 1C    10 289 ld      bc, 28*256+WHITE            ; B = string length (loop counter), C = color attributes
78C4 CD 7E 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78C7 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78CA 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78CD CD 5F 6F    10 293 call    Print_String                ; print "Well done!..."
78D0 DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78D3 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78D5 CD 7E 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78D8 DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
78DC DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
78E0 DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
78E4 13          10 300 inc     de                          ; move DE to next string address
78E5 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
78E7 CD 5F 6F    10 302 call    Print_String                ; print "Choose..."
78EA             10 303 Screen_Choose_Level
78EA CD C6 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
78ED FE 31       10 305 cp      '1'                         ; is it < '1' ?
78EF 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
78F1 FE 35       10 307 cp      '5'                         ; is it >= '5' ?
78F3 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
78F5 D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
78F7 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
78FA 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
78FB C9          10 312 ret
78FC             10 314 ; ----------------------------------------------------------------------------------------------------------------------
78FC             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
78FC             10 316 ;
78FC             10 317 ; Input:    HL = three-in-a-row counter address
78FC             10 318 ;
78FC             10 319 ; Output:   -
78FC             10 320 ;
78FC             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
78FC             10 322 ;
78FC             10 323 ; Destroys: A, C, IX
78FC             10 324 ; ----------------------------------------------------------------------------------------------------------------------
78FC             10 325 Screen_ThreeRow:
78FC CD 18 79    10 326 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
78FF 7E          10 327 ld      a, (hl)                     ; A = three-in-a-row counter
7900 B7          10 328 or      a                           ; is it 0?
7901 C8          10 329 ret     z                           ; yes, return
7902 E5          10 331 push    hl                          ; store three-in-a-row counter address
7903 21 9C 61    10 333 ld      hl, LEVEL_COLOR             ; HL points to level color address
7906 4E          10 334 ld      c, (hl)                     ; save level color in C
7907 3D          10 335 dec     a                           ; is it 1?
7908 28 09       10 336 jr      z, Screen_ThreeRow_1        ; yes, color first mark
790A 3D          10 337 dec     a                           ; is it 2?
790B 28 03       10 338 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
790D DD 71 00    10 339 ld      (ix+0), c                   ; color 3rd mark
7910             10 340 Screen_ThreeRow_2
7910 DD 71 01    10 341 ld      (ix+1), c                   ; color 2nd mark
7913             10 342 Screen_ThreeRow_1
7913 DD 71 02    10 343 ld      (ix+2), c                   ; color 1st mark
7916 E1          10 345 pop     hl
7917 C9          10 346 ret
7918             10 348 ; ----------------------------------------------------------------------------------------------------------------------
7918             10 349 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
7918             10 350 ;
7918             10 351 ; Input:    -
7918             10 352 ;
7918             10 353 ; Output:   IX = three-in-a-row marks attribute address
7918             10 354 ;
7918             10 355 ; Destroys: -
7918             10 356 ; ----------------------------------------------------------------------------------------------------------------------
7918             10 357 Screen_Clear_ThreeRow:
7918 DD 21 F2 5A 10 358 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
791C DD 36 00 01 10 359 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
7920 DD 36 01 01 10 360 ld      (ix+1), BLUE_INK
7924 DD 36 02 01 10 361 ld      (ix+2), BLUE_INK
7928 C9          10 362 ret
7929             10 364 ; ----------------------------------------------------------------------------------------------------------------------
7929             10 365 ; Screen_Frame_Color: set up frame color and print level number depending on current level
7929             10 366 ;
7929             10 367 ; Input:    HL = game level address
7929             10 368 ;
7929             10 369 ; Output:   -
7929             10 370 ;
7929             10 371 ; Uses:     LEVEL_COLOR (current level color for frame border)
7929             10 372 ;
7929             10 373 ; Destroys: A, BC, DE, HL
7929             10 374 ; ----------------------------------------------------------------------------------------------------------------------
7929             10 375 Screen_Frame_Color:
7929 06 00       10 376 ld      b, 0                        ; set game level in BC
792B 4E          10 377 ld      c, (hl)
792C 3E 30       10 378 ld      a, $30                      ; convert game level number to game level character
792E 81          10 379 add     a, c
792F 21 0F 40    10 380 ld      hl, $400F                   ; HL points to screen address of game level
7932 CD 6C 6F    10 381 call    Print_Char                  ; print game level
7935 21 0E 62    10 382 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
7938 09          10 383 add     hl, bc                      ; use BC as index for color map address
7939 7E          10 384 ld      a, (hl)                     ; A = level color
793A CD 4F 79    10 385 call    Screen_Tiles_Color          ; color the frame according to the current level
793D E6 07       10 386 and     %00000111                   ; mask color
793F 32 9C 61    10 387 ld      (LEVEL_COLOR), a            ; save masked color
7942 17          10 388 rla                                 ; rotate to text level color
7943 17          10 389 rla
7944 17          10 390 rla
7945 21 08 58    10 391 ld      hl, $5808                   ; HL points to attribute address of level text
7948 06 09       10 392 ld      b, 9                        ; length of level text (loop counter)
794A             10 393 Screen_Level_Loop
794A 77          10 394 ld      (hl), a                     ; apply color to level text
794B 2C          10 395 inc     l                           ; HL points to attr address of next character of level text
794C 10 FC       10 396 djnz    Screen_Level_Loop           ; repeat for each character of level text
794E C9          10 397 ret
794F             10 399 ; ----------------------------------------------------------------------------------------------------------------------
794F             10 400 ; Screen_Tiles_Color: apply color to the frame tiles
794F             10 401 ;
794F             10 402 ; Input:    A = color to apply
794F             10 403 ;
794F             10 404 ; Output:   -
794F             10 405 ;
794F             10 406 ; Destroys: BC, DE, HL
794F             10 407 ; ----------------------------------------------------------------------------------------------------------------------
794F             10 408 Screen_Tiles_Color:
794F             10 409 ; color up row
794F 21 01 58    10 411 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
7952 06 06       10 412 ld      b, 6                        ; number of tiles (loop counter)
7954             10 413 Screen_Tiles_URow1
7954 77          10 414 ld      (hl), a                     ; apply color
7955 2C          10 415 inc     l                           ; move HL to the next attribute address
7956 10 FC       10 416 djnz    Screen_Tiles_URow1          ; repeat for each tile
7958 2E 12       10 417 ld      l, $12                      ; move HL to the next attribute address
795A 06 0D       10 418 ld      b, 13                       ; number of tiles (loop counter)
795C             10 419 Screen_Tiles_URow2
795C 77          10 420 ld      (hl), a                     ; apply color
795D 2C          10 421 inc     l                           ; move HL to the next attribute address
795E 10 FC       10 422 djnz    Screen_Tiles_URow2          ; repeat for each tile
7960             10 424 ; color vertical bars
7960 2E 00       10 426 ld      l, 0                        ; move HL to the next attribute address
7962 11 1F 00    10 427 ld      de, 31                      ; attribute address displacement (for each bar)
7965 0E 03       10 428 ld      c, 3                        ; number of screen thirds (outer loop counter)
7967             10 429 Screen_Tiles_VBar1
7967 06 08       10 430 ld      b, 8                        ; number of tiles (inner loop counter)
7969             10 431 Screen_Tiles_VBar2
7969 77          10 432 ld      (hl), a                     ; apply color
796A 19          10 433 add     hl, de                      ; move HL to the right column
796B 77          10 434 ld      (hl), a                     ; apply color
796C 2C          10 435 inc     l                           ; move HL to the next attribute address
796D 10 FA       10 436 djnz    Screen_Tiles_VBar2          ; repeat for each tile
796F 24          10 437 inc     h                           ; move HL to the next screen third
7970 0D          10 438 dec     c                           ; decrement number of thirds
7971 20 F4       10 439 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
7973             10 441 ; color bottom row
7973 21 E1 5A    10 443 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
7976 06 10       10 444 ld      b, 16                       ; number of tiles (loop counter)
7978             10 445 Screen_Tiles_BRow1
7978 77          10 446 ld      (hl), a                     ; apply color
7979 2C          10 447 inc     l                           ; move HL to the next attribute address
797A 10 FC       10 448 djnz    Screen_Tiles_BRow1          ; repeat for each tile
797C 2E F6       10 449 ld      l, $F6                      ; move HL to the next attribute address
797E 06 09       10 450 ld      b, 9                        ; number of tiles (loop counter)
7980             10 451 Screen_Tiles_BRow2
7980 77          10 452 ld      (hl), a                     ; apply color
7981 2C          10 453 inc     l                           ; move HL to the next attribute address
7982 10 FC       10 454 djnz    Screen_Tiles_BRow2          ; repeat for each tile
7984 C9          10 455 ret
7985             10 457 ; ----------------------------------------------------------------------------------------------------------------------
7985             10 458 ; Screen_Menu: show main menu and wait for an option
7985             10 459 ;
7985             10 460 ; Input:    -
7985             10 461 ;
7985             10 462 ; Output:   -
7985             10 463 ;
7985             10 464 ; Uses:     GAME_LEVEL (current game level)
7985             10 465 ;
7985             10 466 ; Destroys: A, BC, DE, HL, IX, IY
7985             10 467 ; ----------------------------------------------------------------------------------------------------------------------
7985             10 468 Screen_Menu:
7985 CD 1A 77    10 469 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7988 CD 5F 7C    10 470 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
798B             10 471 Screen_Menu_Strings
798B 21 80 59    10 472 ld      hl, $5980                   ; HL points to menu text area attributes address
798E 11 81 59    10 473 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
7991 36 00       10 474 ld      (hl), 0                     ; set first attribute text area in black
7993 01 7F 01    10 475 ld      bc, 32*12-1                 ; length of text area attributes (-1 already set)
7996 ED B0       10 476 ldir                                ; set the rest of text area attributes in black
7998 DD 21 CA 59 10 478 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
799C DD 36 FF 78 10 479 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79A0 01 47 0D    10 480 ld      bc, 13*256+WHITE_FLASH0     ; B = string length-1 (loop counter), C = color attributes
79A3 CD 7E 78    10 481 call    Screen_Apply_Color_Loop     ; apply color to string area
79A6 11 80 67    10 482 ld      de, STR_OPTIONS             ; DE points to string address
79A9 21 C9 48    10 483 ld      hl, $48C9                   ; HL points to string screen address
79AC CD 5F 6F    10 484 call    Print_String                ; print "Start new game"
79AF DD 21 2A 5A 10 485 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
79B3 DD 36 FF 78 10 486 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79B7 06 0A       10 487 ld      b, 10                       ; string length-1 (loop counter)
79B9 CD 7E 78    10 488 call    Screen_Apply_Color_Loop     ; apply color to string area
79BC 13          10 489 inc     de                          ; move DE to "How to play" string address
79BD 21 29 50    10 490 ld      hl, $5029                   ; HL points to string screen address
79C0 CD 5F 6F    10 491 call    Print_String                ; print "How to play"
79C3 DD 2E 8A    10 492 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79C6 DD 36 FF 78 10 493 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79CA CD 7C 78    10 494 call    Screen_Apply_Color          ; apply color to string area
79CD 13          10 495 inc     de                          ; move DE to "Credits" string address
79CE 2E 89       10 496 ld      l, $89                      ; HL points to string screen address
79D0 CD 5F 6F    10 497 call    Print_String                ; print "Credits"
79D3             10 498 Screen_Menu_Options
79D3 CD C6 6E    10 499 call    Input_Key_Scan              ; wait for a key pressed
79D6 FE 73       10 500 cp      's'                         ; is it 's'?
79D8 C8          10 501 ret     z                           ; yes, return
79D9 FE 63       10 502 cp      'c'                         ; is it 'c'?
79DB CA EF 7B    10 503 jp      z, Screen_Menu_Credits      ; yes, show credits
79DE FE 68       10 504 cp      'h'                         ; is it 'h'?
79E0 20 F1       10 505 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
79E2             10 507 ; ----------------------------------------------------------------------------------------------------------------------
79E2             10 508 ; Show "How to play" pages
79E2             10 509 ; ----------------------------------------------------------------------------------------------------------------------
79E2             10 510 Screen_Menu_How2Play
79E2 CD 1A 77    10 511 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79E5 CD 27 77    10 512 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
79E8 CD 53 77    10 513 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
79EB CD 92 77    10 514 call    Screen_Frame                ; draw the screen frame
79EE 21 9D 61    10 516 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
79F1 34          10 517 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
79F2 CD 29 79    10 518 call    Screen_Frame_Color          ; set up frame color depending on current level
79F5 CD 18 79    10 519 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
79F8 11 4A 68    10 521 ld      de, STR_BUTTONS             ; DE points to "Next" string address
79FB 21 DB 50    10 522 ld      hl, $50DB                   ; HL points to string screen address
79FE CD 5F 6F    10 523 call    Print_String                ; print "Next"
7A01 13          10 524 inc     de                          ; move DE to "Back" string address
7A02 21 C1 50    10 525 ld      hl, $50C1                   ; HL points to string screen address
7A05 CD 5F 6F    10 526 call    Print_String                ; print "Back"
7A08             10 528 Screen_How2Play_RED
7A08 21 5E 58    10 529 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7A0B CD 99 7C    10 530 call    Screen_Clear_Text           ; clear text area attributes
7A0E CD A2 6D    10 531 call    Draw_Board                  ; draw an empty hexagons board
7A11             10 533 ; text for RED
7A11 DD 21 01 5A 10 535 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
7A15 01 07 07    10 536 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7A18 CD 7E 78    10 537 call    Screen_Apply_Color_Loop     ; apply color to string area
7A1B 11 5D 68    10 538 ld      de, STR_HELP1               ; DE points to string address
7A1E 21 01 50    10 539 ld      hl, $5001                   ; HL points to string screen address
7A21 CD 5F 6F    10 540 call    Print_String                ; print "Connect"
7A24 DD 2E 21    10 541 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A27 06 08       10 542 ld      b, 8                        ; string length (loop counter)
7A29 CD 7E 78    10 543 call    Screen_Apply_Color_Loop     ; apply color to string area
7A2C 13          10 544 inc     de                          ; move DE to "left and" string address
7A2D 2E 21       10 545 ld      l, $21                      ; HL points to string screen address
7A2F CD 5F 6F    10 546 call    Print_String                ; print "left and"
7A32 DD 2E 41    10 547 ld      ixl, $41                    ; IX points to "right" string attributes address
7A35 06 05       10 548 ld      b, 5                        ; set string length (loop counter)
7A37 CD 7E 78    10 549 call    Screen_Apply_Color_Loop     ; apply color to string area
7A3A 11 75 68    10 550 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A3D 2E 41       10 551 ld      l, $41                      ; HL points to string screen address
7A3F CD 5F 6F    10 552 call    Print_String                ; print "right"
7A42 DD 2E 61    10 553 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A45 06 07       10 554 ld      b, 7                        ; set string length (loop counter)
7A47 CD 7E 78    10 555 call    Screen_Apply_Color_Loop     ; apply color to string area
7A4A 11 80 68    10 556 ld      de, STR_HELP4               ; DE points to "borders" string address
7A4D 2E 61       10 557 ld      l, $61                      ; HL points to string screen address
7A4F CD 5F 6F    10 558 call    Print_String                ; print "borders"
7A52 DD 2E 81    10 559 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A55 CD 7C 78    10 560 call    Screen_Apply_Color          ; apply color to string area
7A58 13          10 561 inc     de                          ; move DE to "to win" string address
7A59 2E 81       10 562 ld      l, $81                      ; HL points to string screen address
7A5B CD 5F 6F    10 563 call    Print_String                ; print "to win"
7A5E DD 21 E3 59 10 564 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A62 01 42 03    10 565 ld      bc, 3*256+RED_COLOR+BRIGHT  ; B = string length (loop counter), C = color attributes
7A65 CD 7E 78    10 566 call    Screen_Apply_Color_Loop     ; apply color to string area
7A68 11 54 68    10 567 ld      de, STR_RED                 ; DE points to "RED" string address
7A6B 21 E3 48    10 568 ld      hl, $48E3                   ; HL points to string screen address
7A6E CD 5F 6F    10 569 call    Print_String                ; print "RED"
7A71             10 571 ; draw RED sample board
7A71 FD 21 3A 67 10 573 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A75 11 3E 66    10 574 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A78 06 07       10 575 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A7A 3E 42       10 576 ld      a, RED_COLOR+BRIGHT         ; set token color
7A7C 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7A7F CD 84 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7A82 06 02       10 579 ld      b, 2                        ; number of red tokens (loop counter)
7A84 3E 02       10 580 ld      a, RED_COLOR                ; set token color
7A86 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7A89 CD 84 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7A8C 06 09       10 583 ld      b, 9                        ; number of cyan tokens (loop counter)
7A8E 3E 05       10 584 ld      a, CYAN_COLOR               ; set token color
7A90 32 9E 61    10 585 ld      (TOKEN_COLOR), a            ; save token color
7A93 CD 84 7C    10 586 call    Screen_Hexagons_Loop        ; draw tokens
7A96             10 588 ; wait for "Next" option pressed
7A96 DD 21 C1 5A 10 590 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A9A 01 00 04    10 591 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7A9D CD 7E 78    10 592 call    Screen_Apply_Color_Loop     ; hide "Back" string
7AA0 DD 2E DC    10 593 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7AA3 DD 36 FF 78 10 594 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7AA7 01 47 03    10 595 ld      bc, 3*256+WHITE_FLASH0      ; B = string length-1 (loop counter), C = color attributes
7AAA CD 7E 78    10 596 call    Screen_Apply_Color_Loop     ; apply color to string area
7AAD             10 597 Screen_How2PlayRED_End
7AAD CD C6 6E    10 598 call    Input_Key_Scan              ; wait for a key pressed
7AB0 FE 6E       10 599 cp      'n'                         ; is it 'n'?
7AB2 20 F9       10 600 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7AB4             10 602 Screen_How2Play_CYAN
7AB4 21 0F 58    10 603 ld      hl, $580F                   ; HL points to level number attribute address
7AB7 CB BE       10 604 res     7, (hl)                     ; reset flash attribute
7AB9 26 40       10 605 ld      h, $40                      ; HL points to level number screen address
7ABB 3E 31       10 606 ld      a, '1'                      ; set level number (char)
7ABD CD 6C 6F    10 607 call    Print_Char                  ; print '1'
7AC0 CD 18 79    10 608 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7AC3 21 C9 59    10 610 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7AC6 CD 99 7C    10 611 call    Screen_Clear_Text           ; clear text area attributes
7AC9 CD A2 6D    10 612 call    Draw_Board                  ; draw an empty hexagons board
7ACC             10 614 ; text for CYAN
7ACC DD 21 98 58 10 616 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7AD0 01 07 07    10 617 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7AD3 CD 7E 78    10 618 call    Screen_Apply_Color_Loop     ; apply color to string area
7AD6 11 5D 68    10 619 ld      de, STR_HELP1               ; DE points to "Connect" string address
7AD9 21 98 40    10 620 ld      hl, $4098                   ; HL points to string screen address
7ADC CD 5F 6F    10 621 call    Print_String                ; print "Connect"
7ADF DD 2E B9    10 622 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7AE2 CD 7C 78    10 623 call    Screen_Apply_Color          ; apply color to string area
7AE5 11 6E 68    10 624 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7AE8 2E B9       10 625 ld      l, $B9                      ; HL points to string screen address
7AEA CD 5F 6F    10 626 call    Print_String                ; print "up and"
7AED DD 2E DB    10 627 ld      ixl, $DB                    ; IX points to "down" string attributes address
7AF0 06 04       10 628 ld      b, 4                        ; string length (loop counter)
7AF2 CD 7E 78    10 629 call    Screen_Apply_Color_Loop     ; apply color to string area
7AF5 11 7B 68    10 630 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7AF8 2E DB       10 631 ld      l, $DB                      ; HL points to string screen address
7AFA CD 5F 6F    10 632 call    Print_String                ; print "down"
7AFD DD 2E F8    10 633 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7B00 06 07       10 634 ld      b, 7                        ; string length (loop counter)
7B02 CD 7E 78    10 635 call    Screen_Apply_Color_Loop     ; apply color to string area
7B05 13          10 636 inc     de                          ; move DE to "borders" string address
7B06 2E F8       10 637 ld      l, $F8                      ; HL points to string screen address
7B08 CD 5F 6F    10 638 call    Print_String                ; print "borders"
7B0B DD 21 19 59 10 639 ld      ix, $5919                   ; IX points to "to win" string attributes address
7B0F CD 7C 78    10 640 call    Screen_Apply_Color          ; apply color to string area
7B12 13          10 641 inc     de                          ; move DE to "to win" string address
7B13 21 19 48    10 642 ld      hl, $4819                   ; HL points to string screen address
7B16 CD 5F 6F    10 643 call    Print_String                ; print "to win"
7B19 DD 21 7A 58 10 644 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B1D 01 45 04    10 645 ld      bc, $0445                   ; B = string length (loop counter)
7B20             10 646 ; C = color attributes (cyan+bright)
7B20 CD 7E 78    10 647 call    Screen_Apply_Color_Loop     ; apply color to string area
7B23 11 58 68    10 648 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B26 21 7A 40    10 649 ld      hl, $407A                   ; HL points to string screen address
7B29 CD 5F 6F    10 650 call    Print_String                ; print "CYAN"
7B2C             10 652 ; draw CYAN sample board
7B2C FD 21 5E 67 10 654 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B30 11 3E 66    10 655 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B33 06 07       10 656 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B35 3E 45       10 657 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B37 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B3A CD 84 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B3D 06 02       10 660 ld      b, 2                        ; number of cyan tokens (loop counter)
7B3F 3E 05       10 661 ld      a, CYAN_COLOR               ; set token color
7B41 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B44 CD 84 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B47 06 08       10 664 ld      b, 8                        ; number of red tokens (loop counter)
7B49 3E 02       10 665 ld      a, RED_COLOR                ; set token color
7B4B 32 9E 61    10 666 ld      (TOKEN_COLOR), a            ; save token color
7B4E CD 84 7C    10 667 call    Screen_Hexagons_Loop        ; draw tokens
7B51             10 669 ; wait for "Next" or "Back" options pressed
7B51 DD 21 C2 5A 10 671 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B55 DD 36 FF 78 10 672 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B59 01 47 03    10 673 ld      bc, 3*256+WHITE_FLASH0      ; B = string length (-1), C = color attributes
7B5C CD 7E 78    10 674 call    Screen_Apply_Color_Loop     ; apply color to string area
7B5F             10 675 Screen_How2PlayCYAN_End
7B5F CD C6 6E    10 676 call    Input_Key_Scan              ; wait for a key pressed
7B62 FE 62       10 677 cp      'b'                         ; is it 'b'?
7B64 CA 08 7A    10 678 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B67 FE 6E       10 679 cp      'n'                         ; is it 'n'?
7B69 20 F4       10 680 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B6B             10 682 Screen_How2Play_LevelUp
7B6B 21 5E 58    10 683 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B6E CD 99 7C    10 684 call    Screen_Clear_Text           ; clear text area attributes
7B71             10 686 ; text for Level Up
7B71 DD 21 21 5A 10 688 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B75 01 07 09    10 689 ld      bc, 9*256+WHITE             ; B = string length (loop counter), C = color attributes
7B78 CD 7E 78    10 690 call    Screen_Apply_Color_Loop     ; apply color to string area
7B7B 11 8F 68    10 691 ld      de, STR_HELP                ; DE points to "Win three" string address
7B7E 21 21 50    10 692 ld      hl, $5021                   ; HL points to string screen address
7B81 CD 5F 6F    10 693 call    Print_String                ; print "Win three"
7B84 DD 2E 41    10 694 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B87 06 08       10 695 ld      b, 8                        ; string length (loop counter)
7B89 CD 7E 78    10 696 call    Screen_Apply_Color_Loop     ; apply color to string area
7B8C 13          10 697 inc     de                          ; move DE to "times in" string address
7B8D 2E 41       10 698 ld      l, $41                      ; HL points to string screen address
7B8F CD 5F 6F    10 699 call    Print_String                ; print "times in"
7B92 DD 2E 61    10 700 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B95 06 08       10 701 ld      b, 8                        ; string length (loop counter)
7B97 CD 7E 78    10 702 call    Screen_Apply_Color_Loop     ; apply color to string area
7B9A 13          10 703 inc     de                          ; move DE to "a row to" string address
7B9B 2E 61       10 704 ld      l, $61                      ; HL points to string screen address
7B9D CD 5F 6F    10 705 call    Print_String                ; print "a row to"
7BA0 DD 2E 81    10 706 ld      ixl, $81                    ; IX points to "level up" string attributes address
7BA3 06 08       10 707 ld      b, 8                        ; string length (loop counter)
7BA5 CD 7E 78    10 708 call    Screen_Apply_Color_Loop     ; apply color to string area
7BA8 13          10 709 inc     de                          ; move DE to "level up" string address
7BA9 2E 81       10 710 ld      l, $81                      ; HL points to string screen address
7BAB CD 5F 6F    10 711 call    Print_String                ; print "level up"
7BAE             10 713 ; reset bright of cyan tokens
7BAE FD 21 5E 67 10 715 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7BB2 11 3E 66    10 716 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7BB5 06 07       10 717 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7BB7 3E 05       10 718 ld      a, CYAN_COLOR               ; set new token color
7BB9 32 9E 61    10 719 ld      (TOKEN_COLOR), a            ; save color
7BBC CD 84 7C    10 720 call    Screen_Hexagons_Loop        ; draw tokens
7BBF             10 722 ; set flash attribute of level number and three-in-a-row marks
7BBF 21 0F 58    10 724 ld      hl, $580F                   ; HL points to level number attribute address
7BC2 CB FE       10 725 set     7, (hl)                     ; set flash attribute
7BC4 21 0F 40    10 726 ld      hl, $400F                   ; HL points to level number screen address
7BC7 3E 32       10 727 ld      a, '2'                      ; set new level
7BC9 CD 6C 6F    10 728 call    Print_Char                  ; print new level
7BCC DD 21 F2 5A 10 729 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BD0 DD 36 00 B8 10 730 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BD4 DD 36 01 B8 10 731 ld      (ix+1), WHITE_PAPER+FLASH
7BD8 DD 36 02 B8 10 732 ld      (ix+2), WHITE_PAPER+FLASH
7BDC             10 734 ; wait for "Next" or "Back" options pressed
7BDC             10 736 Screen_How2Play_End
7BDC CD C6 6E    10 737 call    Input_Key_Scan              ; wait for a key pressed
7BDF FE 62       10 738 cp      'b'                         ; is it 'b'?
7BE1 CA B4 7A    10 739 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7BE4 FE 6E       10 740 cp      'n'                         ; is it 'n'?
7BE6 20 F4       10 741 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7BE8 21 9D 61    10 743 ld      hl, GAME_LEVEL              ; HL points to game level address
7BEB 35          10 744 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7BEC C3 85 79    10 745 jp      Screen_Menu                 ; return to main menu
7BEF             10 747 ; ----------------------------------------------------------------------------------------------------------------------
7BEF             10 748 ; Show credits
7BEF             10 749 ; ----------------------------------------------------------------------------------------------------------------------
7BEF             10 750 Screen_Menu_Credits
7BEF DD 21 84 59 10 751 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7BF3 01 47 19    10 752 ld      bc, 25*256+WHITE_FLASH0     ; B = string length (loop counter), C = color attributes
7BF6 CD 7E 78    10 753 call    Screen_Apply_Color_Loop     ; apply color to string area
7BF9 11 A3 67    10 754 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7BFC 21 84 48    10 755 ld      hl, $4884                   ; HL points to string screen address
7BFF CD 5F 6F    10 756 call    Print_String                ; print "Design..."
7C02 DD 2E C4    10 757 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7C05 06 19       10 758 ld      b, 25                       ; string length (loop counter)
7C07 CD 7E 78    10 759 call    Screen_Apply_Color_Loop     ; apply color to string area
7C0A 13          10 760 inc     de                          ; move DE to to "Code..." string address
7C0B 2E C4       10 761 ld      l, $C4                      ; HL points to string screen address
7C0D CD 5F 6F    10 762 call    Print_String                ; print "Code..."
7C10 DD 2E E4    10 763 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7C13 06 18       10 764 ld      b, 24                       ; string length (loop counter)
7C15 CD 7E 78    10 765 call    Screen_Apply_Color_Loop     ; apply color to string area
7C18 13          10 766 inc     de                          ; move DE to "Einar Saukas" string address
7C19 2E E4       10 767 ld      l, $E4                      ; HL points to string screen address
7C1B CD 5F 6F    10 768 call    Print_String                ; print "Einar Saukas"
7C1E DD 21 24 5A 10 769 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C22 06 18       10 770 ld      b, 24                       ; string length (loop counter)
7C24 CD 7E 78    10 771 call    Screen_Apply_Color_Loop     ; apply color to string area
7C27 13          10 772 inc     de                          ; move DE to "Font..." string address
7C28 21 24 50    10 773 ld      hl, $5024                   ; HL points to string screen address
7C2B CD 5F 6F    10 774 call    Print_String                ; print "Font..."
7C2E DD 2E 64    10 775 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C31 06 18       10 776 ld      b, 24                       ; string length (loop counter)
7C33 CD 7E 78    10 777 call    Screen_Apply_Color_Loop     ; apply color to string area
7C36 13          10 778 inc     de                          ; move DE to "Graphics..." string address
7C37 2E 64       10 779 ld      l, $64                      ; HL points to string screen address
7C39 CD 5F 6F    10 780 call    Print_String                ; print "Graphics..."
7C3C DD 2E 84    10 781 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C3F 06 19       10 782 ld      b, 25                       ; string length (loop counter)
7C41 CD 7E 78    10 783 call    Screen_Apply_Color_Loop     ; apply color to string area
7C44 13          10 784 inc     de                          ; move DE to "Antonio Luque" string address
7C45 2E 84       10 785 ld      l, $84                      ; HL points to string screen address
7C47 CD 5F 6F    10 786 call    Print_String                ; print "Antonio Luque"
7C4A DD 2E E9    10 787 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C4D 01 38 0D    10 788 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7C50 CD 7E 78    10 789 call    Screen_Apply_Color_Loop     ; apply color to string area
7C53 13          10 790 inc     de                          ; move DE to "Press any key" string address
7C54 2E E9       10 791 ld      l, $E9                      ; HL points to string screen address
7C56 CD 5F 6F    10 792 call    Print_String                ; print "Press any key"
7C59 CD C6 6E    10 793 call    Input_Key_Scan              ; wait for a key pressed
7C5C C3 8B 79    10 794 jp      Screen_Menu_Strings         ; return to main menu
7C5F             10 796 ; ----------------------------------------------------------------------------------------------------------------------
7C5F             10 797 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C5F             10 798 ;
7C5F             10 799 ; Input:    -
7C5F             10 800 ;
7C5F             10 801 ; Output:   -
7C5F             10 802 ;
7C5F             10 803 ; Uses:     TOKEN_COLOR (current token color)
7C5F             10 804 ;
7C5F             10 805 ; Destroys: A, BC, DE, HL, IX, IY
7C5F             10 806 ; ----------------------------------------------------------------------------------------------------------------------
7C5F             10 807 Screen_Hexagons:
7C5F FD 21 EA 66 10 808 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C63 3E 07       10 809 ld      a, WHITE                    ; set hexagon color
7C65 32 9E 61    10 810 ld      (TOKEN_COLOR), a            ; save hexagon color
7C68 11 7E 65    10 811 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C6B 06 1C       10 812 ld      b, 28                       ; number of empty hexagons (loop counter)
7C6D CD 84 7C    10 813 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C70 3E 05       10 814 ld      a, CYAN_COLOR               ; set token color
7C72 32 9E 61    10 815 ld      (TOKEN_COLOR), a            ; save hexagon color
7C75 11 3E 66    10 816 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C78 06 06       10 817 ld      b, 6                        ; number of cyan tokens (loop counter)
7C7A CD 84 7C    10 818 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C7D 3E 02       10 819 ld      a, RED_COLOR                ; set token color
7C7F 32 9E 61    10 820 ld      (TOKEN_COLOR), a            ; save hexagon color
7C82 06 06       10 821 ld      b, 6                        ; number of red tokens (loop counter)
7C84             10 822 Screen_Hexagons_Loop:
7C84 FD 6E 00    10 823 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C87 FD 66 01    10 824 ld      h, (iy+1)
7C8A CD 10 6E    10 825 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C8D D5          10 826 push    de                          ; store hexagon/token sprite address
7C8E CD E2 6D    10 827 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C91 D1          10 828 pop     de                          ; restore hexagon/token sprite address
7C92 FD 23       10 829 inc     iy                          ; move IY to next hexagon/token screen address
7C94 FD 23       10 830 inc     iy
7C96 10 EC       10 831 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C98 C9          10 832 ret
7C99             10 834 ; ----------------------------------------------------------------------------------------------------------------------
7C99             10 835 ; Screen_Clear_Text: clean a text attributes area
7C99             10 836 ;
7C99             10 837 ; Input:    HL = text area attributes address
7C99             10 838 ;
7C99             10 839 ; Output:   -
7C99             10 840 ;
7C99             10 841 ; Destroys: BC, DE, HL
7C99             10 842 ; ----------------------------------------------------------------------------------------------------------------------
7C99             10 843 Screen_Clear_Text:
7C99 01 30 00    10 844 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7C9C             10 845 Screen_ClearText_Loop
7C9C 11 18 00    10 846 ld      de, 24                      ; displacement for each text row
7C9F 19          10 847 add     hl, de                      ; add displacement to text area attributes address
7CA0 54          10 848 ld      d, h                        ; DE points to text area attributes address
7CA1 5D          10 849 ld      e, l
7CA2 36 00       10 850 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7CA4 13          10 851 inc     de                          ; move DE to next byte attribute address
7CA5 ED A0       10 852 ldi                                 ; set attributes color for the rest of bytes of current row
7CA7 ED A0       10 853 ldi
7CA9 ED A0       10 854 ldi
7CAB ED A0       10 855 ldi
7CAD ED A0       10 856 ldi
7CAF ED A0       10 857 ldi
7CB1 ED A0       10 858 ldi
7CB3 ED A0       10 859 ldi
7CB5 EA 9C 7C    10 860 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7CB8 C9          10 861 ret

; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

7CB9             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CB9             0 20 ; Credits and acknowledgements:
7CB9             0 21 ;
7CB9             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CB9             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CB9             0 24 ;   "King+" font and TOKEN graphics.
7CB9             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CB9             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CB9             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CB9             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CB9             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CB9             0 30 ;
7CB9             0 31 ; - Special thanks to my wife Sonia.
7CB9             0 32 ; ----------------------------------------------------------------------------------------------------------------------
