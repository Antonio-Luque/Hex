
; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   org     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         defs    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 defb                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 defb    0                           ; board potential
6198 00          1 51 defb    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               defb    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                defb    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             defb    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             defb    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              defb    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             defb    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            defb    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 defb    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 defb    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 defb    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 defb    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 defb    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 defb    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 defb    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 defm    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;org     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 A6 73       1 85 defw    PathFinder_CYAN_Edge_0
6202 C6 73       1 86 defw    PathFinder_CYAN_Edge_1
6204 E1 73       1 87 defw    PathFinder_CYAN_Edge_2
6206 FF 73       1 88 defw    PathFinder_CYAN_Edge_3
6208 1E 74       1 89 defw    PathFinder_CYAN_Edge_4
620A 3C 74       1 90 defw    PathFinder_CYAN_Edge_5
620C 57 74       1 91 defw    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E 00          1 96 THREE_ROW               defb    0                           ; three-in-a-row counter
620F 0F 0E 0C 0B 1 97 ROW_COLOR_MAP           defb    15, 14, 12, 11, 13, 10      ; level-color map for frame border
6213 0D 0A       1 97 
6215 00 2D 30 00 1 98 STR_MOVE                defb    0, '-', '0', 0, '\0'        ; formatted move string
6219 00          1 98 
621A 53 70 65 63 1 99 STR_SPECCY              defm    "Speccy\0"
621E 63 79 00    1 99 
6221 50 6C 61 79 1 100 STR_PLAYER              defm    "Player\0"
6225 65 72 00    1 100 
6228 4C 65 76 65 1 101 STR_LEVELTEXT           defm    "Level\0"
622C 6C 00       1 101 
622E 46 49 4C 4C 1 102 STR_FILLED              defm    "FILLED\0"
6232 45 44 00    1 102 
6235 57 41 49 54 1 103 STR_WAIT                defm    "WAIT\0"
6239 00          1 103 
623A 20 57 49 4E 1 104 STR_WINNER              defm    " WINS \0"
623E 53 20 00    1 104 
6241 20 20 20 20 1 105 STR_EMPTY4              defm    "    \0"
6245 00          1 105 
6246 20 20 20 20 1 106 STR_EMPTY6              defm    "      \0"
624A 20 20 00    1 106 
624D             1 108 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 109 ; Conversion table: from position to XY board indexes
624D             1 110 ; ----------------------------------------------------------------------------------------------------------------------
624D             1 111 BOARD_COORDINATES:
624D 00 00 00 00 1 112 defb    $00, $00, $00, $00, $00, $00, $00, $00
6251 00 00 00 00 1 112 
6255 00 09 0A 0B 1 113 defb    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
6259 0C 0D 0E 0F 1 113 
625D 00 12 13 14 1 114 defb    $00, $12, $13, $14, $15, $16, $17, $18
6261 15 16 17 18 1 114 
6265 00 1B 1C 1D 1 115 defb    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
6269 1E 1F 20 21 1 115 
626D 00 24 25 26 1 116 defb    $00, $24, $25, $26, $27, $28, $29, $2A
6271 27 28 29 2A 1 116 
6275 00 2D 2E 2F 1 117 defb    $00, $2D, $2E, $2F, $30, $31, $32, $33
6279 30 31 32 33 1 117 
627D 00 36 37 38 1 118 defb    $00, $36, $37, $38, $39, $3A, $3B, $3C
6281 39 3A 3B 3C 1 118 
6285 00 3F 40 41 1 119 defb    $00, $3F, $40, $41, $42, $43, $44, $45
6289 42 43 44 45 1 119 
628D             1 121 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 122 ; Graphics map indexes for the frame tiles
628D             1 123 ; ----------------------------------------------------------------------------------------------------------------------
628D             1 124 FRAME_MAP:
628D 00 01 01 01 1 125 defb      0,   1,   1,   1,   1,   1,   2,   3
6291 01 01 02 03 1 125 
6295 04 FF FF FF 1 126 defb      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
6299 FF FF FF FF 1 126 
629D 05 06 07 01 1 127 defb      5,   6,   7,   1,   1,   1,   1,   1
62A1 01 01 01 01 1 127 
62A5 01 01 01 01 1 128 defb      1,   1,   1,   1,   1,   1,   1,   8
62A9 01 01 01 08 1 128 
62AD 09 01 01 01 1 129 defb      9,   1,   1,   1,   1,   1,   1,   1
62B1 01 01 01 01 1 129 
62B5 01 01 01 01 1 130 defb      1,   1,   1,   1,   1,   1,   1,   1
62B9 01 01 01 01 1 130 
62BD 0A 06 0D 0D 1 131 defb     10,   6,  13,  13,  13,   3,  11,   1
62C1 0D 03 0B 01 1 131 
62C5 01 01 01 01 1 132 defb      1,   1,   1,   1,   1,   1,   1,  12
62C9 01 01 01 0C 1 132 
62CD             1 134 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 135 ; Definition of a small "Opening Book" for speccy first move
62CD             1 136 ; ----------------------------------------------------------------------------------------------------------------------
62CD             1 137 OPENINGS:
62CD 0F 14 16 17 1 138 defb    $0F, $14, $16, $17, $18, $1C, $1D
62D1 18 1C 1D    1 138 
62D4 1E 1F 20 24 1 139 defb    $1E, $1F, $20, $24, $25, $26, $27
62D8 25 26 27    1 139 
62DB 28 29 2A 2E 1 140 defb    $28, $29, $2A, $2E, $2F, $30, $31
62DF 2F 30 31    1 140 
62E2 32 36 37 38 1 141 defb    $32, $36, $37, $38, $3A, $3F
62E6 3A 3F       1 141 
62E8             1 143 ; ----------------------------------------------------------------------------------------------------------------------
62E8             1 144 ; Timer variables
62E8             1 145 ; ----------------------------------------------------------------------------------------------------------------------
62E8 00          1 146 TIMER_FLAG              defb    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62E9             1 147 ; for each timer:
62E9             1 148 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62E9             1 149 ;   2nd byte = seconds counter
62E9             1 150 ;   3th byte = minutes counter
62E9 32 00 00    1 151 CYAN_TIMER              defb    50, 0, 0
62EC 32 00 00    1 152 RED_TIMER               defb    50, 0, 0
62EF             1 154 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 155 ; Screen addresses look-up array for board numbers
62EF             1 156 ; ----------------------------------------------------------------------------------------------------------------------
62EF             1 157 NUMBER_SCREEN:
62EF A5 43 E6 43 1 158 defw    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F3 27 4B 68 4B 1 158 
62F7 A9 4B EA 4B 1 158 
62FB 2B 53       1 158 
62FD FF FF FF    1 160 FILLER_1                defb    $FF, $FF, $FF               ; filler to align next block (not used)
6300             1 162 ;org     $6300
6300             1 163 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 164 ; Circular queue
6300             1 165 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 166 RED_QUEUE_AREA          defs    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 166 
6308 00 00 00 00 1 166 
630C 00 00 00 00 1 166 
6310 00 00 00 00 1 166 
6314 00 00 00 00 1 166 
6318 00 00 00 00 1 166 
631C 00 00 00 00 1 166 
6320 00 00 00 00 1 166 
6324 00 00 00 00 1 166 
6328 00 00 00 00 1 166 
632C 00 00 00 00 1 166 
6330 00 00 00 00 1 166 
6334 00 00 00 00 1 166 
6338 00 00 00 00 1 166 
633C 00 00 00 00 1 166 
6340 00 00 00 00 1 166 
6344 00 00 00 00 1 166 
6348 00 00 00 00 1 166 
634C 00 00 00 00 1 166 
6350 00 00 00 00 1 166 
6354 00 00 00 00 1 166 
6358 00 00 00 00 1 166 
635C 00 00 00 00 1 166 
6360 00 00 00 00 1 166 
6364 00 00 00 00 1 166 
6368 00 00 00 00 1 166 
636C 00 00 00 00 1 166 
6370 00 00 00 00 1 166 
6374 00 00 00 00 1 166 
6378 00 00 00 00 1 166 
637C 00 00 00 00 1 166 
6380 00 00 00 00 1 166 
6384 00 00 00 00 1 166 
6388 00 00 00 00 1 166 
638C 00 00 00 00 1 166 
6390 00 00 00 00 1 166 
6394 00 00 00 00 1 166 
6398 00 00 00 00 1 166 
639C 00 00 00 00 1 166 
63A0 00 00 00 00 1 166 
63A4 00 00 00 00 1 166 
63A8 00 00 00 00 1 166 
63AC 00 00 00 00 1 166 
63B0 00 00 00 00 1 166 
63B4 00 00 00 00 1 166 
63B8 00 00 00 00 1 166 
63BC 00 00 00 00 1 166 
63C0 00 00 00 00 1 166 
63C4 00 00 00 00 1 166 
63C8 00 00 00 00 1 166 
63CC 00 00 00 00 1 166 
63D0 00 00 00 00 1 166 
63D4 00 00 00 00 1 166 
63D8 00 00 00 00 1 166 
63DC 00 00 00 00 1 166 
63E0 00 00 00 00 1 166 
63E4 00 00 00 00 1 166 
63E8 00 00 00 00 1 166 
63EC 00 00 00 00 1 166 
63F0 00 00 00 00 1 166 
63F4 00 00 00 00 1 166 
63F8 00 00 00 00 1 166 
63FC 00 00 00 00 1 166 
6400             1 168 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 169 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 170 ; 
6400             1 171 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 172 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 173 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 174 ; 
6400             1 175 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 176 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 177 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 178 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 179 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 180 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 180 
6408 7F 00 00 00 1 181 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 181 
6410 80          1 181 
6411 7F 00 00 00 1 182 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 182 
6419 81          1 182 
641A 7F 00 00 00 1 183 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 183 
6422 82          1 183 
6423 7F 00 00 00 1 184 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 184 
642B 83          1 184 
642C 7F 00 00 00 1 185 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 185 
6434 84          1 185 
6435 7F 00 00 00 1 186 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 186 
643D 85          1 186 
643E 7F 00 00 00 1 187 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 187 
6446 86          1 187 
6447 7F 7F 7F 7F 1 188 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 188 
644F 7F          1 188 
6450             1 189 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 190 defb    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 190 
6458 7F          1 190 
6459 81 00 00 00 1 191 defb       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 191 
6461 7F          1 191 
6462 82 00 00 00 1 192 defb          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 192 
646A 7F          1 192 
646B 83 00 00 00 1 193 defb             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 193 
6473 7F          1 193 
6474 84 00 00 00 1 194 defb                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 194 
647C 7F          1 194 
647D 85 00 00 00 1 195 defb                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 195 
6485 7F          1 195 
6486 86 00 00 00 1 196 defb                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 196 
648E 7F          1 196 
648F 7F 7F 7F 7F 1 197 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 197 
6497             1 199 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 200 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 201 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 202 TIMER_DIGITS:
6497 00 0F 0B 0B 1 203 defb    $00, $0F, $0B, $0B, $0B, $0F, $00, $00
649B 0B 0F 00 00 1 203 
649F 00 06 0E 06 1 204 defb    $00, $06, $0E, $06, $06, $06, $00, $00
64A3 06 06 00 00 1 204 
64A7 00 0F 03 0F 1 205 defb    $00, $0F, $03, $0F, $08, $0F, $00, $00
64AB 08 0F 00 00 1 205 
64AF 00 0F 03 07 1 206 defb    $00, $0F, $03, $07, $03, $0F, $00, $00
64B3 03 0F 00 00 1 206 
64B7 00 0B 0B 0F 1 207 defb    $00, $0B, $0B, $0F, $03, $03, $00, $00
64BB 03 03 00 00 1 207 
64BF 00 0F 08 0F 1 208 defb    $00, $0F, $08, $0F, $03, $0F, $00, $00
64C3 03 0F 00 00 1 208 
64C7 00 0F 0C 0F 1 209 defb    $00, $0F, $0C, $0F, $0D, $0F, $00, $00
64CB 0D 0F 00 00 1 209 
64CF 00 0F 03 03 1 210 defb    $00, $0F, $03, $03, $03, $03, $00, $00
64D3 03 03 00 00 1 210 
64D7 00 0F 0B 0F 1 211 defb    $00, $0F, $0B, $0F, $0B, $0F, $00, $00
64DB 0B 0F 00 00 1 211 
64DF 00 0F 0B 0F 1 212 defb    $00, $0F, $0B, $0F, $03, $0F, $00, $00
64E3 03 0F 00 00 1 212 
64E7             1 214 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 215 ; Tone parameters for sound effects
64E7             1 216 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 217 ; for each tone (from left to right):
64E7             1 218 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 219 ;   - length of a frame (1..65536)
64E7             1 220 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 221 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 222 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 223 TOKEN_FX                defw       1, 1000, 1400,   0
64EB 78 05 00 00 1 223 
64EF 05 00 88 13 1 224 WINNER_FX               defw       5, 5000,  200, 100
64F3 C8 00 64 00 1 224 
64F7 E8 03 0A 00 1 225 FILLED_FX               defw    1000,   10,  100,   0
64FB 64 00 00 00 1 225 
64FF FF          1 227 FILLER_2                defb    $FF                         ; filler to align next block (not used)
6500             1 229 ;org     $6500
6500             1 230 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 231 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 232 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 233 RED_VECTOR_TABLE:
6500 8C 72       1 234 defw    PathFinder_RED_Edge_0
6502 BA 72       1 235 defw    PathFinder_RED_Edge_1
6504 E0 72       1 236 defw    PathFinder_RED_Edge_2
6506 06 73       1 237 defw    PathFinder_RED_Edge_3
6508 2C 73       1 238 defw    PathFinder_RED_Edge_4
650A 52 73       1 239 defw    PathFinder_RED_Edge_5
650C 78 73       1 240 defw    PathFinder_RED_Edge_6
650E             1 242 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 243 ; Graphics for the screen frame
650E             1 244 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 245 FRAME_TILES:
650E 00 00 1F 3F 1 246 defb    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C
6512 3F 3F 3C 3C 1 246 
6516 00 00 FF FF 1 247 defb    $00, $00, $FF, $FF, $FF, $FF, $00, $00
651A FF FF 00 00 1 247 
651E 00 00 FF FE 1 248 defb    $00, $00, $FF, $FE, $FE, $FF, $00, $00
6522 FE FF 00 00 1 248 
6526 03 07 0F 0F 1 249 defb    $03, $07, $0F, $0F, $0F, $0F, $07, $03
652A 0F 0F 07 03 1 249 
652E FF FE FC FC 1 250 defb    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF
6532 FC FC FE FF 1 250 
6536 FF 7F 3F 3F 1 251 defb    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF
653A 3F 3F 7F FF 1 251 
653E C0 E0 F0 F0 1 252 defb    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0
6542 F0 F0 E0 C0 1 252 
6546 00 00 FF 7F 1 253 defb    $00, $00, $FF, $7F, $7F, $FF, $00, $00
654A 7F FF 00 00 1 253 
654E 00 00 F8 FC 1 254 defb    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C
6552 FC FC 3C 3C 1 254 
6556 3C 3C 3F 3F 1 255 defb    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00
655A 3F 1F 00 00 1 255 
655E 00 00 FE FF 1 256 defb    $00, $00, $FE, $FF, $FF, $FE, $00, $00
6562 FF FE 00 00 1 256 
6566 00 00 7F FF 1 257 defb    $00, $00, $7F, $FF, $FF, $7F, $00, $00
656A FF 7F 00 00 1 257 
656E 3C 3C FC FC 1 258 defb    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00
6572 FC F8 00 00 1 258 
6576 00 00 38 7C 1 259 defb    $00, $00, $38, $7C, $7C, $38, $00, $00
657A 7C 38 00 00 1 259 
657E             1 261 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 262 ; Hexagon sprites
657E             1 263 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 264 HEXAGON_EMPTY:
657E 07 E0 18 18 1 265 defb    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 265 
6586 48 02 48 02 1 266 defb    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 266 
658E 40 02 40 02 1 267 defb    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 267 
6596 20 24 20 04 1 268 defb    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 268 
659E             1 269 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 270 defb    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 270 
65A6 24 04 24 04 1 271 defb    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 271 
65AE 20 04 20 04 1 272 defb    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 272 
65B6 10 48 10 08 1 273 defb    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 273 
65BE 01 80 02 40 1 275 defb    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 275 
65C6 0A 10 0A 10 1 276 defb    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 276 
65CE 08 10 08 10 1 277 defb    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 277 
65D6 08 90 04 20 1 278 defb    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 278 
65DE 00 80 00 80 1 280 defb    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 280 
65E6 00 80 00 80 1 281 defb    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 281 
65EE 00 80 00 80 1 282 defb    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 282 
65F6 00 80 00 80 1 283 defb    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 283 
65FE 01 80 02 40 1 285 defb    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 285 
6606 0B D0 0B D0 1 286 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 286 
660E 0B D0 0B D0 1 287 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 287 
6616 0B D0 05 A0 1 288 defb    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 288 
661E 03 C0 0C 30 1 290 defb    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 290 
6626 2F F4 2F F4 1 291 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 291 
662E 2F F4 2F F4 1 292 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 292 
6636 17 E8 13 C8 1 293 defb    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 293 
663E             1 294 HEXAGON_TOKEN:
663E 07 E0 18 18 1 295 defb    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 295 
6646 5F FA 5F FA 1 296 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 296 
664E 5F FA 5F FA 1 297 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 297 
6656 2F F4 27 E4 1 298 defb    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 298 
665E             1 300 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 301 ; Board letter sprites
665E             1 302 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 303 LETTER_SPRITES:
665E 3C 7E FF C3 1 304 defb    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C
6662 F3 C3 D3 C3 1 304 
6666 7E 3C       1 304 
6668 3C 7E CF CF 1 305 defb    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C
666C C3 CB CB C3 1 305 
6670 7E 3C       1 305 
6672 3C 7E FF E3 1 306 defb    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C
6676 CF CF CF E3 1 306 
667A 7E 3C       1 306 
667C 3C 7E F3 F3 1 307 defb    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C
6680 C3 D3 D3 C3 1 307 
6684 7E 3C       1 307 
6686 3C 7E FF E3 1 308 defb    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C
668A CB C3 CF E3 1 308 
668E 7E 3C       1 308 
6690 3C 7E E3 CF 1 309 defb    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C
6694 C7 CF CF CF 1 309 
6698 7E 3C       1 309 
669A 3C 7E FF E3 1 310 defb    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C
669E D3 D3 E3 F3 1 310 
66A2 46 3C       1 310 
66A4             1 312 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 313 ; Board number sprites
66A4             1 314 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 315 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 316 defb    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C
66A8 E7 E7 E7 E7 1 316 
66AC 7E 3C       1 316 
66AE 3C 7E E7 D3 1 317 defb    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C
66B2 F3 E7 CF C3 1 317 
66B6 7E 3C       1 317 
66B8 3C 7E C7 F3 1 318 defb    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C
66BC E3 F3 F3 C7 1 318 
66C0 7E 3C       1 318 
66C2 3C 7E D3 D3 1 319 defb    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C
66C6 C3 F3 F3 F3 1 319 
66CA 7E 3C       1 319 
66CC 3C 7E C3 CF 1 320 defb    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C
66D0 C7 F3 F3 C7 1 320 
66D4 7E 3C       1 320 
66D6 3C 7E E3 CF 1 321 defb    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C
66DA C3 CB CB C3 1 321 
66DE 7E 3C       1 321 
66E0 3C 7E C3 F3 1 322 defb    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C
66E4 F3 E7 E7 E7 1 322 
66E8 7E 3C       1 322 
66EA             1 324 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 325 ; Screen addresses for menu hexagons
66EA             1 326 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 327 MENU_HEXAGONS:
66EA 01 40 05 40 1 328 defw    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 328 
66F2 0F 40 13 40 1 328 
66F6 1A 40       1 328 
66F8 45 40 48 40 1 329 defw    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 329 
6700 81 40 83 40 1 329 
6704 85 40       1 329 
6706 88 40 8A 40 1 330 defw    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 330 
670E C1 40 D0 40 1 330 
6712 D9 40       1 330 
6714 05 48 08 48 1 331 defw    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 331 
671C 19 48 1B 48 1 331 
6720 1D 48       1 331 
6722 0A 40 59 40 1 332 defw    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 332 
672A D2 40 0C 48 1 332 
672E 1C 40       1 332 
6730 41 40 50 40 1 333 defw    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 333 
6738 0F 48       1 333 
673A             1 334 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 335 defw    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 335 
6742 EF 40 F1 40 1 335 
6746 B2 40       1 335 
6748 E9 40 6F 48 1 336 defw    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 336 
6750 AA 48 AC 40 1 336 
6754 EF 48       1 336 
6756 2A 48 6D 48 1 337 defw    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 337 
675E             1 338 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 339 defw    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 339 
6766 AE 48 EF 48 1 339 
676A 2E 50       1 339 
676C AC 48 B4 48 1 340 defw    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 340 
6774 2E 48 F1 40 1 340 
6778 F3 40       1 340 
677A 73 48 B2 48 1 341 defw    $4873, $48B2, $5030
677E 30 50       1 341 
6780             1 343 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 344 ; Strings
6780             1 345 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 346 STR_OPTIONS:
6780 53 74 61 72 1 347 defm    "Start new game\0"
6784 74 20 6E 65 1 347 
6788 77 20 67 61 1 347 
678C 6D 65 00    1 347 
678F 48 6F 77 20 1 348 defm    "How to play\0"
6793 74 6F 20 70 1 348 
6797 6C 61 79 00 1 348 
679B 43 72 65 64 1 349 defm    "Credits\0"
679F 69 74 73 00 1 349 
67A3             1 350 STR_CREDITS:
67A3 44 65 73 69 1 351 defm    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 351 
67AB 20 20 20 20 1 351 
67AF 41 6E 74 6F 1 351 
67B3 6E 69 6F 20 1 351 
67B7 4C 75 71 75 1 351 
67BB 65 00       1 351 
67BD 43 6F 64 65 1 352 defm    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 352 
67C5 20 20 20 20 1 352 
67C9 41 6E 74 6F 1 352 
67CD 6E 69 6F 20 1 352 
67D1 4C 75 71 75 1 352 
67D5 65 00       1 352 
67D7 20 20 20 20 1 353 defm    "            Einar Saukas\0"
67DB 20 20 20 20 1 353 
67DF 20 20 20 20 1 353 
67E3 45 69 6E 61 1 353 
67E7 72 20 53 61 1 353 
67EB 75 6B 61 73 1 353 
67EF 00          1 353 
67F0 46 6F 6E 74 1 354 defm    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 354 
67F8 20 20 20 20 1 354 
67FC 45 69 6E 61 1 354 
6800 72 20 53 61 1 354 
6804 75 6B 61 73 1 354 
6808 00          1 354 
6809 47 72 61 70 1 355 defm    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 355 
6811 3A 20 20 20 1 355 
6815 45 69 6E 61 1 355 
6819 72 20 53 61 1 355 
681D 75 6B 61 73 1 355 
6821 00          1 355 
6822 20 20 20 20 1 356 defm    "            Antonio Luque\0"
6826 20 20 20 20 1 356 
682A 20 20 20 20 1 356 
682E 41 6E 74 6F 1 356 
6832 6E 69 6F 20 1 356 
6836 4C 75 71 75 1 356 
683A 65 00       1 356 
683C 50 72 65 73 1 357 STR_PRESSKEY            defm    "Press any key\0"
6840 73 20 61 6E 1 357 
6844 79 20 6B 65 1 357 
6848 79 00       1 357 
684A             1 358 STR_BUTTONS:
684A 4E 65 78 74 1 359 defm    "Next\0"
684E 00          1 359 
684F 42 61 63 6B 1 360 defm    "Back\0"
6853 00          1 360 
6854 52 45 44 00 1 361 STR_RED                 defm    "RED\0"
6858 43 59 41 4E 1 362 STR_CYAN                defm    "CYAN\0"
685C 00          1 362 
685D 43 6F 6E 6E 1 363 STR_HELP1               defm    "Connect\0"
6861 65 63 74 00 1 363 
6865 6C 65 66 74 1 364 STR_HELP2_RED           defm    "left and\0"
6869 20 61 6E 64 1 364 
686D 00          1 364 
686E 75 70 20 61 1 365 STR_HELP2_CYAN          defm    "up and\0"
6872 6E 64 00    1 365 
6875 72 69 67 68 1 366 STR_HELP3_RED           defm    "right\0"
6879 74 00       1 366 
687B 64 6F 77 6E 1 367 STR_HELP3_CYAN          defm    "down\0"
687F 00          1 367 
6880 62 6F 72 64 1 368 STR_HELP4               defm    "borders\0"
6884 65 72 73 00 1 368 
6888 74 6F 20 77 1 369 STR_HELP5               defm    "to win\0"
688C 69 6E 00    1 369 
688F             1 370 STR_HELP:
688F 57 69 6E 20 1 371 defm    "Win three\0"
6893 74 68 72 65 1 371 
6897 65 00       1 371 
6899 74 69 6D 65 1 372 defm    "times in\0"
689D 73 20 69 6E 1 372 
68A1 00          1 372 
68A2 61 20 72 6F 1 373 defm    "a row to\0"
68A6 77 20 74 6F 1 373 
68AA 00          1 373 
68AB 6C 65 76 65 1 374 defm    "level up\0"
68AF 6C 20 75 70 1 374 
68B3 00          1 374 
68B4 20 43 4F 4E 1 375 STR_CONGRATS            defm    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 375 
68BC 55 4C 41 54 1 375 
68C0 49 4F 4E 53 1 375 
68C4 20 00       1 375 
68C6             1 376 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 377 defm    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 377 
68CE 65 21 20 4C 1 377 
68D2 61 73 74 20 1 377 
68D6 6C 65 76 65 1 377 
68DA 6C 20 70 61 1 377 
68DE 73 73 65 64 1 377 
68E2 00          1 377 
68E3 43 68 6F 6F 1 378 defm    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 378 
68EB 65 76 65 6C 1 378 
68EF 20 74 6F 20 1 378 
68F3 72 65 73 74 1 378 
68F7 61 72 74 2C 1 378 
68FB 20 31 2D 34 1 378 
68FF 00          1 378 
6900             1 380 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 381 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 382 ; this font was designed by Einar Saukas for Hex game
6900             1 383 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 384 FONT:
6900 00 00 00 00 1 385 includebin "King+.bin"
6904 00 00 00 00 1 385 
6908 00 18 18 18 1 385 
690C 00 18 18 00 1 385 
6910 00 24 24 00 1 385 
6914 00 00 00 00 1 385 
6918 00 24 7E 24 1 385 
691C 24 7E 24 00 1 385 
6920 00 08 3E 28 1 385 
6924 3E 0A 3E 08 1 385 
6928 00 62 64 08 1 385 
692C 10 26 46 00 1 385 
6930 00 10 28 10 1 385 
6934 2A 44 3A 00 1 385 
6938 00 18 30 00 1 385 
693C 00 00 00 00 1 385 
6940 06 0C 08 08 1 385 
6944 08 0C 06 00 1 385 
6948 60 30 10 10 1 385 
694C 10 30 60 00 1 385 
6950 00 00 14 08 1 385 
6954 3E 08 14 00 1 385 
6958 00 00 08 08 1 385 
695C 3E 08 08 00 1 385 
6960 00 00 00 00 1 385 
6964 00 0C 18 30 1 385 
6968 00 00 00 7E 1 385 
696C 7E 00 00 00 1 385 
6970 00 00 00 00 1 385 
6974 30 70 70 00 1 385 
6978 02 06 0C 18 1 385 
697C 30 60 40 00 1 385 
6980 00 7E 62 62 1 385 
6984 62 62 7E 00 1 385 
6988 00 18 38 18 1 385 
698C 18 18 3C 00 1 385 
6990 00 38 4C 4C 1 385 
6994 18 30 7C 00 1 385 
6998 00 3C 62 0C 1 385 
699C 06 66 3C 00 1 385 
69A0 00 30 30 30 1 385 
69A4 30 34 3E 04 1 385 
69A8 00 7E 60 7E 1 385 
69AC 06 66 3C 00 1 385 
69B0 00 30 60 7C 1 385 
69B4 66 66 3C 00 1 385 
69B8 00 7E 46 0C 1 385 
69BC 18 30 60 00 1 385 
69C0 00 3C 66 3C 1 385 
69C4 66 66 3C 00 1 385 
69C8 00 3C 66 66 1 385 
69CC 3E 06 3C 00 1 385 
69D0 00 00 08 18 1 385 
69D4 00 08 18 00 1 385 
69D8 00 00 04 0C 1 385 
69DC 00 0C 18 30 1 385 
69E0 00 00 04 08 1 385 
69E4 10 08 04 00 1 385 
69E8 00 00 00 3E 1 385 
69EC 00 3E 00 00 1 385 
69F0 00 00 10 08 1 385 
69F4 04 08 10 00 1 385 
69F8 00 3C 42 04 1 385 
69FC 08 00 08 00 1 385 
6A00 00 3C 4A 56 1 385 
6A04 5E 40 3C 00 1 385 
6A08 00 7E 46 46 1 385 
6A0C 7E 46 46 00 1 385 
6A10 00 7C 62 7C 1 385 
6A14 62 62 7C 00 1 385 
6A18 00 7E 66 60 1 385 
6A1C 60 66 7E 00 1 385 
6A20 00 7C 46 46 1 385 
6A24 46 46 7C 00 1 385 
6A28 00 7E 60 7C 1 385 
6A2C 60 60 7E 00 1 385 
6A30 00 7E 60 7C 1 385 
6A34 60 60 60 00 1 385 
6A38 00 3E 62 60 1 385 
6A3C 66 66 3E 00 1 385 
6A40 00 62 62 7E 1 385 
6A44 62 62 62 00 1 385 
6A48 00 18 18 18 1 385 
6A4C 18 18 18 00 1 385 
6A50 00 0C 0C 0C 1 385 
6A54 0C 4C 38 00 1 385 
6A58 00 66 64 68 1 385 
6A5C 7E 46 66 00 1 385 
6A60 00 60 60 60 1 385 
6A64 60 60 7E 00 1 385 
6A68 00 7E 56 56 1 385 
6A6C 56 56 56 00 1 385 
6A70 00 7E 46 46 1 385 
6A74 46 46 46 00 1 385 
6A78 00 7E 62 62 1 385 
6A7C 62 62 7E 00 1 385 
6A80 00 7E 62 62 1 385 
6A84 7E 60 60 00 1 385 
6A88 00 7C 64 64 1 385 
6A8C 64 64 7E 00 1 385 
6A90 00 7C 62 64 1 385 
6A94 7C 46 46 00 1 385 
6A98 00 7E 60 7E 1 385 
6A9C 06 06 7E 00 1 385 
6AA0 00 7E 18 18 1 385 
6AA4 18 18 18 00 1 385 
6AA8 00 62 62 62 1 385 
6AAC 62 62 7E 00 1 385 
6AB0 00 62 62 62 1 385 
6AB4 62 34 18 00 1 385 
6AB8 00 6A 6A 6A 1 385 
6ABC 6A 6A 7E 00 1 385 
6AC0 00 62 62 34 1 385 
6AC4 4E 46 46 00 1 385 
6AC8 00 62 62 7E 1 385 
6ACC 18 18 18 00 1 385 
6AD0 00 7E 06 1C 1 385 
6AD4 38 60 7E 00 1 385 
6AD8 00 0E 08 08 1 385 
6ADC 08 08 0E 00 1 385 
6AE0 00 00 40 20 1 385 
6AE4 10 08 04 00 1 385 
6AE8 00 70 10 10 1 385 
6AEC 10 10 70 00 1 385 
6AF0 00 08 1C 2A 1 385 
6AF4 08 08 08 08 1 385 
6AF8 00 00 00 00 1 385 
6AFC 00 00 00 FF 1 385 
6B00 0C 12 10 38 1 385 
6B04 10 10 3E 00 1 385 
6B08 00 00 3C 06 1 385 
6B0C 7E 46 7E 00 1 385 
6B10 00 60 60 7E 1 385 
6B14 62 62 7E 00 1 385 
6B18 00 00 7E 62 1 385 
6B1C 60 62 7E 00 1 385 
6B20 00 06 06 7E 1 385 
6B24 46 46 7E 00 1 385 
6B28 00 00 7E 46 1 385 
6B2C 7E 60 7E 00 1 385 
6B30 00 1E 30 3C 1 385 
6B34 30 30 30 00 1 385 
6B38 00 00 7E 46 1 385 
6B3C 46 3E 06 3E 1 385 
6B40 00 60 60 7C 1 385 
6B44 66 66 66 00 1 385 
6B48 00 18 00 38 1 385 
6B4C 18 18 3C 00 1 385 
6B50 00 0C 00 0C 1 385 
6B54 0C 0C 4C 38 1 385 
6B58 00 20 2C 38 1 385 
6B5C 38 2C 26 00 1 385 
6B60 00 18 18 18 1 385 
6B64 18 18 0E 00 1 385 
6B68 00 00 6C 56 1 385 
6B6C 56 56 46 00 1 385 
6B70 00 00 7C 46 1 385 
6B74 46 46 46 00 1 385 
6B78 00 00 3C 46 1 385 
6B7C 46 46 3C 00 1 385 
6B80 00 00 7C 66 1 385 
6B84 66 7C 60 60 1 385 
6B88 00 00 3E 46 1 385 
6B8C 46 3E 06 06 1 385 
6B90 00 00 3C 62 1 385 
6B94 60 60 60 00 1 385 
6B98 00 00 3C 60 1 385 
6B9C 3C 06 3C 00 1 385 
6BA0 00 30 78 30 1 385 
6BA4 30 30 1C 00 1 385 
6BA8 00 00 46 46 1 385 
6BAC 46 46 3C 00 1 385 
6BB0 00 00 46 46 1 385 
6BB4 2C 3C 18 00 1 385 
6BB8 00 00 46 56 1 385 
6BBC 56 56 2C 00 1 385 
6BC0 00 00 46 2C 1 385 
6BC4 18 2C 46 00 1 385 
6BC8 00 00 46 46 1 385 
6BCC 46 3E 06 3C 1 385 
6BD0 00 00 7E 0C 1 385 
6BD4 18 30 7E 00 1 385 
6BD8 00 0E 08 30 1 385 
6BDC 08 08 0E 00 1 385 
6BE0 00 08 08 08 1 385 
6BE4 08 2A 1C 08 1 385 
6BE8 00 70 10 0C 1 385 
6BEC 10 10 70 00 1 385 
6BF0 00 14 28 00 1 385 
6BF4 00 00 00 00 1 385 
6BF8 FF 81 81 81 1 385 
6BFC 81 81 81 FF 1 385 

; File #2: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Main.z80asm

6C00             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 2 ; Main.z80asm
6C00             2 3 ; Coded by Antonio Luque
6C00             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 6 CYAN_COLOR              equ     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6C00             2 7 RED_COLOR               equ     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6C00             2 9 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 10 ; Entry point of the program - Initialization
6C00             2 11 ; ----------------------------------------------------------------------------------------------------------------------
6C00             2 12 Main                    ent     $
6C00 F3          2 14 di                                  ; disable interrupts
6C01             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6C01 21 1F 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6C04 FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C08 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C0B FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C0E 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C10 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C12 ED 5E       2 24 im      2                           ; set interrupt mode 2
6C14             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C14             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C14             2 28 ; resultant vector address is formed as follows:
6C14             2 29 ;
6C14             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C14             2 31 ; Source: 
6C14             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
6C14             2 33 ;
6C14             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C14             2 35 ; memory area and it is used by some ROM routines, but none of them are called by HEX2 program.
6C14 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C17 AF          2 39 xor     a                           ; A = 0
6C18 D3 FE       2 40 out     ($FE), a                    ; set border color (black)
6C1A CD 76 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C1D             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 44 ; Start new game
6C1D             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C1D             2 46 Main_Start
6C1D CD 0B 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C20 CD 18 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C23 CD 44 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C26 CD 83 77    2 50 call    Screen_Frame                ; draw the screen frame
6C29 CD DB 77    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C2C CD FA 77    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C2F CD 3D 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C32 FB          2 55 ei                                  ; enable interrupts
6C33             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 58 ; New level
6C33             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C33             2 60 Main_New_Level
6C33 3E 04       2 61 ld      a, 4                        ; maximum level
6C35 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C38 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C39 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C3B CD 77 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C3E 18 DD       2 66 jr      Main_Start                  ; start a new game
6C40             2 67 Main_Increment_Level
6C40 34          2 68 inc     (hl)                        ; increment game level
6C41 CD 1A 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C44 CD 09 79    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C47 AF          2 71 xor     a                           ; A = 0
6C48 32 0E 62    2 72 ld      (THREE_ROW), a              ; initialize three-in-a-row counter
6C4B             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 75 ; Start new match
6C4B             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C4B             2 77 Main_Start_Match
6C4B             2 78 ; set up timers and clear last messages
6C4B CD B4 76    2 80 call    Timer_Reset                 ; reset timers
6C4E CD 9F 76    2 81 call    Timer_Display_All           ; display timers
6C51 CD 08 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C54 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C56 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C59 CD 2F 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C5C             2 87 ; swap players' colors
6C5C 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C5F EE 07       2 90 xor     %00000111                   ; swap color
6C61 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C64 CD EB 6E    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C67             2 94 ; initialize positions and draw empty board
6C67 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C6A 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C6D 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C6F 01 FF 01    2 99 ld      bc, 256*2-1                 ; length of cyan + red positions areas (-1 already set)
6C72 ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C74 CD 9B 6D    2 101 call    Draw_Board                  ; draw an empty hexagons board
6C77             2 103 ; initialize draw token delay, move number and token color
6C77 3E 0A       2 105 ld      a, 10                       ; set delay duration for animate hexagons
6C79 32 CA 6D    2 106 ld      (@Token_Delay+1), a
6C7C 3E 01       2 107 ld      a, 1                        ; initialize move number
6C7E 32 9B 61    2 108 ld      (MOVE_NUMBER), a
6C81 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C83             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 112 ; Process players moves - Match loop
6C83             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C83             2 114 Main_Match_Loop
6C83             2 115 ; check player turn
6C83 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C86 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C89 BE          2 119 cp      (hl)                        ; is player color = current token color?
6C8A 28 05       2 120 jr      z, Main_Player_Move         ; yes, process player move
6C8C CD E6 6C    2 122 call    Main_GetSpeccy_Move         ; get the speccy move
6C8F 18 03       2 123 jr      Main_Update_Board           ; update board position
6C91             2 124 Main_Player_Move
6C91 CD 30 6D    2 125 call    Main_GetPlayer_Move         ; get a legal (empty position) player move 
6C94             2 126 Main_Update_Board
6C94             2 127 ; update positions with player/speccy move
6C94 CD ED 70    2 129 call    PathFinder_Friend           ; get player/speccy side
6C97 CD F6 70    2 130 call    PathFinder_PutToken         ; put token on cyan and red positions
6C9A             2 132 ; draw token on the board
6C9A AF          2 134 xor     a                           ; stop timers
6C9B 32 E8 62    2 135 ld      (TIMER_FLAG), a
6C9E CD B6 6D    2 136 call    Draw_Token                  ; animate hexagon sprite on the screen
6CA1 DD 21 E7 64 2 137 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6CA5 CD C9 76    2 138 call    Sound_FX                    ; play sound effect
6CA8             2 140 ; check for a winner
6CA8 CD 9F 75    2 142 call    PathFinder_VictoryPath      ; check current player victory path
6CAB 3C          2 143 inc     a                           ; is there a victory path?
6CAC 20 0B       2 144 jr      nz, Main_Match_End          ; yes, match ends
6CAE 21 9B 61    2 146 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CB1 34          2 147 inc     (hl)                        ; increment move number
6CB2             2 149 ; swap players' token color
6CB2 3A 9E 61    2 151 ld      a, (TOKEN_COLOR)            ; get current token color
6CB5 EE 07       2 152 xor     %00000111                   ; swap token color
6CB7 18 CA       2 153 jr      Main_Match_Loop             ; repeat match loop
6CB9             2 155 ; ----------------------------------------------------------------------------------------------------------------------
6CB9             2 156 ; Current player wins the match
6CB9             2 157 ; ----------------------------------------------------------------------------------------------------------------------
6CB9             2 158 Main_Match_End
6CB9 CD D4 75    2 159 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CBC 11 3A 62    2 161 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CBF CD 0F 6F    2 162 call    Print_Alert                 ; print string
6CC2 3A 9E 61    2 164 ld      a, (TOKEN_COLOR)            ; get current token color
6CC5 21 9F 61    2 165 ld      hl, PLAYER_COLOR            ; get player color
6CC8 BE          2 166 cp      (hl)                        ; is player color = current token color?
6CC9 21 0E 62    2 167 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CCC 28 04       2 168 jr      z, Main_ThreeRow_Increment  ; yes, go to increment three-in-a-row counter
6CCE 35          2 169 dec     (hl)                        ; decrement three-in-a-row counter
6CCF F2 D3 6C    2 170 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CD2             2 171 Main_ThreeRow_Increment
6CD2 34          2 172 inc     (hl)                        ; increment three-in-a-row counter
6CD3             2 173 Main_ThreeRow_Show
6CD3 CD ED 78    2 174 call    Screen_ThreeRow             ; show three-in-a-row marks
6CD6 3E FF       2 175 ld      a, 255                      ; set delay duration
6CD8 CD 8C 6D    2 176 call    Main_Delay                  ; execute delay
6CDB 3A 0E 62    2 177 ld      a, (THREE_ROW)              ; check three row counter
6CDE FE 03       2 178 cp      3                           ; is it 3?
6CE0 CA 33 6C    2 179 jp      z, Main_New_Level           ; yes, start a new level
6CE3 C3 4B 6C    2 180 jp      Main_Start_Match            ; start a new match
6CE6             2 182 ; ----------------------------------------------------------------------------------------------------------------------
6CE6             2 183 ; Main_GetSpeccy_Move: get the speccy move
6CE6             2 184 ;
6CE6             2 185 ; Input:     A = current token color
6CE6             2 186 ;
6CE6             2 187 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CE6             2 188 ;           HL = CYAN_POSITIONS move address
6CE6             2 189 ;
6CE6             2 190 ; Uses:     MOVE_NUMBER (current move number)
6CE6             2 191 ;           GAME_LEVEL (current game level)
6CE6             2 192 ;           AI_DEPTH (recursion depth level)
6CE6             2 193 ;           STR_MOVE (formatted move string)
6CE6             2 194 ;
6CE6             2 195 ; Destroys: A, DE, IX, IY
6CE6             2 196 ; ----------------------------------------------------------------------------------------------------------------------
6CE6             2 197 Main_GetSpeccy_Move:
6CE6 E6 03       2 198 and     %00000011                   ; calculate speccy's timer flag based on current token color
6CE8 32 E8 62    2 199 ld      (TIMER_FLAG), a             ; (re)start speccy timer
6CEB CD 28 6F    2 201 call    Print_Wait                  ; print "WAIT" message
6CEE 3A 9B 61    2 202 ld      a, (MOVE_NUMBER)            ; get move number
6CF1 3D          2 203 dec     a                           ; is it cyan first move?
6CF2 28 2A       2 204 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CF4 DD 21 00 7F 2 206 ld      ix, CANDIDATES              ; IX points to candidates list address
6CF8 3A 9D 61    2 207 ld      a, (GAME_LEVEL)             ; get game level
6CFB 32 9A 61    2 208 ld      (AI_DEPTH), a               ; save recursion depth level
6CFE CD ED 70    2 210 call    PathFinder_Friend           ; get speccy side
6D01 CD 79 6F    2 211 call    BRAINIAC_best_move          ; get speccy best move
6D04 6B          2 212 ld      l, e                        ; set node index in L
6D05             2 213 Main_GetSpeccy_Positions
6D05 26 7D       2 214 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D07 E5          2 215 push    hl                          ; store CYAN_POSITIONS move address
6D08 CD 7B 6D    2 216 call    Main_Board2Indexes          ; convert board position to indexes
6D0B 78          2 217 ld      a, b                        ; get 1..7 column
6D0C C6 60       2 218 add     a, $60                      ; adjust to charset ('a'..'g')
6D0E 32 15 62    2 219 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D11 79          2 220 ld      a, c                        ; get 1..7 row
6D12 C6 30       2 221 add     a, $30                      ; adjust to charset ('1'..'7')
6D14 32 18 62    2 222 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D17 C5          2 223 push    bc                          ; store hexagon board indexes
6D18 CD 36 6F    2 224 call    Print_Move                  ; print Speccy move
6D1B C1          2 225 pop     bc                          ; restore hexagon board indexes
6D1C E1          2 226 pop     hl                          ; restore CYAN_POSITIONS move address
6D1D C9          2 227 ret
6D1E             2 228 Main_GetSpeccy_Book
6D1E ED 5F       2 229 ld      a, r                        ; get a pseudo-random number (0..127)
6D20 E6 1F       2 230 and     %00011111                   ; number is in range (0..31)
6D22 FE 1B       2 231 cp      27                          ; is it >= 27?
6D24 30 F8       2 232 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D26 21 CD 62    2 233 ld      hl, OPENINGS                ; HL points to opening book address
6D29 16 00       2 234 ld      d, 0                        ; set index in DE
6D2B 5F          2 235 ld      e, a
6D2C 19          2 236 add     hl, de                      ; HL points to move index address
6D2D 6E          2 237 ld      l, (hl)                     ; get move from opening book
6D2E 18 D5       2 238 jr      Main_GetSpeccy_Positions    ; get speccy move positions
6D30             2 240 ; ----------------------------------------------------------------------------------------------------------------------
6D30             2 241 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D30             2 242 ;
6D30             2 243 ; Input:     A = current token color
6D30             2 244 ;
6D30             2 245 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D30             2 246 ;           HL = CYAN_POSITIONS move address
6D30             2 247 ;
6D30             2 248 ; Uses:     STR_MOVE (formatted move string)
6D30             2 249 ;
6D30             2 250 ; Destroys: A, DE, IX
6D30             2 251 ; ----------------------------------------------------------------------------------------------------------------------
6D30             2 252 Main_GetPlayer_Move:
6D30 E6 03       2 253 and     %00000011                   ; calculate player's timer flag based on current token color
6D32 32 E8 62    2 254 ld      (TIMER_FLAG), a             ; (re)start player timer
6D35             2 255 Main_GetPlayer_Input
6D35 CD 2F 6F    2 256 call    Print_Clear_Move            ; clear player last move
6D38 CD 25 6E    2 257 call    Input_Move                  ; wait for input player move
6D3B CD 36 6F    2 258 call    Print_Move                  ; print player move
6D3E 3A 15 62    2 260 ld      a, (STR_MOVE+0)             ; get column ('a'..'g')
6D41 D6 60       2 261 sub     $60                         ; convert to number (1..7)
6D43 47          2 262 ld      b, a                        ; set column index in B
6D44 3A 18 62    2 263 ld      a, (STR_MOVE+3)             ; get row ('1'..'7')
6D47 D6 30       2 264 sub     $30                         ; convert to number (1..7)
6D49 4F          2 265 ld      c, a                        ; set row index in C
6D4A 11 4D 62    2 266 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D4D CD 6E 6D    2 267 call    Main_Search_Table           ; search board position in board coordinates
6D50 6E          2 268 ld      l, (hl)                     ; set board position of player move
6D51 26 7D       2 269 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D53 3E 00       2 270 ld      a, EMPTY                    ; check position
6D55 BE          2 271 cp      (hl)                        ; is position empty?
6D56 C8          2 272 ret     z                           ; yes, return
6D57             2 274 ; illegal player move (position not empty)
6D57 11 2E 62    2 276 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D5A CD 0F 6F    2 277 call    Print_Alert                 ; print string
6D5D DD 21 F7 64 2 278 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D61 CD C9 76    2 279 call    Sound_FX                    ; play sound fx
6D64 3E 50       2 280 ld      a, 80                       ; set delay counter
6D66 CD 8C 6D    2 281 call    Main_Delay                  ; execute delay
6D69 CD 08 6F    2 282 call    Print_Clear_Alert           ; clear alert message
6D6C 18 C7       2 283 jr      Main_GetPlayer_Input        ; repeat player input until move is legal
6D6E             2 285 ; ----------------------------------------------------------------------------------------------------------------------
6D6E             2 286 ; Main_Search_Table: search an element in a 8x8 bytes table
6D6E             2 287 ;
6D6E             2 288 ; Input:    BC = element indexes (B = column, C = row)
6D6E             2 289 ;           DE = table address in which to search for the element
6D6E             2 290 ;
6D6E             2 291 ; Output:   DE = address of first element in the C row of the table
6D6E             2 292 ;           HL = address of the element in the BC indexes of the table
6D6E             2 293 ;
6D6E             2 294 ; Destroys: -
6D6E             2 295 ; ----------------------------------------------------------------------------------------------------------------------
6D6E             2 296 Main_Search_Table:
6D6E 26 00       2 297 ld      h, 0                        ; first, get the C row in table
6D70 69          2 298 ld      l, c                        ; set index in HL
6D71 29          2 299 add     hl, hl                      ; a row is 8 bytes long
6D72 29          2 300 add     hl, hl
6D73 29          2 301 add     hl, hl
6D74 19          2 302 add     hl, de                      ; HL points to the address of C row 
6D75 EB          2 303 ex      de, hl                      ; DE points to the address of C row
6D76 26 00       2 304 ld      h, 0                        ; go for to the B column
6D78 68          2 305 ld      l, b                        ; set index in HL
6D79 19          2 306 add     hl, de                      ; HL points to the address of BC indexes
6D7A C9          2 307 ret
6D7B             2 309 ; ----------------------------------------------------------------------------------------------------------------------
6D7B             2 310 ; Main_Board2Indexes: convert a board position into a board indexes
6D7B             2 311 ;
6D7B             2 312 ; Input:    L  = board position
6D7B             2 313 ;
6D7B             2 314 ; Output:   BC = board indexes (B = column, C = row)
6D7B             2 315 ;
6D7B             2 316 ; Destroys: HL
6D7B             2 317 ; ----------------------------------------------------------------------------------------------------------------------
6D7B             2 318 Main_Board2Indexes:
6D7B 7D          2 319 ld      a, l                        ; set board position in A to compare later
6D7C 21 8D 62    2 321 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D7F 0E 07       2 322 ld      c, 7                        ; 7 rows
6D81             2 323 Main_Board2Indexes_Row
6D81 06 07       2 324 ld      b, 7                        ; 7 columns
6D83             2 325 Main_Board2Indexes_Col
6D83 2B          2 326 dec     hl                          ; move HL to next board position address
6D84 BE          2 327 cp      (hl)                        ; is A the position?
6D85 C8          2 328 ret     z                           ; yes, return board indexes
6D86 10 FB       2 329 djnz    Main_Board2Indexes_Col      ; repeat for each column
6D88 2B          2 330 dec     hl                          ; skip borders
6D89 0D          2 331 dec     c                           ; decrement row
6D8A 18 F5       2 332 jr      Main_Board2Indexes_Row      ; loop until find position
6D8C             2 334 ; ----------------------------------------------------------------------------------------------------------------------
6D8C             2 335 ; Main_Delay: execute a delay
6D8C             2 336 ;
6D8C             2 337 ; Input:    A = delay counter
6D8C             2 338 ;
6D8C             2 339 ; Output:   -
6D8C             2 340 ;
6D8C             2 341 ; Destroys: A
6D8C             2 342 ; ----------------------------------------------------------------------------------------------------------------------
6D8C             2 343 Main_Delay:
6D8C C5          2 344 push    bc                          ; store register
6D8D             2 345 Main_Delay_Loop
6D8D 0E 0A       2 346 ld      c, 10                       ; set outer loop counter
6D8F             2 347 Main_Delay_Loop1
6D8F 06 00       2 348 ld      b, 0                        ; set inner loop counter (256)
6D91             2 349 Main_Delay_Loop2
6D91 10 FE       2 350 djnz    Main_Delay_Loop2            ; repeat until B=0
6D93 0D          2 351 dec     c                           ; decrement outer loop counter
6D94 20 F9       2 352 jr      nz, Main_Delay_Loop1        ; repeat until C=0
6D96 3D          2 353 dec     a                           ; decrement delay counter
6D97 20 F4       2 354 jr      nz, Main_Delay_Loop         ; repeat until A=0
6D99 C1          2 355 pop     bc                          ; restore register
6D9A C9          2 356 ret

; File #3: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Draw.z80asm

6D9B             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6D9B             3 2 ; Draw.z80asm
6D9B             3 3 ; Coded by Antonio Luque
6D9B             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6D9B             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6D9B             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6D9B             3 8 ;
6D9B             3 9 ; Input:    -
6D9B             3 10 ;
6D9B             3 11 ; Output:   -
6D9B             3 12 ;
6D9B             3 13 ; Uses:     TOKEN_COLOR (current token color)
6D9B             3 14 ;
6D9B             3 15 ; Destroys: A, BC, DE, HL, IXL
6D9B             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6D9B             3 17 Draw_Board:
6D9B 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6D9D 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6DA0 0E 07       3 20 ld      c, 7                        ; 7 rows
6DA2             3 21 Draw_Board_Row
6DA2 06 07       3 22 ld      b, 7                        ; 7 columns
6DA4             3 23 Draw_Board_Column
6DA4 CD D1 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DA7 CD 09 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DAA 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DAD CD DB 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DB0 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DB2 0D          3 29 dec     c                           ; decrement row
6DB3 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DB5 C9          3 31 ret
6DB6             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DB6             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DB6             3 35 ;
6DB6             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DB6             3 37 ;
6DB6             3 38 ; Output:   -
6DB6             3 39 ;
6DB6             3 40 ; Destroys: A, BC, DE, HL, IXL
6DB6             3 41 ; ----------------------------------------------------------------------------------------------------------------------
6DB6             3 42 Draw_Token:
6DB6 CD D1 6D    3 43 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DB9 01 04 06    3 44 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DBC 11 9E 65    3 45 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DBF             3 46 Draw_Token_Loop
6DBF E5          3 47 push    hl                          ; store hexagon screen address
6DC0 CD DB 6D    3 48 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DC3 E1          3 49 pop     hl                          ; restore hexagon screen address
6DC4 78          3 50 ld      a, b                        ; check loop counter
6DC5 B9          3 51 cp      c                           ; is it 4?
6DC6 CC 09 6E    3 52 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DC9             3 53 @Token_Delay
6DC9 3E 00       3 54 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DCB CD 8C 6D    3 55 call    Main_Delay                  ; execute delay
6DCE 10 EF       3 56 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DD0 C9          3 57 ret
6DD1             3 59 ; ----------------------------------------------------------------------------------------------------------------------
6DD1             3 60 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DD1             3 61 ;
6DD1             3 62 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DD1             3 63 ;
6DD1             3 64 ; Output:   HL = hexagon screen address 
6DD1             3 65 ;
6DD1             3 66 ; Destroys: A, DE
6DD1             3 67 ; ----------------------------------------------------------------------------------------------------------------------
6DD1             3 68 Draw_GetHEX_Screen:
6DD1 11 98 61    3 69 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DD4 CD 6E 6D    3 70 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DD7 6E          3 71 ld      l, (hl)                     ; set the low byte of the screen address in L
6DD8 1A          3 72 ld      a, (de)                     ; set the high byte of the screen address in H
6DD9 67          3 73 ld      h, a
6DDA C9          3 74 ret
6DDB             3 76 ; ----------------------------------------------------------------------------------------------------------------------
6DDB             3 77 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DDB             3 78 ;
6DDB             3 79 ; Input:    DE = hexagon sprite address
6DDB             3 80 ;           HL = hexagon screen address
6DDB             3 81 ;
6DDB             3 82 ; Output:   DE = next hexagon sprite address
6DDB             3 83 ;
6DDB             3 84 ; Destroys: A, HL, IXL
6DDB             3 85 ; ----------------------------------------------------------------------------------------------------------------------
6DDB             3 86 Draw_Sprite_Hexagon:
6DDB DD 2E 10    3 87 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DDE             3 88 Draw_Sprite_HexLoop
6DDE 1A          3 89 ld      a, (de)                     ; get sprite byte
6DDF 77          3 90 ld      (hl), a                     ; put sprite byte on screen
6DE0 13          3 91 inc     de                          ; move DE to next sprite byte address
6DE1 2C          3 92 inc     l                           ; move HL to next screen column
6DE2 1A          3 93 ld      a, (de)                     ; get sprite byte
6DE3 77          3 94 ld      (hl), a                     ; put sprite byte on screen
6DE4 13          3 95 inc     de                          ; move DE to next sprite byte
6DE5 2D          3 96 dec     l                           ; move HL to previous screen column
6DE6 CD FA 6D    3 97 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DE9 DD 2D       3 98 dec     ixl                         ; decrement sprite height
6DEB 20 F1       3 99 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6DED C9          3 100 ret
6DEE             3 102 ; ----------------------------------------------------------------------------------------------------------------------
6DEE             3 103 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6DEE             3 104 ;
6DEE             3 105 ; Input:    DE = letter/number sprite address
6DEE             3 106 ;           HL = letter/number screen address
6DEE             3 107 ;
6DEE             3 108 ; Output:   DE = next letter/number sprite address
6DEE             3 109 ;
6DEE             3 110 ; Destroys: A, C, HL
6DEE             3 111 ; ----------------------------------------------------------------------------------------------------------------------
6DEE             3 112 Draw_Sprite_LetterNum:
6DEE 0E 0A       3 113 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6DF0             3 114 Draw_Sprite_Loop
6DF0 1A          3 115 ld      a, (de)                     ; get sprite byte
6DF1 77          3 116 ld      (hl), a                     ; put sprite byte on screen
6DF2 13          3 117 inc     de                          ; move DE to next sprite byte address
6DF3 CD FA 6D    3 118 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6DF6 0D          3 119 dec     c                           ; decrement sprite height
6DF7 20 F7       3 120 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6DF9 C9          3 121 ret
6DFA             3 123 ; ----------------------------------------------------------------------------------------------------------------------
6DFA             3 124 ; Draw_Down_PixelLine: move HL down one pixel-line
6DFA             3 125 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6DFA             3 126 ;
6DFA             3 127 ; The screen address of a pixel-line is encoded as follows:
6DFA             3 128 ;
6DFA             3 129 ;             H           |           L
6DFA             3 130 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DFA             3 131 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6DFA             3 132 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6DFA             3 133 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6DFA             3 134 ;
6DFA             3 135 ; where:
6DFA             3 136 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6DFA             3 137 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6DFA             3 138 ;
6DFA             3 139 ; Input:    HL = pixel-line address
6DFA             3 140 ;
6DFA             3 141 ; Output:   HL = next (down) pixel-line address
6DFA             3 142 ;
6DFA             3 143 ; Destroys: A
6DFA             3 144 ; ----------------------------------------------------------------------------------------------------------------------
6DFA             3 145 Draw_Down_PixelLine:
6DFA 24          3 146 inc     h                           ; move HL down one pixel-line
6DFB 7C          3 147 ld      a, h                        ; get high byte of pixel-line address
6DFC E6 07       3 148 and     %00000111                   ; is pixel-line address inside a character line?
6DFE C0          3 149 ret     nz                          ; yes, return
6DFF 7D          3 150 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6E00 C6 20       3 151 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E02 6F          3 152 ld      l, a                        ; move HL down one character line
6E03 D8          3 153 ret     c                           ; a third was crossed? yes, return
6E04 7C          3 154 ld      a, h                        ; get high byte of pixel-line address
6E05 D6 08       3 155 sub     8                           ; clean up the bit from Y6
6E07 67          3 156 ld      h, a                        ; HL points to next (down) pixel-line address
6E08 C9          3 157 ret
6E09             3 159 ; ----------------------------------------------------------------------------------------------------------------------
6E09             3 160 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E09             3 161 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E09             3 162 ;
6E09             3 163 ; This routine converts a screen address (HL) into an attribute address (IX):
6E09             3 164 ;
6E09             3 165 ;             H           |           L
6E09             3 166 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E09             3 167 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E09             3 168 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E09             3 169 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E09             3 170 ;
6E09             3 171 ;            IXH          |          IXL
6E09             3 172 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E09             3 173 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E09             3 174 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E09             3 175 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E09             3 176 ;
6E09             3 177 ; where:
6E09             3 178 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E09             3 179 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E09             3 180 ;
6E09             3 181 ; Input:    HL = screen address of the hexagon
6E09             3 182 ;
6E09             3 183 ; Output:   IX = attribute address of the hexagon
6E09             3 184 ;
6E09             3 185 ; Uses:     TOKEN_COLOR (current token color)
6E09             3 186 ;
6E09             3 187 ; Destroys: A
6E09             3 188 ; ----------------------------------------------------------------------------------------------------------------------
6E09             3 189 Draw_Hexagon_Color:
6E09 7C          3 190 ld      a, h                        ; get high byte of screen address
6E0A F6 87       3 191 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E0C 1F          3 192 rra                                 ; shift Y7-Y6 two positions
6E0D 1F          3 193 rra
6E0E CB 3F       3 194 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E10 DD 67       3 195 ld      ixh, a                      ; set high byte of attribute address in IXH
6E12 7D          3 196 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E13 DD 6F       3 197 ld      ixl, a                      ; set low byte of attribute address in IXL
6E15 3A 9E 61    3 198 ld      a, (TOKEN_COLOR)            ; get current token color
6E18 DD 77 00    3 199 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E1B DD 77 01    3 200 ld      (ix+1), a
6E1E DD 77 20    3 201 ld      (ix+32), a
6E21 DD 77 21    3 202 ld      (ix+33), a
6E24 C9          3 203 ret

; File #4: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Input.z80asm

6E25             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E25             4 2 ; Input.z80asm
6E25             4 3 ; Coded by Antonio Luque
6E25             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E25             4 6 MAX_CHARS               equ     2                           ; maximum of input chars
6E25             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E25             4 9 ; Input_Move: wait for input a move from keyboard
6E25             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E25             4 11 ;
6E25             4 12 ; Input:    -
6E25             4 13 ;
6E25             4 14 ; Output:   -
6E25             4 15 ;
6E25             4 16 ; Uses:     TOKEN_COLOR (current token color)
6E25             4 17 ;           STR_MOVE (formatted move string)
6E25             4 18 ;
6E25             4 19 ; Destroys: A, A', BC, DE, HL, IX
6E25             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E25             4 21 Input_Move:
6E25 01 00 02    4 22 ld      bc, MAX_CHARS*256           ; B = maximum of input chars, C = chars counter
6E28 DD 21 83 5A 4 24 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E2C 21 83 50    4 25 ld      hl, $5083                   ; HL points to screen address of RED input text
6E2F 3A 9E 61    4 26 ld      a, (TOKEN_COLOR)            ; check current player color
6E32 FE 02       4 27 cp      RED_COLOR                   ; is RED the current token color?
6E34 28 07       4 28 jr      z, Input_Start              ; yes, start input
6E36 DD 21 19 59 4 29 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E3A 21 19 48    4 30 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E3D             4 31 Input_Start
6E3D DD 36 00 C7 4 32 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E41 3E 5F       4 33 ld      a, '_'                      ; text input cursor
6E43 CD 5F 6F    4 34 call    Print_Char                  ; print cursor
6E46             4 35 Input_Loop
6E46 CD BF 6E    4 36 call    Input_Key_Scan              ; scan for a key pressed
6E49 FE 0D       4 38 cp      $0D                         ; is it ENTER?
6E4B 28 64       4 39 jr      z, Input_Enter              ; yes, perform enter pressed
6E4D FE 30       4 40 cp      '0'                         ; is it "delete"? (char '0' acts as delete, without Shift)
6E4F 28 42       4 41 jr      z, Input_Delete             ; yes, perform delete char
6E51 08          4 42 ex      af, af'                     ; store char in A'
6E52 79          4 43 ld      a, c                        ; check number of chars inserted
6E53 B8          4 44 cp      b                           ; chars limit reached?
6E54 28 F0       4 45 jr      z, Input_Loop               ; yes, repeat input loop
6E56 B7          4 47 or      a                           ; is it the first char?
6E57 20 21       4 48 jr      nz, Input_Numbers           ; no, perform input of 2nd char
6E59             4 50 ; restrict first char to 'a'-'g'
6E59 08          4 52 ex      af, af'                     ; restore char
6E5A FE 61       4 53 cp      'a'                         ; is it < 'a'?
6E5C 38 E8       4 54 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E5E FE 68       4 55 cp      'h'                         ; is it >= 'g'?
6E60 30 E4       4 56 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E62             4 58 ; char is valid as column
6E62 32 15 62    4 60 ld      (STR_MOVE+0), a             ; save char in player move
6E65 DD 36 00 47 4 61 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E69 CD 5F 6F    4 62 call    Print_Char                  ; print key pressed
6E6C 0C          4 63 inc     c                           ; increment chars counter
6E6D 2C          4 64 inc     l                           ; increment X position of current input screen location
6E6E DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E70 3E 2D       4 66 ld      a, '-'                      ; set dash char
6E72 CD 5F 6F    4 67 call    Print_Char                  ; print key pressed
6E75 2C          4 68 inc     l                           ; increment X position of current input screen location
6E76 DD 2C       4 69 inc     ixl                         ; increment X position of current input attr location
6E78 18 C3       4 70 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E7A             4 71 Input_Numbers
6E7A             4 72 ; restrict second char to '1'-'7'
6E7A 08          4 74 ex      af, af'                     ; restore char
6E7B FE 31       4 75 cp      '1'                         ; is it < '1'?
6E7D 38 C7       4 76 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6E7F FE 38       4 77 cp      '8'                         ; is it >= '8'?
6E81 30 C3       4 78 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6E83             4 80 ; char is valid as row
6E83 32 18 62    4 82 ld      (STR_MOVE+3), a             ; save char in player move
6E86 DD 36 00 47 4 83 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E8A CD 5F 6F    4 84 call    Print_Char                  ; print key pressed
6E8D 0C          4 85 inc     c                           ; increment chars counter
6E8E 2C          4 86 inc     l                           ; increment X position of current input screen location
6E8F DD 2C       4 87 inc     ixl                         ; increment X position of current input attr location
6E91 18 AA       4 88 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6E93             4 90 ; player pressed "delete" (char '0')
6E93             4 91 Input_Delete
6E93 79          4 92 ld      a, c                        ; get char counter
6E94 B7          4 93 or      a                           ; is it 0?
6E95 28 AF       4 94 jr      z, Input_Loop               ; repeat input loop (no chars to delete)
6E97 DD 36 00 47 4 96 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E9B B8          4 97 cp      b                           ; is it the first char?
6E9C 28 08       4 98 jr      z, Input_Delete_Char        ; yes, continue delete
6E9E 3E 20       4 99 ld      a, ' '                      ; empty char
6EA0 CD 5F 6F    4 100 call    Print_Char                  ; delete cursor and last char
6EA3 2D          4 101 dec     l                           ; decrement X position of input screen location
6EA4 DD 2D       4 102 dec     ixl                         ; decrement X position of input attr location
6EA6             4 103 Input_Delete_Char
6EA6 0D          4 104 dec     c                           ; decrement char counter
6EA7 3E 20       4 105 ld      a, ' '                      ; empty char
6EA9 CD 5F 6F    4 106 call    Print_Char                  ; delete cursor and last char
6EAC 2D          4 107 dec     l                           ; decrement X position of player input screen location
6EAD DD 2D       4 108 dec     ixl                         ; decrement X position of player input attr location
6EAF 18 8C       4 109 jr      Input_Start                 ; get next char
6EB1             4 111 ; player pressed ENTER
6EB1             4 112 Input_Enter
6EB1 79          4 113 ld      a, c                        ; check char counter  
6EB2 B8          4 114 cp      b                           ; is it < MAX_CHARS?
6EB3 38 91       4 115 jr      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EB5 DD 36 00 47 4 117 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EB9 3E 20       4 118 ld      a, ' '                      ; empty char
6EBB CD 5F 6F    4 119 call    Print_Char                  ; delete cursor
6EBE C9          4 120 ret
6EBF             4 122 ; ----------------------------------------------------------------------------------------------------------------------
6EBF             4 123 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EBF             4 124 ;
6EBF             4 125 ;                           Bit
6EBF             4 126 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EBF             4 127 ;  ------+-------+-------+-------+-------+-------+
6EBF             4 128 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EBF             4 129 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EBF             4 130 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EBF             4 131 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EBF             4 132 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EBF             4 133 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EBF             4 134 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EBF             4 135 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EBF             4 136 ;
6EBF             4 137 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EBF             4 138 ;
6EBF             4 139 ; Input:    -
6EBF             4 140 ;
6EBF             4 141 ; Output:   A = ASCII code of key pressed
6EBF             4 142 ;
6EBF             4 143 ; Destroys: DE
6EBF             4 144 ; ----------------------------------------------------------------------------------------------------------------------
6EBF             4 145 Input_Key_Scan:
6EBF C5          4 146 push    bc                          ; store registers
6EC0 E5          4 147 push    hl
6EC1             4 148 Input_Key_Released
6EC1 01 FE FE    4 149 ld      bc, $FEFE                   ; set keyboard port (see above)
6EC4             4 150 Input_Key_Released_Line
6EC4 ED 78       4 151 in      a, (c)                      ; read port
6EC6 2F          4 152 cpl                                 ; invert bits
6EC7 E6 1F       4 153 and     %00011111                   ; check 0 to 4 bits
6EC9 20 F6       4 154 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6ECB CB 00       4 155 rlc     b                           ; move BC to the next port
6ECD 38 F5       4 156 jr      c, Input_Key_Released_Line  ; repeat for each port
6ECF 11 05 00    4 157 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6ED2             4 158 Input_Key_Pressed_Begin
6ED2 21 D8 61    4 159 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6ED5             4 160 Input_Key_Pressed_Line
6ED5 ED 78       4 161 in      a, (c)                      ; read port
6ED7 2F          4 162 cpl                                 ; invert bits
6ED8 E6 1F       4 163 and     %00011111                   ; check 0 to 4 bits
6EDA 20 08       4 164 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6EDC 19          4 165 add     hl, de                      ; HL points to the next KEY_MAP block
6EDD CB 00       4 166 rlc     b                           ; move BC to the next port
6EDF 38 F4       4 167 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6EE1 18 EF       4 168 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6EE3             4 169 Input_Key_Next
6EE3 23          4 170 inc     hl                          ; move HL to the next character
6EE4             4 171 Input_Key_Pressed
6EE4 1F          4 172 rra                                 ; rotate bits of port readed
6EE5 30 FC       4 173 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6EE7 7E          4 174 ld      a, (hl)                     ; return key pressed (ASCII) in A
6EE8 E1          4 175 pop     hl                          ; restore registers
6EE9 C1          4 176 pop     bc
6EEA C9          4 177 ret

; File #5: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Print.z80asm

6EEB             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6EEB             5 2 ; Print.z80asm
6EEB             5 3 ; Coded by Antonio Luque
6EEB             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6EEB             5 6 CHAR_SET                equ     FONT-256                    ; address of character set data, adjusted for ASCII codes
6EEB             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6EEB             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6EEB             5 10 ;
6EEB             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6EEB             5 12 ;
6EEB             5 13 ; Output:   -
6EEB             5 14 ;
6EEB             5 15 ; Destroys: A, BC, DE, HL
6EEB             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6EEB             5 17 Print_Players:
6EEB 11 21 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6EEE 01 1A 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6EF1 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6EF4 FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6EF6 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6EF8 11 1A 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6EFB 01 21 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6EFE             5 25 Print_Players_Strings
6EFE CD 53 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6F01 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F02 59          5 28 ld      e, c
6F03 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F06 18 4B       5 30 jr      Print_String                ; print "Player" or "Speccy"
6F08             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F08             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F08             5 34 ;
6F08             5 35 ; Input:    -
6F08             5 36 ; Output:   -
6F08             5 37 ; Destroys: A, BC, DE, HL, IX
6F08             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F08             5 39 Print_Clear_Alert:
6F08 11 46 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F0B 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F0D 18 02       5 42 jr      Print_Alert_XY              ; print (clear) alert string
6F0F             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F0F             5 45 ; Print_Alert: print an alert message below the current player input move
6F0F             5 46 ;
6F0F             5 47 ; Input:    DE = alert message string address
6F0F             5 48 ;
6F0F             5 49 ; Output:   -
6F0F             5 50 ;
6F0F             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F0F             5 52 ;
6F0F             5 53 ; Destroys: A, BC, DE, HL, IX
6F0F             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F0F             5 55 Print_Alert:
6F0F 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F11             5 57 Print_Alert_XY
6F11 DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F15 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F18 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F1B FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F1D 28 31       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F1F DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F23 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F26 18 28       5 65 jr      Print_String_Color          ; print alert string with color
6F28             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F28             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F28             5 69 ;
6F28             5 70 ; Input:    -
6F28             5 71 ;
6F28             5 72 ; Output:   -
6F28             5 73 ;
6F28             5 74 ; Destroys: A, BC, DE, HL, IX
6F28             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F28             5 76 Print_Wait:
6F28 11 35 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F2B 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F2D 18 0C       5 79 jr      Print_Move_XY               ; print wait string
6F2F             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F2F             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F2F             5 83 ;
6F2F             5 84 ; Input:    -
6F2F             5 85 ;
6F2F             5 86 ; Output:   -
6F2F             5 87 ;
6F2F             5 88 ; Destroys: A, BC, DE, HL, IX
6F2F             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F2F             5 90 Print_Clear_Move:
6F2F 11 41 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F32 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F34 18 05       5 93 jr      Print_Move_XY               ; print (clear) move string
6F36             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F36             5 96 ; Print_Move: print a formatted move at current player input move location 
6F36             5 97 ;
6F36             5 98 ; Input:    -
6F36             5 99 ;
6F36             5 100 ; Output:   -
6F36             5 101 ;
6F36             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F36             5 103 ;
6F36             5 104 ; Destroys: A, BC, DE, HL, IX
6F36             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F36             5 106 Print_Move:
6F36 11 15 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F39 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F3B             5 109 Print_Move_XY
6F3B DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F3F 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F42 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F45 FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F47 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F49 DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F4D 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F50             5 117 Print_String_Color
6F50 CD 6D 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F53             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F53             5 120 ; Print_String: print a string on the screen
6F53             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F53             5 122 ;
6F53             5 123 ; Input:    DE = string address (ending with 0)
6F53             5 124 ;           HL = string screen address
6F53             5 125 ;
6F53             5 126 ; Output:   -
6F53             5 127 ;
6F53             5 128 ; Destroys: A, DE, HL
6F53             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F53             5 130 Print_String:
6F53 1A          5 131 ld      a, (de)                     ; get string character
6F54 B7          5 132 or      a                           ; is it 0? (end of string)
6F55 C8          5 133 ret     z                           ; yes, return
6F56 D5          5 134 push    de                          ; store pointer to string address
6F57 CD 5F 6F    5 135 call    Print_Char                  ; print character
6F5A D1          5 136 pop     de                          ; restore pointer to string address
6F5B 13          5 137 inc     de                          ; move DE to next string character
6F5C 2C          5 138 inc     l                           ; move HL to next screen column
6F5D 18 F4       5 139 jr      Print_String                ; repeat until end of string
6F5F             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F5F             5 142 ; Print_Char: print a character on the screen
6F5F             5 143 ;
6F5F             5 144 ; Input:    A  = character to print (ASCII)
6F5F             5 145 ;           HL = character screen address
6F5F             5 146 ;
6F5F             5 147 ; Output:   -
6F5F             5 148 ;
6F5F             5 149 ; Destroys: A, DE
6F5F             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F5F             5 151 Print_Char:
6F5F 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F62             5 153 Print_Tile:
6F62 E5          5 154 push    hl                          ; store pointer to character/tile screen address
6F63 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F65 6F          5 156 ld      l, a
6F66 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6F67 29          5 158 add     hl, hl
6F68 29          5 159 add     hl, hl
6F69 19          5 160 add     hl, de                      ; move HL to character/tile address
6F6A EB          5 161 ex      de, hl                      ; DE points to character/tile address
6F6B E1          5 162 pop     hl                          ; restore pointer to character/tile screen address
6F6C C5          5 163 push    bc                          ; store BC register
6F6D 4C          5 164 ld      c, h                        ; save high byte of character/tile screen address
6F6E 06 08       5 165 ld      b, 8                        ; number of character/tile bytes (loop counter)
6F70             5 166 Print_Tile_Pixels
6F70 1A          5 167 ld      a, (de)                     ; get character/tile byte
6F71 77          5 168 ld      (hl), a                     ; put character/tile byte on screen
6F72 13          5 169 inc     de                          ; move DE to next character/tile byte
6F73 24          5 170 inc     h                           ; move HL down one pixel-line
6F74 10 FA       5 171 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6F76 61          5 172 ld      h, c                        ; restore high byte of character/tile screen address
6F77 C1          5 173 pop     bc                          ; restore BC register
6F78 C9          5 174 ret

; File #6: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Brainiac.z80asm

6F79             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6F79             6 2 ; Brainiac.z80asm
6F79             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F79             6 4 ;
6F79             6 5 ; Adapted for Hex game by Einar Saukas
6F79             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6F79             6 8 MIN_VALUE               equ     0                           ; alphaBeta pruning minimum value
6F79             6 9 MAX_VALUE               equ     255                         ; alphaBeta pruning maximum value
6F79             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6F79             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6F79             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6F79             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6F79             6 15 ; depth.
6F79             6 16 ;
6F79             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6F79             6 18 ;
6F79             6 19 ; Input:    A  = speccy side (FRIEND or ENEMY)
6F79             6 20 ;           IX = candidates vector address
6F79             6 21 ;
6F79             6 22 ; Output:   E  = selected position (speccy move)
6F79             6 23 ;
6F79             6 24 ; Uses:     AI_PLAYER (speccy side)
6F79             6 25 ;           AI_DEPTH (recursion depth level)
6F79             6 26 ;
6F79             6 27 ; Destroys: A, A', BC, D, HL, IX, IY
6F79             6 28 ; ----------------------------------------------------------------------------------------------------------------------
6F79             6 29 BRAINIAC_best_move:
6F79 32 99 61    6 30 ld      (AI_PLAYER), a              ; save speccy side
6F7C CD 77 74    6 32 call    PathFinder_Score            ; get board score
6F7F CD 1A 75    6 33 call    PathFinder_Candidates       ; get candidates from board potentials
6F82             6 35 ; BRAINIAC start
6F82             6 36 AI_First_Candidate
6F82 DD 7E 00    6 37 ld      a, (ix+0)                   ; A is our first candidate
6F85 5F          6 39 ld      e, a                        ; E = best speccy move (initialization)
6F86 16 00       6 40 ld      d, MIN_VALUE                ; D = alphaMax
6F88             6 42 AI_Main_Loop                                                ; for each candidate {
6F88 D5          6 43 push    de                          ;       store alphaMax and best speccy move
6F89 26 7D       6 45 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6F8B 6F          6 46 ld      l, a
6F8C E5          6 47 push    hl
6F8D 3A 99 61    6 49 ld      a, (AI_PLAYER)              ;       get speccy side
6F90 CD F6 70    6 50 call    PathFinder_PutToken         ;       BRAINIAC_play
6F93 EE 7C       6 51 xor     $7C                         ;       restore speccy side
6F95 1E FF       6 52 ld      e, MAX_VALUE                ;       E = betaMin
6F97 CD B0 6F    6 53 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6F9A E1          6 55 pop     hl                          ;       restore candidate position
6F9B CD FC 70    6 56 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6F9E D1          6 58 pop     de                          ;       restore alphaMax and best player node
6F9F BA          6 60 cp      d
6FA0 38 04       6 61 jr      c, AI_Main_Next
6FA2 28 02       6 62 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FA4 57          6 64 ld      d, a                        ;       alphaMax = A
6FA5 5D          6 65 ld      e, l                        ;       best move = E
6FA6             6 67 AI_Main_Next
6FA6 DD 2D       6 68 dec     ixl
6FA8 DD 7E 00    6 69 ld      a, (ix+0)                   ;       A is our next candidate
6FAB B7          6 70 or      a                           ;       repeat until no more candidates
6FAC C2 88 6F    6 71 jp      nz, AI_Main_Loop            ; }
6FAF C9          6 72 ret
6FB0             6 74 ; ----------------------------------------------------------------------------------------------------------------------
6FB0             6 75 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FB0             6 76 ; Speccy's score.
6FB0             6 77 ;
6FB0             6 78 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FB0             6 79 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FB0             6 80 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FB0             6 81 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FB0             6 82 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FB0             6 83 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FB0             6 84 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FB0             6 85 ; could be just reproducing the best score from its sibling.
6FB0             6 86 ;
6FB0             6 87 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB0             6 88 ;
6FB0             6 89 ; Input:    A = speccy side (FRIEND or ENEMY)
6FB0             6 90 ;           D = alphaMax
6FB0             6 91 ;           E = betaMin
6FB0             6 92 ;
6FB0             6 93 ; Output:   A = "improved" betaMin
6FB0             6 94 ;           D = alphaMax
6FB0             6 95 ;           E = "improved" betaMin
6FB0             6 96 ;
6FB0             6 97 ; Uses:     AI_PLAYER (speccy side)
6FB0             6 98 ;           AI_DEPTH (recursion depth level)
6FB0             6 99 ;
6FB0             6 100 ; Destroys: BC, HL, IX, IY
6FB0             6 101 ; ----------------------------------------------------------------------------------------------------------------------
6FB0             6 102 Alphabeta_Min:
6FB0 D5          6 103 push    de
6FB1             6 105 ; check if last speccy move is a winner one
6FB1 CD 77 74    6 107 call    PathFinder_Score            ; if (speccy won)
6FB4 B7          6 108 or      a
6FB5 C2 BF 6F    6 109 jp      nz, Alphabeta_Min_Candidates
6FB8 3A 9A 61    6 110 ld      a, (AI_DEPTH)
6FBB C6 E0       6 111 add     a, 224                      ;     return 224+depth
6FBD D1          6 112 pop     de
6FBE C9          6 113 ret
6FBF             6 115 Alphabeta_Min_Candidates
6FBF CD 1A 75    6 116 call    PathFinder_Candidates       ; find candidates for next move
6FC2 D1          6 117 pop     de
6FC3 DD 7E 00    6 119 ld      a, (ix+0)                   ; A is our first candidate
6FC6 21 9A 61    6 121 ld      hl, AI_DEPTH
6FC9 35          6 122 dec     (hl)                        ; depth--
6FCA CA 0A 70    6 123 jp      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
6FCD             6 125 Alphabeta_Min_Loop                                          ; for each candidate {
6FCD D5          6 126 push    de                          ;       store alphaMax and betaMin
6FCE 26 7D       6 128 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FD0 6F          6 129 ld      l, a
6FD1 E5          6 130 push    hl
6FD2 3A 99 61    6 132 ld      a, (AI_PLAYER)              ;       get speccy side
6FD5 EE 7C       6 133 xor     $7C                         ;       switch to player side
6FD7 CD F6 70    6 134 call    PathFinder_PutToken         ;       BRAINIAC_play
6FDA CD 4E 70    6 135 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
6FDD E1          6 137 pop     hl                          ;       restore candidate position
6FDE CD FC 70    6 138 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FE1 D1          6 140 pop     de                          ;       restore alphaMax and betaMin
6FE2 BB          6 142 cp      e
6FE3 30 06       6 143 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
6FE5 BA          6 145 cp      d
6FE6 38 12       6 146 jr      c, Alphabeta_Min_Exit
6FE8 28 10       6 147 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
6FEA 5F          6 149 ld      e, a                        ;       betaMin = A
6FEB             6 151 Alphabeta_Min_Next
6FEB DD 2D       6 152 dec     ixl
6FED DD 7E 00    6 153 ld      a, (ix+0)                   ;       A is our next candidate
6FF0 B7          6 154 or      a                           ;       repeat until no more candidates
6FF1 C2 CD 6F    6 155 jp      nz, Alphabeta_Min_Loop      ; }
6FF4 7B          6 157 ld      a, e                        ; return betaMin
6FF5 21 9A 61    6 159 ld      hl, AI_DEPTH
6FF8 34          6 160 inc     (hl)                        ; depth++
6FF9 C9          6 161 ret
6FFA             6 163 Alphabeta_Min_Exit
6FFA 5F          6 164 ld      e, a                        ; (discard remaining candidates)
6FFB AF          6 165 xor     a
6FFC             6 166 Alphabeta_Min_Skip
6FFC DD 2D       6 167 dec     ixl
6FFE DD BE 00    6 168 cp      (ix+0)
7001 C2 FC 6F    6 169 jp      nz, Alphabeta_Min_Skip
7004 7B          6 170 ld      a, e
7005 21 9A 61    6 172 ld      hl, AI_DEPTH
7008 34          6 173 inc     (hl)                        ; (depth++)
7009 C9          6 174 ret
700A             6 176 ; ----------------------------------------------------------------------------------------------------------------------
700A             6 177 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
700A             6 178 ; beta pruning, when it requires MINIMIZING Speccy's score.
700A             6 179 ;
700A             6 180 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
700A             6 181 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
700A             6 182 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
700A             6 183 ; faster.
700A             6 184 ;
700A             6 185 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
700A             6 186 ;
700A             6 187 ; Input:    A = first candidate
700A             6 188 ;           D = alphaMax
700A             6 189 ;           E = betaMin
700A             6 190 ;
700A             6 191 ; Output:   A = "improved" betaMin
700A             6 192 ;           D = alphaMax
700A             6 193 ;           E = "improved" betaMin
700A             6 194 ;
700A             6 195 ; Uses:     AI_PLAYER (speccy side)
700A             6 196 ;           AI_DEPTH (recursion depth level)
700A             6 197 ;
700A             6 198 ; Destroys: BC, HL, IX, IY
700A             6 199 ; ----------------------------------------------------------------------------------------------------------------------
700A             6 200 Heuristic_Min:                                              ; for each candidate {
700A D5          6 201 push    de                          ;       store alphaMax and betaMin
700B 26 7D       6 203 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
700D 6F          6 204 ld      l, a
700E E5          6 205 push    hl
700F 3A 99 61    6 207 ld      a, (AI_PLAYER)              ;       get speccy side
7012 EE 7C       6 208 xor     $7C                         ;       switch to player side
7014 CD F6 70    6 209 call    PathFinder_PutToken         ;       BRAINIAC_play
7017 CD 77 74    6 211 call    PathFinder_Score            ;       if (player won)
701A FE FF       6 212 cp      -1
701C C2 21 70    6 213 jp      nz, Heuristic_Min_Continue
701F 3E 20       6 214 ld      a, 32                       ;           A = 32
7021             6 215 Heuristic_Min_Continue
7021 E1          6 216 pop     hl
7022 CD FC 70    6 217 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7025 D1          6 219 pop     de
7026 BB          6 221 cp      e
7027 30 06       6 222 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
7029 BA          6 224 cp      d
702A 38 12       6 225 jr      c, Heuristic_Min_Exit
702C 28 10       6 226 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
702E 5F          6 228 ld      e, a                        ;       betaMin = A
702F             6 230 Heuristic_Min_Next
702F DD 2D       6 231 dec     ixl
7031 DD 7E 00    6 232 ld      a, (ix+0)                   ;       A is our next candidate
7034 B7          6 233 or      a                           ;       repeat until no more candidates
7035 C2 0A 70    6 234 jp      nz, Heuristic_Min           ; }
7038 7B          6 236 ld      a, e                        ; return betaMin
7039 21 9A 61    6 238 ld      hl, AI_DEPTH
703C 34          6 239 inc     (hl)                        ; depth++
703D C9          6 240 ret
703E             6 242 Heuristic_Min_Exit
703E 5F          6 243 ld      e, a                        ; (discard remaining candidates)
703F AF          6 244 xor     a
7040             6 245 Heuristic_Min_Skip
7040 DD 2D       6 246 dec     ixl
7042 DD BE 00    6 247 cp      (ix+0)
7045 C2 40 70    6 248 jp      nz, Heuristic_Min_Skip
7048 7B          6 249 ld      a, e
7049 21 9A 61    6 251 ld      hl, AI_DEPTH
704C 34          6 252 inc     (hl)                        ; (depth++)
704D C9          6 253 ret
704E             6 255 ; ----------------------------------------------------------------------------------------------------------------------
704E             6 256 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
704E             6 257 ; Speccy's score.
704E             6 258 ;
704E             6 259 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
704E             6 260 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
704E             6 261 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
704E             6 262 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
704E             6 263 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
704E             6 264 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
704E             6 265 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
704E             6 266 ; the same score and could be just reproducing the best score from its sibling.
704E             6 267 ;
704E             6 268 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
704E             6 269 ;
704E             6 270 ; Input:    A = speccy side (FRIEND or ENEMY)
704E             6 271 ;           D = alphaMax
704E             6 272 ;           E = betaMin
704E             6 273 ;
704E             6 274 ; Output:   A = "improved" alphaMax
704E             6 275 ;           D = "improved" alphaMax
704E             6 276 ;           E = betaMin
704E             6 277 ;
704E             6 278 ; Uses:     AI_PLAYER (speccy side)
704E             6 279 ;           AI_DEPTH (recursion depth level)
704E             6 280 ;
704E             6 281 ; Destroys: BC, HL, IX, IY
704E             6 282 ; ----------------------------------------------------------------------------------------------------------------------
704E             6 283 Alphabeta_Max:
704E D5          6 284 push    de
704F             6 286 ; check if last player move is a winner one
704F CD 77 74    6 288 call    PathFinder_Score            ; if (player won)
7052 FE FF       6 289 cp      -1
7054 C2 5F 70    6 290 jp      nz, Alphabeta_Max_Candidates
7057 3A 9A 61    6 291 ld      a, (AI_DEPTH)
705A 2F          6 292 cpl
705B C6 21       6 293 add     a, 32+1                     ;     return 32-depth
705D D1          6 294 pop     de
705E C9          6 295 ret
705F             6 297 Alphabeta_Max_Candidates
705F CD 1A 75    6 298 call    PathFinder_Candidates       ; find candidates for next move
7062 D1          6 299 pop     de
7063 DD 7E 00    6 301 ld      a, (ix+0)                   ; A is our first candidate
7066 21 9A 61    6 303 ld      hl, AI_DEPTH
7069 35          6 304 dec     (hl)                        ; depth--
706A CA AA 70    6 305 jp      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
706D             6 307 Alphabeta_Max_Loop                                          ; for each candidate {
706D D5          6 308 push    de                          ;       store alphaMax and betaMin
706E 26 7D       6 310 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7070 6F          6 311 ld      l, a
7071 E5          6 312 push    hl
7072 3A 99 61    6 314 ld      a, (AI_PLAYER)              ;       get speccy side
7075 CD F6 70    6 315 call    PathFinder_PutToken         ;       BRAINIAC_play
7078 EE 7C       6 316 xor     $7C                         ;       restore speccy side
707A CD B0 6F    6 317 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
707D E1          6 319 pop     hl                          ;       restore candidate position
707E CD FC 70    6 320 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7081 D1          6 322 pop     de                          ;       restore alphaMax and betaMin
7082 BA          6 324 cp      d
7083 38 06       6 325 jr      c, Alphabeta_Max_Next
7085 28 04       6 326 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
7087 BB          6 328 cp      e
7088 30 10       6 329 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
708A 57          6 331 ld      d, a                        ;       alphaMax = A
708B             6 333 Alphabeta_Max_Next
708B DD 2D       6 334 dec     ixl
708D DD 7E 00    6 335 ld      a, (ix+0)                   ;       A is our next candidate
7090 B7          6 336 or      a                           ;       repeat until no more candidates
7091 C2 6D 70    6 337 jp      nz, Alphabeta_Max_Loop      ; }
7094 7A          6 339 ld      a, d                        ; return alphaMax
7095 21 9A 61    6 341 ld      hl, AI_DEPTH
7098 34          6 342 inc     (hl)                        ; depth++
7099 C9          6 343 ret
709A             6 345 Alphabeta_Max_Exit
709A 57          6 346 ld      d, a                        ; (discard remaining candidates)
709B AF          6 347 xor     a
709C             6 348 Alphabeta_Max_Skip
709C DD 2D       6 349 dec     ixl
709E DD BE 00    6 350 cp      (ix+0)
70A1 C2 9C 70    6 351 jp      nz, Alphabeta_Max_Skip
70A4 7A          6 352 ld      a, d
70A5 21 9A 61    6 354 ld      hl, AI_DEPTH
70A8 34          6 355 inc     (hl)                        ; (depth++)
70A9 C9          6 356 ret
70AA             6 358 ; ----------------------------------------------------------------------------------------------------------------------
70AA             6 359 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70AA             6 360 ; beta pruning, when it requires MAXIMIZING Speccy's score.
70AA             6 361 ;
70AA             6 362 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70AA             6 363 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70AA             6 364 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70AA             6 365 ; faster.
70AA             6 366 ;
70AA             6 367 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70AA             6 368 ;
70AA             6 369 ; Input:    A = first candidate
70AA             6 370 ;           D = alphaMax
70AA             6 371 ;           E = betaMin
70AA             6 372 ;
70AA             6 373 ; Returns:  A = "improved" alphaMax
70AA             6 374 ;           D = "improved" alphaMax
70AA             6 375 ;           E = betaMin
70AA             6 376 ;
70AA             6 377 ; Uses:     AI_PLAYER (speccy side)
70AA             6 378 ;           AI_DEPTH (recursion depth level)
70AA             6 379 ;
70AA             6 380 ; Destroys: BC, HL, IX, IY
70AA             6 381 ; ----------------------------------------------------------------------------------------------------------------------
70AA             6 382 Heuristic_Max:                                              ; for each candidate {
70AA D5          6 383 push    de                          ;       store alphaMax and betaMin
70AB 26 7D       6 385 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70AD 6F          6 386 ld      l, a
70AE E5          6 387 push    hl
70AF 3A 99 61    6 389 ld      a, (AI_PLAYER)              ;       get speccy side
70B2 CD F6 70    6 390 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70B5 EE 7C       6 391 xor     $7C                         ;       restore speccy side
70B7 CD 77 74    6 393 call    PathFinder_Score            ;       if (speccy won)
70BA B7          6 394 or      a
70BB C2 C0 70    6 395 jp      nz, Heuristic_Max_Continue
70BE 3E E0       6 396 ld      a, 224                      ;           A = 224
70C0             6 397 Heuristic_Max_Continue
70C0 E1          6 398 pop     hl                          ;       restore candidate position
70C1 CD FC 70    6 399 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70C4 D1          6 401 pop     de                          ;       restore alphaMax and betaMin
70C5 BA          6 403 cp      d
70C6 38 06       6 404 jr      c, Heuristic_Max_Next
70C8 28 04       6 405 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
70CA BB          6 407 cp      e
70CB 30 10       6 408 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70CD 57          6 410 ld      d, a                        ;       alphaMax = A
70CE             6 412 Heuristic_Max_Next
70CE DD 2D       6 413 dec     ixl
70D0 DD 7E 00    6 414 ld      a, (ix+0)                   ;       A is our next candidate
70D3 B7          6 415 or      a                           ;       repeat until no more candidates
70D4 C2 AA 70    6 416 jp      nz, Heuristic_Max           ; }
70D7 7A          6 418 ld      a, d                        ; return alphaMax
70D8 21 9A 61    6 420 ld      hl, AI_DEPTH
70DB 34          6 421 inc     (hl)                        ; depth++
70DC C9          6 422 ret
70DD             6 424 Heuristic_Max_Exit
70DD 57          6 425 ld      d, a                        ; (discard remaining candidates)
70DE AF          6 426 xor     a
70DF             6 427 Heuristic_Max_Skip
70DF DD 2D       6 428 dec     ixl
70E1 DD BE 00    6 429 cp      (ix+0)
70E4 C2 DF 70    6 430 jp      nz, Heuristic_Max_Skip
70E7 7A          6 431 ld      a, d
70E8 21 9A 61    6 433 ld      hl, AI_DEPTH
70EB 34          6 434 inc     (hl)                        ; (depth++)
70EC C9          6 435 ret

; File #7: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\PathFinder.z80asm

70ED             7 1 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 2 ; PathFinder.z80asm
70ED             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
70ED             7 4 ;
70ED             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
70ED             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
70ED             7 7 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 9 EMPTY                   equ     $00                         ; empty positions on the board
70ED             7 10 SKIPPED                 equ     $01                         ; skipped positions on the board
70ED             7 11 FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
70ED             7 12 ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
70ED             7 13 VICTORY                 equ     $03                         ; internal value if victory
70ED             7 14 WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor
70ED             7 16 CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
70ED             7 17 RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
70ED             7 18 CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates
70ED             7 20 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 21 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
70ED             7 22 ;
70ED             7 23 ; Input:    -
70ED             7 24 ;
70ED             7 25 ; Output:   A   = FRIEND if current token color is cyan, or A = ENEMY if current token color is red
70ED             7 26 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70ED             7 27 ;
70ED             7 28 ; Uses:     TOKEN_COLOR (current token color)
70ED             7 29 ;
70ED             7 30 ; Destroys: -
70ED             7 31 ; ----------------------------------------------------------------------------------------------------------------------
70ED             7 32 PathFinder_Friend:
70ED 3A 9E 61    7 33 ld      a, (TOKEN_COLOR)            ; get current player color
70F0 EE 07       7 34 xor     $07                         ; is current player color cyan?
70F2 E0          7 35 ret     po                          ; yes, return FRIEND 
70F3 3E 7E       7 36 ld      a, ENEMY                    ; no, return ENEMY
70F5 C9          7 37 ret
70F6             7 39 ; ----------------------------------------------------------------------------------------------------------------------
70F6             7 40 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
70F6             7 41 ;
70F6             7 42 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
70F6             7 43 ;           HL = CYAN_POSITIONS token address
70F6             7 44 ;
70F6             7 45 ; Output:   A   = inverted side (FRIEND or ENEMY)
70F6             7 46 ;           P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
70F6             7 47 ;
70F6             7 48 ; Destroys: -
70F6             7 49 ; ----------------------------------------------------------------------------------------------------------------------
70F6             7 50 PathFinder_PutToken:
70F6 77          7 51 ld      (hl), a                     ; put token at cyan position
70F7 24          7 52 inc     h                           ; move HL to red position address
70F8 EE 7C       7 53 xor     $7C                         ; invert side
70FA 77          7 54 ld      (hl), a                     ; put token at red position
70FB C9          7 55 ret
70FC             7 57 ; ----------------------------------------------------------------------------------------------------------------------
70FC             7 58 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
70FC             7 59 ;
70FC             7 60 ; Input:    HL = CYAN_POSITIONS token address
70FC             7 61 ;
70FC             7 62 ; Output:   -
70FC             7 63 ;
70FC             7 64 ; Destroys: -
70FC             7 65 ; ----------------------------------------------------------------------------------------------------------------------
70FC             7 66 PathFinder_EraseToken:
70FC 36 00       7 67 ld      (hl), EMPTY                 ; erase token at cyan position
70FE 24          7 68 inc     h                           ; move HL to red position address
70FF 36 00       7 69 ld      (hl), EMPTY                 ; erase token at red position
7101 C9          7 70 ret
7102             7 72 ; ----------------------------------------------------------------------------------------------------------------------
7102             7 73 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
7102             7 74 ;
7102             7 75 ; Input:    DE = cyan or red board address (destiny)
7102             7 76 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
7102             7 77 ;
7102             7 78 ; Output:   -
7102             7 79 ;
7102             7 80 ; Destroys: BC, DE, HL
7102             7 81 ; ----------------------------------------------------------------------------------------------------------------------
7102             7 82 PathFinder_CopyPositions:
7102 01 31 00    7 83 ld      bc, 7*7                     ; number of positions to be copied
7105             7 84 PathFinder_CopyLoop
7105 2C          7 85 inc     l                           ; skip borders on positions
7106 2C          7 86 inc     l
7107 1C          7 87 inc     e                           ; skip borders on board
7108 1C          7 88 inc     e
7109 ED A0       7 89 ldi                                 ; copy a row of 7 positions
710B ED A0       7 90 ldi
710D ED A0       7 91 ldi
710F ED A0       7 92 ldi
7111 ED A0       7 93 ldi
7113 ED A0       7 94 ldi
7115 ED A0       7 95 ldi
7117 EA 05 71    7 96 jp      pe, PathFinder_CopyLoop     ; repeat for each row
711A C9          7 97 ret
711B             7 99 ; ----------------------------------------------------------------------------------------------------------------------
711B             7 100 ; PathFinder_Update: update current board position during heuristic function evaluation
711B             7 101 ;
711B             7 102 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
711B             7 103 ; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
711B             7 104 ; adjacent".
711B             7 105 ;
711B             7 106 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
711B             7 107 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
711B             7 108 ; follows, depending on current content:
711B             7 109 ;
711B             7 110 ; * SKIPPED: 1 + distance of neighbor closest to goal
711B             7 111 ; * FRIEND:  distance of neighbor closest to goal
711B             7 112 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
711B             7 113 ;
711B             7 114 ; Input:    Z  = flag set when (HL) is FRIEND
711B             7 115 ;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
711B             7 116 ;           HL = current position address (on either cyan boards or red boards)
711B             7 117 ;
711B             7 118 ; Output:   -
711B             7 119 ;
711B             7 120 ; Destroys: B, DE
711B             7 121 ; ----------------------------------------------------------------------------------------------------------------------
711B             7 122 PathFinder_Update:
711B 28 12       7 123 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
711D 46          7 124 ld      b, (hl)                     ; check current position
711E 10 1A       7 125 djnz    PathFinder_EMPTY
7120             7 126 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
7120             7 127 PathFinder_Skipped:
7120 71          7 128 ld      (hl), c                     ; save current distance in current position
7121 34          7 129 inc     (hl)                        ; increment distance of current position
7122 CB B6       7 130 res     6, (hl)                     ; reset friendly token flag
7124 EB          7 131 ex      de, hl                      ; store current position in DE
7125             7 132 @Queue_Tail
7125 21 00 00    7 133 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
7128 2C          7 134 inc     l                           ; move queue tail down
7129 73          7 135 ld      (hl), e                     ; store position into queue tail
712A 22 26 71    7 136 ld      (@Queue_Tail+1), hl         ; update queue tail
712D EB          7 137 ex      de, hl                      ; restore current position
712E C9          7 138 ret
712F             7 139 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
712F             7 140 PathFinder_Friendly
712F 71          7 141 ld      (hl), c                     ; save current distance in current position
7130 CB F6       7 142 set     6, (hl)                     ; set friendly token flag
7132 45          7 143 ld      b, l                        ; save current position in B
7133 D1          7 144 pop     de                          ; preserve RET address
7134 E3          7 145 ex      (sp), hl                    ; retrieve queue head
7135 70          7 146 ld      (hl), b                     ; push this position into queue head
7136 2D          7 147 dec     l                           ; move queue head up
7137 E3          7 148 ex      (sp), hl                    ; update queue head
7138 D5          7 149 push    de                          ; restore RET address
7139 C9          7 150 ret
713A             7 151 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
713A             7 152 PathFinder_EMPTY
713A CB 71       7 153 bit     6, c                        ; is current distance friendly?
713C 20 E2       7 154 jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
713E 34          7 155 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
713F C9          7 156 ret
7140             7 158 ; ----------------------------------------------------------------------------------------------------------------------
7140             7 159 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7140             7 160 ;
7140             7 161 ; Input:    -
7140             7 162 ;
7140             7 163 ; Output:   A = -1, if down edge couldn't be reached
7140             7 164 ;           A =  0, if there is chain of connected cyan tokens between the two edges
7140             7 165 ;           A = last edge position visited (-1), otherwise
7140             7 166 ;
7140             7 167 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7140             7 168 ;
7140             7 169 ; Destroys: BC, DE, HL, IY
7140             7 170 ; ----------------------------------------------------------------------------------------------------------------------
7140             7 171 PathFinder_Cyan_UpDown:
7140 21 07 7D    7 172 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7143 11 07 61    7 173 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
7146 CD 02 71    7 174 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
7149             7 176 ; entry point for PathFinder_VictoryPath
7149             7 177 PathFinder_Cyan_CheckPath:
7149 FD 21 00 09 7 178 ld      iy, $0900                   ; IYH = distance to check edge positions
714D             7 179 ; IYL = last edge position visited
714D 21 00 60    7 180 ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
7150 22 26 71    7 181 ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
7153 E5          7 182 push    hl                          ; store cyan queue head
7154             7 184 ; set up cyan board (up-down) start positions distances
7154 21 09 61    7 186 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7157 0E 43       7 187 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7159 3E 02       7 188 ld      a, FRIEND                   ; set distance to compare with
715B BE          7 189 cp      (hl)                        ; check 1st start position distance
715C D4 1B 71    7 190 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
715F 2C          7 191 inc     l                           ; move HL to next start position address
7160 BE          7 192 cp      (hl)                        ; check 2nd start position distance
7161 D4 1B 71    7 193 call    nc, PathFinder_Update       ; (repeat for each start position)
7164 2C          7 194 inc     l
7165 BE          7 195 cp      (hl)                        ; check 3rd start position distance
7166 D4 1B 71    7 196 call    nc, PathFinder_Update
7169 2C          7 197 inc     l
716A BE          7 198 cp      (hl)                        ; check 4th start position distance
716B D4 1B 71    7 199 call    nc, PathFinder_Update
716E 2C          7 200 inc     l
716F BE          7 201 cp      (hl)                        ; check 5th start position distance
7170 D4 1B 71    7 202 call    nc, PathFinder_Update
7173 2C          7 203 inc     l
7174 BE          7 204 cp      (hl)                        ; check 6th start position distance
7175 D4 1B 71    7 205 call    nc, PathFinder_Update
7178 2C          7 206 inc     l
7179 C3 66 72    7 207 jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)
717C             7 209 ; ----------------------------------------------------------------------------------------------------------------------
717C             7 210 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
717C             7 211 ;
717C             7 212 ; Input:    -
717C             7 213 ;
717C             7 214 ; Output:   A = -1, if up edge couldn't be reached
717C             7 215 ;           A =  0, if there is chain of connected cyan tokens between the two edges
717C             7 216 ;           A = last edge position visited (-1), otherwise
717C             7 217 ;
717C             7 218 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
717C             7 219 ;
717C             7 220 ; Destroys: BC, DE, HL, IY
717C             7 221 ; ----------------------------------------------------------------------------------------------------------------------
717C             7 222 PathFinder_Cyan_DownUp:
717C 21 07 7D    7 223 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
717F 11 4F 61    7 224 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
7182 CD 02 71    7 225 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
7185 FD 21 00 F7 7 227 ld      iy, $F700                   ; IYH = distance to check edge positions
7189             7 228 ; IYL = last edge position visited
7189 2A 26 71    7 229 ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
718C E5          7 230 push    hl                          ; initialize cyan queue head
718D             7 232 ; set up cyan board (down-up) start positions distances
718D EB          7 234 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
718E 2D          7 235 dec     l                           ; move HL to cyan boad down-up address (last position)
718F 0E 43       7 236 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
7191 3E 02       7 237 ld      a, FRIEND                   ; set distance to compare with
7193 BE          7 238 cp      (hl)                        ; check 1st start position distance
7194 D4 1B 71    7 239 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7197 2D          7 240 dec     l                           ; move HL to next start position address
7198 BE          7 241 cp      (hl)                        ; check 2nd start position distance
7199 D4 1B 71    7 242 call    nc, PathFinder_Update       ; (repeat for each start position)
719C 2D          7 243 dec     l
719D BE          7 244 cp      (hl)                        ; check 3rd start position distance
719E D4 1B 71    7 245 call    nc, PathFinder_Update
71A1 2D          7 246 dec     l
71A2 BE          7 247 cp      (hl)                        ; check 4th start position distance
71A3 D4 1B 71    7 248 call    nc, PathFinder_Update
71A6 2D          7 249 dec     l
71A7 BE          7 250 cp      (hl)                        ; check 5th start position distance
71A8 D4 1B 71    7 251 call    nc, PathFinder_Update
71AB 2D          7 252 dec     l
71AC BE          7 253 cp      (hl)                        ; check 6th start position distance
71AD D4 1B 71    7 254 call    nc, PathFinder_Update
71B0 2D          7 255 dec     l
71B1 C3 66 72    7 256 jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)
71B4             7 258 ; ----------------------------------------------------------------------------------------------------------------------
71B4             7 259 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71B4             7 260 ;
71B4             7 261 ; Input:    -
71B4             7 262 ;
71B4             7 263 ; Output:   A = -1, if right edge couldn't be reached
71B4             7 264 ;           A =  0, if there is chain of connected cyan tokens between the two edges
71B4             7 265 ;           A = last edge position visited (-1), otherwise
71B4             7 266 ;
71B4             7 267 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71B4             7 268 ;
71B4             7 269 ; Destroys: BC, DE, HL, IY
71B4             7 270 ; ----------------------------------------------------------------------------------------------------------------------
71B4             7 271 PathFinder_Red_LeftRight:
71B4 21 07 7E    7 272 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71B7 11 07 64    7 273 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71BA CD 02 71    7 274 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71BD             7 276 ; entry point for PathFinder_VictoryPath
71BD             7 277 PathFinder_Red_CheckPath
71BD FD 21 00 01 7 278 ld      iy, $0100                   ; IYH = distance to check edge positions
71C1             7 279 ; IYL = last edge position visited
71C1 21 00 63    7 280 ld      hl, RED_QUEUE_AREA          ; HL points to red queue area address
71C4 22 26 71    7 281 ld      (@Queue_Tail+1), hl         ; initialize red queue tail
71C7 E5          7 282 push    hl                          ; store red queue head
71C8             7 284 ; set up red board (left-right) start positions distances
71C8 21 09 64    7 286 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
71CB 0E 43       7 287 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
71CD 3E 02       7 288 ld      a, FRIEND                   ; set distance to compare with
71CF BE          7 289 cp      (hl)                        ; check 1st start position distance
71D0 D4 1B 71    7 290 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71D3 2E 12       7 291 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
71D5 BE          7 292 cp      (hl)                        ; check 2nd start position distance
71D6 D4 1B 71    7 293 call    nc, PathFinder_Update       ; (repeat for each start position)
71D9 2E 1B       7 294 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
71DB BE          7 295 cp      (hl)                        ; check 3rd start position distance
71DC D4 1B 71    7 296 call    nc, PathFinder_Update
71DF 2E 24       7 297 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
71E1 BE          7 298 cp      (hl)                        ; check 4th start position distance
71E2 D4 1B 71    7 299 call    nc, PathFinder_Update
71E5 2E 2D       7 300 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
71E7 BE          7 301 cp      (hl)                        ; check 5th start position distance
71E8 D4 1B 71    7 302 call    nc, PathFinder_Update
71EB 2E 36       7 303 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
71ED BE          7 304 cp      (hl)                        ; check 6th start position distance
71EE D4 1B 71    7 305 call    nc, PathFinder_Update
71F1 2E 3F       7 306 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
71F3 C3 66 72    7 307 jp      Path_Finder_First           ; calculate two-distances of red board (left-right)
71F6             7 309 ; ----------------------------------------------------------------------------------------------------------------------
71F6             7 310 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
71F6             7 311 ;
71F6             7 312 ; Input:    -
71F6             7 313 ;
71F6             7 314 ; Output:   A = -1, if left edge couldn't be reached
71F6             7 315 ;           A =  0, if there is chain of connected cyan tokens between the two edges
71F6             7 316 ;           A = last edge position visited (-1), otherwise
71F6             7 317 ;
71F6             7 318 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71F6             7 319 ;
71F6             7 320 ; Destroys: BC, DE, HL, IY
71F6             7 321 ; ----------------------------------------------------------------------------------------------------------------------
71F6             7 322 PathFinder_Red_RightLeft:
71F6 21 07 7E    7 323 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71F9 11 4F 64    7 324 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
71FC CD 02 71    7 325 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
71FF FD 21 00 FF 7 327 ld      iy, $FF00                   ; IYH = distance to check edge positions
7203             7 328 ; IYL = last edge position visited
7203 2A 26 71    7 329 ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
7206 E5          7 330 push    hl                          ; initialize red queue head
7207             7 332 ; set up red board (right-left) start positions distances
7207 EB          7 334 ex      de, hl                      ; take advantage of last "CopyPositions" execution
7208 2D          7 335 dec     l                           ; move HL to red board right-left address (last position)
7209 0E 43       7 336 ld      c, VICTORY+$40              ; set start positions distance + friendly flag
720B 3E 02       7 337 ld      a, FRIEND                   ; set distance to compare with
720D BE          7 338 cp      (hl)                        ; check 1st start position distance
720E D4 1B 71    7 339 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7211 2E 84       7 340 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
7213 BE          7 341 cp      (hl)                        ; check 2nd start position distance
7214 D4 1B 71    7 342 call    nc, PathFinder_Update       ; (repeat for each start position)
7217 2E 7B       7 343 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
7219 BE          7 344 cp      (hl)                        ; check 3rd start position distance
721A D4 1B 71    7 345 call    nc, PathFinder_Update
721D 2E 72       7 346 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
721F BE          7 347 cp      (hl)                        ; check 4th start position distance
7220 D4 1B 71    7 348 call    nc, PathFinder_Update
7223 2E 69       7 349 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
7225 BE          7 350 cp      (hl)                        ; check 5th start position distance
7226 D4 1B 71    7 351 call    nc, PathFinder_Update
7229 2E 60       7 352 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
722B BE          7 353 cp      (hl)                        ; check 6th start position distance
722C D4 1B 71    7 354 call    nc, PathFinder_Update
722F 2E 57       7 355 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
7231 C3 66 72    7 356 jp      Path_Finder_First           ; calculate red two-distance (right-left)
7234             7 358 ; ----------------------------------------------------------------------------------------------------------------------
7234             7 359 ; Path_Finder: calculate two-distance metric for each board position
7234             7 360 ;
7234             7 361 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
7234             7 362 ;
7234             7 363 ; Input:    HL  = cyan or red queue area address
7234             7 364 ;           IYH = distance to check edge positions
7234             7 365 ;           IYL = 0
7234             7 366 ;
7234             7 367 ; Output:   A = -1, if corresponding edge couldn't be reached
7234             7 368 ;           A =  0, if there is chain of connected (color) tokens between the two edges
7234             7 369 ;           A = last edge position visited (-1), otherwise
7234             7 370 ;
7234             7 371 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7234             7 372 ;
7234             7 373 ; Destroys: DE, HL, IY
7234             7 374 ; ----------------------------------------------------------------------------------------------------------------------
7234             7 375 Path_Finder:
7234 2C          7 376 inc     l                           ; move queue head down
7235 E5          7 377 push    hl                          ; preserve queue head address
7236 6E          7 378 ld      l, (hl)                     ; retrieve next position to be checked
7237 24          7 379 inc     h                           ; move HL to corresponding board address
7238 4E          7 380 ld      c, (hl)                     ; retrieve distance from this position to start
7239 5D          7 381 ld      e, l                        ; store current position
723A             7 383 ; look for adjacent positions
723A 7D          7 385 ld      a, l                        ; get current position
723B FD 84       7 386 add     a, iyh                      ; add distance to check edge positions
723D 6F          7 387 ld      l, a                        ; move HL to calculated position address
723E CB 7E       7 388 bit     7, (hl)                     ; is it an edge?
7240 20 34       7 389 jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions
7242 3E 02       7 391 ld      a, FRIEND                   ; set distance to compare with
7244             7 392 ; return point from PathFinder_Adjacent
7244             7 393 Path_Finder_Neighbors
7244 6B          7 394 ld      l, e                        ; restore current position to be checked
7245 2C          7 395 inc     l                           ; move HL to right neighbor address
7246 BE          7 396 cp      (hl)                        ; check right neighbor distance
7247 D4 1B 71    7 397 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
724A 2D          7 398 dec     l                           ; move HL to left neighbor address
724B 2D          7 399 dec     l
724C BE          7 400 cp      (hl)                        ; check left neighbor distance
724D D4 1B 71    7 401 call    nc, PathFinder_Update       ; (repeat for each neighbor)
7250 11 F8 FF    7 402 ld      de, -WIDTH
7253 19          7 403 add     hl, de
7254 BE          7 404 cp      (hl)                        ; check upper-left neighbor distance
7255 D4 1B 71    7 405 call    nc, PathFinder_Update
7258 2C          7 406 inc     l
7259 BE          7 407 cp      (hl)                        ; check upper-right neighbor distance
725A D4 1B 71    7 408 call    nc, PathFinder_Update
725D 11 10 00    7 409 ld      de, WIDTH*2
7260 19          7 410 add     hl, de
7261 BE          7 411 cp      (hl)                        ; check lower-left neighbor distance
7262 D4 1B 71    7 412 call    nc, PathFinder_Update
7265 2C          7 413 inc     l
7266             7 414 Path_Finder_First
7266 BE          7 415 cp      (hl)                        ; check lower-right neighbor distance
7267 D4 1B 71    7 416 call    nc, PathFinder_Update
726A E1          7 417 pop     hl                          ; retreive queue head address
726B 3A 26 71    7 418 ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
726E BD          7 419 cp      l                           ; is queue empty?
726F C2 34 72    7 420 jp      nz, Path_Finder             ; no, repeat until queue is empty
7272 FD 7D       7 422 ld      a, iyl                      ; get last edge position visited
7274 3D          7 423 dec     a                           ; return A = -1, if the edge couldn't be reached
7275 C9          7 424 ret
7276             7 426 ; ----------------------------------------------------------------------------------------------------------------------
7276             7 427 ; Check adjacent hexagons.
7276             7 428 ;
7276             7 429 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
7276             7 430 ; "two cells are adjacent if they share a common edge on the board."
7276             7 431 ;
7276             7 432 ; Input:    E  = current position
7276             7 433 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
7276             7 434 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
7276             7 435 ;                edge number)
7276             7 436 ;
7276             7 437 ; Output:   A = 0, if there is a chain of connected tokens of the same color between the two edges.
7276             7 438 ;           A = FRIEND and E = current position, otherwise.
7276             7 439 ;
7276             7 440 ; Destroys: DE, HL
7276             7 441 ; ----------------------------------------------------------------------------------------------------------------------
7276             7 442 Path_Finder_Adjacent
7276 3E 43       7 443 ld      a, VICTORY+$40              ; set victory distance + friendly flag
7278 B9          7 444 cp      c                           ; is current distance victory and friendly?
7279 28 0E       7 445 jr      z, Path_Finder_Abort        ; yes, abort path_finder
727B FD 6B       7 447 ld      iyl, e                      ; update last edge position visited
727D 54          7 448 ld      d, h                        ; store pointer to current position address in DE
727E 6E          7 449 ld      l, (hl)                     ; get current edge position
727F CB 25       7 450 sla     l                           ; calculate vector table routine index
7281 24          7 451 inc     h                           ; move HL to (cyan or red) vector table routine address
7282 7E          7 452 ld      a, (hl)                     ; get low byte of vector table routine address
7283 2C          7 453 inc     l                           ; move HL to high byte of vector table routine address
7284 66          7 454 ld      h, (hl)                     ; get high byte of vector table routine address
7285 6F          7 455 ld      l, a                        ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
7286 3E 02       7 456 ld      a, FRIEND                   ; set distance to compare with
7288 E9          7 457 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
7289             7 458 Path_Finder_Abort
7289 E1          7 459 pop     hl                          ; restore queue head address
728A AF          7 460 xor     a                           ; return A = 0
728B C9          7 461 ret
728C             7 463 ; ----------------------------------------------------------------------------------------------------------------------
728C             7 464 ;  Check two-distance of RED adjacents
728C             7 465 ; ----------------------------------------------------------------------------------------------------------------------
728C             7 466 PathFinder_RED_Edge_0
728C EB          7 467 ex      de, hl                      ; restore pointer to current position address
728D 11 12 00    7 468 ld      de, 9*2                     ; calculate distance to adjacent #2
7290 19          7 469 add     hl, de                      ; move HL to adjacent #2 address
7291 BE          7 470 cp      (hl)                        ; check adjacent #2 distance
7292 D4 1B 71    7 471 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
7295 11 09 00    7 472 ld      de, 9                       ; calculate distance to adjacent #3
7298 19          7 473 add     hl, de                      ; move HL to adjacent #3 address
7299 BE          7 474 cp      (hl)                        ; check adjacent #3 distance
729A D4 1B 71    7 475 call    nc, PathFinder_Update       ; (repeat for each adjacent)
729D 11 09 00    7 476 ld      de, 9
72A0 19          7 477 add     hl, de
72A1 BE          7 478 cp      (hl)                        ; check adjacent #4 distance
72A2 D4 1B 71    7 479 call    nc, PathFinder_Update
72A5 11 09 00    7 480 ld      de, 9
72A8 19          7 481 add     hl, de
72A9 BE          7 482 cp      (hl)                        ; check adjacent #5 distance
72AA D4 1B 71    7 483 call    nc, PathFinder_Update
72AD 11 09 00    7 484 ld      de, 9
72B0 19          7 485 add     hl, de
72B1 BE          7 486 cp      (hl)                        ; check adjacent #6 distance
72B2 D4 1B 71    7 487 call    nc, PathFinder_Update
72B5 FD 5D       7 488 ld      e, iyl                      ; restore current position
72B7 C3 44 72    7 489 jp      Path_Finder_Neighbors       ; continue processing neighbors
72BA             7 491 PathFinder_RED_Edge_1
72BA EB          7 492 ex      de, hl                      ; restore pointer to current position address
72BB 11 12 00    7 493 ld      de, 9*2
72BE 19          7 494 add     hl, de
72BF BE          7 495 cp      (hl)                        ; check adjacent #3 distance
72C0 D4 1B 71    7 496 call    nc, PathFinder_Update
72C3 11 09 00    7 497 ld      de, 9
72C6 19          7 498 add     hl, de
72C7 BE          7 499 cp      (hl)                        ; check adjacent #4 distance
72C8 D4 1B 71    7 500 call    nc, PathFinder_Update
72CB 11 09 00    7 501 ld      de, 9
72CE 19          7 502 add     hl, de
72CF BE          7 503 cp      (hl)                        ; check adjacent #5 distance
72D0 D4 1B 71    7 504 call    nc, PathFinder_Update
72D3 11 09 00    7 505 ld      de, 9
72D6 19          7 506 add     hl, de
72D7 BE          7 507 cp      (hl)                        ; check adjacent #6 distance
72D8 D4 1B 71    7 508 call    nc, PathFinder_Update
72DB FD 5D       7 509 ld      e, iyl                      ; restore current position
72DD C3 44 72    7 510 jp      Path_Finder_Neighbors       ; continue processing neighbors
72E0             7 512 PathFinder_RED_Edge_2
72E0 EB          7 513 ex      de, hl                      ; restore pointer to current position address
72E1 11 12 00    7 514 ld      de, 9*2
72E4 19          7 515 add     hl, de
72E5 BE          7 516 cp      (hl)                        ; check adjacent #4 distance
72E6 D4 1B 71    7 517 call    nc, PathFinder_Update
72E9 11 09 00    7 518 ld      de, 9
72EC 19          7 519 add     hl, de
72ED BE          7 520 cp      (hl)                        ; check adjacent #5 distance
72EE D4 1B 71    7 521 call    nc, PathFinder_Update
72F1 11 09 00    7 522 ld      de, 9
72F4 19          7 523 add     hl, de
72F5 BE          7 524 cp      (hl)                        ; check adjacent #6 distance
72F6 D4 1B 71    7 525 call    nc, PathFinder_Update
72F9 11 CA FF    7 526 ld      de, -9*6
72FC 19          7 527 add     hl, de
72FD BE          7 528 cp      (hl)                        ; check adjacent #0 distance
72FE D4 1B 71    7 529 call    nc, PathFinder_Update
7301 FD 5D       7 530 ld      e, iyl                      ; restore current position
7303 C3 44 72    7 531 jp      Path_Finder_Neighbors       ; continue processing neighbors
7306             7 533 PathFinder_RED_Edge_3
7306 EB          7 534 ex      de, hl                      ; restore pointer to current position address
7307 11 E5 FF    7 535 ld      de, -9*3
730A 19          7 536 add     hl, de
730B BE          7 537 cp      (hl)                        ; check adjacent #0 distance
730C D4 1B 71    7 538 call    nc, PathFinder_Update
730F 11 09 00    7 539 ld      de, 9
7312 19          7 540 add     hl, de
7313 BE          7 541 cp      (hl)                        ; check adjacent #1 distance
7314 D4 1B 71    7 542 call    nc, PathFinder_Update
7317 11 24 00    7 543 ld      de, 9*4
731A 19          7 544 add     hl, de
731B BE          7 545 cp      (hl)                        ; check adjacent #5 distance
731C D4 1B 71    7 546 call    nc, PathFinder_Update
731F 11 09 00    7 547 ld      de, 9
7322 19          7 548 add     hl, de
7323 BE          7 549 cp      (hl)                        ; check adjacent #6 distance
7324 D4 1B 71    7 550 call    nc, PathFinder_Update
7327 FD 5D       7 551 ld      e, iyl                      ; restore current position
7329 C3 44 72    7 552 jp      Path_Finder_Neighbors       ; continue processing neighbors
732C             7 554 PathFinder_RED_Edge_4
732C EB          7 555 ex      de, hl                      ; restore pointer to current position address
732D 11 12 00    7 556 ld      de, 9*2
7330 19          7 557 add     hl, de
7331 BE          7 558 cp      (hl)                        ; check adjacent #6 distance
7332 D4 1B 71    7 559 call    nc, PathFinder_Update
7335 11 CA FF    7 560 ld      de, -9*6
7338 19          7 561 add     hl, de
7339 BE          7 562 cp      (hl)                        ; check adjacent #0 distance
733A D4 1B 71    7 563 call    nc, PathFinder_Update
733D 11 09 00    7 564 ld      de, 9
7340 19          7 565 add     hl, de
7341 BE          7 566 cp      (hl)                        ; check adjacent #1 distance
7342 D4 1B 71    7 567 call    nc, PathFinder_Update
7345 11 09 00    7 568 ld      de, 9
7348 19          7 569 add     hl, de
7349 BE          7 570 cp      (hl)                        ; check adjacent #2 distance
734A D4 1B 71    7 571 call    nc, PathFinder_Update
734D FD 5D       7 572 ld      e, iyl                      ; restore current position
734F C3 44 72    7 573 jp      Path_Finder_Neighbors       ; continue processing neighbors
7352             7 575 PathFinder_RED_Edge_5
7352 EB          7 576 ex      de, hl                      ; restore pointer to current position address
7353 11 D3 FF    7 577 ld      de, -9*5
7356 19          7 578 add     hl, de
7357 BE          7 579 cp      (hl)                        ; check adjacent #0 distance
7358 D4 1B 71    7 580 call    nc, PathFinder_Update
735B 11 09 00    7 581 ld      de, 9
735E 19          7 582 add     hl, de
735F BE          7 583 cp      (hl)                        ; check adjacent #1 distance
7360 D4 1B 71    7 584 call    nc, PathFinder_Update
7363 11 09 00    7 585 ld      de, 9
7366 19          7 586 add     hl, de
7367 BE          7 587 cp      (hl)                        ; check adjacent #2 distance
7368 D4 1B 71    7 588 call    nc, PathFinder_Update
736B 11 09 00    7 589 ld      de, 9
736E 19          7 590 add     hl, de
736F BE          7 591 cp      (hl)                        ; check adjacent #3 distance
7370 D4 1B 71    7 592 call    nc, PathFinder_Update
7373 FD 5D       7 593 ld      e, iyl                      ; restore current position
7375 C3 44 72    7 594 jp      Path_Finder_Neighbors       ; continue processing neighbors
7378             7 596 PathFinder_RED_Edge_6
7378 EB          7 597 ex      de, hl                      ; restore pointer to current position address
7379 11 CA FF    7 598 ld      de, -9*6
737C 19          7 599 add     hl, de
737D BE          7 600 cp      (hl)                        ; check adjacent #0 distance
737E D4 1B 71    7 601 call    nc, PathFinder_Update
7381 11 09 00    7 602 ld      de, 9
7384 19          7 603 add     hl, de
7385 BE          7 604 cp      (hl)                        ; check adjacent #1 distance
7386 D4 1B 71    7 605 call    nc, PathFinder_Update
7389 11 09 00    7 606 ld      de, 9
738C 19          7 607 add     hl, de
738D BE          7 608 cp      (hl)                        ; check adjacent #2 distance
738E D4 1B 71    7 609 call    nc, PathFinder_Update
7391 11 09 00    7 610 ld      de, 9
7394 19          7 611 add     hl, de
7395 BE          7 612 cp      (hl)                        ; check adjacent #3 distance
7396 D4 1B 71    7 613 call    nc, PathFinder_Update
7399 11 09 00    7 614 ld      de, 9
739C 19          7 615 add     hl, de
739D BE          7 616 cp      (hl)                        ; check adjacent #4 distance
739E D4 1B 71    7 617 call    nc, PathFinder_Update
73A1 FD 5D       7 618 ld      e, iyl                      ; restore current position
73A3 C3 44 72    7 619 jp      Path_Finder_Neighbors       ; continue processing neighbors
73A6             7 621 ; ----------------------------------------------------------------------------------------------------------------------
73A6             7 622 ;  Check two-distance of CYAN adjacents
73A6             7 623 ; ----------------------------------------------------------------------------------------------------------------------
73A6             7 624 PathFinder_CYAN_Edge_0
73A6 EB          7 625 ex      de, hl                      ; restore pointer to current position address
73A7 2C          7 626 inc     l
73A8 2C          7 627 inc     l
73A9 BE          7 628 cp      (hl)                        ; check adjacent #2 distance
73AA D4 1B 71    7 629 call    nc, PathFinder_Update
73AD 2C          7 630 inc     l
73AE BE          7 631 cp      (hl)                        ; check adjacent #3 distance
73AF D4 1B 71    7 632 call    nc, PathFinder_Update
73B2 2C          7 633 inc     l
73B3 BE          7 634 cp      (hl)                        ; check adjacent #4 distance
73B4 D4 1B 71    7 635 call    nc, PathFinder_Update
73B7 2C          7 636 inc     l
73B8 BE          7 637 cp      (hl)                        ; check adjacent of edge number 5
73B9 D4 1B 71    7 638 call    nc, PathFinder_Update
73BC 2C          7 639 inc     l
73BD BE          7 640 cp      (hl)                        ; check adjacent of edge number 6
73BE D4 1B 71    7 641 call    nc, PathFinder_Update
73C1 FD 5D       7 642 ld      e, iyl                      ; restore current position
73C3 C3 44 72    7 643 jp      Path_Finder_Neighbors       ; continue processing neighbors
73C6             7 645 PathFinder_CYAN_Edge_1
73C6 EB          7 646 ex      de, hl                      ; restore pointer to current position address
73C7 2C          7 647 inc     l
73C8 2C          7 648 inc     l
73C9 BE          7 649 cp      (hl)                        ; check adjacent #3 distance
73CA D4 1B 71    7 650 call    nc, PathFinder_Update
73CD 2C          7 651 inc     l
73CE BE          7 652 cp      (hl)                        ; check adjacent #4 distance
73CF D4 1B 71    7 653 call    nc, PathFinder_Update
73D2 2C          7 654 inc     l
73D3 BE          7 655 cp      (hl)                        ; check adjacent #5 distance
73D4 D4 1B 71    7 656 call    nc, PathFinder_Update
73D7 2C          7 657 inc     l
73D8 BE          7 658 cp      (hl)                        ; check adjacent #6 distance
73D9 D4 1B 71    7 659 call    nc, PathFinder_Update
73DC FD 5D       7 660 ld      e, iyl                      ; restore current position
73DE C3 44 72    7 661 jp      Path_Finder_Neighbors       ; continue processing neighbors
73E1             7 663 PathFinder_CYAN_Edge_2
73E1 EB          7 664 ex      de, hl                      ; restore pointer to current position address
73E2 2D          7 665 dec     l
73E3 2D          7 666 dec     l
73E4 BE          7 667 cp      (hl)                        ; check adjacent #0 distance
73E5 D4 1B 71    7 668 call    nc, PathFinder_Update
73E8 2C          7 669 inc     l
73E9 2C          7 670 inc     l
73EA 2C          7 671 inc     l
73EB 2C          7 672 inc     l
73EC BE          7 673 cp      (hl)                        ; check adjacent #4 distance
73ED D4 1B 71    7 674 call    nc, PathFinder_Update
73F0 2C          7 675 inc     l
73F1 BE          7 676 cp      (hl)                        ; check adjacent #5 distance
73F2 D4 1B 71    7 677 call    nc, PathFinder_Update
73F5 2C          7 678 inc     l
73F6 BE          7 679 cp      (hl)                        ; check adjacent #6 distance
73F7 D4 1B 71    7 680 call    nc, PathFinder_Update
73FA FD 5D       7 681 ld      e, iyl                      ; restore current position
73FC C3 44 72    7 682 jp      Path_Finder_Neighbors       ; continue processing neighbors
73FF             7 684 PathFinder_CYAN_Edge_3
73FF EB          7 685 ex      de, hl                      ; restore pointer to current position address
7400 2D          7 686 dec     l
7401 2D          7 687 dec     l
7402 2D          7 688 dec     l
7403 BE          7 689 cp      (hl)                        ; check adjacent #0 distance
7404 D4 1B 71    7 690 call    nc, PathFinder_Update
7407 2C          7 691 inc     l
7408 BE          7 692 cp      (hl)                        ; check adjacent #1 distance
7409 D4 1B 71    7 693 call    nc, PathFinder_Update
740C 2C          7 694 inc     l
740D 2C          7 695 inc     l
740E 2C          7 696 inc     l
740F 2C          7 697 inc     l
7410 BE          7 698 cp      (hl)                        ; check adjacent #5 distance
7411 D4 1B 71    7 699 call    nc, PathFinder_Update
7414 2C          7 700 inc     l
7415 BE          7 701 cp      (hl)                        ; check adjacent #6 distance
7416 D4 1B 71    7 702 call    nc, PathFinder_Update
7419 FD 5D       7 703 ld      e, iyl                      ; restore current position
741B C3 44 72    7 704 jp      Path_Finder_Neighbors       ; continue processing neighbors
741E             7 706 PathFinder_CYAN_Edge_4
741E EB          7 707 ex      de, hl                      ; restore pointer to current position address
741F 2C          7 708 inc     l
7420 2C          7 709 inc     l
7421 BE          7 710 cp      (hl)                        ; check adjacent #6 distance
7422 D4 1B 71    7 711 call    nc, PathFinder_Update
7425 2D          7 712 dec     l
7426 2D          7 713 dec     l
7427 2D          7 714 dec     l
7428 2D          7 715 dec     l
7429 BE          7 716 cp      (hl)                        ; check adjacent #2 distance
742A D4 1B 71    7 717 call    nc, PathFinder_Update
742D 2D          7 718 dec     l
742E BE          7 719 cp      (hl)                        ; check adjacent #1 distance
742F D4 1B 71    7 720 call    nc, PathFinder_Update
7432 2D          7 721 dec     l
7433 BE          7 722 cp      (hl)                        ; check adjacent #0 distance
7434 D4 1B 71    7 723 call    nc, PathFinder_Update
7437 FD 5D       7 724 ld      e, iyl                      ; restore current position
7439 C3 44 72    7 725 jp      Path_Finder_Neighbors       ; continue processing neighbors
743C             7 727 PathFinder_CYAN_Edge_5
743C EB          7 728 ex      de, hl                      ; restore pointer to current position address
743D 2D          7 729 dec     l
743E 2D          7 730 dec     l
743F BE          7 731 cp      (hl)                        ; check adjacent #3 distance
7440 D4 1B 71    7 732 call    nc, PathFinder_Update
7443 2D          7 733 dec     l
7444 BE          7 734 cp      (hl)                        ; check adjacent #2 distance
7445 D4 1B 71    7 735 call    nc, PathFinder_Update
7448 2D          7 736 dec     l
7449 BE          7 737 cp      (hl)                        ; check adjacent #1 distance
744A D4 1B 71    7 738 call    nc, PathFinder_Update
744D 2D          7 739 dec     l
744E BE          7 740 cp      (hl)                        ; check adjacent #0 distance
744F D4 1B 71    7 741 call    nc, PathFinder_Update
7452 FD 5D       7 742 ld      e, iyl                      ; restore current position
7454 C3 44 72    7 743 jp      Path_Finder_Neighbors       ; continue processing neighbors
7457             7 745 PathFinder_CYAN_Edge_6
7457 EB          7 746 ex      de, hl                      ; restore pointer to current position address
7458 2D          7 747 dec     l
7459 2D          7 748 dec     l
745A BE          7 749 cp      (hl)                        ; check adjacent #4 distance
745B D4 1B 71    7 750 call    nc, PathFinder_Update
745E 2D          7 751 dec     l
745F BE          7 752 cp      (hl)                        ; check adjacent #3 distance
7460 D4 1B 71    7 753 call    nc, PathFinder_Update
7463 2D          7 754 dec     l
7464 BE          7 755 cp      (hl)                        ; check adjacent #2 distance
7465 D4 1B 71    7 756 call    nc, PathFinder_Update
7468 2D          7 757 dec     l
7469 BE          7 758 cp      (hl)                        ; check adjacent #1 distance
746A D4 1B 71    7 759 call    nc, PathFinder_Update
746D 2D          7 760 dec     l
746E BE          7 761 cp      (hl)                        ; check adjacent #0 distance
746F D4 1B 71    7 762 call    nc, PathFinder_Update
7472 FD 5D       7 763 ld      e, iyl                      ; restore current position
7474 C3 44 72    7 764 jp      Path_Finder_Neighbors       ; continue processing neighbors
7477             7 766 ; ----------------------------------------------------------------------------------------------------------------------
7477             7 767 ; PathFinder_Score: calculate board score depending on speccy color
7477             7 768 ;
7477             7 769 ; Input:    P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
7477             7 770 ;
7477             7 771 ; Output:   A = -1, if speccy can't reach his opposite edge
7477             7 772 ;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
7477             7 773 ;           A = speccy heuristic evaluation, otherwise
7477             7 774 ;
7477             7 775 ; Uses:     -
7477             7 776 ;
7477             7 777 ; Destroys: A', BC, DE, HL, IY
7477             7 778 ; ----------------------------------------------------------------------------------------------------------------------
7477             7 779 PathFinder_Score:
7477 E2 AB 74    7 780 jp      po, PathFinder_CyanScore    ; if speccy side is FRIEND, calculate CYAN score
747A             7 782 ; ----------------------------------------------------------------------------------------------------------------------
747A             7 783 ; PathFinder_RedScore: calculate red score
747A             7 784 ;
747A             7 785 ; Input:    -
747A             7 786 ;
747A             7 787 ; Output:   A = -1, if red can't reach his opposite edge
747A             7 788 ;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
747A             7 789 ;           A = red heuristic evaluation, otherwise
747A             7 790 ;
747A             7 791 ; Uses:     POTENTIALS (board potential and attack mobility)
747A             7 792 ;
747A             7 793 ; Destroys: A', BC, DE, HL, IY
747A             7 794 ; ----------------------------------------------------------------------------------------------------------------------
747A             7 795 PathFinder_RedScore
747A CD B4 71    7 796 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
747D C8          7 797 ret     z                           ; if red has a chain of connected tokens, return A = 0
747E 08          7 798 ex      af, af'                     ; save first result
747F CD F6 71    7 799 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
7482 47          7 800 ld      b, a                        ; save second result
7483 08          7 801 ex      af, af'                     ; restore first result
7484 90          7 802 sub     b                           ; subtract both results
7485 78          7 803 ld      a, b                        ; restore second result
7486 C8          7 804 ret     z                           ; if red can't reach his opposite edge, return A = -1
7487 CD 40 71    7 806 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
748A 08          7 807 ex      af, af'                     ; save result
748B CD 7C 71    7 808 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
748E 47          7 809 ld      b, a                        ; save second result
748F 08          7 810 ex      af, af'                     ; restore first result
7490 90          7 811 sub     b                           ; subtract both results
7491 C8          7 812 ret     z                           ; if cyan can't reach his opposite edge, return A = 0
7492 21 09 64    7 814 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
7495 11 51 64    7 815 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7498 CD E9 74    7 816 call    PathFinder_Potentials       ; calculate RED potentials
749B ED 43 97 61 7 817 ld      (POTENTIALS), bc            ; store RED potentials
749F 21 09 61    7 819 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74A2 11 51 61    7 820 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74A5 CD E9 74    7 821 call    PathFinder_Potentials       ; calculate cyan potentials
74A8 C3 D9 74    7 822 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74AB             7 824 ; ----------------------------------------------------------------------------------------------------------------------
74AB             7 825 ; PathFinder_CyanScore: calculate cyan score
74AB             7 826 ;
74AB             7 827 ; Input:    -
74AB             7 828 ;
74AB             7 829 ; Output:   A = -1, if cyan can't reach his opposite edge
74AB             7 830 ;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
74AB             7 831 ;           A = cyan heuristic evaluation, otherwise
74AB             7 832 ;
74AB             7 833 ; Uses:     POTENTIALS (board potential and attack mobility)
74AB             7 834 ;
74AB             7 835 ; Destroys: A', BC, DE, HL
74AB             7 836 ; ----------------------------------------------------------------------------------------------------------------------
74AB             7 837 PathFinder_CyanScore
74AB CD 40 71    7 838 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74AE C8          7 839 ret     z                           ; if cyan has a chain of connected tokens, return A = 0
74AF 08          7 840 ex      af, af'                     ; save result
74B0 CD 7C 71    7 841 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74B3 47          7 842 ld      b, a                        ; save second result
74B4 08          7 843 ex      af, af'                     ; restore first result
74B5 90          7 844 sub     b                           ; subtract both results
74B6 78          7 845 ld      a, b                        ; restore second result
74B7 C8          7 846 ret     z                           ; if cyan can't reach his opposite edge, return A = -1
74B8 CD B4 71    7 848 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74BB 08          7 849 ex      af, af'                     ; save result
74BC CD F6 71    7 850 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74BF 47          7 851 ld      b, a                        ; save second result
74C0 08          7 852 ex      af, af'                     ; restore first result
74C1 90          7 853 sub     b                           ; subtract both results
74C2 C8          7 854 ret     z                           ; if red can't reach his opposite edge, return A = 0
74C3 21 09 61    7 856 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74C6 11 51 61    7 857 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74C9 CD E9 74    7 858 call    PathFinder_Potentials       ; calculate cyan potentials
74CC ED 43 97 61 7 859 ld      (POTENTIALS), bc            ; save cyan potentials
74D0 21 09 64    7 861 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74D3 11 51 64    7 862 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74D6 CD E9 74    7 863 call    PathFinder_Potentials       ; calculate red potentials
74D9             7 864 ; ----------------------------------------------------------------------------------------------------------------------
74D9             7 865 ; PathFinder_Evaluation: calculate heuristic evaluation.
74D9             7 866 ; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
74D9             7 867 ;
74D9             7 868 ;                                       e = M (pC - pR) - (aC - aR)
74D9             7 869 ; where:
74D9             7 870 ;   pC = cyan board potential
74D9             7 871 ;   pR = red board potential
74D9             7 872 ;   aC = cyan attack mobility
74D9             7 873 ;   aR = red attack mobility
74D9             7 874 ;    M = a large number
74D9             7 875 ;
74D9             7 876 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
74D9             7 877 ;
74D9             7 878 ; Input:    B = opponent attack mobility
74D9             7 879 ;           C = opponent board potential
74D9             7 880 ;
74D9             7 881 ; Output:   A = heuristic evaluation
74D9             7 882 ;
74D9             7 883 ; Destroys: E, HL
74D9             7 884 ; ----------------------------------------------------------------------------------------------------------------------
74D9             7 885 PathFinder_Evaluation:
74D9 21 98 61    7 886 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
74DC 78          7 887 ld      a, b                        ; get opponent's attack mobility
74DD 96          7 888 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
74DE 5F          7 889 ld      e, a                        ; save the result in E
74DF 2D          7 890 dec     l                           ; move HL to player's board potential address
74E0 79          7 891 ld      a, c                        ; get opponent's board potential
74E1 96          7 892 sub     (hl)                        ; subtract potentials -> (pC - pR)
74E2 87          7 893 add     a, a                        ; multiply by 8 -> M (pC - pR)
74E3 87          7 894 add     a, a
74E4 87          7 895 add     a, a
74E5 93          7 896 sub     e                           ; subtract result of attack mobilities subtraction
74E6             7 897 ; -> M (pC - pR) - (aC - aR)
74E6 EE 80       7 898 xor     $80                         ; invert sign for easier further comparative
74E8 C9          7 899 ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))
74E9             7 901 ; ----------------------------------------------------------------------------------------------------------------------
74E9             7 902 ; PathFinder_Potentials: calculate board potential and attack mobility
74E9             7 903 ;
74E9             7 904 ; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
74E9             7 905 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
74E9             7 906 ;   the board.
74E9             7 907 ; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
74E9             7 908 ;
74E9             7 909 ; Input:    HL = cyan board or red board address
74E9             7 910 ;           DE = cyan board or red board address
74E9             7 911 ;
74E9             7 912 ; Output:   B = attack mobility
74E9             7 913 ;           C = board potential
74E9             7 914 ;
74E9             7 915 ; Destroys: A, DE, HL, IYL
74E9             7 916 ; ----------------------------------------------------------------------------------------------------------------------
74E9             7 917 PathFinder_Potentials:
74E9 01 FF 00    7 918 ld      bc, $00FF                   ; initialize attack mobility and board potential
74EC FD 2E 3D    7 919 ld      iyl, 61                     ; number of cells to be checked (loop counter)
74EF             7 920 Potentials_Loop
74EF 7E          7 921 ld      a, (hl)                     ; get cell's two-distance pointed by HL
74F0 FE 40       7 922 cp      $40                         ; is cell occupied or border?
74F2 30 14       7 923 jr      nc, Potentials_Next         ; yes, skip to next cell
74F4 FE 04       7 924 cp      $04                         ; cell distance was not updated?
74F6 38 18       7 925 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
74F8 1A          7 926 ld      a, (de)                     ; get cell's two-distance pointed by DE
74F9 FE 04       7 927 cp      $04                         ; cell distance was not updated?
74FB 38 13       7 928 jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
74FD 86          7 929 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
74FE 77          7 930 ld      (hl), a                     ; save potential in the cell pointed by HL
74FF B9          7 931 cp      c                           ; is the new potential = board potential?
7500 28 05       7 932 jr      z, Potentials_Increment     ; yes, increment attack mobility
7502 30 04       7 933 jr      nc, Potentials_Next         ; if (new potential > board potential) skip to next cell
7504 4F          7 934 ld      c, a                        ; board potential = new potential
7505 06 00       7 935 ld      b, 0                        ; restart attack mobility
7507             7 936 Potentials_Increment
7507 04          7 937 inc     b                           ; increment attack mobility
7508             7 938 Potentials_Next
7508 1C          7 939 inc     e                           ; move to next cell of each board
7509 2C          7 940 inc     l
750A FD 2D       7 941 dec     iyl                         ; decrement loop counter
750C C2 EF 74    7 942 jp      nz, Potentials_Loop         ; repeat until end of boards
750F C9          7 943 ret
7510             7 944 Potentials_Infinite
7510 CB FE       7 945 set     7, (hl)                     ; set cell potential as "infinite"
7512 1C          7 946 inc     e                           ; move to next cell of each board
7513 2C          7 947 inc     l
7514 FD 2D       7 948 dec     iyl                         ; decrement loop counter
7516 C2 EF 74    7 949 jp      nz, Potentials_Loop         ; repeat until end of boards
7519 C9          7 950 ret
751A             7 952 ; ----------------------------------------------------------------------------------------------------------------------
751A             7 953 ; PathFinder_Candidates: search candidates based on score result and boards potentials
751A             7 954 ;
751A             7 955 ; Input:    A  = -1, 0 or heuristic result
751A             7 956 ;           IX = candidates area address
751A             7 957 ;
751A             7 958 ; Output:   IX = first candidate address
751A             7 959 ;
751A             7 960 ; Uses:     AI_PLAYER (speccy side)
751A             7 961 ;
751A             7 962 ; Destroys: A, A', BC, DE, HL
751A             7 963 ; ----------------------------------------------------------------------------------------------------------------------
751A             7 964 PathFinder_Candidates:
751A DD 36 00 00 7 965 ld      (ix+0), 0                   ; set candidates endmarker
751E B7          7 967 or      a                           ; A = 0?
751F 28 3D       7 968 jr      z, Candidates_Winner        ; yes, fill candidates for winner color
7521 3C          7 969 inc     a                           ; A = -1?
7522 28 4E       7 970 jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color
7524             7 972 ; if score is not -1 nor 0, fill candidates from total potentials
7524 21 09 61    7 974 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7527 11 09 64    7 975 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
752A CD E9 74    7 976 call    PathFinder_Potentials       ; process candidates from total potentials
752D 79          7 978 ld      a, c                        ; set board potential in A
752E 08          7 979 ex      af, af'                     ; save board potential
752F 50          7 980 ld      d, b                        ; store attack mobility
7530 DD 5D       7 981 ld      e, ixl                      ; store candidates position
7532             7 983 ; insert the second best board potentials in candidates area
7532             7 984 Candidates_2ndBest
7532 2E 09       7 985 ld      l, 9                        ; HL points to board potentials address (1st position)
7534 0C          7 986 inc     c                           ; increment board potential
7535 79          7 987 ld      a, c                        ; A = second best potential
7536 FE 20       7 988 cp      $20                         ; is potential >= $20? (2nd best max potential)
7538 30 13       7 989 jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential
753A 06 3D       7 991 ld      b, 61                       ; number of cells to be checked (loop counter)
753C             7 992 Candidates_2ndBest_Loop
753C BE          7 993 cp      (hl)                        ; is current board potential = 2nd best board potential?
753D C2 45 75    7 994 jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
7540 DD 2C       7 995 inc     ixl                         ; yes, insert candidate
7542 DD 75 00    7 996 ld      (ix+0), l
7545             7 997 Candidates_2ndBest_Next
7545 2C          7 998 inc     l                           ; move HL to next board potential address
7546 10 F4       7 999 djnz    Candidates_2ndBest_Loop     ; repeat for each cell
7548 DD 7D       7 1000 ld      a, ixl                      ; A = current candidates position
754A BB          7 1001 cp      e                           ; new candidates inserted?
754B 28 E5       7 1002 jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted
754D             7 1004 Candidates_2ndBest_Exit
754D 42          7 1005 ld      b, d                        ; restore attack mobility
754E 08          7 1006 ex      af, af'                     ; restore board potential
754F             7 1008 ; insert the best board potentials in candidates area
754F             7 1009 Candidates_Best
754F 2E 08       7 1010 ld      l, 8                        ; HL points to board potential address (1st position -1)
7551             7 1011 Candidates_Best_Loop
7551 2C          7 1012 inc     l                           ; move HL to next board potential address
7552 BE          7 1013 cp      (hl)                        ; is current board potential equal to best board potential?
7553 C2 51 75    7 1014 jp      nz, Candidates_Best_Loop    ; no, next potential
7556 DD 2C       7 1015 inc     ixl                         ; yes, insert candidate
7558 DD 75 00    7 1016 ld      (ix+0), l
755B 10 F4       7 1017 djnz    Candidates_Best_Loop        ; repeat for each cell
755D C9          7 1018 ret
755E             7 1020 ; ----------------------------------------------------------------------------------------------------------------------
755E             7 1021 ; Fill candidates for winner color
755E             7 1022 ; ----------------------------------------------------------------------------------------------------------------------
755E             7 1023 Candidates_Winner
755E 3A 99 61    7 1024 ld      a, (AI_PLAYER)              ; check speccy side
7561 B7          7 1025 or      a                           ; is it FRIEND?
7562 EA 92 75    7 1026 jp      pe, Candidates_Red_Potential; no, fill candidates from red potentials
7565 21 09 61    7 1028 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7568 11 51 61    7 1029 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
756B CD E9 74    7 1030 call    PathFinder_Potentials       ; calculate cyan potentials
756E 79          7 1032 ld      a, c                        ; set board potential in A
756F C3 4F 75    7 1033 jp      Candidates_Best             ; fill only the best candidates
7572             7 1035 ; ----------------------------------------------------------------------------------------------------------------------
7572             7 1036 ; Fill candidates for defeated color
7572             7 1037 ; ----------------------------------------------------------------------------------------------------------------------
7572             7 1038 Candidates_Defeat
7572 3A 99 61    7 1039 ld      a, (AI_PLAYER)              ; check speccy side
7575 B7          7 1040 or      a                           ; is it FRIEND?
7576 E2 8C 75    7 1041 jp      po, Candidates_Red          ; yes, fill candidates from red potentials
7579             7 1043 ; if RED is defeated, candidates are chosen from cyan board potentials
7579 CD 40 71    7 1045 call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
757C CD 7C 71    7 1046 call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
757F 21 09 61    7 1047 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7582 11 51 61    7 1048 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7585 CD E9 74    7 1049 call    PathFinder_Potentials       ; calculate cyan potentials
7588 79          7 1051 ld      a, c                        ; set board potential in A
7589 C3 4F 75    7 1052 jp      Candidates_Best             ; fill only the best candidates
758C             7 1054 ; if CYAN is defeated, candidates are chosen from red board potentials
758C             7 1055 Candidates_Red
758C CD B4 71    7 1056 call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
758F CD F6 71    7 1057 call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
7592             7 1058 Candidates_Red_Potential
7592 21 09 64    7 1059 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
7595 11 51 64    7 1060 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7598 CD E9 74    7 1061 call    PathFinder_Potentials       ; calculate red potentials
759B 79          7 1063 ld      a, c                        ; set board potential in A
759C C3 4F 75    7 1064 jp      Candidates_Best             ; fill only the best candidates
759F             7 1066 ; ----------------------------------------------------------------------------------------------------------------------
759F             7 1067 ; PathFinder_VictoryPath: calculate current player victory path
759F             7 1068 ;
759F             7 1069 ; Input:    -
759F             7 1070 ;
759F             7 1071 ; Output:   A = -1, if there isn't a victory path
759F             7 1072 ;           A = start position (-1) of the victory path, otherwise
759F             7 1073 ;
759F             7 1074 ; Uses:     TOKEN_COLOR (current token color)
759F             7 1075 ;
759F             7 1076 ; Destroys: BC, DE, HL, IY
759F             7 1077 ; ----------------------------------------------------------------------------------------------------------------------
759F             7 1078 PathFinder_VictoryPath:
759F 3A 9E 61    7 1079 ld      a, (TOKEN_COLOR)            ; get current token color
75A2 FE 05       7 1080 cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
75A4 28 0C       7 1081 jr      z, PathFinder_VictoryPath_Cyan
75A6 CD B4 71    7 1083 call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
75A9 21 45 64    7 1084 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75AC CD BE 75    7 1085 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75AF C3 BD 71    7 1086 jp      PathFinder_Red_CheckPath    ; calculate RED victory path
75B2             7 1088 PathFinder_VictoryPath_Cyan
75B2 CD 40 71    7 1089 call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
75B5 21 45 61    7 1090 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75B8 CD BE 75    7 1091 call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
75BB C3 49 71    7 1092 jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path
75BE             7 1094 ; ----------------------------------------------------------------------------------------------------------------------
75BE             7 1095 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to 1, everything else to ENEMY.
75BE             7 1096 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
75BE             7 1097 ; [color]' again to find a victory path.
75BE             7 1098 ;
75BE             7 1099 ; Coded by Einar Saukas
75BE             7 1100 ;
75BE             7 1101 ; Input:    HL = pointer to last position of [color]_BOARD
75BE             7 1102 ;
75BE             7 1103 ; Output:   -
75BE             7 1104 ;
75BE             7 1105 ; Destroys: A, BC, HL
75BE             7 1106 ; ----------------------------------------------------------------------------------------------------------------------
75BE             7 1107 PathFinder_PrepareBoard:
75BE 3E 43       7 1108 ld      a, VICTORY+$40              ; set victory distance + friendly flag
75C0 0E 07       7 1109 ld      c, 7                        ; 7 rows
75C2             7 1110 PrepareBoard_Row
75C2 06 07       7 1111 ld      b, 7                        ; 7 columns
75C4             7 1112 PrepareBoard_Column
75C4 BE          7 1113 cp      (hl)                        ; is it win condition?
75C5 36 01       7 1114 ld      (hl), 1                     ; save 1 by default
75C7 28 02       7 1115 jr      z, PrepareBoard_Next        ; yes, next position
75C9 36 7E       7 1116 ld      (hl), ENEMY                 ; no, save ENEMY
75CB             7 1117 PrepareBoard_Next
75CB 2D          7 1118 dec     l                           ; HL points to next board position
75CC 10 F6       7 1119 djnz    PrepareBoard_Column         ; repeat for each column
75CE 2D          7 1121 dec     l                           ; skip borders
75CF 2D          7 1122 dec     l
75D0 0D          7 1123 dec     c                           ; decrement rows
75D1 20 EF       7 1124 jr      nz, PrepareBoard_Row        ; repeat for each row
75D3 C9          7 1125 ret
75D4             7 1127 ; ----------------------------------------------------------------------------------------------------------------------
75D4             7 1128 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75D4             7 1129 ;
75D4             7 1130 ; Input:    A  = start position of the victory path
75D4             7 1131 ;           HL = [color]_QUEUE_AREA address
75D4             7 1132 ;
75D4             7 1133 ; Output:   -
75D4             7 1134 ;
75D4             7 1135 ; Uses:     TOKEN_COLOR (current token color)
75D4             7 1136 ;
75D4             7 1137 ; Destroys: A, BC, DE, HL, IX
75D4             7 1138 ; ----------------------------------------------------------------------------------------------------------------------
75D4             7 1139 PathFinder_BrightPath:
75D4 44          7 1140 ld      b, h                        ; store high byte of QUEUE_AREA address
75D5 21 9E 61    7 1142 ld      hl, TOKEN_COLOR             ; get current token color address
75D8 CB F6       7 1143 set     6, (hl)                     ; switch on bright attribute
75DA 21 CA 6D    7 1144 ld      hl, @Token_Delay+1          ; set delay duration for animate hexagons
75DD 36 04       7 1145 ld      (hl), 4
75DF 60          7 1147 ld      h, b                        ; restore high byte of QUEUE_AREA address
75E0 6F          7 1148 ld      l, a                        ; move HL to the start position of the victory path
75E1 24          7 1149 inc     h
75E2 4E          7 1150 ld      c, (hl)                     ; set current victory path length in C
75E3 06 03       7 1151 ld      b, VICTORY                  ; set victory length in B
75E5 18 1C       7 1152 jr      BrightPath_Position         ; animate and highlight the hexagon position
75E7             7 1154 BrightPath_Neighbor
75E7 2C          7 1155 inc     l                           ; move HL to left neighbor address
75E8 BE          7 1156 cp      (hl)                        ; is it the same as current victory path length?
75E9 28 18       7 1157 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75EB 2D          7 1158 dec     l                           ; move HL to right neighbor address
75EC 2D          7 1159 dec     l
75ED BE          7 1160 cp      (hl)                        ; is it the same as current victory path length?
75EE 28 13       7 1161 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F0 11 F8 FF    7 1162 ld      de, -WIDTH                  ; move HL to upper-right neighbor address
75F3 19          7 1163 add     hl, de
75F4 BE          7 1164 cp      (hl)                        ; is it the same as current victory path length?
75F5 28 0C       7 1165 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75F7 2C          7 1166 inc     l                           ; move HL to upper-left neighbor address
75F8 BE          7 1167 cp      (hl)                        ; is it the same as current victory path length?
75F9 28 08       7 1168 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
75FB 11 10 00    7 1169 ld      de, WIDTH*2                 ; move HL to lower-right neighbor address
75FE 19          7 1170 add     hl, de
75FF BE          7 1171 cp      (hl)                        ; is it the same as current victory path length?
7600 28 01       7 1172 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7602 2C          7 1173 inc     l                           ; move HL to lower-left neighbor address
7603             7 1174 BrightPath_Position
7603 C5          7 1175 push    bc                          ; store current victory path length
7604 E5          7 1176 push    hl                          ; store current position pointer
7605 CD 7B 6D    7 1178 call    Main_Board2Indexes          ; convert a board position into a board indexes
7608 CD B6 6D    7 1179 call    Draw_Token                  ; animate hexagon sprite on the screen
760B DD 21 E7 64 7 1180 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
760F CD C9 76    7 1181 call    Sound_FX                    ; play sound effect
7612 E1          7 1183 pop     hl                          ; restore current position pointer
7613 C1          7 1184 pop     bc                          ; restore current victory path length
7614 0D          7 1186 dec     c                           ; decrement current victory path length
7615 79          7 1187 ld      a, c                        ; set current victory path length in A
7616 B8          7 1188 cp      b                           ; has reached victory length?
7617 20 CE       7 1189 jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach victory length
7619 21 9E 61    7 1191 ld      hl, TOKEN_COLOR             ; get current token color address
761C CB B6       7 1192 res     6, (hl)                     ; switch off bright attribute
761E C9          7 1193 ret

; File #8: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Timer.z80asm

761F             8 1 ; ----------------------------------------------------------------------------------------------------------------------
761F             8 2 ; Timer.z80asm
761F             8 3 ; Coded by Antonio Luque
761F             8 4 ;
761F             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
761F             8 6 ; ----------------------------------------------------------------------------------------------------------------------
761F             8 8 ; ----------------------------------------------------------------------------------------------------------------------
761F             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
761F             8 10 ;
761F             8 11 ; Input:    -
761F             8 12 ;
761F             8 13 ; Output:   -
761F             8 14 ;
761F             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
761F             8 16 ;
761F             8 17 ; Destroys: BC', DE', HL'
761F             8 18 ; ----------------------------------------------------------------------------------------------------------------------
761F             8 19 Timer_Interrupt:
761F F5          8 20 push    af                          ; store AF register
7620 D9          8 21 exx                                 ; store BC, DE and HL registers
7621 3A E8 62    8 23 ld      a, (TIMER_FLAG)             ; check timer flag
7624 B7          8 24 or      a                           ; is timer stopped?
7625 CA 4E 76    8 25 jp      z, Timer_Exit               ; yes, exit routine
7628 21 EC 62    8 27 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
762B 3D          8 28 dec     a                           ; is red timer on?
762C C2 32 76    8 29 jp      nz, Timer_Counters          ; yes, check interrupt counter 
762F 21 E9 62    8 30 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
7632             8 31 Timer_Counters
7632 35          8 32 dec     (hl)                        ; decrement interrupt counter
7633 C2 4E 76    8 33 jp      nz, Timer_Exit              ; if not 0, exit routine
7636 36 32       8 35 ld      (hl), 50                    ; restart interrupt counter
7638 23          8 36 inc     hl                          ; move HL to seconds counter address
7639 3E 01       8 37 ld      a, 1                        ; increment seconds counter
763B 86          8 38 add     a, (hl)
763C 27          8 39 daa                                 ; convert to BCD (Binary-Coded-Decimal)
763D 77          8 40 ld      (hl), a                     ; store seconds
763E FE 60       8 41 cp      $60                         ; 60 seconds reached?
7640 C2 4B 76    8 42 jp      nz, Timer_Show              ; no, show timer
7643 36 00       8 43 ld      (hl), 0                     ; restart seconds counter
7645 23          8 44 inc     hl                          ; move HL to minutes counter address
7646 3E 01       8 45 ld      a, 1                        ; increment minutes counter
7648 86          8 46 add     a, (hl)
7649 27          8 47 daa                                 ; convert to BCD (Binary-Coded-Decimal)
764A 77          8 48 ld      (hl), a                     ; store minutes
764B             8 49 Timer_Show
764B CD 52 76    8 50 call    Timer_Display               ; display timer on the screen
764E             8 51 Timer_Exit
764E D9          8 52 exx                                 ; restore BC, DE and HL registers
764F F1          8 53 pop     af                          ; restore AF register
7650 FB          8 55 ei                                  ; enable interrupts
7651 C9          8 56 ret
7652             8 58 ; ----------------------------------------------------------------------------------------------------------------------
7652             8 59 ; Timer_Display: display a timer on the screen
7652             8 60 ;
7652             8 61 ; Input:    -
7652             8 62 ;
7652             8 63 ; Output:   -
7652             8 64 ;
7652             8 65 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
7652             8 66 ;
7652             8 67 ; Destroys: A, BC, DE, HL
7652             8 68 ; ----------------------------------------------------------------------------------------------------------------------
7652             8 69 Timer_Display:
7652 01 EE 62    8 70 ld      bc, RED_TIMER+2             ; BC points to red's minutes counter address
7655 11 E2 48    8 71 ld      de, $48E2                   ; DE points to red's minutes screen address
7658 3A E8 62    8 72 ld      a, (TIMER_FLAG)             ; check timer flag
765B 3D          8 73 dec     a                           ; is cyan timer on?
765C C2 65 76    8 74 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
765F 01 EB 62    8 75 ld      bc, CYAN_TIMER+2            ; BC points to cyan's minutes counter address
7662 11 78 40    8 76 ld      de, $4078                   ; DE points to cyan's minutes screen address
7665             8 77 Timer_Display_Min
7665 CD 6A 76    8 78 call    Timer_Display_MinSec        ; display minutes counter on screen
7668 0B          8 79 dec     bc                          ; BC points to seconds counter address
7669 1C          8 80 inc     e                           ; DE points to seconds screen address
766A             8 81 Timer_Display_MinSec:
766A 0A          8 82 ld      a, (bc)                     ; set min/sec counter in A
766B 1F          8 83 rra                                 ; move tens digit to the first 4th bits of A
766C 1F          8 84 rra
766D 1F          8 85 rra
766E 1F          8 86 rra
766F CD 73 76    8 87 call    Timer_Display_Digit         ; display tens digit on screen
7672 0A          8 88 ld      a, (bc)                     ; set min/sec counter in A 
7673             8 89 Timer_Display_Digit:
7673 E6 0F       8 90 and     %00001111                   ; discard the last 4th bits of the digit
7675 D5          8 91 push    de                          ; store digit screen address
7676 21 97 64    8 93 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
7679 87          8 94 add     a, a                        ; a digit is 8 bytes long
767A 87          8 95 add     a, a
767B 87          8 96 add     a, a
767C 85          8 97 add     a, l                        ; set digit index in HL
767D 6F          8 98 ld      l, a
767E 7E          8 100 ld      a, (hl)                     ; get digit tile
767F 12          8 101 ld      (de), a                     ; put it on screen address
7680 14          8 102 inc     d                           ; move DE to next pixel-line address
7681 2C          8 103 inc     l                           ; move HL to next digit tile address
7682 7E          8 104 ld      a, (hl)                     ; (repeat 7 more times)
7683 12          8 105 ld      (de), a
7684 14          8 106 inc     d
7685 2C          8 107 inc     l
7686 7E          8 108 ld      a, (hl)
7687 12          8 109 ld      (de), a
7688 14          8 110 inc     d
7689 2C          8 111 inc     l
768A 7E          8 112 ld      a, (hl)
768B 12          8 113 ld      (de), a
768C 14          8 114 inc     d
768D 2C          8 115 inc     l
768E 7E          8 116 ld      a, (hl)
768F 12          8 117 ld      (de), a
7690 14          8 118 inc     d
7691 2C          8 119 inc     l
7692 7E          8 120 ld      a, (hl)
7693 12          8 121 ld      (de), a
7694 14          8 122 inc     d
7695 2C          8 123 inc     l
7696 7E          8 124 ld      a, (hl)
7697 12          8 125 ld      (de), a
7698 14          8 126 inc     d
7699 2C          8 127 inc     l
769A 7E          8 128 ld      a, (hl)
769B 12          8 129 ld      (de), a
769C D1          8 131 pop     de                          ; restore digit screen address
769D 1C          8 132 inc     e                           ; move screen address to next column
769E C9          8 133 ret
769F             8 135 ; ----------------------------------------------------------------------------------------------------------------------
769F             8 136 ; Timer_Display_All: display cyan and red timers
769F             8 137 ;
769F             8 138 ; Input:    -
769F             8 139 ;
769F             8 140 ; Output:   -
769F             8 141 ;
769F             8 142 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
769F             8 143 ;
769F             8 144 ; Destroys: BC, DE, HL
769F             8 145 ; ----------------------------------------------------------------------------------------------------------------------
769F             8 146 Timer_Display_All:
769F 3E 01       8 147 ld      a, 1                        ; set cyan timer on
76A1 32 E8 62    8 148 ld      (TIMER_FLAG), a
76A4 CD 52 76    8 149 call    Timer_Display               ; display cyan timer
76A7 3E 02       8 151 ld      a, 2                        ; set red timer on
76A9 32 E8 62    8 152 ld      (TIMER_FLAG), a
76AC CD 52 76    8 153 call    Timer_Display               ; display red timer
76AF AF          8 155 xor     a                           ; stop timers
76B0 32 E8 62    8 156 ld      (TIMER_FLAG), a
76B3 C9          8 157 ret
76B4             8 159 ; ----------------------------------------------------------------------------------------------------------------------
76B4             8 160 ; Timer_Reset: initialize cyan and red timers
76B4             8 161 ;
76B4             8 162 ; Input:    -
76B4             8 163 ;
76B4             8 164 ; Output:   -
76B4             8 165 ;
76B4             8 166 ; Destroys: HL
76B4             8 167 ; ----------------------------------------------------------------------------------------------------------------------
76B4             8 168 Timer_Reset:
76B4 21 E9 62    8 169 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76B7 36 32       8 171 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76B9 23          8 172 inc     hl                          ; move HL to cyan's seconds counter address
76BA 36 00       8 173 ld      (hl), 0                     ; reset seconds counter
76BC 23          8 174 inc     hl                          ; move HL to cyan's minutes counter address
76BD 36 00       8 175 ld      (hl), 0                     ; reset minutes counter
76BF 23          8 176 inc     hl                          ; move HL to red's interrupt counter
76C0 36 32       8 178 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76C2 23          8 179 inc     hl                          ; move HL to red's seconds counter address
76C3 36 00       8 180 ld      (hl), 0                     ; reset seconds counter
76C5 23          8 181 inc     hl                          ; move HL to red's minutes counter address
76C6 36 00       8 182 ld      (hl), 0                     ; reset minutes counter
76C8 C9          8 183 ret

; File #9: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Sound.z80asm

76C9             9 1 ; ----------------------------------------------------------------------------------------------------------------------
76C9             9 2 ; Sound.z80asm
76C9             9 3 ; Coded with BeepFX player tool by Shiru: https://shiru.untergrund.net/software.shtml
76C9             9 4 ;
76C9             9 5 ; Adapted for Hex game by Antonio Luque
76C9             9 6 ; ----------------------------------------------------------------------------------------------------------------------
76C9             9 8 ; ----------------------------------------------------------------------------------------------------------------------
76C9             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
76C9             9 10 ; 
76C9             9 11 ; Input:    IX = tone parameters address
76C9             9 12 ;
76C9             9 13 ; Output:   -
76C9             9 14 ;
76C9             9 15 ; Destroys: A, BC, DE, HL, IY
76C9             9 16 ; ----------------------------------------------------------------------------------------------------------------------
76C9             9 17 Sound_FX:
76C9 F3          9 18 di                                  ; disable interrupts
76CA DD 4E 00    9 20 ld      c, (ix+0)                   ; BC = frames
76CD DD 46 01    9 21 ld      b, (ix+1)
76D0 DD 5E 02    9 22 ld      e, (ix+2)                   ; DE = frame length
76D3 DD 56 03    9 23 ld      d, (ix+3)
76D6 D5          9 24 push    de                          ; store frame length in IY
76D7 FD E1       9 25 pop     iy
76D9 DD 5E 04    9 26 ld      e, (ix+4)                   ; DE = pitch
76DC DD 56 05    9 27 ld      d, (ix+5)
76DF 21 00 00    9 28 ld      hl, 0                       ; reset HL
76E2             9 30 Sound_FX_Frames
76E2 C5          9 31 push    bc                          ; store frames
76E3 FD E5       9 32 push    iy                          ; restore frame length in BC
76E5 C1          9 33 pop     bc
76E6             9 34 Sound_FX_FrameLength
76E6 19          9 35 add     hl, de                      ; HL = incremented pitch
76E7 7C          9 36 ld      a, h                        ; compares with fixed duty cycle ($80 for 50% square wave)
76E8 FE 80       9 37 cp      $80                         ; if (incremented pitch < duty cycle)
76EA 9F          9 38 sbc     a, a                        ;    { A = %11111111 } else { A = %00000000 }
76EB E6 10       9 39 and     %00010000                   ; toggling bit 4 controls the internal speaker
76ED F6 00       9 40 or      0                           ; keep border unchanged, dummy (7t)
76EF D3 FE       9 41 out     ($FE), a                    ; send bit to internal speaker
76F1 3A 00 00    9 42 ld      a, (0)                      ; dummy (13t)
76F4 0B          9 43 dec     bc                          ; decrement frame length
76F5 78          9 44 ld      a, b                        ; check frame length
76F6 B1          9 45 or      c                           ; frame length = 0?
76F7 C2 E6 76    9 46 jp      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times (loop = 88t)
76FA DD 4E 06    9 48 ld      c, (ix+6)                   ; BC = pitch slide
76FD DD 46 07    9 49 ld      b, (ix+7)
7700 EB          9 50 ex      de, hl                      ; HL = current pitch
7701 09          9 51 add     hl, bc                      ; increment pitch with pitch slide
7702 EB          9 52 ex      de, hl                      ; DE = new pitch
7703 C1          9 54 pop     bc                          ; restore frames
7704 0B          9 55 dec     bc                          ; decrement frames
7705 78          9 56 ld      a, b                        ; check frames
7706 B1          9 57 or      c                           ; frames = 0?
7707 20 D9       9 58 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
7709 FB          9 60 ei                                  ; enable interrupts
770A C9          9 61 ret

; File #10: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Screen.z80asm

770B             10 1 ; ----------------------------------------------------------------------------------------------------------------------
770B             10 2 ; Screen.z80asm
770B             10 3 ; Coded by Antonio Luque
770B             10 4 ; ----------------------------------------------------------------------------------------------------------------------
770B             10 6 BLUE_INK                equ     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
770B             10 7 BLUE_PAPER              equ     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
770B             10 8 WHITE_PAPER             equ     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
770B             10 9 WHITE                   equ     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
770B             10 10 BRIGHT                  equ     %01000000                   ; mask to apply bright to attributes
770B             10 11 FLASH                   equ     %10000000                   ; mask to apply flash to attributes
770B             10 12 WHITE_FLASH0            equ     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
770B             10 13 WHITE_FLASH1            equ     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
770B             10 15 ; ----------------------------------------------------------------------------------------------------------------------
770B             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
770B             10 17 ;
770B             10 18 ; Input:    -
770B             10 19 ;
770B             10 20 ; Output:   -
770B             10 21 ;
770B             10 22 ; Destroys: BC, DE, HL
770B             10 23 ; ----------------------------------------------------------------------------------------------------------------------
770B             10 24 Screen_Clear:
770B 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
770E 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
7711 75          10 27 ld      (hl), l                     ; set first pixel-byte in black
7712 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
7715 ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
7717 C9          10 30 ret
7718             10 32 ; ----------------------------------------------------------------------------------------------------------------------
7718             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
7718             10 34 ;
7718             10 35 ; Input:    -
7718             10 36 ;
7718             10 37 ; Output:   -
7718             10 38 ;
7718             10 39 ; Destroys: A, BC, DE, HL, IX
7718             10 40 ; ----------------------------------------------------------------------------------------------------------------------
7718             10 41 Screen_Letters:
7718 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
771B DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
771F CD 29 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
7722 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
7725 DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
7729             10 47 Screen_Letters_Row:
7729 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
772C 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
772E             10 50 Screen_Letter_Loop
772E E5          10 51 push    hl                          ; store letter screen address
772F CD EE 6D    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
7732 E1          10 53 pop     hl                          ; restore letter screen address
7733 2C          10 54 inc     l                           ; move HL to next screen address
7734 2C          10 55 inc     l
7735 DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
7739 DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
773D DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
773F DD 2C       10 59 inc     ixl
7741 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
7743 C9          10 61 ret
7744             10 63 ; ----------------------------------------------------------------------------------------------------------------------
7744             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
7744             10 65 ;
7744             10 66 ; Input:    -
7744             10 67 ;
7744             10 68 ; Output:   -
7744             10 69 ;
7744             10 70 ; Destroys: A, BC, DE, HL, IX, IY
7744             10 71 ; ----------------------------------------------------------------------------------------------------------------------
7744             10 72 Screen_Numbers:
7744 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
7747 FD 21 EF 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
774B DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
774F 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
7751             10 77 Screen_Number_Loop
7751 FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
7754 FD 66 01    10 79 ld      h, (iy+1)
7757 E5          10 80 push    hl                          ; store pointer to number screen address
7758 D5          10 81 push    de                          ; store pointer to sprite address
7759 CD EE 6D    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
775C D1          10 83 pop     de                          ; restore pointer to sprite address
775D E1          10 84 pop     hl                          ; restore pointer to number screen address
775E DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7762 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
7766 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
7767 C6 0F       10 88 add     a, 15
7769 6F          10 89 ld      l, a
776A CD EE 6D    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
776D DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
7771 DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
7775 78          10 93 ld      a, b                        ; save loop counter
7776 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
7779 DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
777B FD 23       10 96 inc     iy                          ; move IY to next number screen address
777D FD 23       10 97 inc     iy
777F 47          10 98 ld      b, a                        ; restore loop counter
7780 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
7782 C9          10 100 ret
7783             10 102 ; ----------------------------------------------------------------------------------------------------------------------
7783             10 103 ; Screen_Frame: draw the screen frame on the screen
7783             10 104 ;
7783             10 105 ; Input:    -
7783             10 106 ;
7783             10 107 ; Output:   -
7783             10 108 ;
7783             10 109 ; Destroys: A, BC, DE, HL, IX
7783             10 110 ; ----------------------------------------------------------------------------------------------------------------------
7783             10 111 Screen_Frame:
7783 11 28 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
7786 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
7789 CD 53 6F    10 114 call    Print_String                ; print "Level"
778C CD C8 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
778F 01 8D 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
7792 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
7795 CD 9B 77    10 119 call    Screen_Frame_Border         ; draw up-border
7798 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
779B             10 121 Screen_Frame_Border:
779B DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
779E             10 123 Screen_Frame_Loop
779E 0A          10 124 ld      a, (bc)                     ; get tile index
779F FE FF       10 125 cp      -1                          ; is it -1?
77A1 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
77A3 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
77A6 CD 62 6F    10 128 call    Print_Tile                  ; print frame tile
77A9             10 129 Screen_Frame_Next
77A9 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77AA 03          10 131 inc     bc                          ; BC points to the next tile index
77AB DD 2D       10 132 dec     ixl                         ; decrement loop counter
77AD 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77AF DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77B3 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77B7 DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77BB DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77BF DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77C3 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77C7 C9          10 141 ret
77C8             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77C8             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77C8             10 145 ;
77C8             10 146 ; Input:    -
77C8             10 147 ;
77C8             10 148 ; Output:   -
77C8             10 149 ;
77C8             10 150 ; Destroys: A, BC, HL
77C8             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77C8             10 152 Screen_Vertical_Bars:
77C8 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
77CB CD D1 77    10 154 call    Screen_Vertical_Bar         ; draw left bar
77CE 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
77D1             10 156 Screen_Vertical_Bar:
77D1 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
77D3             10 158 Screen_Vertical_Loop
77D3 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
77D5 CD FA 6D    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
77D8 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
77DA C9          10 162 ret
77DB             10 164 ; ----------------------------------------------------------------------------------------------------------------------
77DB             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
77DB             10 166 ;
77DB             10 167 ; Input:    -
77DB             10 168 ;
77DB             10 169 ; Output:   -
77DB             10 170 ;
77DB             10 171 ; Uses:     TOKEN_COLOR (current token color)
77DB             10 172 ;
77DB             10 173 ; Destroys: A, BC, DE, HL, IX
77DB             10 174 ; ----------------------------------------------------------------------------------------------------------------------
77DB             10 175 Screen_Tokens:
77DB 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
77DD 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
77E0 CD E8 77    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
77E3 3E 02       10 180 ld      a, RED_COLOR                ; set token color
77E5 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
77E8             10 182 Screen_Tokens_Draw:
77E8 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
77EB CD 09 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
77EE DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
77F1 DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
77F4 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
77F7 C3 DB 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
77FA             10 190 ; ----------------------------------------------------------------------------------------------------------------------
77FA             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
77FA             10 192 ;
77FA             10 193 ; Input:    -
77FA             10 194 ;
77FA             10 195 ; Output:   -
77FA             10 196 ;
77FA             10 197 ; Destroys: IX
77FA             10 198 ; ----------------------------------------------------------------------------------------------------------------------
77FA             10 199 Screen_Timer_Quotes:
77FA DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
77FE DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7802 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7806 DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
7808 DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
780C DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7810 DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
7813 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
7817 DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
781B DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
781F DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7823 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
7827 DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
7829 DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
782D DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7831 DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
7834 DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
7838 DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
783C C9          10 219 ret
783D             10 221 ; ----------------------------------------------------------------------------------------------------------------------
783D             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
783D             10 223 ;
783D             10 224 ; Input:    -
783D             10 225 ;
783D             10 226 ; Output:   -
783D             10 227 ;
783D             10 228 ; Destroys: BC, IX
783D             10 229 ; ----------------------------------------------------------------------------------------------------------------------
783D             10 230 Screen_Color_Statics:
783D DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
7841 0E 07       10 232 ld      c, WHITE                    ; set color in C
7843 CD 6D 78    10 233 call    Screen_Apply_Color          ; apply color
7846 DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
7849 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
784B CD 6D 78    10 236 call    Screen_Apply_Color          ; apply color
784E DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7852 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
7854 CD 6D 78    10 239 call    Screen_Apply_Color          ; apply color
7857 DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
785A 0E 07       10 241 ld      c, WHITE                    ; set color in C
785C CD 6D 78    10 242 call    Screen_Apply_Color          ; apply color
785F DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7863 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
7865 CD 6D 78    10 245 call    Screen_Apply_Color          ; apply color
7868 DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
786B 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
786D             10 248 Screen_Apply_Color:
786D 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
786F             10 250 Screen_Apply_Color_Loop:
786F DD 71 00    10 251 ld      (ix+0), c                   ; apply color
7872 DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
7874 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
7876 C9          10 254 ret
7877             10 256 ; ----------------------------------------------------------------------------------------------------------------------
7877             10 257 ; Screen_Last_Level: show last level screen and input game level
7877             10 258 ;
7877             10 259 ; Input:    -
7877             10 260 ;
7877             10 261 ; Output:   -
7877             10 262 ;
7877             10 263 ; Uses:     GAME_LEVEL (current game level)
7877             10 264 ;
7877             10 265 ; Destroys: A, BC, DE, HL, IX, IY
7877             10 266 ; ----------------------------------------------------------------------------------------------------------------------
7877             10 267 Screen_Last_Level:
7877 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
787A 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
787D CD 53 6F    10 270 call    Print_String                ; print "Press any key"
7880 DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
7884 01 38 0D    10 272 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7887 CD 6F 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
788A CD BF 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
788D CD 0B 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7890 CD 50 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
7893 DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
7897 01 C7 11    10 279 ld      bc, 17*256+WHITE_FLASH1     ; B = string length (loop counter), C = color attributes
789A CD 6F 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
789D 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
78A0 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
78A3 CD 53 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
78A6 DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78AA CD C9 76    10 285 call    Sound_FX                    ; play sound fx
78AD F3          10 287 di                                  ; disable interrupts
78AE DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78B2 01 07 1C    10 289 ld      bc, 28*256+WHITE            ; B = string length (loop counter), C = color attributes
78B5 CD 6F 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78B8 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78BB 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78BE CD 53 6F    10 293 call    Print_String                ; print "Well done!..."
78C1 DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78C4 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78C6 CD 6F 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78C9 DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
78CD DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
78D1 DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
78D5 13          10 300 inc     de                          ; move DE to next string address
78D6 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
78D8 CD 53 6F    10 302 call    Print_String                ; print "Choose..."
78DB             10 303 Screen_Choose_Level
78DB CD BF 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
78DE FE 31       10 305 cp      '1'                         ; is it < '1' ?
78E0 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
78E2 FE 35       10 307 cp      '5'                         ; is it >= '5' ?
78E4 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
78E6 D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
78E8 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
78EB 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
78EC C9          10 312 ret
78ED             10 314 ; ----------------------------------------------------------------------------------------------------------------------
78ED             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
78ED             10 316 ;
78ED             10 317 ; Input:    -
78ED             10 318 ;
78ED             10 319 ; Output:   -
78ED             10 320 ;
78ED             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
78ED             10 322 ;           THREE_ROW (three-in-a-row counter)
78ED             10 323 ;
78ED             10 324 ; Destroys: A, C, HL, IX
78ED             10 325 ; ----------------------------------------------------------------------------------------------------------------------
78ED             10 326 Screen_ThreeRow:
78ED 21 9C 61    10 327 ld      hl, LEVEL_COLOR             ; HL points to level color address
78F0 4E          10 328 ld      c, (hl)                     ; save level color in C
78F1 CD 09 79    10 329 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
78F4 3A 0E 62    10 330 ld      a, (THREE_ROW)              ; A = three-in-a-row counter
78F7 B7          10 331 or      a                           ; is it 0?
78F8 C8          10 332 ret     z                           ; yes, return
78F9 3D          10 333 dec     a                           ; is it 1?
78FA 28 09       10 334 jr      z, Screen_ThreeRow_1        ; yes, color first mark
78FC 3D          10 335 dec     a                           ; is it 2?
78FD 28 03       10 336 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
78FF DD 71 00    10 337 ld      (ix+0), c                   ; color 3rd mark
7902             10 338 Screen_ThreeRow_2
7902 DD 71 01    10 339 ld      (ix+1), c                   ; color 2nd mark
7905             10 340 Screen_ThreeRow_1
7905 DD 71 02    10 341 ld      (ix+2), c                   ; color 1st mark
7908 C9          10 342 ret
7909             10 344 ; ----------------------------------------------------------------------------------------------------------------------
7909             10 345 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
7909             10 346 ;
7909             10 347 ; Input:    -
7909             10 348 ;
7909             10 349 ; Output:   IX = three-in-a-row marks attribute address
7909             10 350 ;
7909             10 351 ; Destroys: -
7909             10 352 ; ----------------------------------------------------------------------------------------------------------------------
7909             10 353 Screen_Clear_ThreeRow:
7909 DD 21 F2 5A 10 354 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
790D DD 36 00 01 10 355 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
7911 DD 36 01 01 10 356 ld      (ix+1), BLUE_INK
7915 DD 36 02 01 10 357 ld      (ix+2), BLUE_INK
7919 C9          10 358 ret
791A             10 360 ; ----------------------------------------------------------------------------------------------------------------------
791A             10 361 ; Screen_Frame_Color: set up frame color and print level number depending on current level
791A             10 362 ;
791A             10 363 ; Input:    HL = game level address
791A             10 364 ;
791A             10 365 ; Output:   -
791A             10 366 ;
791A             10 367 ; Uses:     LEVEL_COLOR (current level color for frame border)
791A             10 368 ;
791A             10 369 ; Destroys: A, BC, DE, HL
791A             10 370 ; ----------------------------------------------------------------------------------------------------------------------
791A             10 371 Screen_Frame_Color:
791A 06 00       10 372 ld      b, 0                        ; set game level in BC
791C 4E          10 373 ld      c, (hl)
791D 3E 30       10 374 ld      a, $30                      ; convert game level number to game level character
791F 81          10 375 add     a, c
7920 21 0F 40    10 376 ld      hl, $400F                   ; HL points to screen address of game level
7923 CD 5F 6F    10 377 call    Print_Char                  ; print game level
7926 21 0E 62    10 378 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
7929 09          10 379 add     hl, bc                      ; use BC as index for color map address
792A 7E          10 380 ld      a, (hl)                     ; A = level color
792B CD 40 79    10 381 call    Screen_Tiles_Color          ; color the frame according to the current level
792E E6 07       10 382 and     %00000111                   ; mask color
7930 32 9C 61    10 383 ld      (LEVEL_COLOR), a            ; save masked color
7933 17          10 384 rla                                 ; rotate to text level color
7934 17          10 385 rla
7935 17          10 386 rla
7936 21 08 58    10 387 ld      hl, $5808                   ; HL points to attribute address of level text
7939 06 09       10 388 ld      b, 9                        ; length of level text (loop counter)
793B             10 389 Screen_Level_Loop
793B 77          10 390 ld      (hl), a                     ; apply color to level text
793C 2C          10 391 inc     l                           ; HL points to attr address of next character of level text
793D 10 FC       10 392 djnz    Screen_Level_Loop           ; repeat for each character of level text
793F C9          10 393 ret
7940             10 395 ; ----------------------------------------------------------------------------------------------------------------------
7940             10 396 ; Screen_Tiles_Color: apply color to the frame tiles
7940             10 397 ;
7940             10 398 ; Input:    A = color to apply
7940             10 399 ;
7940             10 400 ; Output:   -
7940             10 401 ;
7940             10 402 ; Destroys: BC, DE, HL
7940             10 403 ; ----------------------------------------------------------------------------------------------------------------------
7940             10 404 Screen_Tiles_Color:
7940             10 405 ; color up row
7940 21 01 58    10 407 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
7943 06 06       10 408 ld      b, 6                        ; number of tiles (loop counter)
7945             10 409 Screen_Tiles_URow1
7945 77          10 410 ld      (hl), a                     ; apply color
7946 2C          10 411 inc     l                           ; move HL to the next attribute address
7947 10 FC       10 412 djnz    Screen_Tiles_URow1          ; repeat for each tile
7949 2E 12       10 413 ld      l, $12                      ; move HL to the next attribute address
794B 06 0D       10 414 ld      b, 13                       ; number of tiles (loop counter)
794D             10 415 Screen_Tiles_URow2
794D 77          10 416 ld      (hl), a                     ; apply color
794E 2C          10 417 inc     l                           ; move HL to the next attribute address
794F 10 FC       10 418 djnz    Screen_Tiles_URow2          ; repeat for each tile
7951             10 420 ; color vertical bars
7951 2E 00       10 422 ld      l, 0                        ; move HL to the next attribute address
7953 11 1F 00    10 423 ld      de, 31                      ; attribute address displacement (for each bar)
7956 0E 03       10 424 ld      c, 3                        ; number of screen thirds (outer loop counter)
7958             10 425 Screen_Tiles_VBar1
7958 06 08       10 426 ld      b, 8                        ; number of tiles (inner loop counter)
795A             10 427 Screen_Tiles_VBar2
795A 77          10 428 ld      (hl), a                     ; apply color
795B 19          10 429 add     hl, de                      ; move HL to the right column
795C 77          10 430 ld      (hl), a                     ; apply color
795D 2C          10 431 inc     l                           ; move HL to the next attribute address
795E 10 FA       10 432 djnz    Screen_Tiles_VBar2          ; repeat for each tile
7960 24          10 433 inc     h                           ; move HL to the next screen third
7961 0D          10 434 dec     c                           ; decrement number of thirds
7962 20 F4       10 435 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
7964             10 437 ; color bottom row
7964 21 E1 5A    10 439 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
7967 06 10       10 440 ld      b, 16                       ; number of tiles (loop counter)
7969             10 441 Screen_Tiles_BRow1
7969 77          10 442 ld      (hl), a                     ; apply color
796A 2C          10 443 inc     l                           ; move HL to the next attribute address
796B 10 FC       10 444 djnz    Screen_Tiles_BRow1          ; repeat for each tile
796D 2E F6       10 445 ld      l, $F6                      ; move HL to the next attribute address
796F 06 09       10 446 ld      b, 9                        ; number of tiles (loop counter)
7971             10 447 Screen_Tiles_BRow2
7971 77          10 448 ld      (hl), a                     ; apply color
7972 2C          10 449 inc     l                           ; move HL to the next attribute address
7973 10 FC       10 450 djnz    Screen_Tiles_BRow2          ; repeat for each tile
7975 C9          10 451 ret
7976             10 453 ; ----------------------------------------------------------------------------------------------------------------------
7976             10 454 ; Screen_Menu: show main menu and wait for an option
7976             10 455 ;
7976             10 456 ; Input:    -
7976             10 457 ;
7976             10 458 ; Output:   -
7976             10 459 ;
7976             10 460 ; Uses:     GAME_LEVEL (current game level)
7976             10 461 ;
7976             10 462 ; Destroys: A, BC, DE, HL, IX, IY
7976             10 463 ; ----------------------------------------------------------------------------------------------------------------------
7976             10 464 Screen_Menu:
7976 CD 0B 77    10 465 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7979 CD 50 7C    10 466 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
797C             10 467 Screen_Menu_Strings
797C 21 80 59    10 468 ld      hl, $5980                   ; HL points to menu text area attributes address
797F 11 81 59    10 469 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
7982 36 00       10 470 ld      (hl), 0                     ; set first attribute text area in black
7984 01 7F 01    10 471 ld      bc, 32*12-1                 ; length of text area attributes (-1 already set)
7987 ED B0       10 472 ldir                                ; set the rest of text area attributes in black
7989 DD 21 CA 59 10 474 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
798D DD 36 FF 78 10 475 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7991 01 47 0D    10 476 ld      bc, 13*256+WHITE_FLASH0     ; B = string length-1 (loop counter), C = color attributes
7994 CD 6F 78    10 477 call    Screen_Apply_Color_Loop     ; apply color to string area
7997 11 80 67    10 478 ld      de, STR_OPTIONS             ; DE points to string address
799A 21 C9 48    10 479 ld      hl, $48C9                   ; HL points to string screen address
799D CD 53 6F    10 480 call    Print_String                ; print "Start new game"
79A0 DD 21 2A 5A 10 481 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
79A4 DD 36 FF 78 10 482 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79A8 06 0A       10 483 ld      b, 10                       ; string length-1 (loop counter)
79AA CD 6F 78    10 484 call    Screen_Apply_Color_Loop     ; apply color to string area
79AD 13          10 485 inc     de                          ; move DE to "How to play" string address
79AE 21 29 50    10 486 ld      hl, $5029                   ; HL points to string screen address
79B1 CD 53 6F    10 487 call    Print_String                ; print "How to play"
79B4 DD 2E 8A    10 488 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79B7 DD 36 FF 78 10 489 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79BB CD 6D 78    10 490 call    Screen_Apply_Color          ; apply color to string area
79BE 13          10 491 inc     de                          ; move DE to "Credits" string address
79BF 2E 89       10 492 ld      l, $89                      ; HL points to string screen address
79C1 CD 53 6F    10 493 call    Print_String                ; print "Credits"
79C4             10 494 Screen_Menu_Options
79C4 CD BF 6E    10 495 call    Input_Key_Scan              ; wait for a key pressed
79C7 FE 73       10 496 cp      's'                         ; is it 's'?
79C9 C8          10 497 ret     z                           ; yes, return
79CA FE 63       10 498 cp      'c'                         ; is it 'c'?
79CC CA E0 7B    10 499 jp      z, Screen_Menu_Credits      ; yes, show credits
79CF FE 68       10 500 cp      'h'                         ; is it 'h'?
79D1 20 F1       10 501 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
79D3             10 503 ; ----------------------------------------------------------------------------------------------------------------------
79D3             10 504 ; Show "How to play" pages
79D3             10 505 ; ----------------------------------------------------------------------------------------------------------------------
79D3             10 506 Screen_Menu_How2Play
79D3 CD 0B 77    10 507 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79D6 CD 18 77    10 508 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
79D9 CD 44 77    10 509 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
79DC CD 83 77    10 510 call    Screen_Frame                ; draw the screen frame
79DF 21 9D 61    10 512 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
79E2 34          10 513 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
79E3 CD 1A 79    10 514 call    Screen_Frame_Color          ; set up frame color depending on current level
79E6 CD 09 79    10 515 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
79E9 11 4A 68    10 517 ld      de, STR_BUTTONS             ; DE points to "Next" string address
79EC 21 DB 50    10 518 ld      hl, $50DB                   ; HL points to string screen address
79EF CD 53 6F    10 519 call    Print_String                ; print "Next"
79F2 13          10 520 inc     de                          ; move DE to "Back" string address
79F3 21 C1 50    10 521 ld      hl, $50C1                   ; HL points to string screen address
79F6 CD 53 6F    10 522 call    Print_String                ; print "Back"
79F9             10 524 Screen_How2Play_RED
79F9 21 5E 58    10 525 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
79FC CD 8A 7C    10 526 call    Screen_Clear_Text           ; clear text area attributes
79FF CD 9B 6D    10 527 call    Draw_Board                  ; draw an empty hexagons board
7A02             10 529 ; text for RED
7A02 DD 21 01 5A 10 531 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
7A06 01 07 07    10 532 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7A09 CD 6F 78    10 533 call    Screen_Apply_Color_Loop     ; apply color to string area
7A0C 11 5D 68    10 534 ld      de, STR_HELP1               ; DE points to string address
7A0F 21 01 50    10 535 ld      hl, $5001                   ; HL points to string screen address
7A12 CD 53 6F    10 536 call    Print_String                ; print "Connect"
7A15 DD 2E 21    10 537 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A18 06 08       10 538 ld      b, 8                        ; string length (loop counter)
7A1A CD 6F 78    10 539 call    Screen_Apply_Color_Loop     ; apply color to string area
7A1D 13          10 540 inc     de                          ; move DE to "left and" string address
7A1E 2E 21       10 541 ld      l, $21                      ; HL points to string screen address
7A20 CD 53 6F    10 542 call    Print_String                ; print "left and"
7A23 DD 2E 41    10 543 ld      ixl, $41                    ; IX points to "right" string attributes address
7A26 06 05       10 544 ld      b, 5                        ; set string length (loop counter)
7A28 CD 6F 78    10 545 call    Screen_Apply_Color_Loop     ; apply color to string area
7A2B 11 75 68    10 546 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A2E 2E 41       10 547 ld      l, $41                      ; HL points to string screen address
7A30 CD 53 6F    10 548 call    Print_String                ; print "right"
7A33 DD 2E 61    10 549 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A36 06 07       10 550 ld      b, 7                        ; set string length (loop counter)
7A38 CD 6F 78    10 551 call    Screen_Apply_Color_Loop     ; apply color to string area
7A3B 11 80 68    10 552 ld      de, STR_HELP4               ; DE points to "borders" string address
7A3E 2E 61       10 553 ld      l, $61                      ; HL points to string screen address
7A40 CD 53 6F    10 554 call    Print_String                ; print "borders"
7A43 DD 2E 81    10 555 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A46 CD 6D 78    10 556 call    Screen_Apply_Color          ; apply color to string area
7A49 13          10 557 inc     de                          ; move DE to "to win" string address
7A4A 2E 81       10 558 ld      l, $81                      ; HL points to string screen address
7A4C CD 53 6F    10 559 call    Print_String                ; print "to win"
7A4F DD 21 E3 59 10 560 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A53 01 42 03    10 561 ld      bc, 3*256+RED_COLOR+BRIGHT  ; B = string length (loop counter), C = color attributes
7A56 CD 6F 78    10 562 call    Screen_Apply_Color_Loop     ; apply color to string area
7A59 11 54 68    10 563 ld      de, STR_RED                 ; DE points to "RED" string address
7A5C 21 E3 48    10 564 ld      hl, $48E3                   ; HL points to string screen address
7A5F CD 53 6F    10 565 call    Print_String                ; print "RED"
7A62             10 567 ; draw RED sample board
7A62 FD 21 3A 67 10 569 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A66 11 3E 66    10 570 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A69 06 07       10 571 ld      b, 7                        ; number of red+bright tokens (loop counter)
7A6B 3E 42       10 572 ld      a, RED_COLOR+BRIGHT         ; set token color
7A6D 32 9E 61    10 573 ld      (TOKEN_COLOR), a            ; save token color
7A70 CD 75 7C    10 574 call    Screen_Hexagons_Loop        ; draw tokens
7A73 06 02       10 575 ld      b, 2                        ; number of red tokens (loop counter)
7A75 3E 02       10 576 ld      a, RED_COLOR                ; set token color
7A77 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7A7A CD 75 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7A7D 06 09       10 579 ld      b, 9                        ; number of cyan tokens (loop counter)
7A7F 3E 05       10 580 ld      a, CYAN_COLOR               ; set token color
7A81 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7A84 CD 75 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7A87             10 584 ; wait for "Next" option pressed
7A87 DD 21 C1 5A 10 586 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7A8B 01 00 04    10 587 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7A8E CD 6F 78    10 588 call    Screen_Apply_Color_Loop     ; hide "Back" string
7A91 DD 2E DC    10 589 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7A94 DD 36 FF 78 10 590 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7A98 01 47 03    10 591 ld      bc, 3*256+WHITE_FLASH0      ; B = string length-1 (loop counter), C = color attributes
7A9B CD 6F 78    10 592 call    Screen_Apply_Color_Loop     ; apply color to string area
7A9E             10 593 Screen_How2PlayRED_End
7A9E CD BF 6E    10 594 call    Input_Key_Scan              ; wait for a key pressed
7AA1 FE 6E       10 595 cp      'n'                         ; is it 'n'?
7AA3 20 F9       10 596 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7AA5             10 598 Screen_How2Play_CYAN
7AA5 21 0F 58    10 599 ld      hl, $580F                   ; HL points to level number attribute address
7AA8 CB BE       10 600 res     7, (hl)                     ; reset flash attribute
7AAA 26 40       10 601 ld      h, $40                      ; HL points to level number screen address
7AAC 3E 31       10 602 ld      a, '1'                      ; set level number (char)
7AAE CD 5F 6F    10 603 call    Print_Char                  ; print '1'
7AB1 CD 09 79    10 604 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7AB4 21 C9 59    10 606 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7AB7 CD 8A 7C    10 607 call    Screen_Clear_Text           ; clear text area attributes
7ABA CD 9B 6D    10 608 call    Draw_Board                  ; draw an empty hexagons board
7ABD             10 610 ; text for CYAN
7ABD DD 21 98 58 10 612 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7AC1 01 07 07    10 613 ld      bc, 7*256+WHITE             ; B = string length (loop counter), C = color attributes
7AC4 CD 6F 78    10 614 call    Screen_Apply_Color_Loop     ; apply color to string area
7AC7 11 5D 68    10 615 ld      de, STR_HELP1               ; DE points to "Connect" string address
7ACA 21 98 40    10 616 ld      hl, $4098                   ; HL points to string screen address
7ACD CD 53 6F    10 617 call    Print_String                ; print "Connect"
7AD0 DD 2E B9    10 618 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7AD3 CD 6D 78    10 619 call    Screen_Apply_Color          ; apply color to string area
7AD6 11 6E 68    10 620 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7AD9 2E B9       10 621 ld      l, $B9                      ; HL points to string screen address
7ADB CD 53 6F    10 622 call    Print_String                ; print "up and"
7ADE DD 2E DB    10 623 ld      ixl, $DB                    ; IX points to "down" string attributes address
7AE1 06 04       10 624 ld      b, 4                        ; string length (loop counter)
7AE3 CD 6F 78    10 625 call    Screen_Apply_Color_Loop     ; apply color to string area
7AE6 11 7B 68    10 626 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7AE9 2E DB       10 627 ld      l, $DB                      ; HL points to string screen address
7AEB CD 53 6F    10 628 call    Print_String                ; print "down"
7AEE DD 2E F8    10 629 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7AF1 06 07       10 630 ld      b, 7                        ; string length (loop counter)
7AF3 CD 6F 78    10 631 call    Screen_Apply_Color_Loop     ; apply color to string area
7AF6 13          10 632 inc     de                          ; move DE to "borders" string address
7AF7 2E F8       10 633 ld      l, $F8                      ; HL points to string screen address
7AF9 CD 53 6F    10 634 call    Print_String                ; print "borders"
7AFC DD 21 19 59 10 635 ld      ix, $5919                   ; IX points to "to win" string attributes address
7B00 CD 6D 78    10 636 call    Screen_Apply_Color          ; apply color to string area
7B03 13          10 637 inc     de                          ; move DE to "to win" string address
7B04 21 19 48    10 638 ld      hl, $4819                   ; HL points to string screen address
7B07 CD 53 6F    10 639 call    Print_String                ; print "to win"
7B0A DD 21 7A 58 10 640 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B0E 01 45 04    10 641 ld      bc, $0445                   ; B = string length (loop counter)
7B11             10 642 ; C = color attributes (cyan+bright)
7B11 CD 6F 78    10 643 call    Screen_Apply_Color_Loop     ; apply color to string area
7B14 11 58 68    10 644 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B17 21 7A 40    10 645 ld      hl, $407A                   ; HL points to string screen address
7B1A CD 53 6F    10 646 call    Print_String                ; print "CYAN"
7B1D             10 648 ; draw CYAN sample board
7B1D FD 21 5E 67 10 650 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B21 11 3E 66    10 651 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B24 06 07       10 652 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B26 3E 45       10 653 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B28 32 9E 61    10 654 ld      (TOKEN_COLOR), a            ; save token color
7B2B CD 75 7C    10 655 call    Screen_Hexagons_Loop        ; draw tokens
7B2E 06 02       10 656 ld      b, 2                        ; number of cyan tokens (loop counter)
7B30 3E 05       10 657 ld      a, CYAN_COLOR               ; set token color
7B32 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B35 CD 75 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B38 06 08       10 660 ld      b, 8                        ; number of red tokens (loop counter)
7B3A 3E 02       10 661 ld      a, RED_COLOR                ; set token color
7B3C 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B3F CD 75 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B42             10 665 ; wait for "Next" or "Back" options pressed
7B42 DD 21 C2 5A 10 667 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B46 DD 36 FF 78 10 668 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B4A 01 47 03    10 669 ld      bc, 3*256+WHITE_FLASH0      ; B = string length (-1), C = color attributes
7B4D CD 6F 78    10 670 call    Screen_Apply_Color_Loop     ; apply color to string area
7B50             10 671 Screen_How2PlayCYAN_End
7B50 CD BF 6E    10 672 call    Input_Key_Scan              ; wait for a key pressed
7B53 FE 62       10 673 cp      'b'                         ; is it 'b'?
7B55 CA F9 79    10 674 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B58 FE 6E       10 675 cp      'n'                         ; is it 'n'?
7B5A 20 F4       10 676 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B5C             10 678 Screen_How2Play_LevelUp
7B5C 21 5E 58    10 679 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B5F CD 8A 7C    10 680 call    Screen_Clear_Text           ; clear text area attributes
7B62             10 682 ; text for Level Up
7B62 DD 21 21 5A 10 684 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B66 01 07 09    10 685 ld      bc, 9*256+WHITE             ; B = string length (loop counter), C = color attributes
7B69 CD 6F 78    10 686 call    Screen_Apply_Color_Loop     ; apply color to string area
7B6C 11 8F 68    10 687 ld      de, STR_HELP                ; DE points to "Win three" string address
7B6F 21 21 50    10 688 ld      hl, $5021                   ; HL points to string screen address
7B72 CD 53 6F    10 689 call    Print_String                ; print "Win three"
7B75 DD 2E 41    10 690 ld      ixl, $41                    ; IX points to "times in" string attributes address
7B78 06 08       10 691 ld      b, 8                        ; string length (loop counter)
7B7A CD 6F 78    10 692 call    Screen_Apply_Color_Loop     ; apply color to string area
7B7D 13          10 693 inc     de                          ; move DE to "times in" string address
7B7E 2E 41       10 694 ld      l, $41                      ; HL points to string screen address
7B80 CD 53 6F    10 695 call    Print_String                ; print "times in"
7B83 DD 2E 61    10 696 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7B86 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7B88 CD 6F 78    10 698 call    Screen_Apply_Color_Loop     ; apply color to string area
7B8B 13          10 699 inc     de                          ; move DE to "a row to" string address
7B8C 2E 61       10 700 ld      l, $61                      ; HL points to string screen address
7B8E CD 53 6F    10 701 call    Print_String                ; print "a row to"
7B91 DD 2E 81    10 702 ld      ixl, $81                    ; IX points to "level up" string attributes address
7B94 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7B96 CD 6F 78    10 704 call    Screen_Apply_Color_Loop     ; apply color to string area
7B99 13          10 705 inc     de                          ; move DE to "level up" string address
7B9A 2E 81       10 706 ld      l, $81                      ; HL points to string screen address
7B9C CD 53 6F    10 707 call    Print_String                ; print "level up"
7B9F             10 709 ; reset bright of cyan tokens
7B9F FD 21 5E 67 10 711 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7BA3 11 3E 66    10 712 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7BA6 06 07       10 713 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7BA8 3E 05       10 714 ld      a, CYAN_COLOR               ; set new token color
7BAA 32 9E 61    10 715 ld      (TOKEN_COLOR), a            ; save color
7BAD CD 75 7C    10 716 call    Screen_Hexagons_Loop        ; draw tokens
7BB0             10 718 ; set flash attribute of level number and three-in-a-row marks
7BB0 21 0F 58    10 720 ld      hl, $580F                   ; HL points to level number attribute address
7BB3 CB FE       10 721 set     7, (hl)                     ; set flash attribute
7BB5 21 0F 40    10 722 ld      hl, $400F                   ; HL points to level number screen address
7BB8 3E 32       10 723 ld      a, '2'                      ; set new level
7BBA CD 5F 6F    10 724 call    Print_Char                  ; print new level
7BBD DD 21 F2 5A 10 725 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BC1 DD 36 00 B8 10 726 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BC5 DD 36 01 B8 10 727 ld      (ix+1), WHITE_PAPER+FLASH
7BC9 DD 36 02 B8 10 728 ld      (ix+2), WHITE_PAPER+FLASH
7BCD             10 730 ; wait for "Next" or "Back" options pressed
7BCD             10 732 Screen_How2Play_End
7BCD CD BF 6E    10 733 call    Input_Key_Scan              ; wait for a key pressed
7BD0 FE 62       10 734 cp      'b'                         ; is it 'b'?
7BD2 CA A5 7A    10 735 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7BD5 FE 6E       10 736 cp      'n'                         ; is it 'n'?
7BD7 20 F4       10 737 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7BD9 21 9D 61    10 739 ld      hl, GAME_LEVEL              ; HL points to game level address
7BDC 35          10 740 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7BDD C3 76 79    10 741 jp      Screen_Menu                 ; return to main menu
7BE0             10 743 ; ----------------------------------------------------------------------------------------------------------------------
7BE0             10 744 ; Show credits
7BE0             10 745 ; ----------------------------------------------------------------------------------------------------------------------
7BE0             10 746 Screen_Menu_Credits
7BE0 DD 21 84 59 10 747 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7BE4 01 47 19    10 748 ld      bc, 25*256+WHITE_FLASH0     ; B = string length (loop counter), C = color attributes
7BE7 CD 6F 78    10 749 call    Screen_Apply_Color_Loop     ; apply color to string area
7BEA 11 A3 67    10 750 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7BED 21 84 48    10 751 ld      hl, $4884                   ; HL points to string screen address
7BF0 CD 53 6F    10 752 call    Print_String                ; print "Design..."
7BF3 DD 2E C4    10 753 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7BF6 06 19       10 754 ld      b, 25                       ; string length (loop counter)
7BF8 CD 6F 78    10 755 call    Screen_Apply_Color_Loop     ; apply color to string area
7BFB 13          10 756 inc     de                          ; move DE to to "Code..." string address
7BFC 2E C4       10 757 ld      l, $C4                      ; HL points to string screen address
7BFE CD 53 6F    10 758 call    Print_String                ; print "Code..."
7C01 DD 2E E4    10 759 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7C04 06 18       10 760 ld      b, 24                       ; string length (loop counter)
7C06 CD 6F 78    10 761 call    Screen_Apply_Color_Loop     ; apply color to string area
7C09 13          10 762 inc     de                          ; move DE to "Einar Saukas" string address
7C0A 2E E4       10 763 ld      l, $E4                      ; HL points to string screen address
7C0C CD 53 6F    10 764 call    Print_String                ; print "Einar Saukas"
7C0F DD 21 24 5A 10 765 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C13 06 18       10 766 ld      b, 24                       ; string length (loop counter)
7C15 CD 6F 78    10 767 call    Screen_Apply_Color_Loop     ; apply color to string area
7C18 13          10 768 inc     de                          ; move DE to "Font..." string address
7C19 21 24 50    10 769 ld      hl, $5024                   ; HL points to string screen address
7C1C CD 53 6F    10 770 call    Print_String                ; print "Font..."
7C1F DD 2E 64    10 771 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C22 06 18       10 772 ld      b, 24                       ; string length (loop counter)
7C24 CD 6F 78    10 773 call    Screen_Apply_Color_Loop     ; apply color to string area
7C27 13          10 774 inc     de                          ; move DE to "Graphics..." string address
7C28 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7C2A CD 53 6F    10 776 call    Print_String                ; print "Graphics..."
7C2D DD 2E 84    10 777 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C30 06 19       10 778 ld      b, 25                       ; string length (loop counter)
7C32 CD 6F 78    10 779 call    Screen_Apply_Color_Loop     ; apply color to string area
7C35 13          10 780 inc     de                          ; move DE to "Antonio Luque" string address
7C36 2E 84       10 781 ld      l, $84                      ; HL points to string screen address
7C38 CD 53 6F    10 782 call    Print_String                ; print "Antonio Luque"
7C3B DD 2E E9    10 783 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C3E 01 38 0D    10 784 ld      bc, 13*256+WHITE_PAPER      ; B = string length (loop counter), C = color attributes
7C41 CD 6F 78    10 785 call    Screen_Apply_Color_Loop     ; apply color to string area
7C44 13          10 786 inc     de                          ; move DE to "Press any key" string address
7C45 2E E9       10 787 ld      l, $E9                      ; HL points to string screen address
7C47 CD 53 6F    10 788 call    Print_String                ; print "Press any key"
7C4A CD BF 6E    10 789 call    Input_Key_Scan              ; wait for a key pressed
7C4D C3 7C 79    10 790 jp      Screen_Menu_Strings         ; return to main menu
7C50             10 792 ; ----------------------------------------------------------------------------------------------------------------------
7C50             10 793 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C50             10 794 ;
7C50             10 795 ; Input:    -
7C50             10 796 ;
7C50             10 797 ; Output:   -
7C50             10 798 ;
7C50             10 799 ; Uses:     TOKEN_COLOR (current token color)
7C50             10 800 ;
7C50             10 801 ; Destroys: A, BC, DE, HL, IX, IY
7C50             10 802 ; ----------------------------------------------------------------------------------------------------------------------
7C50             10 803 Screen_Hexagons:
7C50 FD 21 EA 66 10 804 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C54 3E 07       10 805 ld      a, WHITE                    ; set hexagon color
7C56 32 9E 61    10 806 ld      (TOKEN_COLOR), a            ; save hexagon color
7C59 11 7E 65    10 807 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C5C 06 1C       10 808 ld      b, 28                       ; number of empty hexagons (loop counter)
7C5E CD 75 7C    10 809 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C61 3E 05       10 810 ld      a, CYAN_COLOR               ; set token color
7C63 32 9E 61    10 811 ld      (TOKEN_COLOR), a            ; save hexagon color
7C66 11 3E 66    10 812 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C69 06 06       10 813 ld      b, 6                        ; number of cyan tokens (loop counter)
7C6B CD 75 7C    10 814 call    Screen_Hexagons_Loop        ; draw cyan tokens
7C6E 3E 02       10 815 ld      a, RED_COLOR                ; set token color
7C70 32 9E 61    10 816 ld      (TOKEN_COLOR), a            ; save hexagon color
7C73 06 06       10 817 ld      b, 6                        ; number of red tokens (loop counter)
7C75             10 818 Screen_Hexagons_Loop:
7C75 FD 6E 00    10 819 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7C78 FD 66 01    10 820 ld      h, (iy+1)
7C7B CD 09 6E    10 821 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7C7E D5          10 822 push    de                          ; store hexagon/token sprite address
7C7F CD DB 6D    10 823 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7C82 D1          10 824 pop     de                          ; restore hexagon/token sprite address
7C83 FD 23       10 825 inc     iy                          ; move IY to next hexagon/token screen address
7C85 FD 23       10 826 inc     iy
7C87 10 EC       10 827 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7C89 C9          10 828 ret
7C8A             10 830 ; ----------------------------------------------------------------------------------------------------------------------
7C8A             10 831 ; Screen_Clear_Text: clean a text attributes area
7C8A             10 832 ;
7C8A             10 833 ; Input:    HL = text area attributes address
7C8A             10 834 ;
7C8A             10 835 ; Output:   -
7C8A             10 836 ;
7C8A             10 837 ; Destroys: BC, DE, HL
7C8A             10 838 ; ----------------------------------------------------------------------------------------------------------------------
7C8A             10 839 Screen_Clear_Text:
7C8A 01 30 00    10 840 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7C8D             10 841 Screen_ClearText_Loop
7C8D 11 18 00    10 842 ld      de, 24                      ; displacement for each text row
7C90 19          10 843 add     hl, de                      ; add displacement to text area attributes address
7C91 54          10 844 ld      d, h                        ; DE points to text area attributes address
7C92 5D          10 845 ld      e, l
7C93 36 00       10 846 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7C95 13          10 847 inc     de                          ; move DE to next byte attribute address
7C96 ED A0       10 848 ldi                                 ; set attributes color for the rest of bytes of current row
7C98 ED A0       10 849 ldi
7C9A ED A0       10 850 ldi
7C9C ED A0       10 851 ldi
7C9E ED A0       10 852 ldi
7CA0 ED A0       10 853 ldi
7CA2 ED A0       10 854 ldi
7CA4 ED A0       10 855 ldi
7CA6 EA 8D 7C    10 856 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7CA9 C9          10 857 ret

; File #0: C:\Users\Antonio\source\repos\Hex\Z80CodeFiles\Hex2.z80asm

7CAA             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CAA             0 20 ; Credits and acknowledgements:
7CAA             0 21 ;
7CAA             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CAA             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CAA             0 24 ;   "King+" font and TOKEN graphics.
7CAA             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CAA             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CAA             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CAA             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CAA             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CAA             0 30 ;
7CAA             0 31 ; - Special thanks to my wife Sonia.
7CAA             0 32 ; ----------------------------------------------------------------------------------------------------------------------
