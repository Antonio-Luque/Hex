
; File #0: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Hex2.z80asm

8000             0 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             0 2 ; Hex2.z80asm
8000             0 3 ; Coded by Antonio Luque
8000             0 4 ;
8000             0 5 ; Build file
8000             0 6 ; ----------------------------------------------------------------------------------------------------------------------

; File #1: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Data.z80asm

8000             1 1 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 2 ; Data.z80asm
8000             1 3 ; Coded by Antonio Luque
8000             1 4 ;
8000             1 5 ; Definition of data, variables and tables
8000             1 6 ; ----------------------------------------------------------------------------------------------------------------------
8000             1 8 STACK                   org     $6000
6000             1 10 ; ----------------------------------------------------------------------------------------------------------------------
6000             1 11 ; Circular queue
6000             1 12 ; ----------------------------------------------------------------------------------------------------------------------
6000 00 00 00 00 1 13 CYAN_QUEUE_AREA         defs    256                         ; 256-aligned block reserved for circular queue
6004 00 00 00 00 1 13 
6008 00 00 00 00 1 13 
600C 00 00 00 00 1 13 
6010 00 00 00 00 1 13 
6014 00 00 00 00 1 13 
6018 00 00 00 00 1 13 
601C 00 00 00 00 1 13 
6020 00 00 00 00 1 13 
6024 00 00 00 00 1 13 
6028 00 00 00 00 1 13 
602C 00 00 00 00 1 13 
6030 00 00 00 00 1 13 
6034 00 00 00 00 1 13 
6038 00 00 00 00 1 13 
603C 00 00 00 00 1 13 
6040 00 00 00 00 1 13 
6044 00 00 00 00 1 13 
6048 00 00 00 00 1 13 
604C 00 00 00 00 1 13 
6050 00 00 00 00 1 13 
6054 00 00 00 00 1 13 
6058 00 00 00 00 1 13 
605C 00 00 00 00 1 13 
6060 00 00 00 00 1 13 
6064 00 00 00 00 1 13 
6068 00 00 00 00 1 13 
606C 00 00 00 00 1 13 
6070 00 00 00 00 1 13 
6074 00 00 00 00 1 13 
6078 00 00 00 00 1 13 
607C 00 00 00 00 1 13 
6080 00 00 00 00 1 13 
6084 00 00 00 00 1 13 
6088 00 00 00 00 1 13 
608C 00 00 00 00 1 13 
6090 00 00 00 00 1 13 
6094 00 00 00 00 1 13 
6098 00 00 00 00 1 13 
609C 00 00 00 00 1 13 
60A0 00 00 00 00 1 13 
60A4 00 00 00 00 1 13 
60A8 00 00 00 00 1 13 
60AC 00 00 00 00 1 13 
60B0 00 00 00 00 1 13 
60B4 00 00 00 00 1 13 
60B8 00 00 00 00 1 13 
60BC 00 00 00 00 1 13 
60C0 00 00 00 00 1 13 
60C4 00 00 00 00 1 13 
60C8 00 00 00 00 1 13 
60CC 00 00 00 00 1 13 
60D0 00 00 00 00 1 13 
60D4 00 00 00 00 1 13 
60D8 00 00 00 00 1 13 
60DC 00 00 00 00 1 13 
60E0 00 00 00 00 1 13 
60E4 00 00 00 00 1 13 
60E8 00 00 00 00 1 13 
60EC 00 00 00 00 1 13 
60F0 00 00 00 00 1 13 
60F4 00 00 00 00 1 13 
60F8 00 00 00 00 1 13 
60FC 00 00 00 00 1 13 
6100             1 15 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 16 ; CYAN BOARDS: these boards must be located immediately after cyan queue area!
6100             1 17 ; 
6100             1 18 ; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
6100             1 19 ; distance" (Jack van Rijswijck) from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN
6100             1 20 ; board is also used to store CYAN potentials and TOTAL potentials.
6100             1 21 ; 
6100             1 22 ; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
6100             1 23 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6100             1 24 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6100             1 25 ; ----------------------------------------------------------------------------------------------------------------------
6100             1 26 CYAN_BOARD_UP_DOWN:
6100 7F 7F 7F 7F 1 27 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6104 7F 7F 7F 7F 1 27 
6108 7F 00 00 00 1 28 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
610C 00 00 00 00 1 28 
6110 7F          1 28 
6111 7F 00 00 00 1 29 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6115 00 00 00 00 1 29 
6119 7F          1 29 
611A 7F 00 00 00 1 30 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
611E 00 00 00 00 1 30 
6122 7F          1 30 
6123 7F 00 00 00 1 31 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6127 00 00 00 00 1 31 
612B 7F          1 31 
612C 7F 00 00 00 1 32 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6130 00 00 00 00 1 32 
6134 7F          1 32 
6135 7F 00 00 00 1 33 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6139 00 00 00 00 1 33 
613D 7F          1 33 
613E 7F 00 00 00 1 34 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6142 00 00 00 00 1 34 
6146 7F          1 34 
6147 7F 80 81 82 1 35 defb                         $7F, $80, $81, $82, $83, $84, $85, $86, $7F
614B 83 84 85 86 1 35 
614F 7F          1 35 
6150             1 36 CYAN_BOARD_DOWN_UP:
6150 7F 00 00 00 1 37 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6154 00 00 00 00 1 37 
6158 7F          1 37 
6159 7F 00 00 00 1 38 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $7F
615D 00 00 00 00 1 38 
6161 7F          1 38 
6162 7F 00 00 00 1 39 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6166 00 00 00 00 1 39 
616A 7F          1 39 
616B 7F 00 00 00 1 40 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $7F
616F 00 00 00 00 1 40 
6173 7F          1 40 
6174 7F 00 00 00 1 41 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6178 00 00 00 00 1 41 
617C 7F          1 41 
617D 7F 00 00 00 1 42 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $7F
6181 00 00 00 00 1 42 
6185 7F          1 42 
6186 7F 00 00 00 1 43 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $7F
618A 00 00 00 00 1 43 
618E 7F          1 43 
618F 7F 7F 7F 7F 1 44 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6193 7F 7F 7F 7F 1 44 
6197             1 46 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 47 ; Variables
6197             1 48 ; ----------------------------------------------------------------------------------------------------------------------
6197             1 49 POTENTIALS:                                                 ; (must be in a 256-byte boundary)
6197 00          1 50 defb    0                           ; board potential
6198 00          1 51 defb    0                           ; attack mobility
6199 00          1 52 AI_PLAYER               defb    0                           ; speccy side (FRIEND or ENEMY)
619A 00          1 53 AI_DEPTH                defb    0                           ; recursion depth level (1-4)
619B 00          1 54 MOVE_NUMBER             defb    0                           ; current move number
619C 00          1 55 LEVEL_COLOR             defb    0                           ; current level color for frame border
619D 00          1 56 GAME_LEVEL              defb    0                           ; current game level (1-4)
619E 00          1 57 TOKEN_COLOR             defb    0                           ; current token color
619F 05          1 58 PLAYER_COLOR            defb    5                           ; current player color
61A0             1 60 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 61 ; Screen addresses look-up table for board hexagons
61A0             1 62 ;
61A0             1 63 ; The first column contains the screen addresses high byte
61A0             1 64 ; The rest of bytes are the screen addresses low byte
61A0             1 65 ; ----------------------------------------------------------------------------------------------------------------------
61A0             1 66 BOARD_MAP:
61A0 40 A6 A8 AA 1 67 defb    $40, $A6, $A8, $AA, $AC, $AE, $B0, $B2
61A4 AC AE B0 B2 1 67 
61A8 40 E7 E9 EB 1 68 defb    $40, $E7, $E9, $EB, $ED, $EF, $F1, $F3
61AC ED EF F1 F3 1 68 
61B0 48 28 2A 2C 1 69 defb    $48, $28, $2A, $2C, $2E, $30, $32, $34
61B4 2E 30 32 34 1 69 
61B8 48 69 6B 6D 1 70 defb    $48, $69, $6B, $6D, $6F, $71, $73, $75
61BC 6F 71 73 75 1 70 
61C0 48 AA AC AE 1 71 defb    $48, $AA, $AC, $AE, $B0, $B2, $B4, $B6
61C4 B0 B2 B4 B6 1 71 
61C8 48 EB ED EF 1 72 defb    $48, $EB, $ED, $EF, $F1, $F3, $F5, $F7
61CC F1 F3 F5 F7 1 72 
61D0 50 2C 2E 30 1 73 defb    $50, $2C, $2E, $30, $32, $34, $36, $38
61D4 32 34 36 38 1 73 
61D8             1 75 ; ----------------------------------------------------------------------------------------------------------------------
61D8             1 76 ; Keyboard array map
61D8             1 77 ; ----------------------------------------------------------------------------------------------------------------------
61D8 20 7A 78 63 1 78 KEY_MAP                 defm    " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"
61DC 76 61 73 64 1 78 
61E0 66 67 71 77 1 78 
61E4 65 72 74 31 1 78 
61E8 32 33 34 35 1 78 
61EC 30 39 38 37 1 78 
61F0 36 70 6F 69 1 78 
61F4 75 79 0D 6C 1 78 
61F8 6B 6A 68 20 1 78 
61FC 20 6D 6E 62 1 78 
6200             1 80 ;org     $6200
6200             1 81 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 82 ; Vector table of routines (must be aligned at the next page of cyan board arrays)
6200             1 83 ; ----------------------------------------------------------------------------------------------------------------------
6200             1 84 CYAN_VECTOR_TABLE:
6200 EA 73       1 85 defw    PathFinder_CYAN_Edge_0
6202 0A 74       1 86 defw    PathFinder_CYAN_Edge_1
6204 25 74       1 87 defw    PathFinder_CYAN_Edge_2
6206 43 74       1 88 defw    PathFinder_CYAN_Edge_3
6208 62 74       1 89 defw    PathFinder_CYAN_Edge_4
620A 80 74       1 90 defw    PathFinder_CYAN_Edge_5
620C 9B 74       1 91 defw    PathFinder_CYAN_Edge_6
620E             1 93 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 94 ; Variables and strings
620E             1 95 ; ----------------------------------------------------------------------------------------------------------------------
620E             1 96 PLAYER_MOVE:                                                ; player move in ASCII format
620E 00          1 97 defb    0                           ; column ('a'..'g')
620F 00          1 98 defb    0                           ; row ('1'..'7')
6210 00          1 99 CHAR_COUNT              defb    0                           ; number of current characters in input player move
6211 00          1 100 THREE_ROW               defb    0                           ; three-in-a-row counter
6212 0F 0E 0C 0B 1 101 ROW_COLOR_MAP           defb    15, 14, 12, 11              ; level-color map for frame border
6216 00 2D 30 00 1 102 STR_MOVE                defb    0, '-', '0', 0, '\0'        ; formatted move string
621A 00          1 102 
621B 53 70 65 63 1 103 STR_SPECCY              defm    "Speccy\0"
621F 63 79 00    1 103 
6222 50 6C 61 79 1 104 STR_PLAYER              defm    "Player\0"
6226 65 72 00    1 104 
6229 4C 65 76 65 1 105 STR_LEVELTEXT           defm    "Level\0"
622D 6C 00       1 105 
622F 46 49 4C 4C 1 106 STR_FILLED              defm    "FILLED\0"
6233 45 44 00    1 106 
6236 57 41 49 54 1 107 STR_WAIT                defm    "WAIT\0"
623A 00          1 107 
623B 20 57 49 4E 1 108 STR_WINNER              defm    " WINS \0"
623F 53 20 00    1 108 
6242 20 20 20 20 1 109 STR_EMPTY4              defm    "    \0"
6246 00          1 109 
6247 20 20 20 20 1 110 STR_EMPTY6              defm    "      \0"
624B 20 20 00    1 110 
624E             1 112 ; ----------------------------------------------------------------------------------------------------------------------
624E             1 113 ; Conversion table: from position to XY board indexes
624E             1 114 ; ----------------------------------------------------------------------------------------------------------------------
624E             1 115 BOARD_COORDINATES:
624E 00 00 00 00 1 116 defb    $00, $00, $00, $00, $00, $00, $00, $00
6252 00 00 00 00 1 116 
6256 00 09 0A 0B 1 117 defb    $00, $09, $0A, $0B, $0C, $0D, $0E, $0F
625A 0C 0D 0E 0F 1 117 
625E 00 12 13 14 1 118 defb    $00, $12, $13, $14, $15, $16, $17, $18
6262 15 16 17 18 1 118 
6266 00 1B 1C 1D 1 119 defb    $00, $1B, $1C, $1D, $1E, $1F, $20, $21
626A 1E 1F 20 21 1 119 
626E 00 24 25 26 1 120 defb    $00, $24, $25, $26, $27, $28, $29, $2A
6272 27 28 29 2A 1 120 
6276 00 2D 2E 2F 1 121 defb    $00, $2D, $2E, $2F, $30, $31, $32, $33
627A 30 31 32 33 1 121 
627E 00 36 37 38 1 122 defb    $00, $36, $37, $38, $39, $3A, $3B, $3C
6282 39 3A 3B 3C 1 122 
6286 00 3F 40 41 1 123 defb    $00, $3F, $40, $41, $42, $43, $44, $45
628A 42 43 44 45 1 123 
628E             1 125 ; ----------------------------------------------------------------------------------------------------------------------
628E             1 126 ; Graphics map indexes for the frame tiles
628E             1 127 ; ----------------------------------------------------------------------------------------------------------------------
628E             1 128 FRAME_MAP:
628E 00 01 01 01 1 129 defb      0,   1,   1,   1,   1,   1,   2,   3
6292 01 01 02 03 1 129 
6296 04 FF FF FF 1 130 defb      4,  -1,  -1,  -1,  -1,  -1,  -1,  -1
629A FF FF FF FF 1 130 
629E 05 06 07 01 1 131 defb      5,   6,   7,   1,   1,   1,   1,   1
62A2 01 01 01 01 1 131 
62A6 01 01 01 01 1 132 defb      1,   1,   1,   1,   1,   1,   1,   8
62AA 01 01 01 08 1 132 
62AE 09 01 01 01 1 133 defb      9,   1,   1,   1,   1,   1,   1,   1
62B2 01 01 01 01 1 133 
62B6 01 01 01 01 1 134 defb      1,   1,   1,   1,   1,   1,   1,   1
62BA 01 01 01 01 1 134 
62BE 0A 06 0D 0D 1 135 defb     10,   6,  13,  13,  13,   3,  11,   1
62C2 0D 03 0B 01 1 135 
62C6 01 01 01 01 1 136 defb      1,   1,   1,   1,   1,   1,   1,  12
62CA 01 01 01 0C 1 136 
62CE             1 138 ; ----------------------------------------------------------------------------------------------------------------------
62CE             1 139 ; Definition of a small "Opening Book" for speccy first move
62CE             1 140 ; ----------------------------------------------------------------------------------------------------------------------
62CE             1 141 OPENINGS:
62CE 0F 14 16 17 1 142 defb    $0F, $14, $16, $17, $18, $1C, $1D
62D2 18 1C 1D    1 142 
62D5 1E 1F 20 24 1 143 defb    $1E, $1F, $20, $24, $25, $26, $27
62D9 25 26 27    1 143 
62DC 28 29 2A 2E 1 144 defb    $28, $29, $2A, $2E, $2F, $30, $31
62E0 2F 30 31    1 144 
62E3 32 36 37 38 1 145 defb    $32, $36, $37, $38, $3A, $3F
62E7 3A 3F       1 145 
62E9             1 147 ; ----------------------------------------------------------------------------------------------------------------------
62E9             1 148 ; Timer variables
62E9             1 149 ; ----------------------------------------------------------------------------------------------------------------------
62E9 00          1 150 TIMER_FLAG              defb    0                           ; 0 = timer stopped, 1 = cyan timer on, 2 = red timer on
62EA             1 151 ; for each timer:
62EA             1 152 ;   1st byte = interrupt counter (incremented each 1/50 seconds)
62EA             1 153 ;   2nd byte = seconds counter
62EA             1 154 ;   3th byte = minutes counter
62EA 32 00 00    1 155 CYAN_TIMER              defb    50, 0, 0
62ED 32 00 00    1 156 RED_TIMER               defb    50, 0, 0
62F0             1 158 ; ----------------------------------------------------------------------------------------------------------------------
62F0             1 159 ; Screen addresses look-up array for board numbers
62F0             1 160 ; ----------------------------------------------------------------------------------------------------------------------
62F0             1 161 NUMBER_SCREEN:
62F0 A5 43 E6 43 1 162 defw    $43A5, $43E6, $4B27, $4B68, $4BA9, $4BEA, $532B
62F4 27 4B 68 4B 1 162 
62F8 A9 4B EA 4B 1 162 
62FC 2B 53       1 162 
62FE F1 F1       1 164 FILLER_1                defb    $F1, $F1                    ; filler to align next block (not used)
6300             1 166 ;org     $6300
6300             1 167 ; ----------------------------------------------------------------------------------------------------------------------
6300             1 168 ; Circular queue
6300             1 169 ; ----------------------------------------------------------------------------------------------------------------------
6300 00 00 00 00 1 170 RED_QUEUE_AREA          defs    256                         ; 256-aligned block reserved for circular queue
6304 00 00 00 00 1 170 
6308 00 00 00 00 1 170 
630C 00 00 00 00 1 170 
6310 00 00 00 00 1 170 
6314 00 00 00 00 1 170 
6318 00 00 00 00 1 170 
631C 00 00 00 00 1 170 
6320 00 00 00 00 1 170 
6324 00 00 00 00 1 170 
6328 00 00 00 00 1 170 
632C 00 00 00 00 1 170 
6330 00 00 00 00 1 170 
6334 00 00 00 00 1 170 
6338 00 00 00 00 1 170 
633C 00 00 00 00 1 170 
6340 00 00 00 00 1 170 
6344 00 00 00 00 1 170 
6348 00 00 00 00 1 170 
634C 00 00 00 00 1 170 
6350 00 00 00 00 1 170 
6354 00 00 00 00 1 170 
6358 00 00 00 00 1 170 
635C 00 00 00 00 1 170 
6360 00 00 00 00 1 170 
6364 00 00 00 00 1 170 
6368 00 00 00 00 1 170 
636C 00 00 00 00 1 170 
6370 00 00 00 00 1 170 
6374 00 00 00 00 1 170 
6378 00 00 00 00 1 170 
637C 00 00 00 00 1 170 
6380 00 00 00 00 1 170 
6384 00 00 00 00 1 170 
6388 00 00 00 00 1 170 
638C 00 00 00 00 1 170 
6390 00 00 00 00 1 170 
6394 00 00 00 00 1 170 
6398 00 00 00 00 1 170 
639C 00 00 00 00 1 170 
63A0 00 00 00 00 1 170 
63A4 00 00 00 00 1 170 
63A8 00 00 00 00 1 170 
63AC 00 00 00 00 1 170 
63B0 00 00 00 00 1 170 
63B4 00 00 00 00 1 170 
63B8 00 00 00 00 1 170 
63BC 00 00 00 00 1 170 
63C0 00 00 00 00 1 170 
63C4 00 00 00 00 1 170 
63C8 00 00 00 00 1 170 
63CC 00 00 00 00 1 170 
63D0 00 00 00 00 1 170 
63D4 00 00 00 00 1 170 
63D8 00 00 00 00 1 170 
63DC 00 00 00 00 1 170 
63E0 00 00 00 00 1 170 
63E4 00 00 00 00 1 170 
63E8 00 00 00 00 1 170 
63EC 00 00 00 00 1 170 
63F0 00 00 00 00 1 170 
63F4 00 00 00 00 1 170 
63F8 00 00 00 00 1 170 
63FC 00 00 00 00 1 170 
6400             1 172 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 173 ; RED BOARDS: these boards must be located immediately after red queue area!
6400             1 174 ; 
6400             1 175 ; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
6400             1 176 ; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
6400             1 177 ; LEFT-RIGHT board is also used to store RED potentials.
6400             1 178 ; 
6400             1 179 ; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
6400             1 180 ; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
6400             1 181 ; that indicates a position occupied by a friendly token (stored in 6th bit).
6400             1 182 ; ----------------------------------------------------------------------------------------------------------------------
6400             1 183 RED_BOARD_LEFT_RIGHT:
6400 7F 7F 7F 7F 1 184 defb      $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6404 7F 7F 7F 7F 1 184 
6408 7F 00 00 00 1 185 defb    $7F, $00, $00, $00, $00, $00, $00, $00, $80
640C 00 00 00 00 1 185 
6410 80          1 185 
6411 7F 00 00 00 1 186 defb       $7F, $00, $00, $00, $00, $00, $00, $00, $81
6415 00 00 00 00 1 186 
6419 81          1 186 
641A 7F 00 00 00 1 187 defb          $7F, $00, $00, $00, $00, $00, $00, $00, $82
641E 00 00 00 00 1 187 
6422 82          1 187 
6423 7F 00 00 00 1 188 defb             $7F, $00, $00, $00, $00, $00, $00, $00, $83
6427 00 00 00 00 1 188 
642B 83          1 188 
642C 7F 00 00 00 1 189 defb                $7F, $00, $00, $00, $00, $00, $00, $00, $84
6430 00 00 00 00 1 189 
6434 84          1 189 
6435 7F 00 00 00 1 190 defb                   $7F, $00, $00, $00, $00, $00, $00, $00, $85
6439 00 00 00 00 1 190 
643D 85          1 190 
643E 7F 00 00 00 1 191 defb                      $7F, $00, $00, $00, $00, $00, $00, $00, $86
6442 00 00 00 00 1 191 
6446 86          1 191 
6447 7F 7F 7F 7F 1 192 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
644B 7F 7F 7F 7F 1 192 
644F 7F          1 192 
6450             1 193 RED_BOARD_RIGHT_LEFT:
6450 80 00 00 00 1 194 defb    $80, $00, $00, $00, $00, $00, $00, $00, $7F
6454 00 00 00 00 1 194 
6458 7F          1 194 
6459 81 00 00 00 1 195 defb       $81, $00, $00, $00, $00, $00, $00, $00, $7F
645D 00 00 00 00 1 195 
6461 7F          1 195 
6462 82 00 00 00 1 196 defb          $82, $00, $00, $00, $00, $00, $00, $00, $7F
6466 00 00 00 00 1 196 
646A 7F          1 196 
646B 83 00 00 00 1 197 defb             $83, $00, $00, $00, $00, $00, $00, $00, $7F
646F 00 00 00 00 1 197 
6473 7F          1 197 
6474 84 00 00 00 1 198 defb                $84, $00, $00, $00, $00, $00, $00, $00, $7F
6478 00 00 00 00 1 198 
647C 7F          1 198 
647D 85 00 00 00 1 199 defb                   $85, $00, $00, $00, $00, $00, $00, $00, $7F
6481 00 00 00 00 1 199 
6485 7F          1 199 
6486 86 00 00 00 1 200 defb                      $86, $00, $00, $00, $00, $00, $00, $00, $7F
648A 00 00 00 00 1 200 
648E 7F          1 200 
648F 7F 7F 7F 7F 1 201 defb                         $7F, $7F, $7F, $7F, $7F, $7F, $7F, $7F
6493 7F 7F 7F 7F 1 201 
6497             1 203 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 204 ; Timer digits graphics. Must be in a 256 bytes boundary
6497             1 205 ; ----------------------------------------------------------------------------------------------------------------------
6497             1 206 TIMER_DIGITS:
6497 00 0F 0B 0B 1 207 defb    $00, $0F, $0B, $0B, $0B, $0F, $00, $00              ; 0
649B 0B 0F 00 00 1 207 
649F 00 06 0E 06 1 208 defb    $00, $06, $0E, $06, $06, $06, $00, $00              ; 1
64A3 06 06 00 00 1 208 
64A7 00 0F 03 0F 1 209 defb    $00, $0F, $03, $0F, $08, $0F, $00, $00              ; 2
64AB 08 0F 00 00 1 209 
64AF 00 0F 03 07 1 210 defb    $00, $0F, $03, $07, $03, $0F, $00, $00              ; 3
64B3 03 0F 00 00 1 210 
64B7 00 0B 0B 0F 1 211 defb    $00, $0B, $0B, $0F, $03, $03, $00, $00              ; 4 
64BB 03 03 00 00 1 211 
64BF 00 0F 08 0F 1 212 defb    $00, $0F, $08, $0F, $03, $0F, $00, $00              ; 5
64C3 03 0F 00 00 1 212 
64C7 00 0F 0C 0F 1 213 defb    $00, $0F, $0C, $0F, $0D, $0F, $00, $00              ; 6
64CB 0D 0F 00 00 1 213 
64CF 00 0F 03 03 1 214 defb    $00, $0F, $03, $03, $03, $03, $00, $00              ; 7
64D3 03 03 00 00 1 214 
64D7 00 0F 0B 0F 1 215 defb    $00, $0F, $0B, $0F, $0B, $0F, $00, $00              ; 8
64DB 0B 0F 00 00 1 215 
64DF 00 0F 0B 0F 1 216 defb    $00, $0F, $0B, $0F, $03, $0F, $00, $00              ; 9
64E3 03 0F 00 00 1 216 
64E7             1 218 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 219 ; Tone parameters for sound effects
64E7             1 220 ; ----------------------------------------------------------------------------------------------------------------------
64E7             1 221 ; for each tone (from left to right):
64E7             1 222 ;   - number of frames in the block, slide changes applied once per frame (1..65536)
64E7             1 223 ;   - length of a frame (1..65536)
64E7             1 224 ;   - tone pitch, lower numbers for lower tone (1..65536)
64E7             1 225 ;   - pitch slide, this value is added to pitch every frame (-32767..32768)
64E7             1 226 ; ----------------------------------------------------------------------------------------------------------------------
64E7 01 00 E8 03 1 227 TOKEN_FX                defw       1, 1000, 1400,   0
64EB 78 05 00 00 1 227 
64EF 05 00 88 13 1 228 WINNER_FX               defw       5, 5000,  200, 100
64F3 C8 00 64 00 1 228 
64F7 E8 03 0A 00 1 229 FILLED_FX               defw    1000,   10,  100,   0
64FB 64 00 00 00 1 229 
64FF F2          1 231 FILLER_2                defb    $F2                         ; filler to align next block (not used)
6500             1 233 ;org     $6500
6500             1 234 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 235 ; Vector table of routines (must be aligned at the next page of red board arrays)
6500             1 236 ; ----------------------------------------------------------------------------------------------------------------------
6500             1 237 RED_VECTOR_TABLE:
6500 D0 72       1 238 defw    PathFinder_RED_Edge_0
6502 FE 72       1 239 defw    PathFinder_RED_Edge_1
6504 24 73       1 240 defw    PathFinder_RED_Edge_2
6506 4A 73       1 241 defw    PathFinder_RED_Edge_3
6508 70 73       1 242 defw    PathFinder_RED_Edge_4
650A 96 73       1 243 defw    PathFinder_RED_Edge_5
650C BC 73       1 244 defw    PathFinder_RED_Edge_6
650E             1 246 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 247 ; Graphics for the screen frame
650E             1 248 ; ----------------------------------------------------------------------------------------------------------------------
650E             1 249 FRAME_TILES:
650E 00 00 1F 3F 1 250 defb    $00, $00, $1F, $3F, $3F, $3F, $3C, $3C              ; 00: up-left corner
6512 3F 3F 3C 3C 1 250 
6516 00 00 FF FF 1 251 defb    $00, $00, $FF, $FF, $FF, $FF, $00, $00              ; 01: horizontal bar
651A FF FF 00 00 1 251 
651E 00 00 FF FE 1 252 defb    $00, $00, $FF, $FE, $FE, $FF, $00, $00              ; 02: concave left
6522 FE FF 00 00 1 252 
6526 03 07 0F 0F 1 253 defb    $03, $07, $0F, $0F, $0F, $0F, $07, $03              ; 03: end frame 1
652A 0F 0F 07 03 1 253 
652E FF FE FC FC 1 254 defb    $FF, $FE, $FC, $FC, $FC, $FC, $FE, $FF              ; 04: level left
6532 FC FC FE FF 1 254 
6536 FF 7F 3F 3F 1 255 defb    $FF, $7F, $3F, $3F, $3F, $3F, $7F, $FF              ; 05: level right
653A 3F 3F 7F FF 1 255 
653E C0 E0 F0 F0 1 256 defb    $C0, $E0, $F0, $F0, $F0, $F0, $E0, $C0              ; 06: end frame 2
6542 F0 F0 E0 C0 1 256 
6546 00 00 FF 7F 1 257 defb    $00, $00, $FF, $7F, $7F, $FF, $00, $00              ; 07: concave right
654A 7F FF 00 00 1 257 
654E 00 00 F8 FC 1 258 defb    $00, $00, $F8, $FC, $FC, $FC, $3C, $3C              ; 08: up-right corner
6552 FC FC 3C 3C 1 258 
6556 3C 3C 3F 3F 1 259 defb    $3C, $3C, $3F, $3F, $3F, $1F, $00, $00              ; 09: bottom-left corner
655A 3F 1F 00 00 1 259 
655E 00 00 FE FF 1 260 defb    $00, $00, $FE, $FF, $FF, $FE, $00, $00              ; 10: convex left
6562 FF FE 00 00 1 260 
6566 00 00 7F FF 1 261 defb    $00, $00, $7F, $FF, $FF, $7F, $00, $00              ; 11: convex right
656A FF 7F 00 00 1 261 
656E 3C 3C FC FC 1 262 defb    $3C, $3C, $FC, $FC, $FC, $F8, $00, $00              ; 12: bottom-right corner
6572 FC F8 00 00 1 262 
6576 00 00 38 7C 1 263 defb    $00, $00, $38, $7C, $7C, $38, $00, $00              ; 13: level marks
657A 7C 38 00 00 1 263 
657E             1 265 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 266 ; Hexagon sprites
657E             1 267 ; ----------------------------------------------------------------------------------------------------------------------
657E             1 268 HEXAGON_EMPTY:
657E 07 E0 18 18 1 269 defb    $07, $E0, $18, $18, $20, $04, $24, $04
6582 20 04 24 04 1 269 
6586 48 02 48 02 1 270 defb    $48, $02, $48, $02, $40, $02, $40, $02
658A 40 02 40 02 1 270 
658E 40 02 40 02 1 271 defb    $40, $02, $40, $02, $40, $12, $40, $12
6592 40 12 40 12 1 271 
6596 20 24 20 04 1 272 defb    $20, $24, $20, $04, $18, $18, $07, $E0
659A 18 18 07 E0 1 272 
659E             1 273 HEXAGON_SPRITE:
659E 03 C0 0C 30 1 274 defb    $03, $C0, $0C, $30, $10, $08, $12, $08
65A2 10 08 12 08 1 274 
65A6 24 04 24 04 1 275 defb    $24, $04, $24, $04, $20, $04, $20, $04
65AA 20 04 20 04 1 275 
65AE 20 04 20 04 1 276 defb    $20, $04, $20, $04, $20, $24, $20, $24
65B2 20 24 20 24 1 276 
65B6 10 48 10 08 1 277 defb    $10, $48, $10, $08, $0C, $30, $03, $C0
65BA 0C 30 03 C0 1 277 
65BE 01 80 02 40 1 279 defb    $01, $80, $02, $40, $04, $20, $09, $10
65C2 04 20 09 10 1 279 
65C6 0A 10 0A 10 1 280 defb    $0A, $10, $0A, $10, $08, $10, $08, $10
65CA 08 10 08 10 1 280 
65CE 08 10 08 10 1 281 defb    $08, $10, $08, $10, $08, $50, $08, $50
65D2 08 50 08 50 1 281 
65D6 08 90 04 20 1 282 defb    $08, $90, $04, $20, $02, $40, $01, $80
65DA 02 40 01 80 1 282 
65DE 00 80 00 80 1 284 defb    $00, $80, $00, $80, $00, $80, $00, $80
65E2 00 80 00 80 1 284 
65E6 00 80 00 80 1 285 defb    $00, $80, $00, $80, $00, $80, $00, $80
65EA 00 80 00 80 1 285 
65EE 00 80 00 80 1 286 defb    $00, $80, $00, $80, $00, $80, $00, $80
65F2 00 80 00 80 1 286 
65F6 00 80 00 80 1 287 defb    $00, $80, $00, $80, $00, $80, $00, $80
65FA 00 80 00 80 1 287 
65FE 01 80 02 40 1 289 defb    $01, $80, $02, $40, $05, $A0, $0B, $D0
6602 05 A0 0B D0 1 289 
6606 0B D0 0B D0 1 290 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
660A 0B D0 0B D0 1 290 
660E 0B D0 0B D0 1 291 defb    $0B, $D0, $0B, $D0, $0B, $D0, $0B, $D0
6612 0B D0 0B D0 1 291 
6616 0B D0 05 A0 1 292 defb    $0B, $D0, $05, $A0, $02, $40, $01, $80
661A 02 40 01 80 1 292 
661E 03 C0 0C 30 1 294 defb    $03, $C0, $0C, $30, $13, $C8, $17, $E8
6622 13 C8 17 E8 1 294 
6626 2F F4 2F F4 1 295 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
662A 2F F4 2F F4 1 295 
662E 2F F4 2F F4 1 296 defb    $2F, $F4, $2F, $F4, $2F, $F4, $2F, $F4
6632 2F F4 2F F4 1 296 
6636 17 E8 13 C8 1 297 defb    $17, $E8, $13, $C8, $0C, $30, $03, $C0
663A 0C 30 03 C0 1 297 
663E             1 298 HEXAGON_TOKEN:
663E 07 E0 18 18 1 299 defb    $07, $E0, $18, $18, $27, $E4, $2F, $F4
6642 27 E4 2F F4 1 299 
6646 5F FA 5F FA 1 300 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
664A 5F FA 5F FA 1 300 
664E 5F FA 5F FA 1 301 defb    $5F, $FA, $5F, $FA, $5F, $FA, $5F, $FA
6652 5F FA 5F FA 1 301 
6656 2F F4 27 E4 1 302 defb    $2F, $F4, $27, $E4, $18, $18, $07, $E0
665A 18 18 07 E0 1 302 
665E             1 304 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 305 ; Board letter sprites
665E             1 306 ; ----------------------------------------------------------------------------------------------------------------------
665E             1 307 LETTER_SPRITES:
665E 3C 7E FF C3 1 308 defb    $3C, $7E, $FF, $C3, $F3, $C3, $D3, $C3, $7E, $3C    ; a
6662 F3 C3 D3 C3 1 308 
6666 7E 3C       1 308 
6668 3C 7E CF CF 1 309 defb    $3C, $7E, $CF, $CF, $C3, $CB, $CB, $C3, $7E, $3C    ; b
666C C3 CB CB C3 1 309 
6670 7E 3C       1 309 
6672 3C 7E FF E3 1 310 defb    $3C, $7E, $FF, $E3, $CF, $CF, $CF, $E3, $7E, $3C    ; c
6676 CF CF CF E3 1 310 
667A 7E 3C       1 310 
667C 3C 7E F3 F3 1 311 defb    $3C, $7E, $F3, $F3, $C3, $D3, $D3, $C3, $7E, $3C    ; d
6680 C3 D3 D3 C3 1 311 
6684 7E 3C       1 311 
6686 3C 7E FF E3 1 312 defb    $3C, $7E, $FF, $E3, $CB, $C3, $CF, $E3, $7E, $3C    ; e
668A CB C3 CF E3 1 312 
668E 7E 3C       1 312 
6690 3C 7E E3 CF 1 313 defb    $3C, $7E, $E3, $CF, $C7, $CF, $CF, $CF, $7E, $3C    ; f
6694 C7 CF CF CF 1 313 
6698 7E 3C       1 313 
669A 3C 7E FF E3 1 314 defb    $3C, $7E, $FF, $E3, $D3, $D3, $E3, $F3, $46, $3C    ; g
669E D3 D3 E3 F3 1 314 
66A2 46 3C       1 314 
66A4             1 316 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 317 ; Board number sprites
66A4             1 318 ; ----------------------------------------------------------------------------------------------------------------------
66A4             1 319 NUMBER_SPRITES:
66A4 3C 7E E7 C7 1 320 defb    $3C, $7E, $E7, $C7, $E7, $E7, $E7, $E7, $7E, $3C    ; 1
66A8 E7 E7 E7 E7 1 320 
66AC 7E 3C       1 320 
66AE 3C 7E E7 D3 1 321 defb    $3C, $7E, $E7, $D3, $F3, $E7, $CF, $C3, $7E, $3C    ; 2
66B2 F3 E7 CF C3 1 321 
66B6 7E 3C       1 321 
66B8 3C 7E C7 F3 1 322 defb    $3C, $7E, $C7, $F3, $E3, $F3, $F3, $C7, $7E, $3C    ; 3
66BC E3 F3 F3 C7 1 322 
66C0 7E 3C       1 322 
66C2 3C 7E D3 D3 1 323 defb    $3C, $7E, $D3, $D3, $C3, $F3, $F3, $F3, $7E, $3C    ; 4
66C6 C3 F3 F3 F3 1 323 
66CA 7E 3C       1 323 
66CC 3C 7E C3 CF 1 324 defb    $3C, $7E, $C3, $CF, $C7, $F3, $F3, $C7, $7E, $3C    ; 5
66D0 C7 F3 F3 C7 1 324 
66D4 7E 3C       1 324 
66D6 3C 7E E3 CF 1 325 defb    $3C, $7E, $E3, $CF, $C3, $CB, $CB, $C3, $7E, $3C    ; 6
66DA C3 CB CB C3 1 325 
66DE 7E 3C       1 325 
66E0 3C 7E C3 F3 1 326 defb    $3C, $7E, $C3, $F3, $F3, $E7, $E7, $E7, $7E, $3C    ; 7
66E4 F3 E7 E7 E7 1 326 
66E8 7E 3C       1 326 
66EA             1 328 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 329 ; Screen addresses for menu hexagons
66EA             1 330 ; ----------------------------------------------------------------------------------------------------------------------
66EA             1 331 MENU_HEXAGONS:
66EA 01 40 05 40 1 332 defw    $4001, $4005, $4008, $400C, $400F, $4013, $401A
66EE 08 40 0C 40 1 332 
66F2 0F 40 13 40 1 332 
66F6 1A 40       1 332 
66F8 45 40 48 40 1 333 defw    $4045, $4048, $4052, $405D, $4081, $4083, $4085
66FC 52 40 5D 40 1 333 
6700 81 40 83 40 1 333 
6704 85 40       1 333 
6706 88 40 8A 40 1 334 defw    $4088, $408A, $4091, $409D, $40C1, $40D0, $40D9
670A 91 40 9D 40 1 334 
670E C1 40 D0 40 1 334 
6712 D9 40       1 334 
6714 05 48 08 48 1 335 defw    $4805, $4808, $480A, $4813, $4819, $481B, $481D
6718 0A 48 13 48 1 335 
671C 19 48 1B 48 1 335 
6720 1D 48       1 335 
6722 0A 40 59 40 1 336 defw    $400A, $4059, $40BB, $40C5, $40D2, $480C, $401C
6726 BB 40 C5 40 1 336 
672A D2 40 0C 48 1 336 
672E 1C 40       1 336 
6730 41 40 50 40 1 337 defw    $4041, $4050, $40C8, $4801, $480F
6734 C8 40 01 48 1 337 
6738 0F 48       1 337 
673A             1 338 SAMPLE_BOARD_RED:
673A 69 48 6B 48 1 339 defw    $4869, $486B, $482C, $482E, $40EF, $40F1, $40B2
673E 2C 48 2E 48 1 339 
6742 EF 40 F1 40 1 339 
6746 B2 40       1 339 
6748 E9 40 6F 48 1 340 defw    $40E9, $486F, $4830, $40F3, $48AA, $40AC, $48EF
674C 30 48 F3 40 1 340 
6750 AA 48 AC 40 1 340 
6754 EF 48       1 340 
6756 2A 48 6D 48 1 341 defw    $482A, $486D, $40ED, $48AE
675A ED 40 AE 48 1 341 
675E             1 342 SAMPLE_BOARD_CYAN:
675E AE 40 EF 40 1 343 defw    $40AE, $40EF, $4830, $486F, $48AE, $48EF, $502E
6762 30 48 6F 48 1 343 
6766 AE 48 EF 48 1 343 
676A 2E 50       1 343 
676C AC 48 B4 48 1 344 defw    $48AC, $48B4, $486B, $486D, $482E, $40F1, $40F3
6770 6B 48 6D 48 1 344 
6774 2E 48 F1 40 1 344 
6778 F3 40       1 344 
677A 73 48 B2 48 1 345 defw    $4873, $48B2, $5030
677E 30 50       1 345 
6780             1 347 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 348 ; Strings
6780             1 349 ; ----------------------------------------------------------------------------------------------------------------------
6780             1 350 STR_OPTIONS:
6780 53 74 61 72 1 351 defm    "Start new game\0"
6784 74 20 6E 65 1 351 
6788 77 20 67 61 1 351 
678C 6D 65 00    1 351 
678F 48 6F 77 20 1 352 defm    "How to play\0"
6793 74 6F 20 70 1 352 
6797 6C 61 79 00 1 352 
679B 43 72 65 64 1 353 defm    "Credits\0"
679F 69 74 73 00 1 353 
67A3             1 354 STR_CREDITS:
67A3 44 65 73 69 1 355 defm    "Design:     Antonio Luque\0"
67A7 67 6E 3A 20 1 355 
67AB 20 20 20 20 1 355 
67AF 41 6E 74 6F 1 355 
67B3 6E 69 6F 20 1 355 
67B7 4C 75 71 75 1 355 
67BB 65 00       1 355 
67BD 43 6F 64 65 1 356 defm    "Code:       Antonio Luque\0"
67C1 3A 20 20 20 1 356 
67C5 20 20 20 20 1 356 
67C9 41 6E 74 6F 1 356 
67CD 6E 69 6F 20 1 356 
67D1 4C 75 71 75 1 356 
67D5 65 00       1 356 
67D7 20 20 20 20 1 357 defm    "            Einar Saukas\0"
67DB 20 20 20 20 1 357 
67DF 20 20 20 20 1 357 
67E3 45 69 6E 61 1 357 
67E7 72 20 53 61 1 357 
67EB 75 6B 61 73 1 357 
67EF 00          1 357 
67F0 46 6F 6E 74 1 358 defm    "Font:       Einar Saukas\0"
67F4 3A 20 20 20 1 358 
67F8 20 20 20 20 1 358 
67FC 45 69 6E 61 1 358 
6800 72 20 53 61 1 358 
6804 75 6B 61 73 1 358 
6808 00          1 358 
6809 47 72 61 70 1 359 defm    "Graphics:   Einar Saukas\0"
680D 68 69 63 73 1 359 
6811 3A 20 20 20 1 359 
6815 45 69 6E 61 1 359 
6819 72 20 53 61 1 359 
681D 75 6B 61 73 1 359 
6821 00          1 359 
6822 20 20 20 20 1 360 defm    "            Antonio Luque\0"
6826 20 20 20 20 1 360 
682A 20 20 20 20 1 360 
682E 41 6E 74 6F 1 360 
6832 6E 69 6F 20 1 360 
6836 4C 75 71 75 1 360 
683A 65 00       1 360 
683C 50 72 65 73 1 361 STR_PRESSKEY            defm    "Press any key\0"
6840 73 20 61 6E 1 361 
6844 79 20 6B 65 1 361 
6848 79 00       1 361 
684A             1 362 STR_BUTTONS:
684A 4E 65 78 74 1 363 defm    "Next\0"
684E 00          1 363 
684F 42 61 63 6B 1 364 defm    "Back\0"
6853 00          1 364 
6854 52 45 44 00 1 365 STR_RED                 defm    "RED\0"
6858 43 59 41 4E 1 366 STR_CYAN                defm    "CYAN\0"
685C 00          1 366 
685D 43 6F 6E 6E 1 367 STR_HELP1               defm    "Connect\0"
6861 65 63 74 00 1 367 
6865 6C 65 66 74 1 368 STR_HELP2_RED           defm    "left and\0"
6869 20 61 6E 64 1 368 
686D 00          1 368 
686E 75 70 20 61 1 369 STR_HELP2_CYAN          defm    "up and\0"
6872 6E 64 00    1 369 
6875 72 69 67 68 1 370 STR_HELP3_RED           defm    "right\0"
6879 74 00       1 370 
687B 64 6F 77 6E 1 371 STR_HELP3_CYAN          defm    "down\0"
687F 00          1 371 
6880 62 6F 72 64 1 372 STR_HELP4               defm    "borders\0"
6884 65 72 73 00 1 372 
6888 74 6F 20 77 1 373 STR_HELP5               defm    "to win\0"
688C 69 6E 00    1 373 
688F             1 374 STR_HELP:
688F 57 69 6E 20 1 375 defm    "Win three\0"
6893 74 68 72 65 1 375 
6897 65 00       1 375 
6899 74 69 6D 65 1 376 defm    "times in\0"
689D 73 20 69 6E 1 376 
68A1 00          1 376 
68A2 61 20 72 6F 1 377 defm    "a row to\0"
68A6 77 20 74 6F 1 377 
68AA 00          1 377 
68AB 6C 65 76 65 1 378 defm    "level up\0"
68AF 6C 20 75 70 1 378 
68B3 00          1 378 
68B4 20 43 4F 4E 1 379 STR_CONGRATS            defm    " CONGRATULATIONS \0"
68B8 47 52 41 54 1 379 
68BC 55 4C 41 54 1 379 
68C0 49 4F 4E 53 1 379 
68C4 20 00       1 379 
68C6             1 380 STR_LAST_LEVEL:
68C6 57 65 6C 6C 1 381 defm    "Well done! Last level passed\0"
68CA 20 64 6F 6E 1 381 
68CE 65 21 20 4C 1 381 
68D2 61 73 74 20 1 381 
68D6 6C 65 76 65 1 381 
68DA 6C 20 70 61 1 381 
68DE 73 73 65 64 1 381 
68E2 00          1 381 
68E3 43 68 6F 6F 1 382 defm    "Choose level to restart, 1-4\0"
68E7 73 65 20 6C 1 382 
68EB 65 76 65 6C 1 382 
68EF 20 74 6F 20 1 382 
68F3 72 65 73 74 1 382 
68F7 61 72 74 2C 1 382 
68FB 20 31 2D 34 1 382 
68FF 00          1 382 
6900             1 384 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 385 ; Based on "King" font https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA
6900             1 386 ; this font was designed by Einar Saukas for Hex game
6900             1 387 ; ----------------------------------------------------------------------------------------------------------------------
6900             1 388 FONT:
6900 00 00 00 00 1 389 includebin "King+.bin"
6904 00 00 00 00 1 389 
6908 00 18 18 18 1 389 
690C 00 18 18 00 1 389 
6910 00 24 24 00 1 389 
6914 00 00 00 00 1 389 
6918 00 24 7E 24 1 389 
691C 24 7E 24 00 1 389 
6920 00 08 3E 28 1 389 
6924 3E 0A 3E 08 1 389 
6928 00 62 64 08 1 389 
692C 10 26 46 00 1 389 
6930 00 10 28 10 1 389 
6934 2A 44 3A 00 1 389 
6938 00 18 30 00 1 389 
693C 00 00 00 00 1 389 
6940 06 0C 08 08 1 389 
6944 08 0C 06 00 1 389 
6948 60 30 10 10 1 389 
694C 10 30 60 00 1 389 
6950 00 00 14 08 1 389 
6954 3E 08 14 00 1 389 
6958 00 00 08 08 1 389 
695C 3E 08 08 00 1 389 
6960 00 00 00 00 1 389 
6964 00 0C 18 30 1 389 
6968 00 00 00 7E 1 389 
696C 7E 00 00 00 1 389 
6970 00 00 00 00 1 389 
6974 30 70 70 00 1 389 
6978 02 06 0C 18 1 389 
697C 30 60 40 00 1 389 
6980 00 7E 62 62 1 389 
6984 62 62 7E 00 1 389 
6988 00 18 38 18 1 389 
698C 18 18 3C 00 1 389 
6990 00 38 4C 4C 1 389 
6994 18 30 7C 00 1 389 
6998 00 3C 62 0C 1 389 
699C 06 66 3C 00 1 389 
69A0 00 30 30 30 1 389 
69A4 30 34 3E 04 1 389 
69A8 00 7E 60 7E 1 389 
69AC 06 66 3C 00 1 389 
69B0 00 30 60 7C 1 389 
69B4 66 66 3C 00 1 389 
69B8 00 7E 46 0C 1 389 
69BC 18 30 60 00 1 389 
69C0 00 3C 66 3C 1 389 
69C4 66 66 3C 00 1 389 
69C8 00 3C 66 66 1 389 
69CC 3E 06 3C 00 1 389 
69D0 00 00 08 18 1 389 
69D4 00 08 18 00 1 389 
69D8 00 00 04 0C 1 389 
69DC 00 0C 18 30 1 389 
69E0 00 00 04 08 1 389 
69E4 10 08 04 00 1 389 
69E8 00 00 00 3E 1 389 
69EC 00 3E 00 00 1 389 
69F0 00 00 10 08 1 389 
69F4 04 08 10 00 1 389 
69F8 00 3C 42 04 1 389 
69FC 08 00 08 00 1 389 
6A00 00 3C 4A 56 1 389 
6A04 5E 40 3C 00 1 389 
6A08 00 7E 46 46 1 389 
6A0C 7E 46 46 00 1 389 
6A10 00 7C 62 7C 1 389 
6A14 62 62 7C 00 1 389 
6A18 00 7E 66 60 1 389 
6A1C 60 66 7E 00 1 389 
6A20 00 7C 46 46 1 389 
6A24 46 46 7C 00 1 389 
6A28 00 7E 60 7C 1 389 
6A2C 60 60 7E 00 1 389 
6A30 00 7E 60 7C 1 389 
6A34 60 60 60 00 1 389 
6A38 00 3E 62 60 1 389 
6A3C 66 66 3E 00 1 389 
6A40 00 62 62 7E 1 389 
6A44 62 62 62 00 1 389 
6A48 00 18 18 18 1 389 
6A4C 18 18 18 00 1 389 
6A50 00 0C 0C 0C 1 389 
6A54 0C 4C 38 00 1 389 
6A58 00 66 64 68 1 389 
6A5C 7E 46 66 00 1 389 
6A60 00 60 60 60 1 389 
6A64 60 60 7E 00 1 389 
6A68 00 7E 56 56 1 389 
6A6C 56 56 56 00 1 389 
6A70 00 7E 46 46 1 389 
6A74 46 46 46 00 1 389 
6A78 00 7E 62 62 1 389 
6A7C 62 62 7E 00 1 389 
6A80 00 7E 62 62 1 389 
6A84 7E 60 60 00 1 389 
6A88 00 7C 64 64 1 389 
6A8C 64 64 7E 00 1 389 
6A90 00 7C 62 64 1 389 
6A94 7C 46 46 00 1 389 
6A98 00 7E 60 7E 1 389 
6A9C 06 06 7E 00 1 389 
6AA0 00 7E 18 18 1 389 
6AA4 18 18 18 00 1 389 
6AA8 00 62 62 62 1 389 
6AAC 62 62 7E 00 1 389 
6AB0 00 62 62 62 1 389 
6AB4 62 34 18 00 1 389 
6AB8 00 6A 6A 6A 1 389 
6ABC 6A 6A 7E 00 1 389 
6AC0 00 62 62 34 1 389 
6AC4 4E 46 46 00 1 389 
6AC8 00 62 62 7E 1 389 
6ACC 18 18 18 00 1 389 
6AD0 00 7E 06 1C 1 389 
6AD4 38 60 7E 00 1 389 
6AD8 00 0E 08 08 1 389 
6ADC 08 08 0E 00 1 389 
6AE0 00 00 40 20 1 389 
6AE4 10 08 04 00 1 389 
6AE8 00 70 10 10 1 389 
6AEC 10 10 70 00 1 389 
6AF0 00 08 1C 2A 1 389 
6AF4 08 08 08 08 1 389 
6AF8 00 00 00 00 1 389 
6AFC 00 00 00 FF 1 389 
6B00 0C 12 10 38 1 389 
6B04 10 10 3E 00 1 389 
6B08 00 00 3C 06 1 389 
6B0C 7E 46 7E 00 1 389 
6B10 00 60 60 7E 1 389 
6B14 62 62 7E 00 1 389 
6B18 00 00 7E 62 1 389 
6B1C 60 62 7E 00 1 389 
6B20 00 06 06 7E 1 389 
6B24 46 46 7E 00 1 389 
6B28 00 00 7E 46 1 389 
6B2C 7E 60 7E 00 1 389 
6B30 00 1E 30 3C 1 389 
6B34 30 30 30 00 1 389 
6B38 00 00 7E 46 1 389 
6B3C 46 3E 06 3E 1 389 
6B40 00 60 60 7C 1 389 
6B44 66 66 66 00 1 389 
6B48 00 18 00 38 1 389 
6B4C 18 18 3C 00 1 389 
6B50 00 0C 00 0C 1 389 
6B54 0C 0C 4C 38 1 389 
6B58 00 20 2C 38 1 389 
6B5C 38 2C 26 00 1 389 
6B60 00 18 18 18 1 389 
6B64 18 18 0E 00 1 389 
6B68 00 00 6C 56 1 389 
6B6C 56 56 46 00 1 389 
6B70 00 00 7C 46 1 389 
6B74 46 46 46 00 1 389 
6B78 00 00 3C 46 1 389 
6B7C 46 46 3C 00 1 389 
6B80 00 00 7C 66 1 389 
6B84 66 7C 60 60 1 389 
6B88 00 00 3E 46 1 389 
6B8C 46 3E 06 06 1 389 
6B90 00 00 3C 62 1 389 
6B94 60 60 60 00 1 389 
6B98 00 00 3C 60 1 389 
6B9C 3C 06 3C 00 1 389 
6BA0 00 30 78 30 1 389 
6BA4 30 30 1C 00 1 389 
6BA8 00 00 46 46 1 389 
6BAC 46 46 3C 00 1 389 
6BB0 00 00 46 46 1 389 
6BB4 2C 3C 18 00 1 389 
6BB8 00 00 46 56 1 389 
6BBC 56 56 2C 00 1 389 
6BC0 00 00 46 2C 1 389 
6BC4 18 2C 46 00 1 389 
6BC8 00 00 46 46 1 389 
6BCC 46 3E 06 3C 1 389 
6BD0 00 00 7E 0C 1 389 
6BD4 18 30 7E 00 1 389 
6BD8 00 0E 08 30 1 389 
6BDC 08 08 0E 00 1 389 
6BE0 00 08 08 08 1 389 
6BE4 08 2A 1C 08 1 389 
6BE8 00 70 10 0C 1 389 
6BEC 10 10 70 00 1 389 
6BF0 00 14 28 00 1 389 
6BF4 00 00 00 00 1 389 

; File #2: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Main.z80asm

6BF8             2 1 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 2 ; Main.z80asm
6BF8             2 3 ; Coded by Antonio Luque
6BF8             2 4 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 6 CYAN_COLOR              equ     %00000101                   ; attributes: flash 0, bright 0, paper 0, ink 5
6BF8             2 7 RED_COLOR               equ     %00000010                   ; attributes: flash 0, bright 0, paper 0, ink 2
6BF8             2 9 ent     $
6BF8             2 10 ; ----------------------------------------------------------------------------------------------------------------------
6BF8             2 11 ; Entry point of the program - Initialization
6BF8             2 12 ; ----------------------------------------------------------------------------------------------------------------------
6BF8 F3          2 14 di                                  ; disable interrupts
6BF9             2 16 ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)
6BF9 21 5A 76    2 18 ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
6BFC FD 36 67 C3 2 19 ld      (iy+103), $C3               ; 'jp' opcode
6C00 FD 75 68    2 20 ld      (iy+104), l                 ; Low byte of interrupt routine address
6C03 FD 74 69    2 21 ld      (iy+105), h                 ; High byte of interrupt routine address
6C06 3E 2E       2 22 ld      a, $2E                      ; High byte of interrupt vector address
6C08 ED 47       2 23 ld      i, a                        ; set interrupt vector address
6C0A ED 5E       2 24 im      2                           ; set interrupt mode 2
6C0C             2 26 ; When the ULA triggers an interrupt it doesn't put any device ID in the data bus. When no value
6C0C             2 27 ; is placed on the Spectrum's data bus, this acquires the value of 8 signals one ($FF). So, the
6C0C             2 28 ; resultant vector address is formed as follows:
6C0C             2 29 ;
6C0C             2 30 ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
6C0C             2 31 ; Source: 
6C0C             2 32 ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
6C0C             2 33 ;
6C0C             2 34 ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
6C0C             2 35 ; memory area and it is used by some ROM routines, but it is no longer used by HEX2 program.
6C0C 31 00 60    2 37 ld      sp, STACK                   ; move stack
6C0F AF          2 39 xor     a                           ; A = 0
6C10 D3 FE       2 40 out     ($FE), a                    ; set border color (black)
6C12 CD AC 79    2 41 call    Screen_Menu                 ; show main menu and wait for an option
6C15             2 43 ; ----------------------------------------------------------------------------------------------------------------------
6C15             2 44 ; Start new game
6C15             2 45 ; ----------------------------------------------------------------------------------------------------------------------
6C15             2 46 Main_Start
6C15 CD 40 77    2 47 call    Screen_Clear                ; fill in black the whole screen area and attributes area
6C18 CD 4E 77    2 48 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
6C1B CD 7A 77    2 49 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
6C1E CD B9 77    2 50 call    Screen_Frame                ; draw the screen frame
6C21 CD 11 78    2 51 call    Screen_Tokens               ; draw the fixed tokens on the screen
6C24 CD 30 78    2 52 call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
6C27 CD 73 78    2 53 call    Screen_Color_Statics        ; apply color to statics items of the screen
6C2A FB          2 55 ei                                  ; enable interrupts
6C2B             2 57 ; ----------------------------------------------------------------------------------------------------------------------
6C2B             2 58 ; New level
6C2B             2 59 ; ----------------------------------------------------------------------------------------------------------------------
6C2B             2 60 Main_New_Level
6C2B 3E 04       2 61 ld      a, 4                        ; maximum level
6C2D 21 9D 61    2 62 ld      hl, GAME_LEVEL              ; HL points to game level address
6C30 BE          2 63 cp      (hl)                        ; level 4 achieved?
6C31 20 05       2 64 jr      nz, Main_Increment_Level    ; no, increment game level
6C33 CD AD 78    2 65 call    Screen_Last_Level           ; show last level screen and input game level
6C36 18 DD       2 66 jr      Main_Start                  ; start a new game
6C38             2 67 Main_Increment_Level
6C38 34          2 68 inc     (hl)                        ; increment game level
6C39 CD 50 79    2 69 call    Screen_Frame_Color          ; set up frame color depending on current level
6C3C CD 3F 79    2 70 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
6C3F AF          2 71 xor     a                           ; A = 0
6C40 32 11 62    2 72 ld      (THREE_ROW), a              ; initialize three-in-a-row counter
6C43             2 74 ; ----------------------------------------------------------------------------------------------------------------------
6C43             2 75 ; Start new match
6C43             2 76 ; ----------------------------------------------------------------------------------------------------------------------
6C43             2 77 Main_Start_Match
6C43             2 78 ; set up timers and clear last messages
6C43 CD EF 76    2 80 call    Timer_Reset                 ; reset timers
6C46 CD DA 76    2 81 call    Timer_Display_All           ; display timers
6C49 CD 42 6F    2 82 call    Print_Clear_Alert           ; clear last alert
6C4C 3E 02       2 83 ld      a, RED_COLOR                ; set red color in A
6C4E 32 9E 61    2 84 ld      (TOKEN_COLOR), a            ; save token color
6C51 CD 69 6F    2 85 call    Print_Clear_Move            ; clear red player last move
6C54             2 87 ; swap players' colors
6C54 3A 9F 61    2 89 ld      a, (PLAYER_COLOR)           ; get current player color
6C57 EE 07       2 90 xor     %00000111                   ; swap color
6C59 32 9F 61    2 91 ld      (PLAYER_COLOR), a           ; save swapped player color
6C5C CD 25 6F    2 92 call    Print_Players               ; print "Player" and "Speccy" strings
6C5F             2 94 ; initialize boards
6C5F 21 00 7D    2 96 ld      hl, CYAN_POSITIONS          ; HL points to cyan positions address
6C62 11 01 7D    2 97 ld      de, CYAN_POSITIONS+1        ; DE points to cyan positions (+1) address
6C65 36 00       2 98 ld      (hl), EMPTY                 ; set first position as empty
6C67 01 FF 01    2 99 ld      bc, (256*2)-1               ; length of cyan + red positions areas (-1 already set)
6C6A ED B0       2 100 ldir                                ; fill the rest of positions as empty
6C6C CD A5 6D    2 102 call    Draw_Board                  ; draw an empty hexagons board
6C6F 3E 0A       2 104 ld      a, 10
6C71 32 DB 6D    2 105 ld      (Draw_Token_Delay+1), a     ; set delay duration for animate hexagons
6C74 3E 01       2 106 ld      a, 1
6C76 32 9B 61    2 107 ld      (MOVE_NUMBER), a            ; initialize move number
6C79 32 E9 62    2 108 ld      (TIMER_FLAG), a             ; set cyan timer on
6C7C 3E 05       2 109 ld      a, CYAN_COLOR               ; first player token color
6C7E             2 111 ; ----------------------------------------------------------------------------------------------------------------------
6C7E             2 112 ; Process players moves - Match loop
6C7E             2 113 ; ----------------------------------------------------------------------------------------------------------------------
6C7E             2 114 Main_Match_Loop
6C7E             2 115 ; check player turn
6C7E 32 9E 61    2 117 ld      (TOKEN_COLOR), a            ; save current token color
6C81 21 9F 61    2 118 ld      hl, PLAYER_COLOR            ; HL points to player color address
6C84 BE          2 119 cp      (hl)                        ; is player color = current token color?
6C85 28 05       2 120 jr      z, Main_Player_Move         ; yes, process player move
6C87 CD F5 6C    2 121 call    Main_GetSpeccy_Move         ; get the speccy move
6C8A 18 03       2 122 jr      Main_Update_Board           ; update board position
6C8C             2 123 Main_Player_Move
6C8C CD 3A 6D    2 124 call    Main_GetPlayer_Move         ; get a legal (empty position) player move 
6C8F             2 125 Main_Update_Board
6C8F             2 126 ; update positions with player/speccy move
6C8F CD 2B 71    2 128 call    PathFinder_Friend           ; get player/speccy side
6C92 CD 35 71    2 129 call    PathFinder_PutToken         ; put token on cyan and red positions
6C95 CD C0 6D    2 130 call    Draw_Token                  ; animate hexagon sprite on the screen
6C98             2 132 ; check win condition
6C98 3A 9E 61    2 134 ld      a, (TOKEN_COLOR)            ; get current token color
6C9B FE 05       2 135 cp      CYAN_COLOR                  ; is token color = cyan?
6C9D 28 05       2 136 jr      z, Main_Cyan_Score          ; yes, get score for cyan player
6C9F CD F4 71    2 137 call    PathFinder_Red_LeftRight    ; get score for red player
6CA2 18 03       2 138 jr      Main_Check_Winner           ; check victory condition
6CA4             2 139 Main_Cyan_Score
6CA4 CD 80 71    2 140 call    PathFinder_Cyan_UpDown      ; get score for cyan player
6CA7             2 141 Main_Check_Winner
6CA7 FE 43       2 142 cp      WIN_CONDITION               ; player/speccy won?
6CA9 28 13       2 143 jr      z, Main_Match_End           ; yes, match ends
6CAB 21 9B 61    2 145 ld      hl, MOVE_NUMBER             ; HL points to move number address
6CAE 34          2 146 inc     (hl)                        ; increment move number
6CAF             2 148 ; swap players' timers and token color
6CAF 3A E9 62    2 150 ld      a, (TIMER_FLAG)             ; get current timer flag
6CB2 EE 03       2 151 xor     %00000011                   ; swap timer flag
6CB4 32 E9 62    2 152 ld      (TIMER_FLAG), a             ; save swapped timer flag
6CB7 3A 9E 61    2 154 ld      a, (TOKEN_COLOR)            ; get current token color
6CBA EE 07       2 155 xor     %00000111                   ; swap token color
6CBC 18 C0       2 156 jr      Main_Match_Loop             ; repeat match loop
6CBE             2 158 ; ----------------------------------------------------------------------------------------------------------------------
6CBE             2 159 ; Current player wins the match
6CBE             2 160 ; ----------------------------------------------------------------------------------------------------------------------
6CBE             2 161 Main_Match_End
6CBE 21 E9 62    2 162 ld      hl, TIMER_FLAG              ; HL points to timer flag address
6CC1 36 00       2 163 ld      (hl), 0                     ; stop timers
6CC3 3E 04       2 164 ld      a, 4
6CC5 32 DB 6D    2 165 ld      (Draw_Token_Delay+1), a     ; set delay duration for animate hexagons
6CC8 CD E4 75    2 166 call    PathFinder_BrightPath       ; animate and highlight the winner path
6CCB 11 3B 62    2 167 ld      de, STR_WINNER              ; DE points to "WINS" string address
6CCE CD 49 6F    2 168 call    Print_Alert                 ; print string
6CD1 3A 9E 61    2 170 ld      a, (TOKEN_COLOR)            ; get current token color
6CD4 21 9F 61    2 171 ld      hl, PLAYER_COLOR            ; get player color
6CD7 BE          2 172 cp      (hl)                        ; is player color = current token color?
6CD8 21 11 62    2 173 ld      hl, THREE_ROW               ; HL points to three-in-a-row counter
6CDB 28 04       2 174 jr      z, Main_ThreeRow_Increment  ; yes, go to increment three-in-a-row counter
6CDD 35          2 175 dec     (hl)                        ; decrement three-in-a-row counter
6CDE F2 E2 6C    2 176 jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
6CE1             2 177 Main_ThreeRow_Increment
6CE1 34          2 178 inc     (hl)                        ; increment three-in-a-row counter
6CE2             2 179 Main_ThreeRow_Show
6CE2 CD 23 79    2 180 call    Screen_ThreeRow             ; show three-in-a-row marks
6CE5 3E FF       2 181 ld      a, 255                      ; set delay duration
6CE7 CD 96 6D    2 182 call    Main_Delay                  ; execute delay
6CEA 3A 11 62    2 183 ld      a, (THREE_ROW)              ; check three row counter
6CED FE 03       2 184 cp      3                           ; is it 3?
6CEF CA 2B 6C    2 185 jp      z, Main_New_Level           ; yes, start a new level
6CF2 C3 43 6C    2 186 jp      Main_Start_Match            ; start a new match
6CF5             2 188 ; ----------------------------------------------------------------------------------------------------------------------
6CF5             2 189 ; Main_GetSpeccy_Move: get the speccy move
6CF5             2 190 ;
6CF5             2 191 ; Input:    -
6CF5             2 192 ;
6CF5             2 193 ; Output:   BC = hexagon board indexes (B:column, C:row)
6CF5             2 194 ;           HL = CYAN_POSITIONS move address
6CF5             2 195 ;
6CF5             2 196 ; Uses:     MOVE_NUMBER (current move number)
6CF5             2 197 ;           GAME_LEVEL (current game level)
6CF5             2 198 ;           AI_DEPTH (recursion depth level)
6CF5             2 199 ;           STR_MOVE (formatted move string)
6CF5             2 200 ;
6CF5             2 201 ; Destroys: A, DE, IX, IY
6CF5             2 202 ; ----------------------------------------------------------------------------------------------------------------------
6CF5             2 203 Main_GetSpeccy_Move:
6CF5 CD 62 6F    2 204 call    Print_Wait                  ; print "WAIT" message
6CF8 3A 9B 61    2 205 ld      a, (MOVE_NUMBER)            ; get move number
6CFB 3D          2 206 dec     a                           ; is it cyan first move?
6CFC 28 2A       2 207 jr      z, Main_GetSpeccy_Book      ; yes, get move from opening book
6CFE DD 21 00 7F 2 209 ld      ix, CANDIDATES              ; IX points to candidates list address
6D02 3A 9D 61    2 210 ld      a, (GAME_LEVEL)             ; get game level
6D05 32 9A 61    2 211 ld      (AI_DEPTH), a               ; save recursion depth level
6D08 CD 2B 71    2 212 call    PathFinder_Friend           ; get speccy side
6D0B CD B5 6F    2 213 call    BRAINIAC_best_move          ; get speccy best move
6D0E 6B          2 214 ld      l, e                        ; set node index in L
6D0F             2 215 Main_GetSpeccy_Positions
6D0F 26 7D       2 216 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D11 E5          2 217 push    hl                          ; store CYAN_POSITIONS move address
6D12 CD 85 6D    2 218 call    Main_Board2Indexes          ; convert board position to indexes
6D15 78          2 219 ld      a, b                        ; get 1..7 column
6D16 C6 60       2 220 add     a, $60                      ; adjust to charset ('a'..'g')
6D18 32 16 62    2 221 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D1B 79          2 222 ld      a, c                        ; get 1..7 row
6D1C C6 30       2 223 add     a, $30                      ; adjust to charset ('1'..'7')
6D1E 32 19 62    2 224 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D21 C5          2 225 push    bc                          ; store hexagon board indexes
6D22 CD 70 6F    2 226 call    Print_Move                  ; print Speccy move
6D25 C1          2 227 pop     bc                          ; restore hexagon board indexes
6D26 E1          2 228 pop     hl                          ; restore CYAN_POSITIONS move address
6D27 C9          2 229 ret
6D28             2 230 Main_GetSpeccy_Book
6D28 ED 5F       2 231 ld      a, r                        ; get a pseudo-random number (0..127)
6D2A E6 1F       2 232 and     %00011111                   ; number is in range (0..31)
6D2C FE 1B       2 233 cp      27                          ; is it >= 27?
6D2E 30 F8       2 234 jr      nc, Main_GetSpeccy_Book     ; yes, repeat until range is (0..26)
6D30 21 CE 62    2 235 ld      hl, OPENINGS                ; HL points to opening book address
6D33 16 00       2 236 ld      d, 0                        ; set index in DE
6D35 5F          2 237 ld      e, a
6D36 19          2 238 add     hl, de                      ; HL points to move index address
6D37 6E          2 239 ld      l, (hl)                     ; get move from opening book
6D38 18 D5       2 240 jr      Main_GetSpeccy_Positions    ; get speccy move positions
6D3A             2 242 ; ----------------------------------------------------------------------------------------------------------------------
6D3A             2 243 ; Main_GetPlayer_Move: get a legal (empty hexagon) move from player
6D3A             2 244 ;
6D3A             2 245 ; Input:    -
6D3A             2 246 ;
6D3A             2 247 ; Output:   BC = hexagon board indexes (B:column, C:row)
6D3A             2 248 ;           HL = CYAN_POSITIONS move address
6D3A             2 249 ;
6D3A             2 250 ; Uses:     STR_MOVE (formatted move string)
6D3A             2 251 ;
6D3A             2 252 ; Destroys: A, DE, IX
6D3A             2 253 ; ----------------------------------------------------------------------------------------------------------------------
6D3A             2 254 Main_GetPlayer_Move:
6D3A CD 69 6F    2 255 call    Print_Clear_Move            ; clear player last move
6D3D CD 41 6E    2 256 call    Input_Move                  ; wait for input player move
6D40 7E          2 257 ld      a, (hl)                     ; get column ('a'..'g') from move
6D41 32 16 62    2 258 ld      (STR_MOVE+0), a             ; put it on formatted move string
6D44 D6 60       2 259 sub     $60                         ; convert to number (1..7)
6D46 47          2 260 ld      b, a                        ; set column index in B
6D47 23          2 261 inc     hl                          ; HL points to move-row address
6D48 7E          2 262 ld      a, (hl)                     ; get row ('1'..'7')
6D49 32 19 62    2 263 ld      (STR_MOVE+3), a             ; put it on formatted move string
6D4C D6 30       2 264 sub     $30                         ; convert to number (1..7)
6D4E 4F          2 265 ld      c, a                        ; set row index in C
6D4F C5          2 266 push    bc                          ; store board indexes
6D50 CD 70 6F    2 267 call    Print_Move                  ; print player move
6D53 C1          2 268 pop     bc                          ; restore board indexes
6D54 11 4E 62    2 269 ld      de, BOARD_COORDINATES       ; DE points to board coordinates address
6D57 CD 78 6D    2 270 call    Main_Search_Table           ; search board position in board coordinates
6D5A 6E          2 271 ld      l, (hl)                     ; set board position of player move
6D5B 26 7D       2 272 ld      h, CYAN_POSITIONS/256       ; HL points to CYAN_POSITIONS move address
6D5D 3E 00       2 273 ld      a, EMPTY                    ; check position
6D5F BE          2 274 cp      (hl)                        ; is position empty?
6D60 C8          2 275 ret     z                           ; yes, return
6D61             2 277 ; illegal player move (position not empty)
6D61 11 2F 62    2 279 ld      de, STR_FILLED              ; DE points to "FILLED" string address
6D64 CD 49 6F    2 280 call    Print_Alert                 ; print string
6D67 DD 21 F7 64 2 281 ld      ix, FILLED_FX               ; IX points to filled tone parameters address
6D6B CD 04 77    2 282 call    Sound_FX                    ; play sound fx
6D6E 3E 50       2 283 ld      a, 80                       ; set delay counter
6D70 CD 96 6D    2 284 call    Main_Delay                  ; execute delay
6D73 CD 42 6F    2 285 call    Print_Clear_Alert           ; clear alert message
6D76 18 C2       2 286 jr      Main_GetPlayer_Move         ; repeat player process until move is legal
6D78             2 288 ; ----------------------------------------------------------------------------------------------------------------------
6D78             2 289 ; Main_Search_Table: search an element in a 8x8 bytes table
6D78             2 290 ;
6D78             2 291 ; Input:    BC = element indexes (B = column, C = row)
6D78             2 292 ;           DE = table address in which to search for the element
6D78             2 293 ;
6D78             2 294 ; Output:   DE = address of first element in the C row of the table
6D78             2 295 ;           HL = address of the element in the BC indexes of the table
6D78             2 296 ;
6D78             2 297 ; Destroys: -
6D78             2 298 ; ----------------------------------------------------------------------------------------------------------------------
6D78             2 299 Main_Search_Table:
6D78 26 00       2 300 ld      h, 0                        ; first, get the C row in table
6D7A 69          2 301 ld      l, c                        ; set index in HL
6D7B 29          2 302 add     hl, hl                      ; a row is 8 bytes long
6D7C 29          2 303 add     hl, hl
6D7D 29          2 304 add     hl, hl
6D7E 19          2 305 add     hl, de                      ; HL points to the address of C row 
6D7F EB          2 306 ex      de, hl                      ; DE points to the address of C row
6D80 26 00       2 307 ld      h, 0                        ; go for to the B column
6D82 68          2 308 ld      l, b                        ; set index in HL
6D83 19          2 309 add     hl, de                      ; HL points to the address of BC indexes
6D84 C9          2 310 ret
6D85             2 312 ; ----------------------------------------------------------------------------------------------------------------------
6D85             2 313 ; Main_Board2Indexes: convert a board position into a board indexes
6D85             2 314 ;
6D85             2 315 ; Input:    L  = board position
6D85             2 316 ;
6D85             2 317 ; Output:   BC = board indexes (B = column, C = row)
6D85             2 318 ;
6D85             2 319 ; Destroys: HL
6D85             2 320 ; ----------------------------------------------------------------------------------------------------------------------
6D85             2 321 Main_Board2Indexes:
6D85 7D          2 322 ld      a, l                        ; set board position in A to compare later
6D86 21 8E 62    2 324 ld      hl, BOARD_COORDINATES+64    ; HL points to last board position address (+1)
6D89 0E 07       2 325 ld      c, 7                        ; 7 rows
6D8B             2 326 Board2Indexes_Row
6D8B 06 07       2 327 ld      b, 7                        ; 7 columns
6D8D             2 328 Board2Indexes_Col
6D8D 2B          2 329 dec     hl                          ; move HL to next board position address
6D8E BE          2 330 cp      (hl)                        ; is A the position?
6D8F C8          2 331 ret     z                           ; yes, return board indexes
6D90 10 FB       2 332 djnz    Board2Indexes_Col           ; repeat for each column
6D92 2B          2 333 dec     hl                          ; skip borders
6D93 0D          2 334 dec     c                           ; decrement row
6D94 18 F5       2 335 jr      Board2Indexes_Row           ; loop until find position
6D96             2 337 ; ----------------------------------------------------------------------------------------------------------------------
6D96             2 338 ; Main_Delay: execute a delay
6D96             2 339 ;
6D96             2 340 ; Input:    A = delay counter
6D96             2 341 ;
6D96             2 342 ; Output:   -
6D96             2 343 ;
6D96             2 344 ; Destroys: A
6D96             2 345 ; ----------------------------------------------------------------------------------------------------------------------
6D96             2 346 Main_Delay:
6D96 C5          2 347 push    bc                          ; store register
6D97             2 348 Main_Delay_Loop
6D97 0E 0A       2 349 ld      c, 10                       ; set outer loop counter
6D99             2 350 Main_Delay_Loop1
6D99 06 00       2 351 ld      b, 0                        ; set inner loop counter (256)
6D9B             2 352 Main_Delay_Loop2
6D9B 10 FE       2 353 djnz    Main_Delay_Loop2            ; repeat until B=0
6D9D 0D          2 354 dec     c                           ; decrement outer loop counter
6D9E 20 F9       2 355 jr      nz, Main_Delay_Loop1        ; repeat until C=0
6DA0 3D          2 356 dec     a                           ; decrement delay counter
6DA1 20 F4       2 357 jr      nz, Main_Delay_Loop         ; repeat until A=0
6DA3 C1          2 358 pop     bc                          ; restore register
6DA4 C9          2 359 ret

; File #3: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Draw.z80asm

6DA5             3 1 ; ----------------------------------------------------------------------------------------------------------------------
6DA5             3 2 ; Draw.z80asm
6DA5             3 3 ; Coded by Antonio Luque
6DA5             3 4 ; ----------------------------------------------------------------------------------------------------------------------
6DA5             3 6 ; ----------------------------------------------------------------------------------------------------------------------
6DA5             3 7 ; Draw_Board: draw an empty 7x7 hexagons board on the screen
6DA5             3 8 ;
6DA5             3 9 ; Input:    -
6DA5             3 10 ;
6DA5             3 11 ; Output:   -
6DA5             3 12 ;
6DA5             3 13 ; Uses:     TOKEN_COLOR (current token color)
6DA5             3 14 ;
6DA5             3 15 ; Destroys: A, BC, DE, HL, IXL
6DA5             3 16 ; ----------------------------------------------------------------------------------------------------------------------
6DA5             3 17 Draw_Board:
6DA5 3E 07       3 18 ld      a, WHITE                    ; set empty hexagon color
6DA7 32 9E 61    3 19 ld      (TOKEN_COLOR), a            ; store hexagon color
6DAA 0E 07       3 20 ld      c, 7                        ; 7 rows
6DAC             3 21 Draw_Board_Row
6DAC 06 07       3 22 ld      b, 7                        ; 7 columns
6DAE             3 23 Draw_Board_Column
6DAE CD ED 6D    3 24 call    Draw_GetHEX_Screen          ; get hexagon screen address
6DB1 CD 25 6E    3 25 call    Draw_Hexagon_Color          ; apply color to hexagon area
6DB4 11 7E 65    3 26 ld      de, HEXAGON_EMPTY           ; DE points to hexagon sprite address
6DB7 CD F7 6D    3 27 call    Draw_Sprite_Hexagon         ; draw an empty hexagon at screen address
6DBA 10 F2       3 28 djnz    Draw_Board_Column           ; repeat for each column
6DBC 0D          3 29 dec     c                           ; decrement row
6DBD 20 ED       3 30 jr      nz, Draw_Board_Row          ; repeat for each row
6DBF C9          3 31 ret
6DC0             3 33 ; ----------------------------------------------------------------------------------------------------------------------
6DC0             3 34 ; Draw_Token: animate an hexagon sprite on the screen
6DC0             3 35 ;
6DC0             3 36 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DC0             3 37 ;
6DC0             3 38 ; Output:   -
6DC0             3 39 ;
6DC0             3 40 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
6DC0             3 41 ;
6DC0             3 42 ; Destroys: A, BC, DE, HL, IX
6DC0             3 43 ; ----------------------------------------------------------------------------------------------------------------------
6DC0             3 44 Draw_Token:
6DC0 21 E9 62    3 45 ld      hl, TIMER_FLAG              ; HL points to timer flag address
6DC3 7E          3 46 ld      a, (hl)                     ; save current status
6DC4 36 00       3 47 ld      (hl), 0                     ; stop timer
6DC6 F5          3 48 push    af                          ; store previous timer status
6DC7 CD ED 6D    3 49 call    Draw_GetHex_Screen          ; get hexagon screen address
6DCA 01 04 06    3 50 ld      bc, $0604                   ; B = number of sprites, C = sprite number to change color
6DCD 11 9E 65    3 51 ld      de, HEXAGON_SPRITE          ; DE points to hexagon sprite address
6DD0             3 52 Draw_Token_Loop
6DD0 E5          3 53 push    hl                          ; store hexagon screen address
6DD1 CD F7 6D    3 54 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
6DD4 E1          3 55 pop     hl                          ; restore hexagon screen address
6DD5 78          3 56 ld      a, b                        ; check loop counter
6DD6 B9          3 57 cp      c                           ; is it 4?
6DD7 CC 25 6E    3 58 call    z, Draw_Hexagon_Color       ; yes, apply color to hexagon area
6DDA             3 59 Draw_Token_Delay
6DDA 3E 00       3 60 ld      a, 0                        ; set delay duration (changed before calling this routine)
6DDC CD 96 6D    3 61 call    Main_Delay                  ; execute delay
6DDF 10 EF       3 62 djnz    Draw_Token_Loop             ; repeat for each hexagon sprite
6DE1 DD 21 E7 64 3 63 ld      ix, TOKEN_FX                ; IX points to token tone parameters address
6DE5 CD 04 77    3 64 call    Sound_FX                    ; play sound effect
6DE8 F1          3 65 pop     af                          ; restore previous timer status
6DE9 32 E9 62    3 66 ld      (TIMER_FLAG), a             ; restart timer
6DEC C9          3 67 ret
6DED             3 69 ; ----------------------------------------------------------------------------------------------------------------------
6DED             3 70 ; Draw_GetHEX_Screen: get the screen address of an hexagon on board
6DED             3 71 ;
6DED             3 72 ; Input:    BC = hexagon board indexes (B:column, C:row)
6DED             3 73 ;
6DED             3 74 ; Output:   HL = hexagon screen address 
6DED             3 75 ;
6DED             3 76 ; Destroys: A, DE
6DED             3 77 ; ----------------------------------------------------------------------------------------------------------------------
6DED             3 78 Draw_GetHEX_Screen:
6DED 11 98 61    3 79 ld      de, BOARD_MAP-8             ; DE points to board hexagons screen addresses table (-8)
6DF0 CD 78 6D    3 80 call    Main_Search_Table           ; search the screen address of the hexagon in table
6DF3 6E          3 81 ld      l, (hl)                     ; set the low byte of the screen address in L
6DF4 1A          3 82 ld      a, (de)                     ; set the high byte of the screen address in H
6DF5 67          3 83 ld      h, a
6DF6 C9          3 84 ret
6DF7             3 86 ; ----------------------------------------------------------------------------------------------------------------------
6DF7             3 87 ; Draw_Sprite_Hexagon: draw an hexagon sprite on the screen
6DF7             3 88 ;
6DF7             3 89 ; Input:    DE = hexagon sprite address
6DF7             3 90 ;           HL = hexagon screen address
6DF7             3 91 ;
6DF7             3 92 ; Output:   DE = next hexagon sprite address
6DF7             3 93 ;
6DF7             3 94 ; Destroys: A, HL, IXL
6DF7             3 95 ; ----------------------------------------------------------------------------------------------------------------------
6DF7             3 96 Draw_Sprite_Hexagon:
6DF7 DD 2E 10    3 97 ld      ixl, 16                     ; hexagon sprite height in bytes (loop counter)
6DFA             3 98 Draw_Sprite_HeXLoop
6DFA 1A          3 99 ld      a, (de)                     ; get sprite byte
6DFB 77          3 100 ld      (hl), a                     ; put sprite byte on screen
6DFC 13          3 101 inc     de                          ; move DE to next sprite byte address
6DFD 2C          3 102 inc     l                           ; move HL to next screen column
6DFE 1A          3 103 ld      a, (de)                     ; get sprite byte
6DFF 77          3 104 ld      (hl), a                     ; put sprite byte on screen
6E00 13          3 105 inc     de                          ; move DE to next sprite byte
6E01 2D          3 106 dec     l                           ; move HL to previous screen column
6E02 CD 16 6E    3 107 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6E05 DD 2D       3 108 dec     ixl                         ; decrement sprite height
6E07 20 F1       3 109 jr      nz, Draw_Sprite_HexLoop     ; repeat for each byte in sprite
6E09 C9          3 110 ret
6E0A             3 112 ; ----------------------------------------------------------------------------------------------------------------------
6E0A             3 113 ; Draw_Sprite_LetterNum: draw a letter/number sprite at screen address
6E0A             3 114 ;
6E0A             3 115 ; Input:    DE = letter/number sprite address
6E0A             3 116 ;           HL = letter/number screen address
6E0A             3 117 ;
6E0A             3 118 ; Output:   DE = next letter/number sprite address
6E0A             3 119 ;
6E0A             3 120 ; Destroys: A, C, HL
6E0A             3 121 ; ----------------------------------------------------------------------------------------------------------------------
6E0A             3 122 Draw_Sprite_LetterNum:
6E0A 0E 0A       3 123 ld      c, 10                       ; letter/number sprite height in bytes (loop counter)
6E0C             3 124 Draw_Sprite_Loop
6E0C 1A          3 125 ld      a, (de)                     ; get sprite byte
6E0D 77          3 126 ld      (hl), a                     ; put sprite byte on screen
6E0E 13          3 127 inc     de                          ; move DE to next sprite byte address
6E0F CD 16 6E    3 128 call    Draw_Down_PixelLine         ; move HL down one pixel-line
6E12 0D          3 129 dec     c                           ; decrement sprite height
6E13 20 F7       3 130 jr      nz, Draw_Sprite_Loop        ; repeat for each byte in sprite
6E15 C9          3 131 ret
6E16             3 133 ; ----------------------------------------------------------------------------------------------------------------------
6E16             3 134 ; Draw_Down_PixelLine: move HL down one pixel-line
6E16             3 135 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=35272#p35272
6E16             3 136 ;
6E16             3 137 ; The screen address of a pixel-line is encoded as follows:
6E16             3 138 ;
6E16             3 139 ;             H           |           L
6E16             3 140 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E16             3 141 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E16             3 142 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E16             3 143 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0
6E16             3 144 ;
6E16             3 145 ; where:
6E16             3 146 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E16             3 147 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E16             3 148 ;
6E16             3 149 ; Input:    HL = pixel-line address
6E16             3 150 ;
6E16             3 151 ; Output:   HL = next (down) pixel-line address
6E16             3 152 ;
6E16             3 153 ; Destroys: A
6E16             3 154 ; ----------------------------------------------------------------------------------------------------------------------
6E16             3 155 Draw_Down_PixelLine:
6E16 24          3 156 inc     h                           ; move HL down one pixel-line
6E17 7C          3 157 ld      a, h                        ; get high byte of pixel-line address
6E18 E6 07       3 158 and     %00000111                   ; is pixel-line address inside a character line?
6E1A C0          3 159 ret     nz                          ; yes, return
6E1B 7D          3 160 ld      a, l                        ; get low byte of pixel-line address (at this point Y6 = 1)
6E1C C6 20       3 161 add     a, 32                       ; add size of char line (add extra bit into Y3-Y5)
6E1E 6F          3 162 ld      l, a                        ; move HL down one character line
6E1F D8          3 163 ret     c                           ; a third was crossed? yes, return
6E20 7C          3 164 ld      a, h                        ; get high byte of pixel-line address
6E21 D6 08       3 165 sub     8                           ; clean up the bit from Y6
6E23 67          3 166 ld      h, a                        ; HL points to next (down) pixel-line address
6E24 C9          3 167 ret
6E25             3 169 ; ----------------------------------------------------------------------------------------------------------------------
6E25             3 170 ; Draw_Hexagon_Color: color an hexagon sprite on the screen
6E25             3 171 ; Source: https://spectrumcomputing.co.uk/forums/viewtopic.php?p=42285#p42285
6E25             3 172 ;
6E25             3 173 ; This routine converts a screen address (HL) into an attribute address (IX):
6E25             3 174 ;
6E25             3 175 ;             H           |           L
6E25             3 176 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E25             3 177 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E25             3 178 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E25             3 179 ;   0| 1| 0|Y7|Y6|Y2|Y1|Y0|Y5|Y4|Y3|X4|X3|X2|X1|X0      screen address
6E25             3 180 ;
6E25             3 181 ;            IXH          |          IXL
6E25             3 182 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E25             3 183 ;  07|06|05|04|03|02|01|00|07|06|05|04|03|02|01|00
6E25             3 184 ;  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
6E25             3 185 ;   0| 1| 0| 1| 1| 0|Y7|Y6|Y5|Y4|Y3|X4|X3|X2|X1|X0      attribute address
6E25             3 186 ;
6E25             3 187 ; where:
6E25             3 188 ;   Y = pixel position: Y7,Y6,Y5,Y4,Y3,Y2,Y1,Y0 (0-191)
6E25             3 189 ;   X = byte  position:  0, 0, 0,X4,X3,X2,X1,X0 (0-31)
6E25             3 190 ;
6E25             3 191 ; Input:    HL = screen address of the hexagon
6E25             3 192 ;
6E25             3 193 ; Output:   IX = attribute address of the hexagon
6E25             3 194 ;
6E25             3 195 ; Uses:     TOKEN_COLOR (current token color)
6E25             3 196 ;
6E25             3 197 ; Destroys: A
6E25             3 198 ; ----------------------------------------------------------------------------------------------------------------------
6E25             3 199 Draw_Hexagon_Color:
6E25 7C          3 200 ld      a, h                        ; get high byte of screen address
6E26 F6 87       3 201 or      %10000111                   ; mask Y0-Y2 and set bit 7 on
6E28 1F          3 202 rra                                 ; shift Y7-Y6 two positions
6E29 1F          3 203 rra
6E2A CB 3F       3 204 srl     a                           ; shift Y7-Y6 to last positions and set bit 7 off
6E2C DD 67       3 205 ld      ixh, a                      ; set high byte of attribute address in IXH
6E2E 7D          3 206 ld      a, l                        ; (the low byte for attribute address doesn't change)
6E2F DD 6F       3 207 ld      ixl, a                      ; set low byte of attribute address in IXL
6E31 3A 9E 61    3 208 ld      a, (TOKEN_COLOR)            ; get current token color
6E34 DD 77 00    3 209 ld      (ix+0), a                   ; set hexagon color (4 bytes)
6E37 DD 77 01    3 210 ld      (ix+1), a
6E3A DD 77 20    3 211 ld      (ix+32), a
6E3D DD 77 21    3 212 ld      (ix+33), a
6E40 C9          3 213 ret

; File #4: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Input.z80asm

6E41             4 1 ; ----------------------------------------------------------------------------------------------------------------------
6E41             4 2 ; Input.z80asm
6E41             4 3 ; Coded by Antonio Luque
6E41             4 4 ; ----------------------------------------------------------------------------------------------------------------------
6E41             4 6 MAX_CHARS               equ     2                           ; maximum of input chars
6E41             4 8 ; ----------------------------------------------------------------------------------------------------------------------
6E41             4 9 ; Input_Move: wait for input a move from keyboard
6E41             4 10 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6E41             4 11 ;
6E41             4 12 ; Input:    -
6E41             4 13 ;
6E41             4 14 ; Output:   HL = player move address (PLAYER_MOVE)
6E41             4 15 ;
6E41             4 16 ; Uses:     CHAR_COUNT (number of current characters in input player move)
6E41             4 17 ;           TOKEN_COLOR (current token color)
6E41             4 18 ;
6E41             4 19 ; Destroys: A, A', BC, DE, IX
6E41             4 20 ; ----------------------------------------------------------------------------------------------------------------------
6E41             4 21 Input_Move:
6E41 01 0E 62    4 22 ld      bc, PLAYER_MOVE             ; BC points to player move address
6E44 C5          4 23 push    bc                          ; store pointer to player move address
6E45 AF          4 24 xor     a                           ; A = 0
6E46 32 10 62    4 25 ld      (CHAR_COUNT), a             ; initialize char counter
6E49 DD 21 83 5A 4 27 ld      ix, $5A83                   ; IX points to attribute address of RED input text
6E4D 21 83 50    4 28 ld      hl, $5083                   ; HL points to screen address of RED input text
6E50 3A 9E 61    4 29 ld      a, (TOKEN_COLOR)            ; check current player color
6E53 FE 02       4 30 cp      RED_COLOR                   ; is RED the current token color?
6E55 28 07       4 31 jr      z, Input_Start              ; yes, start input
6E57 DD 21 19 59 4 32 ld      ix, $5919                   ; IX points to attribute address of CYAN input text
6E5B 21 19 48    4 33 ld      hl, $4819                   ; HL points to screen address of CYAN input text
6E5E             4 34 Input_Start
6E5E 3E 5F       4 35 ld      a, '_'                      ; text input cursor
6E60 DD 36 00 C7 4 36 ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
6E64 CD 99 6F    4 37 call    Print_Char                  ; print cursor
6E67             4 38 Input_Loop
6E67 CD F9 6E    4 39 call    Input_Key_Scan              ; scan for a key pressed
6E6A FE 0D       4 40 cp      $0D                         ; is it ENTER?
6E6C 28 78       4 41 jr      z, Input_Exit               ; yes, go to the end of routine
6E6E FE 30       4 42 cp      '0'                         ; is it DELETE?
6E70 28 45       4 43 jr      z, Input_Delete             ; yes, perform delete char
6E72 08          4 44 ex      af, af'                     ; store ASCII code in A'
6E73 3A 10 62    4 45 ld      a, (CHAR_COUNT)             ; A = number of chars inserted
6E76 FE 02       4 46 cp      MAX_CHARS                   ; chars limit reached?
6E78 28 ED       4 47 jr      z, Input_Loop               ; yes, repeat input loop (do not insert char)
6E7A B7          4 48 or      a                           ; is the first char to be inserted? (A = 0)
6E7B 28 24       4 49 jr      z, Input_First_Letter       ; yes, perform input of 1st char (column)
6E7D FE 01       4 50 cp      1                           ; is the secord char to be inserted? (A = 1)
6E7F 28 2B       4 51 jr      z, Input_First_Number       ; yes, perform input of 2nd char (row)
6E81             4 53 ; ----------------------------------------------------------------------------------------------------------------------
6E81             4 54 ; char is valid: 'a'-'g' (1st char) and '1'-'7' (2nd char)
6E81             4 55 ; ----------------------------------------------------------------------------------------------------------------------
6E81             4 56 Input_Char_OK
6E81 02          4 57 ld      (bc), a                     ; set char in ASCII move
6E82 03          4 58 inc     bc                          ; increment ASCII move position
6E83 DD 36 00 47 4 59 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6E87 CD 99 6F    4 60 call    Print_Char                  ; print key pressed
6E8A 3A 10 62    4 61 ld      a, (CHAR_COUNT)             ; increment char counter
6E8D 3C          4 62 inc     a
6E8E 32 10 62    4 63 ld      (CHAR_COUNT), a
6E91 2C          4 64 inc     l                           ; increment X position of current input screen location
6E92 DD 2C       4 65 inc     ixl                         ; increment X position of current input attr location
6E94 3D          4 66 dec     a                           ; is the first char?
6E95 20 C7       4 67 jr      nz, Input_Start             ; no, get next char
6E97 3E 2D       4 68 ld      a, '-'                      ; yes, print dash
6E99 CD 99 6F    4 69 call    Print_Char                  ; print dash
6E9C 2C          4 70 inc     l                           ; increment X position of current input screen location
6E9D DD 2C       4 71 inc     ixl                         ; increment X position of current input attr location
6E9F 18 BD       4 72 jr      Input_Start                 ; get next char (do until ENTER is pressed)
6EA1             4 74 ; ----------------------------------------------------------------------------------------------------------------------
6EA1             4 75 ; restrict first char to 'a'-'g'
6EA1             4 76 ; ----------------------------------------------------------------------------------------------------------------------
6EA1             4 77 Input_First_Letter
6EA1 08          4 78 ex      af, af'                     ; restore ASCII code
6EA2 FE 61       4 79 cp      'a'                         ; is it < 'a'?
6EA4 38 C1       4 80 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6EA6 FE 68       4 81 cp      'h'                         ; is it >= 'h'?
6EA8 30 BD       4 82 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6EAA 18 D5       4 83 jr      Input_Char_OK               ; char is valid
6EAC             4 85 ; ----------------------------------------------------------------------------------------------------------------------
6EAC             4 86 ; restrict second char to '1'-'7'
6EAC             4 87 ; ----------------------------------------------------------------------------------------------------------------------
6EAC             4 88 Input_First_Number
6EAC 08          4 89 ex      af, af'                     ; restore ASCII code
6EAD FE 31       4 90 cp      '1'                         ; is it < '1'?
6EAF 38 B6       4 91 jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
6EB1 FE 38       4 92 cp      '8'                         ; is it >= '8'?
6EB3 30 B2       4 93 jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
6EB5 18 CA       4 94 jr      Input_Char_OK               ; char is valid
6EB7             4 96 ; ----------------------------------------------------------------------------------------------------------------------
6EB7             4 97 ; erase last char, update input screen location and string pointer
6EB7             4 98 ; ----------------------------------------------------------------------------------------------------------------------
6EB7             4 99 Input_Delete
6EB7 3A 10 62    4 100 ld      a, (CHAR_COUNT)             ; get char counter
6EBA B7          4 101 or      a                           ; is it 0?
6EBB 28 AA       4 102 jr      z, Input_Loop               ; yes, repeat input loop (no chars to delete)
6EBD FE 02       4 103 cp      2                           ; is it 2?
6EBF 20 02       4 104 jr      nz, Input_Delete_Dash       ; no, delete dash
6EC1 18 0C       4 105 jr      Input_Decrement_Chars       ; continue delete
6EC3             4 106 Input_Delete_Dash
6EC3 3E 20       4 107 ld      a, ' '                      ; empty char
6EC5 DD 36 00 47 4 108 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EC9 CD 99 6F    4 109 call    Print_Char                  ; delete char
6ECC 2D          4 110 dec     l                           ; decrement X position of input screen location
6ECD DD 2D       4 111 dec     ixl                         ; decrement X position of input attr location
6ECF             4 112 Input_Decrement_Chars
6ECF 3A 10 62    4 113 ld      a, (CHAR_COUNT)             ; decrement char counter
6ED2 3D          4 114 dec     a
6ED3 32 10 62    4 115 ld      (CHAR_COUNT), a
6ED6 0B          4 116 dec     bc                          ; decrement ASCII move position
6ED7 3E 20       4 117 ld      a, ' '                      ; empty char
6ED9 DD 36 00 47 4 118 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EDD CD 99 6F    4 119 call    Print_Char                  ; delete cursor and last char
6EE0 2D          4 120 dec     l                           ; decrement X position of player input screen location
6EE1 DD 2D       4 121 dec     ixl                         ; decrement X position of player input attr location
6EE3 C3 5E 6E    4 122 jp      Input_Start                 ; get next char
6EE6             4 124 ; ----------------------------------------------------------------------------------------------------------------------
6EE6             4 125 ; player finished move (ENTER pressed)
6EE6             4 126 ; ----------------------------------------------------------------------------------------------------------------------
6EE6             4 127 Input_Exit
6EE6 3A 10 62    4 128 ld      a, (CHAR_COUNT)             ; check char counter  
6EE9 FE 02       4 129 cp      2                           ; is it < 2?
6EEB DA 67 6E    4 130 jp      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
6EEE 3E 20       4 131 ld      a, ' '                      ; empty char
6EF0 DD 36 00 47 4 132 ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
6EF4 CD 99 6F    4 133 call    Print_Char                  ; delete cursor
6EF7 E1          4 134 pop     hl                          ; restore pointer to player move address
6EF8 C9          4 135 ret
6EF9             4 137 ; ----------------------------------------------------------------------------------------------------------------------
6EF9             4 138 ; Input_Key_Scan: wait for a key pressed and return its ASCII code
6EF9             4 139 ;
6EF9             4 140 ;                           Bit
6EF9             4 141 ;  Port  |   0   |   1   |   2   |   3   |   4   |
6EF9             4 142 ;  ------+-------+-------+-------+-------+-------+
6EF9             4 143 ;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
6EF9             4 144 ;  $FDFE |   A   |   S   |   D   |   F   |   G   |
6EF9             4 145 ;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
6EF9             4 146 ;  $F7FE |   1   |   2   |   3   |   4   |   5   |
6EF9             4 147 ;  $EFFE |   0   |   9   |   8   |   7   |   6   |
6EF9             4 148 ;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
6EF9             4 149 ;  $BFFE | Enter |   L   |   K   |   J   |   H   |
6EF9             4 150 ;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
6EF9             4 151 ;
6EF9             4 152 ;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
6EF9             4 153 ;
6EF9             4 154 ; Input:    -
6EF9             4 155 ;
6EF9             4 156 ; Output:   A = ASCII code of key pressed
6EF9             4 157 ;
6EF9             4 158 ; Destroys: DE
6EF9             4 159 ; ----------------------------------------------------------------------------------------------------------------------
6EF9             4 160 Input_Key_Scan:
6EF9 C5          4 161 push    bc                          ; store registers
6EFA E5          4 162 push    hl
6EFB             4 163 Input_Key_Released
6EFB 01 FE FE    4 164 ld      bc, $FEFE                   ; set keyboard port (see above)
6EFE             4 165 Input_Key_Released_Line
6EFE ED 78       4 166 in      a, (c)                      ; read port
6F00 2F          4 167 cpl                                 ; invert bits
6F01 E6 1F       4 168 and     %00011111                   ; check 0 to 4 bits
6F03 20 F6       4 169 jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
6F05 CB 00       4 170 rlc     b                           ; move BC to the next port
6F07 38 F5       4 171 jr      c, Input_Key_Released_Line  ; repeat for each port
6F09 11 05 00    4 172 ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
6F0C             4 173 Input_Key_Pressed_Begin
6F0C 21 D8 61    4 174 ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
6F0F             4 175 Input_Key_Pressed_Line
6F0F ED 78       4 176 in      a, (c)                      ; read port
6F11 2F          4 177 cpl                                 ; invert bits
6F12 E6 1F       4 178 and     %00011111                   ; check 0 to 4 bits
6F14 20 08       4 179 jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
6F16 19          4 180 add     hl, de                      ; HL points to the next KEY_MAP block
6F17 CB 00       4 181 rlc     b                           ; move BC to the next port
6F19 38 F4       4 182 jr      c, Input_Key_Pressed_Line   ; repeat for each port
6F1B 18 EF       4 183 jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
6F1D             4 184 Input_Key_Next
6F1D 23          4 185 inc     hl                          ; move HL to the next character
6F1E             4 186 Input_Key_Pressed
6F1E 1F          4 187 rra                                 ; rotate bits of port readed
6F1F 30 FC       4 188 jr      nc, Input_Key_Next          ; repeat until find the key pressed
6F21 7E          4 189 ld      a, (hl)                     ; return key pressed (ASCII) in A
6F22 E1          4 190 pop     hl                          ; restore registers
6F23 C1          4 191 pop     bc
6F24 C9          4 192 ret

; File #5: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Print.z80asm

6F25             5 1 ; ----------------------------------------------------------------------------------------------------------------------
6F25             5 2 ; Print.z80asm
6F25             5 3 ; Coded by Antonio Luque
6F25             5 4 ; ----------------------------------------------------------------------------------------------------------------------
6F25             5 6 CHAR_SET                equ     FONT-256                    ; address of character set data, adjusted for ASCII codes
6F25             5 8 ; ----------------------------------------------------------------------------------------------------------------------
6F25             5 9 ; Print_Players: print "Player" and "Speccy" strings in the corresponding positions
6F25             5 10 ;
6F25             5 11 ; Input:    A = player color (CYAN_COLOR or RED_COLOR)
6F25             5 12 ;
6F25             5 13 ; Output:   -
6F25             5 14 ;
6F25             5 15 ; Destroys: A, BC, DE, HL
6F25             5 16 ; ----------------------------------------------------------------------------------------------------------------------
6F25             5 17 Print_Players:
6F25 11 22 62    5 18 ld      de, STR_PLAYER              ; DE points to "Player" string address
6F28 01 1B 62    5 19 ld      bc, STR_SPECCY              ; BC points to "Speccy" string address
6F2B 21 02 50    5 20 ld      hl, $5002                   ; HL points to red string screen address
6F2E FE 02       5 21 cp      RED_COLOR                   ; is player color red?
6F30 28 06       5 22 jr      z, Print_Players_Strings    ; yes, print players strings
6F32 11 1B 62    5 23 ld      de, STR_SPECCY              ; DE points to "Speccy" string address
6F35 01 22 62    5 24 ld      bc, STR_PLAYER              ; BC points to "Player" string address
6F38             5 25 Print_Players_Strings
6F38 CD 8D 6F    5 26 call    Print_String                ; print "Player" or "Speccy"
6F3B 50          5 27 ld      d, b                        ; DE points to "Player" or "Speccy" string address
6F3C 59          5 28 ld      e, c
6F3D 21 98 40    5 29 ld      hl, $4098                   ; HL points to cyan string screen address
6F40 18 4B       5 30 jr      Print_String                ; print "Player" or "Speccy"
6F42             5 32 ; ----------------------------------------------------------------------------------------------------------------------
6F42             5 33 ; Print_Clear_Alert: clear a printed alert message below the current player input move
6F42             5 34 ;
6F42             5 35 ; Input:    -
6F42             5 36 ; Output:   -
6F42             5 37 ; Destroys: A, BC, DE, HL, IX
6F42             5 38 ; ----------------------------------------------------------------------------------------------------------------------
6F42             5 39 Print_Clear_Alert:
6F42 11 47 62    5 40 ld      de, STR_EMPTY6              ; DE points to a 6 blanks string address
6F45 0E 47       5 41 ld      c, WHITE_FLASH0             ; set (clear) alert message color
6F47 18 02       5 42 jr      Print_Alert_XY              ; print (clear) alert string
6F49             5 44 ; ----------------------------------------------------------------------------------------------------------------------
6F49             5 45 ; Print_Alert: print an alert message below the current player input move
6F49             5 46 ;
6F49             5 47 ; Input:    DE = alert message string address
6F49             5 48 ;
6F49             5 49 ; Output:   -
6F49             5 50 ;
6F49             5 51 ; Uses:     TOKEN_COLOR (current token color)
6F49             5 52 ;
6F49             5 53 ; Destroys: A, BC, DE, HL, IX
6F49             5 54 ; ----------------------------------------------------------------------------------------------------------------------
6F49             5 55 Print_Alert:
6F49 0E C7       5 56 ld      c, WHITE_FLASH1             ; set alert message color
6F4B             5 57 Print_Alert_XY
6F4B DD 21 A2 5A 5 58 ld      ix, $5AA2                   ; IX points to red alert string attribute address
6F4F 21 A2 50    5 59 ld      hl, $50A2                   ; HL points to red alert string screen address
6F52 3A 9E 61    5 60 ld      a, (TOKEN_COLOR)            ; check current token color
6F55 FE 02       5 61 cp      RED_COLOR                   ; is token color red?
6F57 28 31       5 62 jr      z, Print_String_Color       ; yes, print alert string with color
6F59 DD 21 38 59 5 63 ld      ix, $5938                   ; IX points to cyan alert string attribute address
6F5D 21 38 48    5 64 ld      hl, $4838                   ; HL points to cyan alert string screen address
6F60 18 28       5 65 jr      Print_String_Color          ; print alert string with color
6F62             5 67 ; ----------------------------------------------------------------------------------------------------------------------
6F62             5 68 ; Print_Wait: print "WAIT" message at current player input move location 
6F62             5 69 ;
6F62             5 70 ; Input:    -
6F62             5 71 ;
6F62             5 72 ; Output:   -
6F62             5 73 ;
6F62             5 74 ; Destroys: A, BC, DE, HL, IX
6F62             5 75 ; ----------------------------------------------------------------------------------------------------------------------
6F62             5 76 Print_Wait:
6F62 11 36 62    5 77 ld      de, STR_WAIT                ; DE points to "WAIT" string address
6F65 0E C7       5 78 ld      c, WHITE_FLASH1             ; set wait message color
6F67 18 0C       5 79 jr      Print_Move_XY               ; print wait string
6F69             5 81 ; ----------------------------------------------------------------------------------------------------------------------
6F69             5 82 ; Clear_Move: clear a printed player move at current player input move location 
6F69             5 83 ;
6F69             5 84 ; Input:    -
6F69             5 85 ;
6F69             5 86 ; Output:   -
6F69             5 87 ;
6F69             5 88 ; Destroys: A, BC, DE, HL, IX
6F69             5 89 ; ----------------------------------------------------------------------------------------------------------------------
6F69             5 90 Print_Clear_Move:
6F69 11 42 62    5 91 ld      de, STR_EMPTY4              ; DE points to a 4 blanks string address
6F6C 0E 47       5 92 ld      c, WHITE_FLASH0             ; set (clear) move string color
6F6E 18 05       5 93 jr      Print_Move_XY               ; print (clear) move string
6F70             5 95 ; ----------------------------------------------------------------------------------------------------------------------
6F70             5 96 ; Print_Move: print a formatted move at current player input move location 
6F70             5 97 ;
6F70             5 98 ; Input:    -
6F70             5 99 ;
6F70             5 100 ; Output:   -
6F70             5 101 ;
6F70             5 102 ; Uses:     TOKEN_COLOR (current token color)
6F70             5 103 ;
6F70             5 104 ; Destroys: A, BC, DE, HL, IX
6F70             5 105 ; ----------------------------------------------------------------------------------------------------------------------
6F70             5 106 Print_Move:
6F70 11 16 62    5 107 ld      de, STR_MOVE                ; DE points to formatted move string address
6F73 0E 47       5 108 ld      c, WHITE_FLASH0             ; set string color
6F75             5 109 Print_Move_XY
6F75 DD 21 82 5A 5 110 ld      ix, $5A82                   ; IX points to red move attribute address
6F79 21 83 50    5 111 ld      hl, $5083                   ; HL points to red move screen address
6F7C 3A 9E 61    5 112 ld      a, (TOKEN_COLOR)            ; check current token color
6F7F FE 02       5 113 cp      RED_COLOR                   ; is token color red?
6F81 28 07       5 114 jr      z, Print_String_Color       ; yes, print move string with color
6F83 DD 21 18 59 5 115 ld      ix, $5918                   ; IX points to cyan move attribute address
6F87 21 19 48    5 116 ld      hl, $4819                   ; HL points to cyan move screen address
6F8A             5 117 Print_String_Color
6F8A CD A3 78    5 118 call    Screen_Apply_Color          ; apply color to string area
6F8D             5 119 ; ----------------------------------------------------------------------------------------------------------------------
6F8D             5 120 ; Print_String: print a string on the screen
6F8D             5 121 ; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
6F8D             5 122 ;
6F8D             5 123 ; Input:    DE = string address (ending with 0)
6F8D             5 124 ;           HL = string screen address
6F8D             5 125 ;
6F8D             5 126 ; Output:   -
6F8D             5 127 ;
6F8D             5 128 ; Destroys: A, DE, HL
6F8D             5 129 ; ----------------------------------------------------------------------------------------------------------------------
6F8D             5 130 Print_String:
6F8D 1A          5 131 ld      a, (de)                     ; get string character
6F8E B7          5 132 or      a                           ; is it 0? (end of string)
6F8F C8          5 133 ret     z                           ; yes, return
6F90 D5          5 134 push    de                          ; store pointer to string address
6F91 CD 99 6F    5 135 call    Print_Char                  ; print character
6F94 D1          5 136 pop     de                          ; restore pointer to string address
6F95 13          5 137 inc     de                          ; move DE to next string character
6F96 2C          5 138 inc     l                           ; move HL to next screen column
6F97 18 F4       5 139 jr      Print_String                ; repeat until end of string
6F99             5 141 ; ----------------------------------------------------------------------------------------------------------------------
6F99             5 142 ; Print_Char: print a character on the screen
6F99             5 143 ;
6F99             5 144 ; Input:    A  = character to print (ASCII)
6F99             5 145 ;           HL = character screen address
6F99             5 146 ;
6F99             5 147 ; Output:   -
6F99             5 148 ;
6F99             5 149 ; Destroys: A, DE
6F99             5 150 ; ----------------------------------------------------------------------------------------------------------------------
6F99             5 151 Print_Char:
6F99 11 00 68    5 152 ld      de, CHAR_SET                ; DE points to charset address
6F9C             5 153 Print_Tile:
6F9C E5          5 154 push    hl                          ; store pointer to character screen address
6F9D 26 00       5 155 ld      h, 0                        ; set character/tile index in HL
6F9F 6F          5 156 ld      l, a
6FA0 29          5 157 add     hl, hl                      ; a character/tile is 8 bytes long
6FA1 29          5 158 add     hl, hl
6FA2 29          5 159 add     hl, hl
6FA3 19          5 160 add     hl, de                      ; move HL to character/tile address
6FA4 EB          5 161 ex      de, hl                      ; DE points to character/tile address
6FA5 E1          5 162 pop     hl                          ; restore pointer to character screen address
6FA6 C5          5 163 push    bc                          ; store BC register
6FA7 06 08       5 164 ld      b, 8                        ; number of character/tile bytes (loop counter)
6FA9             5 165 Print_Tile_Pixels
6FA9 1A          5 166 ld      a, (de)                     ; get character/tile byte
6FAA 77          5 167 ld      (hl), a                     ; put character/tile byte on screen
6FAB 13          5 168 inc     de                          ; move DE to next character/tile byte
6FAC 24          5 169 inc     h                           ; move HL down one pixel-line
6FAD 10 FA       5 170 djnz    Print_Tile_Pixels           ; repeat for each character/tile bytes
6FAF C1          5 171 pop     bc                          ; restore BC register
6FB0 7C          5 172 ld      a, h                        ; get high byte of character screen address
6FB1 D6 08       5 173 sub     8                           ; subtract number of character/tile bytes
6FB3 67          5 174 ld      h, a                        ; HL points to character screen address
6FB4 C9          5 175 ret

; File #6: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Brainiac.z80asm

6FB5             6 1 ; ----------------------------------------------------------------------------------------------------------------------
6FB5             6 2 ; Brainiac.z80asm
6FB5             6 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB5             6 4 ;
6FB5             6 5 ; Adapted for Hex game by Einar Saukas
6FB5             6 6 ; ----------------------------------------------------------------------------------------------------------------------
6FB5             6 8 MIN_VALUE               equ     0                           ; alphaBeta pruning minimum value
6FB5             6 9 MAX_VALUE               equ     255                         ; alphaBeta pruning maximum value
6FB5             6 11 ; ----------------------------------------------------------------------------------------------------------------------
6FB5             6 12 ; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, according to
6FB5             6 13 ; specified AI difficulty level. This algorithm is implemented as recursive Minimax with alpha-beta pruning, that
6FB5             6 14 ; alternates between tree nodes maximizing score (speccy move) and minimizing it (player move) depending on recursion
6FB5             6 15 ; depth.
6FB5             6 16 ;
6FB5             6 17 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FB5             6 18 ;
6FB5             6 19 ; Input:    A  = speccy side (FRIEND or ENEMY)
6FB5             6 20 ;           IX = candidates vector address
6FB5             6 21 ;
6FB5             6 22 ; Output:   E  = selected position (speccy move)
6FB5             6 23 ;
6FB5             6 24 ; Uses:     AI_PLAYER (speccy side)
6FB5             6 25 ;           AI_DEPTH (recursion depth level)
6FB5             6 26 ;
6FB5             6 27 ; Destroys: A, BC, D, HL, IX, IY
6FB5             6 28 ; ----------------------------------------------------------------------------------------------------------------------
6FB5             6 29 BRAINIAC_best_move:
6FB5 32 99 61    6 30 ld      (AI_PLAYER), a              ; save speccy side
6FB8 CD BB 74    6 31 call    PathFinder_SpeccyScore      ; get speccy score
6FBB FE 43       6 32 cp      WIN_CONDITION               ; speccy won?
6FBD 28 05       6 33 jr      z, AI_Color_Candidates      ; yes, get candidates depending on speccy color
6FBF CD 79 75    6 34 call    PathFinder_Candidates       ; get candidates from board potentials
6FC2 18 0F       6 35 jr      AI_First_Candidate          ; go to first candidate
6FC4             6 37 ; if speccy won, candidates are chosen depending on speccy color
6FC4             6 38 AI_Color_Candidates
6FC4 3A 99 61    6 39 ld      a, (AI_PLAYER)              ; get speccy side
6FC7 FE 02       6 40 cp      FRIEND                      ; is speccy friend?
6FC9 28 05       6 41 jr      z, AI_Cyan_Candidates       ; yes, go to get cyan candidates
6FCB CD A7 75    6 42 call    PathFinder_RedCandidates    ; get red candidates
6FCE 18 03       6 43 jr      AI_First_Candidate          ; go to first candidate
6FD0             6 44 AI_Cyan_Candidates
6FD0 CD 92 75    6 45 call    PathFinder_CyanCandidates   ; get cyan candidates
6FD3             6 46 AI_First_Candidate
6FD3 DD 7E 00    6 47 ld      a, (ix+0)                   ; A is our first candidate
6FD6 5F          6 49 ld      e, a                        ; E = best speccy move (initialization)
6FD7 16 00       6 50 ld      d, MIN_VALUE                ; D = alphaMax
6FD9             6 52 AI_Main_Loop                                                ; for each candidate {
6FD9 D5          6 53 push    de                          ;       store alphaMax and best speccy move
6FDA 26 7D       6 55 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
6FDC 6F          6 56 ld      l, a
6FDD E5          6 57 push    hl
6FDE 3A 99 61    6 59 ld      a, (AI_PLAYER)              ;       get speccy side
6FE1 CD 35 71    6 60 call    PathFinder_PutToken         ;       BRAINIAC_play
6FE4 1E FF       6 61 ld      e, MAX_VALUE                ;       E = betaMin
6FE6 CD FE 6F    6 62 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
6FE9 E1          6 64 pop     hl                          ;       restore candidate position
6FEA CD 3B 71    6 65 call    PathFinder_EraseToken       ;       BRAINIAC_undo
6FED D1          6 67 pop     de                          ;       restore alphaMax and best player node
6FEE BA          6 69 cp      d
6FEF 38 04       6 70 jr      c, AI_Main_Next
6FF1 28 02       6 71 jr      z, AI_Main_Next             ;       if (A <= alphaMax) continue
6FF3 57          6 73 ld      d, a                        ;       alphaMax = A
6FF4 5D          6 74 ld      e, l                        ;       best move = E
6FF5             6 76 AI_Main_Next
6FF5 DD 2D       6 77 dec     ixl
6FF7 DD 7E 00    6 78 ld      a, (ix+0)                   ;       A is our next candidate
6FFA B7          6 79 or      a                           ;       repeat until no more candidates
6FFB 20 DC       6 80 jr      nz, AI_Main_Loop            ; }
6FFD C9          6 81 ret
6FFE             6 83 ; ----------------------------------------------------------------------------------------------------------------------
6FFE             6 84 ; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
6FFE             6 85 ; player's score.
6FFE             6 86 ;
6FFE             6 87 ; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
6FFE             6 88 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
6FFE             6 89 ; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
6FFE             6 90 ; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
6FFE             6 91 ; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
6FFE             6 92 ; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
6FFE             6 93 ; always choose the child node evaluated first, since the other child node node may not really have the same score and
6FFE             6 94 ; could be just; reproducing the best score from its sibling.
6FFE             6 95 ;
6FFE             6 96 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
6FFE             6 97 ;
6FFE             6 98 ; Input:    D = alphaMax
6FFE             6 99 ;           E = betaMin
6FFE             6 100 ;
6FFE             6 101 ; Output:   A = "improved" betaMin
6FFE             6 102 ;           D = alphaMax
6FFE             6 103 ;           E = "improved" betaMin
6FFE             6 104 ;
6FFE             6 105 ; Uses:     AI_PLAYER (speccy side)
6FFE             6 106 ;           AI_DEPTH (recursion depth level)
6FFE             6 107 ;
6FFE             6 108 ; Destroys: BC, HL, IX, IY
6FFE             6 109 ; ----------------------------------------------------------------------------------------------------------------------
6FFE             6 110 Alphabeta_Min:
6FFE D5          6 111 push    de
6FFF             6 113 ; check if last speccy move is a winner one
6FFF CD BB 74    6 115 call    PathFinder_SpeccyScore      ; if (speccy won)
7002 FE 43       6 116 cp      WIN_CONDITION
7004 20 07       6 117 jr      nz, Alphabeta_Min_Candidates
7006 3A 9A 61    6 118 ld      a, (AI_DEPTH)
7009 C6 C0       6 119 add     a, 192                      ;     return 192+depth
700B D1          6 120 pop     de
700C C9          6 121 ret
700D             6 123 Alphabeta_Min_Candidates
700D CD 79 75    6 124 call    PathFinder_Candidates       ; find candidates for next move
7010 D1          6 125 pop     de
7011 DD 7E 00    6 127 ld      a, (ix+0)                   ; A is our first candidate
7014 21 9A 61    6 129 ld      hl, AI_DEPTH
7017 35          6 130 dec     (hl)                        ; depth--
7018 28 3B       6 131 jr      z, Heuristic_Min            ; if (depth == 0) return heuristic_min
701A             6 133 Alphabeta_Min_Loop                                          ; for each candidate {
701A D5          6 134 push    de                          ;       store alphaMax and betaMin
701B 26 7D       6 136 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
701D 6F          6 137 ld      l, a
701E E5          6 138 push    hl
701F 3A 99 61    6 140 ld      a, (AI_PLAYER)              ;       rather to track player or speccy side
7022             6 141 ;       we get it from AI_PLAYER
7022 EE 7C       6 142 xor     $7C                         ;       get player side
7024 CD 35 71    6 143 call    PathFinder_PutToken         ;       BRAINIAC_play
7027 CD 96 70    6 144 call    Alphabeta_Max               ;       A = alphabeta_max(alphaMax, betaMin)
702A E1          6 146 pop     hl                          ;       restore candidate position
702B CD 3B 71    6 147 call    PathFinder_EraseToken       ;       BRAINIAC_undo
702E D1          6 149 pop     de                          ;       restore alphaMax and betaMin
702F BB          6 151 cp      e
7030 30 06       6 152 jr      nc, Alphabeta_Min_Next      ;       if (A >= betaMin) continue
7032 BA          6 154 cp      d
7033 38 11       6 155 jr      c, Alphabeta_Min_Exit
7035 28 0F       6 156 jr      z, Alphabeta_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
7037 5F          6 158 ld      e, a                        ;       betaMin = A
7038             6 160 Alphabeta_Min_Next
7038 DD 2D       6 161 dec     ixl
703A DD 7E 00    6 162 ld      a, (ix+0)                   ;       A is our next candidate
703D B7          6 163 or      a                           ;       repeat until no more candidates
703E 20 DA       6 164 jr      nz, Alphabeta_Min_Loop      ; }
7040 7B          6 166 ld      a, e                        ; return betaMin
7041 21 9A 61    6 168 ld      hl, AI_DEPTH
7044 34          6 169 inc     (hl)                        ; depth++
7045 C9          6 170 ret
7046             6 172 Alphabeta_Min_Exit
7046 5F          6 173 ld      e, a                        ; (discard remaining candidates)
7047 AF          6 174 xor     a
7048             6 175 Alphabeta_Min_Skip
7048 DD 2D       6 176 dec     ixl
704A DD BE 00    6 177 cp      (ix+0)
704D 20 F9       6 178 jr      nz, Alphabeta_Min_Skip
704F 7B          6 179 ld      a, e
7050 21 9A 61    6 181 ld      hl, AI_DEPTH
7053 34          6 182 inc     (hl)                        ; (depth++)
7054 C9          6 183 ret
7055             6 185 ; ----------------------------------------------------------------------------------------------------------------------
7055             6 186 ; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
7055             6 187 ; beta pruning, when it requires MINIMIZING player's score.
7055             6 188 ;
7055             6 189 ; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child
7055             6 190 ; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
7055             6 191 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
7055             6 192 ; faster.
7055             6 193 ;
7055             6 194 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7055             6 195 ;
7055             6 196 ; Input:    A = first candidate
7055             6 197 ;           D = alphaMax
7055             6 198 ;           E = betaMin
7055             6 199 ;
7055             6 200 ; Output:   A = "improved" betaMin
7055             6 201 ;           D = alphaMax
7055             6 202 ;           E = "improved" betaMin
7055             6 203 ;
7055             6 204 ; Uses:     AI_PLAYER (speccy side)
7055             6 205 ;           AI_DEPTH (recursion depth level)
7055             6 206 ;
7055             6 207 ; Destroys: BC, HL, IX, IY
7055             6 208 ; ----------------------------------------------------------------------------------------------------------------------
7055             6 209 Heuristic_Min:                                              ; for each candidate {
7055 D5          6 210 push    de                          ;       store alphaMax and betaMin
7056 26 7D       6 212 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
7058 6F          6 213 ld      l, a
7059 E5          6 214 push    hl
705A 3A 99 61    6 216 ld      a, (AI_PLAYER)              ;       get speccy side
705D EE 7C       6 217 xor     $7C                         ;       convert to player side
705F CD 35 71    6 218 call    PathFinder_PutToken         ;       BRAINIAC_play
7062 CD FB 74    6 220 call    PathFinder_PlayerScore      ;       if (player won)
7065 FE 43       6 221 cp      WIN_CONDITION
7067 20 02       6 222 jr      nz, Heuristic_Min_Continue
7069 3E 40       6 223 ld      a, 64                       ;           A = 64
706B             6 224 Heuristic_Min_Continue
706B E1          6 225 pop     hl
706C CD 3B 71    6 226 call    PathFinder_EraseToken       ;       BRAINIAC_undo
706F D1          6 228 pop     de
7070 BB          6 230 cp      e
7071 30 06       6 231 jr      nc, Heuristic_Min_Next      ;       if (A >= betaMin) continue
7073 BA          6 233 cp      d
7074 38 11       6 234 jr      c, Heuristic_Min_Exit
7076 28 0F       6 235 jr      z, Heuristic_Min_Exit       ;       if (A <= alphaMax) { depth++; return A }
7078 5F          6 237 ld      e, a                        ;       betaMin = A
7079             6 239 Heuristic_Min_Next
7079 DD 2D       6 240 dec     ixl
707B DD 7E 00    6 241 ld      a, (ix+0)                   ;       A is our next candidate
707E B7          6 242 or      a                           ;       repeat until no more candidates
707F 20 D4       6 243 jr      nz, Heuristic_Min           ; }
7081 7B          6 245 ld      a, e                        ; return betaMin
7082 21 9A 61    6 247 ld      hl, AI_DEPTH
7085 34          6 248 inc     (hl)                        ; depth++
7086 C9          6 249 ret
7087             6 251 Heuristic_Min_Exit
7087 5F          6 252 ld      e, a                        ; (discard remaining candidates)
7088 AF          6 253 xor     a
7089             6 254 Heuristic_Min_Skip
7089 DD 2D       6 255 dec     ixl
708B DD BE 00    6 256 cp      (ix+0)
708E 20 F9       6 257 jr      nz, Heuristic_Min_Skip
7090 7B          6 258 ld      a, e
7091 21 9A 61    6 260 ld      hl, AI_DEPTH
7094 34          6 261 inc     (hl)                        ; (depth++)
7095 C9          6 262 ret
7096             6 264 ; ----------------------------------------------------------------------------------------------------------------------
7096             6 265 ; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
7096             6 266 ; speccy's score.
7096             6 267 ;
7096             6 268 ; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
7096             6 269 ; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best
7096             6 270 ; (highest) score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous
7096             6 271 ; sibling node would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a
7096             6 272 ; previous sibling node anyway. This change was useful to allow a highly optimized Assembly implementation with a more
7096             6 273 ; efficient register allocation. The only drawback was that, whenever a parent node obtains the same best score from 2
7096             6 274 ; child nodes, it must always choose the child node evaluated first, since the other child node node may not really have
7096             6 275 ; the same score and could be just reproducing the best score from its sibling.
7096             6 276 ;
7096             6 277 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
7096             6 278 ;
7096             6 279 ; Input:    D = alphaMax
7096             6 280 ;           E = betaMin
7096             6 281 ;
7096             6 282 ; Output:   A = "improved" alphaMax
7096             6 283 ;           D = "improved" alphaMax
7096             6 284 ;           E = betaMin
7096             6 285 ;
7096             6 286 ; Uses:     AI_PLAYER (speccy side)
7096             6 287 ;           AI_DEPTH (recursion depth level)
7096             6 288 ;
7096             6 289 ; Destroys: BC, HL, IX, IY
7096             6 290 ; ----------------------------------------------------------------------------------------------------------------------
7096             6 291 Alphabeta_Max:
7096 D5          6 292 push    de
7097             6 294 ; check if last player move is a winner one
7097 CD FB 74    6 296 call    PathFinder_PlayerScore      ; if (player won)
709A FE 43       6 297 cp      WIN_CONDITION
709C 20 08       6 298 jr      nz, Alphabeta_Max_Candidates
709E 3A 9A 61    6 299 ld      a, (AI_DEPTH)
70A1 2F          6 300 cpl
70A2 C6 41       6 301 add     a, 64+1                     ;     return 64-depth
70A4 D1          6 302 pop     de
70A5 C9          6 303 ret
70A6             6 305 Alphabeta_Max_Candidates
70A6 CD 79 75    6 306 call    PathFinder_Candidates       ; find candidates for next move
70A9 D1          6 307 pop     de
70AA DD 7E 00    6 309 ld      a, (ix+0)                   ; A is our first candidate
70AD 21 9A 61    6 311 ld      hl, AI_DEPTH
70B0 35          6 312 dec     (hl)                        ; depth--
70B1 28 39       6 313 jr      z, Heuristic_Max            ; if (depth == 0) return heuristic_max
70B3             6 315 Alphabeta_Max_Loop                                          ; for each candidate {
70B3 D5          6 316 push    de                          ;       store alphaMax and betaMin
70B4 26 7D       6 318 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70B6 6F          6 319 ld      l, a
70B7 E5          6 320 push    hl
70B8 3A 99 61    6 322 ld      a, (AI_PLAYER)              ;       get speccy side
70BB CD 35 71    6 323 call    PathFinder_PutToken         ;       BRAINIAC_play
70BE CD FE 6F    6 324 call    Alphabeta_Min               ;       A = alphabeta_min(alphaMax, betaMin)
70C1 E1          6 326 pop     hl                          ;       restore candidate position
70C2 CD 3B 71    6 327 call    PathFinder_EraseToken       ;       BRAINIAC_undo
70C5 D1          6 329 pop     de                          ;       restore alphaMax and betaMin
70C6 BA          6 331 cp      d
70C7 38 06       6 332 jr      c, Alphabeta_Max_Next
70C9 28 04       6 333 jr      z, Alphabeta_Max_Next       ;       if (A <= alphaMax) continue
70CB BB          6 335 cp      e
70CC 30 0F       6 336 jr      nc, Alphabeta_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
70CE 57          6 338 ld      d, a                        ;       alphaMax = A
70CF             6 340 Alphabeta_Max_Next
70CF DD 2D       6 341 dec     ixl
70D1 DD 7E 00    6 342 ld      a, (ix+0)                   ;       A is our next candidate
70D4 B7          6 343 or      a                           ;       repeat until no more candidates
70D5 20 DC       6 344 jr      nz, Alphabeta_Max_Loop      ; }
70D7 7A          6 346 ld      a, d                        ; return alphaMax
70D8 21 9A 61    6 348 ld      hl, AI_DEPTH
70DB 34          6 349 inc     (hl)                        ; depth++
70DC C9          6 350 ret
70DD             6 352 Alphabeta_Max_Exit
70DD 57          6 353 ld      d, a                        ; (discard remaining candidates)
70DE AF          6 354 xor     a
70DF             6 355 Alphabeta_Max_Skip
70DF DD 2D       6 356 dec     ixl
70E1 DD BE 00    6 357 cp      (ix+0)
70E4 20 F9       6 358 jr      nz, Alphabeta_Max_Skip
70E6 7A          6 359 ld      a, d
70E7 21 9A 61    6 361 ld      hl, AI_DEPTH
70EA 34          6 362 inc     (hl)                        ; (depth++)
70EB C9          6 363 ret
70EC             6 365 ; ----------------------------------------------------------------------------------------------------------------------
70EC             6 366 ; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-
70EC             6 367 ; beta pruning, when it requires MAXIMIZING speccy's score.
70EC             6 368 ;
70EC             6 369 ; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
70EC             6 370 ; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
70EC             6 371 ; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds
70EC             6 372 ; faster.
70EC             6 373 ;
70EC             6 374 ; Original source code by Einar Saukas: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC
70EC             6 375 ;
70EC             6 376 ; Input:    A = first candidate
70EC             6 377 ;           D = alphaMax
70EC             6 378 ;           E = betaMin
70EC             6 379 ;
70EC             6 380 ; Returns:  A = "improved" alphaMax
70EC             6 381 ;           D = "improved" alphaMax
70EC             6 382 ;           E = betaMin
70EC             6 383 ;
70EC             6 384 ; Uses:     AI_PLAYER (speccy side)
70EC             6 385 ;           AI_DEPTH (recursion depth level)
70EC             6 386 ;
70EC             6 387 ; Destroys: BC, HL, IX, IY
70EC             6 388 ; ----------------------------------------------------------------------------------------------------------------------
70EC             6 389 Heuristic_Max:                                              ; for each candidate {
70EC D5          6 390 push    de                          ;       store alphaMax and betaMin
70ED 26 7D       6 392 ld      h, CYAN_POSITIONS/256       ;       get and store candidate position on board
70EF 6F          6 393 ld      l, a
70F0 E5          6 394 push    hl
70F1 3A 99 61    6 396 ld      a, (AI_PLAYER)              ;       get speccy side
70F4 CD 35 71    6 397 call    PathFinder_PutToken         ;       (BRAINIAC_play)
70F7 CD BB 74    6 399 call    PathFinder_SpeccyScore      ;       if (speccy won)
70FA FE 43       6 400 cp      WIN_CONDITION
70FC 20 02       6 401 jr      nz, Heuristic_Max_Continue
70FE 3E C0       6 402 ld      a, 192                      ;           A = 192
7100             6 403 Heuristic_Max_Continue
7100 E1          6 404 pop     hl                          ;       restore candidate position
7101 CD 3B 71    6 405 call    PathFinder_EraseToken       ;       BRAINIAC_undo
7104 D1          6 407 pop     de                          ;       restore alphaMax and betaMin
7105 BA          6 409 cp      d
7106 38 06       6 410 jr      c, Heuristic_Max_Next
7108 28 04       6 411 jr      z, Heuristic_Max_Next       ;       if (A <= alphaMax) continue
710A BB          6 413 cp      e
710B 30 0F       6 414 jr      nc, Heuristic_Max_Exit      ;       if (A >= betaMin) { depth++; return A }
710D 57          6 416 ld      d, a                        ;       alphaMax = A
710E             6 418 Heuristic_Max_Next
710E DD 2D       6 419 dec     ixl
7110 DD 7E 00    6 420 ld      a, (ix+0)                   ;       A is our next candidate
7113 B7          6 421 or      a                           ;       repeat until no more candidates
7114 20 D6       6 422 jr      nz, Heuristic_Max           ; }
7116 7A          6 424 ld      a, d                        ; return alphaMax
7117 21 9A 61    6 426 ld      hl, AI_DEPTH
711A 34          6 427 inc     (hl)                        ; depth++
711B C9          6 428 ret
711C             6 430 Heuristic_Max_Exit:
711C 57          6 431 ld      d, a                        ; (discard remaining candidates)
711D AF          6 432 xor     a
711E             6 433 Heuristic_Max_Skip:
711E DD 2D       6 434 dec     ixl
7120 DD BE 00    6 435 cp      (ix+0)
7123 20 F9       6 436 jr      nz, Heuristic_Max_Skip
7125 7A          6 437 ld      a, d
7126 21 9A 61    6 439 ld      hl, AI_DEPTH
7129 34          6 440 inc     (hl)                        ; (depth++)
712A C9          6 441 ret

; File #7: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\PathFinder.z80asm

712B             7 1 ; ----------------------------------------------------------------------------------------------------------------------
712B             7 2 ; PathFinder.z80asm
712B             7 3 ; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
712B             7 4 ;
712B             7 5 ; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
712B             7 6 ; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
712B             7 7 ; ----------------------------------------------------------------------------------------------------------------------
712B             7 9 CYAN                    equ     $01                         ; cyan side
712B             7 10 RED                     equ     $02                         ; red side
712B             7 11 WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor
712B             7 12 EMPTY                   equ     $00                         ; empty positions on the board
712B             7 13 SKIPPED                 equ     $01                         ; skipped positions on the board
712B             7 14 FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
712B             7 15 ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
712B             7 16 DEFEAT                  equ     $FF                         ; return value if defeat
712B             7 17 VICTORY                 equ     $03                         ; internal value if victory
712B             7 18 FRIENDLY                equ     %01000000                   ; mask to set friendly flag
712B             7 19 WIN_CONDITION           equ     VICTORY+FRIENDLY            ; return value if victory
712B             7 20 INFINITE                equ     $30                         ; cell potential value when two-distance cannot percolate
712B             7 21 ; through two-bridges
712B             7 22 CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
712B             7 23 RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
712B             7 24 CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates
712B             7 26 ; ----------------------------------------------------------------------------------------------------------------------
712B             7 27 ; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
712B             7 28 ;
712B             7 29 ; Input:    -
712B             7 30 ;
712B             7 31 ; Output:   A = FRIEND, if current token color is cyan
712B             7 32 ;           A = ENEMY, if current token color is red
712B             7 33 ;
712B             7 34 ; Uses:     TOKEN_COLOR (current token color)
712B             7 35 ;
712B             7 36 ; Destroys: -
712B             7 37 ; ----------------------------------------------------------------------------------------------------------------------
712B             7 38 PathFinder_Friend:
712B 3A 9E 61    7 39 ld      a, (TOKEN_COLOR)            ; get current player color
712E 1F          7 40 rra                                 ; is current player color cyan?
712F 3E 02       7 41 ld      a, FRIEND                   ; set FRIEND in A
7131 D8          7 42 ret     c                           ; yes, return FRIEND 
7132 EE 7C       7 43 xor     $7C                         ; no, return ENEMY
7134 C9          7 44 ret
7135             7 46 ; ----------------------------------------------------------------------------------------------------------------------
7135             7 47 ; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
7135             7 48 ;
7135             7 49 ; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
7135             7 50 ;           HL = CYAN_POSITIONS token address
7135             7 51 ;
7135             7 52 ; Output:   -
7135             7 53 ;
7135             7 54 ; Destroys: -
7135             7 55 ; ----------------------------------------------------------------------------------------------------------------------
7135             7 56 PathFinder_PutToken:
7135 77          7 57 ld      (hl), a                     ; put token at cyan position
7136 24          7 58 inc     h                           ; move HL to red position address
7137 EE 7C       7 59 xor     $7C                         ; invert side
7139 77          7 60 ld      (hl), a                     ; put token at red position
713A C9          7 61 ret
713B             7 63 ; ----------------------------------------------------------------------------------------------------------------------
713B             7 64 ; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
713B             7 65 ;
713B             7 66 ; Input:    HL = CYAN_POSITIONS token address
713B             7 67 ;
713B             7 68 ; Output:   -
713B             7 69 ;
713B             7 70 ; Destroys: -
713B             7 71 ; ----------------------------------------------------------------------------------------------------------------------
713B             7 72 PathFinder_EraseToken:
713B 36 00       7 73 ld      (hl), EMPTY                 ; erase token at cyan position
713D 24          7 74 inc     h                           ; move HL to red position address
713E 36 00       7 75 ld      (hl), EMPTY                 ; erase token at red position
7140 C9          7 76 ret
7141             7 78 ; ----------------------------------------------------------------------------------------------------------------------
7141             7 79 ; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
7141             7 80 ;
7141             7 81 ; Input:    DE = cyan or red board address (destiny)
7141             7 82 ;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
7141             7 83 ;
7141             7 84 ; Output:   -
7141             7 85 ;
7141             7 86 ; Destroys: BC, DE, HL
7141             7 87 ; ----------------------------------------------------------------------------------------------------------------------
7141             7 88 PathFinder_CopyPositions:
7141 01 31 00    7 89 ld      bc, 7*7                     ; number of positions to be copied
7144             7 90 PathFinder_CopyLoop
7144 2C          7 91 inc     l                           ; skip borders on positions
7145 2C          7 92 inc     l
7146 1C          7 93 inc     e                           ; skip borders on board
7147 1C          7 94 inc     e
7148 ED A0       7 95 ldi                                 ; copy a row of 7 positions
714A ED A0       7 96 ldi
714C ED A0       7 97 ldi
714E ED A0       7 98 ldi
7150 ED A0       7 99 ldi
7152 ED A0       7 100 ldi
7154 ED A0       7 101 ldi
7156 EA 44 71    7 102 jp      pe, PathFinder_CopyLoop     ; repeat for each row
7159 C9          7 103 ret
715A             7 105 ; ----------------------------------------------------------------------------------------------------------------------
715A             7 106 ; PathFinder_Update: update current board position during heuristic function evaluation
715A             7 107 ;
715A             7 108 ; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
715A             7 109 ; second lowest distance of ps neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
715A             7 110 ; adjacent".
715A             7 111 ;
715A             7 112 ; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
715A             7 113 ; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
715A             7 114 ; follows, depending on current content:
715A             7 115 ;
715A             7 116 ; * SKIPPED: 1 + distance of neighbor closest to goal
715A             7 117 ; * FRIEND:  distance of neighbor closest to goal
715A             7 118 ; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
715A             7 119 ;
715A             7 120 ; Input:    Z  = flag set when (HL) is FRIEND
715A             7 121 ;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
715A             7 122 ;           HL = current position address (on either cyan boards or red boards)
715A             7 123 ;
715A             7 124 ; Output:   -
715A             7 125 ;
715A             7 126 ; Destroys: B, DE
715A             7 127 ; ----------------------------------------------------------------------------------------------------------------------
715A             7 128 PathFinder_Update:
715A 28 12       7 129 jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
715C 46          7 130 ld      b, (hl)                     ; check current position
715D 10 1A       7 131 djnz    PathFinder_EMPTY
715F             7 132 ; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
715F             7 133 PathFinder_Increment:
715F 71          7 134 ld      (hl), c                     ; save current distance in current position
7160 34          7 135 inc     (hl)                        ; increment distance of current position
7161 CB B6       7 136 res     6, (hl)                     ; reset friendly token flag
7163 EB          7 137 ex      de, hl                      ; store current position in DE
7164             7 138 @Queue_Tail
7164 21 00 00    7 139 ld      hl, $0000                   ; HL points to queue tail address (changed before call)
7167 2C          7 140 inc     l                           ; move queue tail down
7168 73          7 141 ld      (hl), e                     ; store position into queue tail
7169 22 65 71    7 142 ld      (@Queue_Tail+1), hl         ; update queue tail
716C EB          7 143 ex      de, hl                      ; restore current position
716D C9          7 144 ret
716E             7 145 ; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
716E             7 146 PathFinder_Friendly
716E 71          7 147 ld      (hl), c                     ; save current distance in current position
716F CB F6       7 148 set     6, (hl)                     ; set friendly token flag
7171 45          7 149 ld      b, l                        ; save current position in B
7172 D1          7 150 pop     de                          ; preserve RET address
7173 E3          7 151 ex      (sp), hl                    ; retrieve queue head
7174 70          7 152 ld      (hl), b                     ; push this position into queue head
7175 2D          7 153 dec     l                           ; move queue head up
7176 E3          7 154 ex      (sp), hl                    ; update queue head
7177 D5          7 155 push    de                          ; restore RET address
7178 C9          7 156 ret
7179             7 157 ; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
7179             7 158 PathFinder_EMPTY
7179 CB 71       7 159 bit     6, c                        ; is current distance friendly?
717B C2 5F 71    7 160 jp      nz, PathFinder_Increment    ; yes, set (HL) = C+1 and insert HL in queue tail
717E 34          7 161 inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
717F C9          7 162 ret
7180             7 164 ; ----------------------------------------------------------------------------------------------------------------------
7180             7 165 ; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
7180             7 166 ;
7180             7 167 ; Input:    -
7180             7 168 ;
7180             7 169 ; Output:   A = DEFEAT, if down edge couldn't be reached
7180             7 170 ;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
7180             7 171 ;           A = 0, otherwise
7180             7 172 ;
7180             7 173 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7180             7 174 ;
7180             7 175 ; Destroys: BC, DE, HL, IY
7180             7 176 ; ----------------------------------------------------------------------------------------------------------------------
7180             7 177 PathFinder_Cyan_UpDown:
7180 21 07 7D    7 178 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
7183 11 07 61    7 179 ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
7186 CD 41 71    7 180 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down
7189             7 182 ; entry point for PathFinder_BrightPath
7189             7 183 PathFinder_Cyan_BrightPath:
7189 FD 21 00 09 7 184 ld      iy, $0900                   ; IYH = distance to check edge positions
718D             7 185 ; IYL = initialize return value of 'Path_Finder'
718D 21 00 60    7 186 ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
7190 22 65 71    7 187 ld      (@Queue_Tail+1), hl         ; initialize cyan queue area
7193 E5          7 188 push    hl                          ; store queue tail address
7194             7 190 ; set up cyan board (up-down) start positions distances
7194 21 09 61    7 192 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7197 0E 43       7 193 ld      c, VICTORY+FRIENDLY         ; initialize start positions distance
7199 3E 02       7 194 ld      a, FRIEND                   ; set distance to compare with
719B BE          7 195 cp      (hl)                        ; check 1st start position distance
719C D4 5A 71    7 196 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
719F 2C          7 197 inc     l                           ; move HL to next start position address
71A0 BE          7 198 cp      (hl)                        ; check 2nd start position distance
71A1 D4 5A 71    7 199 call    nc, PathFinder_Update       ; (repeat for each start position)
71A4 2C          7 200 inc     l
71A5 BE          7 201 cp      (hl)                        ; check 3rd start position distance
71A6 D4 5A 71    7 202 call    nc, PathFinder_Update
71A9 2C          7 203 inc     l
71AA BE          7 204 cp      (hl)                        ; check 4th start position distance
71AB D4 5A 71    7 205 call    nc, PathFinder_Update
71AE 2C          7 206 inc     l
71AF BE          7 207 cp      (hl)                        ; check 5th start position distance
71B0 D4 5A 71    7 208 call    nc, PathFinder_Update
71B3 2C          7 209 inc     l
71B4 BE          7 210 cp      (hl)                        ; check 6th start position distance
71B5 D4 5A 71    7 211 call    nc, PathFinder_Update
71B8 2C          7 212 inc     l
71B9 C3 A6 72    7 213 jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)
71BC             7 215 ; ----------------------------------------------------------------------------------------------------------------------
71BC             7 216 ; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
71BC             7 217 ;
71BC             7 218 ; Input:    -
71BC             7 219 ;
71BC             7 220 ; Output:   A = DEFEAT, if up edge couldn't be reached
71BC             7 221 ;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
71BC             7 222 ;           A = 0, otherwise
71BC             7 223 ;
71BC             7 224 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71BC             7 225 ;
71BC             7 226 ; Destroys: BC, DE, HL, IY
71BC             7 227 ; ----------------------------------------------------------------------------------------------------------------------
71BC             7 228 PathFinder_Cyan_DownUp:
71BC 21 07 7D    7 229 ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
71BF 11 4F 61    7 230 ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
71C2 CD 41 71    7 231 call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up
71C5 FD 21 00 F7 7 233 ld      iy, $F700                   ; IYH = distance to check edge positions
71C9             7 234 ; IYL = initialize return value of 'Path_Finder'
71C9 2A 65 71    7 235 ld      hl, (@Queue_Tail+1)         ; initialize cyan queue area
71CC E5          7 236 push    hl                          ; store Queue Tail
71CD             7 238 ; set up cyan board (down-up) start positions distances
71CD EB          7 240 ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
71CE 2D          7 241 dec     l                           ; move HL to cyan boad down-up address (last position)
71CF 0E 43       7 242 ld      c, VICTORY+FRIENDLY         ; initialize start positions distance
71D1 3E 02       7 243 ld      a, FRIEND                   ; set distance to compare with
71D3 BE          7 244 cp      (hl)                        ; check 1st start position distance
71D4 D4 5A 71    7 245 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
71D7 2D          7 246 dec     l                           ; move HL to next start position address
71D8 BE          7 247 cp      (hl)                        ; check 2nd start position distance
71D9 D4 5A 71    7 248 call    nc, PathFinder_Update       ; (repeat for each start position)
71DC 2D          7 249 dec     l
71DD BE          7 250 cp      (hl)                        ; check 3rd start position distance
71DE D4 5A 71    7 251 call    nc, PathFinder_Update
71E1 2D          7 252 dec     l
71E2 BE          7 253 cp      (hl)                        ; check 4th start position distance
71E3 D4 5A 71    7 254 call    nc, PathFinder_Update
71E6 2D          7 255 dec     l
71E7 BE          7 256 cp      (hl)                        ; check 5th start position distance
71E8 D4 5A 71    7 257 call    nc, PathFinder_Update
71EB 2D          7 258 dec     l
71EC BE          7 259 cp      (hl)                        ; check 6th start position distance
71ED D4 5A 71    7 260 call    nc, PathFinder_Update
71F0 2D          7 261 dec     l
71F1 C3 A6 72    7 262 jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)
71F4             7 264 ; ----------------------------------------------------------------------------------------------------------------------
71F4             7 265 ; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
71F4             7 266 ;
71F4             7 267 ; Input:    -
71F4             7 268 ;
71F4             7 269 ; Output:   A = DEFEAT, if right edge couldn't be reached
71F4             7 270 ;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
71F4             7 271 ;           A = 0, otherwise
71F4             7 272 ;
71F4             7 273 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
71F4             7 274 ;
71F4             7 275 ; Destroys: BC, DE, HL, IY
71F4             7 276 ; ----------------------------------------------------------------------------------------------------------------------
71F4             7 277 PathFinder_Red_LeftRight:
71F4 21 07 7E    7 278 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
71F7 11 07 64    7 279 ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
71FA CD 41 71    7 280 call    PathFinder_CopyPositions    ; copy from red positions to red board left-right
71FD             7 282 ; entry point for PathFinder_BrightPath
71FD             7 283 PathFinder_Red_BrightPath
71FD FD 21 00 01 7 284 ld      iy, $0100                   ; IYH = distance to check edge positions
7201             7 285 ; IYL = initialize return value of 'Path_Finder'
7201 21 00 63    7 286 ld      hl, RED_QUEUE_AREA          ; initialize red queue area
7204 22 65 71    7 287 ld      (@Queue_Tail+1), hl
7207 E5          7 288 push    hl                          ; store Queue Tail
7208             7 290 ; set up red board (left-right) start positions distances
7208 21 09 64    7 292 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
720B 0E 43       7 293 ld      c, VICTORY+FRIENDLY         ; initialize start positions distance
720D 3E 02       7 294 ld      a, FRIEND                   ; set distance to compare with
720F BE          7 295 cp      (hl)                        ; check 1st start position distance
7210 D4 5A 71    7 296 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7213 2E 12       7 297 ld      l, (RED_BOARD_LEFT_RIGHT+18)%256 ; move HL to next start position address
7215 BE          7 298 cp      (hl)                        ; check 2nd start position distance
7216 D4 5A 71    7 299 call    nc, PathFinder_Update       ; (repeat for each start position)
7219 2E 1B       7 300 ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
721B BE          7 301 cp      (hl)                        ; check 3rd start position distance
721C D4 5A 71    7 302 call    nc, PathFinder_Update
721F 2E 24       7 303 ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
7221 BE          7 304 cp      (hl)                        ; check 4th start position distance
7222 D4 5A 71    7 305 call    nc, PathFinder_Update
7225 2E 2D       7 306 ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
7227 BE          7 307 cp      (hl)                        ; check 5th start position distance
7228 D4 5A 71    7 308 call    nc, PathFinder_Update
722B 2E 36       7 309 ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
722D BE          7 310 cp      (hl)                        ; check 6th start position distance
722E D4 5A 71    7 311 call    nc, PathFinder_Update
7231 2E 3F       7 312 ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
7233 C3 A6 72    7 313 jp      Path_Finder_First           ; calculate two-distances of red board (left-right)
7236             7 315 ; ----------------------------------------------------------------------------------------------------------------------
7236             7 316 ; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
7236             7 317 ;
7236             7 318 ; Input:    -
7236             7 319 ;
7236             7 320 ; Output:   A = DEFEAT, if left edge couldn't be reached
7236             7 321 ;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
7236             7 322 ;           A = 0, otherwise
7236             7 323 ;
7236             7 324 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7236             7 325 ;
7236             7 326 ; Destroys: BC, DE, HL, IY
7236             7 327 ; ----------------------------------------------------------------------------------------------------------------------
7236             7 328 PathFinder_Red_RightLeft:
7236 21 07 7E    7 329 ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
7239 11 4F 64    7 330 ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
723C CD 41 71    7 331 call    PathFinder_CopyPositions    ; copy from red positions to red board right-left
723F FD 21 00 FF 7 333 ld      iy, $FF00                   ; IYH = distance to check edge positions
7243             7 334 ; IYL = initialize return value of 'Path_Finder'
7243 2A 65 71    7 335 ld      hl, (@Queue_Tail+1)         ; initialize red queue area
7246 E5          7 336 push    hl                          ; store queue tail
7247             7 338 ; set up red board (right-left) start positions distances
7247 EB          7 340 ex      de, hl                      ; take advantage of last "CopyPositions" execution
7248 2D          7 341 dec     l                           ; move HL to red board right-left address (last position)
7249 0E 43       7 342 ld      c, VICTORY+FRIENDLY         ; set start positions distance (+ friendly flag)
724B 3E 02       7 343 ld      a, FRIEND                   ; set distance to compare with
724D BE          7 344 cp      (hl)                        ; check 1st start position distance
724E D4 5A 71    7 345 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
7251 2E 84       7 346 ld      l, (RED_BOARD_RIGHT_LEFT+52)%256 ; move HL to next start position address
7253 BE          7 347 cp      (hl)                        ; check 2nd start position distance
7254 D4 5A 71    7 348 call    nc, PathFinder_Update       ; (repeat for each start position)
7257 2E 7B       7 349 ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
7259 BE          7 350 cp      (hl)                        ; check 3rd start position distance
725A D4 5A 71    7 351 call    nc, PathFinder_Update
725D 2E 72       7 352 ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
725F BE          7 353 cp      (hl)                        ; check 4th start position distance
7260 D4 5A 71    7 354 call    nc, PathFinder_Update
7263 2E 69       7 355 ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
7265 BE          7 356 cp      (hl)                        ; check 5th start position distance
7266 D4 5A 71    7 357 call    nc, PathFinder_Update
7269 2E 60       7 358 ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
726B BE          7 359 cp      (hl)                        ; check 6th start position distance
726C D4 5A 71    7 360 call    nc, PathFinder_Update
726F 2E 57       7 361 ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
7271 C3 A6 72    7 362 jp      Path_Finder_First           ; calculate red two-distance (right-left)
7274             7 364 ; ----------------------------------------------------------------------------------------------------------------------
7274             7 365 ; Path_Finder: calculate two-distance metric for each board position
7274             7 366 ;
7274             7 367 ; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
7274             7 368 ;
7274             7 369 ; Input:    HL  = cyan or red queue area address
7274             7 370 ;           IYH = distance to check edge positions
7274             7 371 ;           IYL = 0
7274             7 372 ;
7274             7 373 ; Output:   A = DEFEAT, if corresponding edge couldn't be reached
7274             7 374 ;           A = WIN_CONDITION, if there is chain of connected (color) tokens between the two edges
7274             7 375 ;           A = 0, otherwise
7274             7 376 ;
7274             7 377 ; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
7274             7 378 ;
7274             7 379 ; Destroys: DE, HL, IY
7274             7 380 ; ----------------------------------------------------------------------------------------------------------------------
7274             7 381 Path_Finder:
7274 2C          7 382 inc     l                           ; move queue head down
7275 E5          7 383 push    hl                          ; preserve queue head address
7276 6E          7 384 ld      l, (hl)                     ; retrieve next position to be checked
7277 24          7 385 inc     h                           ; move HL to corresponding board address
7278 4E          7 386 ld      c, (hl)                     ; retrieve distance from this position to start
7279 45          7 387 ld      b, l                        ; store current position
727A             7 389 ; look for adjacent positions
727A 7D          7 391 ld      a, l                        ; get current position
727B FD 84       7 392 add     a, iyh                      ; add distance to check edge positions
727D 6F          7 393 ld      l, a                        ; move HL to calculated position address
727E CB 7E       7 394 bit     7, (hl)                     ; is it an edge?
7280 20 36       7 395 jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions
7282 3E 02       7 397 ld      a, FRIEND                   ; set distance to compare with
7284             7 398 ; return point from PathFinder_Adjacent
7284             7 399 Path_Finder_Neighbors
7284 68          7 400 ld      l, b                        ; restore current position to be checked
7285 2C          7 401 inc     l                           ; move HL to right neighbor address
7286 BE          7 402 cp      (hl)                        ; check right neighbor distance
7287 D4 5A 71    7 403 call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
728A 2D          7 404 dec     l                           ; move HL to left neighbor address
728B 2D          7 405 dec     l
728C BE          7 406 cp      (hl)                        ; check left neighbor distance
728D D4 5A 71    7 407 call    nc, PathFinder_Update       ; (repeat for each neighbor)
7290 11 F8 FF    7 408 ld      de, -WIDTH
7293 19          7 409 add     hl, de
7294 BE          7 410 cp      (hl)                        ; check upper-left neighbor distance
7295 D4 5A 71    7 411 call    nc, PathFinder_Update
7298 2C          7 412 inc     l
7299 BE          7 413 cp      (hl)                        ; check upper-right neighbor distance
729A D4 5A 71    7 414 call    nc, PathFinder_Update
729D 11 10 00    7 415 ld      de, WIDTH*2
72A0 19          7 416 add     hl, de
72A1 BE          7 417 cp      (hl)                        ; check lower-left neighbor distance
72A2 D4 5A 71    7 418 call    nc, PathFinder_Update
72A5 2C          7 419 inc     l
72A6             7 420 Path_Finder_First
72A6 BE          7 421 cp      (hl)                        ; check lower-right neighbor distance
72A7 D4 5A 71    7 422 call    nc, PathFinder_Update
72AA E1          7 423 pop     hl                          ; restore queue tail address
72AB 3A 65 71    7 424 ld      a, (@Queue_Tail+1)          ; check queue
72AE BD          7 425 cp      l                           ; is queue empty?
72AF C2 74 72    7 426 jp      nz, Path_Finder             ; no, repeat until queue is empty
72B2             7 428 ; check if corresponding edge was reached
72B2 FD 7D       7 430 ld      a, iyl                      ; get last position processed by 'Path_Finder_Adjacent'
72B4 3D          7 431 dec     a                           ; check if the initial value (0) of IYL is unchanged
72B5 F8          7 432 ret     m                           ; return A = DEFEAT, if the edge couldn't be reached
72B6 AF          7 433 xor     a                           ; return A = 0, otherwise
72B7 C9          7 434 ret
72B8             7 436 ; ----------------------------------------------------------------------------------------------------------------------
72B8             7 437 ; Check adjacent hexagons.
72B8             7 438 ;
72B8             7 439 ; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
72B8             7 440 ; "two cells are adjacent if they share a common edge on the board."
72B8             7 441 ;
72B8             7 442 ; Input:    B  = current position
72B8             7 443 ;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
72B8             7 444 ;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
72B8             7 445 ;                edge number)
72B8             7 446 ;
72B8             7 447 ; Output:   A = WIN_CONDITION, if there is a chain of connected tokens of the same color between the two edges.
72B8             7 448 ;           A = FRIEND, IYL = current position, otherwise.
72B8             7 449 ;
72B8             7 450 ; Destroys: DE, HL
72B8             7 451 ; ----------------------------------------------------------------------------------------------------------------------
72B8             7 452 Path_Finder_Adjacent
72B8 3E 43       7 453 ld      a, WIN_CONDITION            ; A = VICTORY+FRIENDLY
72BA B9          7 454 cp      c                           ; is current distance victory and friendly?
72BB 28 11       7 455 jr      z, Path_Finder_Abort        ; yes, abort path_finder
72BD 7E          7 457 ld      a, (hl)                     ; get current edge position
72BE E6 07       7 458 and     %00000111                   ; convert to edge number (0..6)
72C0 87          7 459 add     a, a                        ; calculate vector table routine index
72C1 6F          7 460 ld      l, a                        ; set index in L
72C2 24          7 461 inc     h                           ; move HL to (cyan or red) vector table routine address
72C3 5E          7 462 ld      e, (hl)                     ; get low byte of vector table routine address
72C4 2C          7 463 inc     l                           ; move HL to high byte of vector table routine address
72C5 56          7 464 ld      d, (hl)                     ; get high byte of vector table routine address
72C6 EB          7 465 ex      de, hl                      ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
72C7 15          7 466 dec     d                           ; move DE to cyan or red board address
72C8 58          7 467 ld      e, b                        ; restore pointer to current position address
72C9 FD 68       7 468 ld      iyl, b                      ; store current position
72CB 3E 02       7 469 ld      a, FRIEND                   ; set distance to compare with
72CD E9          7 470 jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
72CE             7 471 Path_Finder_Abort
72CE E1          7 472 pop     hl                          ; discard queue pointer to return to previous caller
72CF C9          7 473 ret                                 ; return A = WIN_CONDITION
72D0             7 475 ; ----------------------------------------------------------------------------------------------------------------------
72D0             7 476 ;  Check two-distance of RED adjacents
72D0             7 477 ; ----------------------------------------------------------------------------------------------------------------------
72D0             7 478 PathFinder_RED_Edge_0
72D0 EB          7 479 ex      de, hl                      ; restore pointer to current position address
72D1 11 12 00    7 480 ld      de, 9*2                     ; calculate distance to adjacent #2
72D4 19          7 481 add     hl, de                      ; move HL to adjacent #2 address
72D5 BE          7 482 cp      (hl)                        ; check adjacent #2 distance
72D6 D4 5A 71    7 483 call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
72D9 11 09 00    7 484 ld      de, 9                       ; calculate distance to adjacent #3
72DC 19          7 485 add     hl, de                      ; move HL to adjacent #3 address
72DD BE          7 486 cp      (hl)                        ; check adjacent #3 distance
72DE D4 5A 71    7 487 call    nc, PathFinder_Update       ; (repeat for each adjacent)
72E1 11 09 00    7 488 ld      de, 9
72E4 19          7 489 add     hl, de
72E5 BE          7 490 cp      (hl)                        ; check adjacent #4 distance
72E6 D4 5A 71    7 491 call    nc, PathFinder_Update
72E9 11 09 00    7 492 ld      de, 9
72EC 19          7 493 add     hl, de
72ED BE          7 494 cp      (hl)                        ; check adjacent #5 distance
72EE D4 5A 71    7 495 call    nc, PathFinder_Update
72F1 11 09 00    7 496 ld      de, 9
72F4 19          7 497 add     hl, de
72F5 BE          7 498 cp      (hl)                        ; check adjacent #6 distance
72F6 D4 5A 71    7 499 call    nc, PathFinder_Update
72F9 FD 45       7 500 ld      b, iyl                      ; restore current position
72FB C3 84 72    7 501 jp      Path_Finder_Neighbors       ; continue processing neighbors
72FE             7 503 PathFinder_RED_Edge_1
72FE EB          7 504 ex      de, hl                      ; restore pointer to current position address
72FF 11 12 00    7 505 ld      de, 9*2
7302 19          7 506 add     hl, de
7303 BE          7 507 cp      (hl)                        ; check adjacent #3 distance
7304 D4 5A 71    7 508 call    nc, PathFinder_Update
7307 11 09 00    7 509 ld      de, 9
730A 19          7 510 add     hl, de
730B BE          7 511 cp      (hl)                        ; check adjacent #4 distance
730C D4 5A 71    7 512 call    nc, PathFinder_Update
730F 11 09 00    7 513 ld      de, 9
7312 19          7 514 add     hl, de
7313 BE          7 515 cp      (hl)                        ; check adjacent #5 distance
7314 D4 5A 71    7 516 call    nc, PathFinder_Update
7317 11 09 00    7 517 ld      de, 9
731A 19          7 518 add     hl, de
731B BE          7 519 cp      (hl)                        ; check adjacent #6 distance
731C D4 5A 71    7 520 call    nc, PathFinder_Update
731F FD 45       7 521 ld      b, iyl                      ; restore current position
7321 C3 84 72    7 522 jp      Path_Finder_Neighbors       ; continue processing neighbors
7324             7 524 PathFinder_RED_Edge_2
7324 EB          7 525 ex      de, hl                      ; restore pointer to current position address
7325 11 12 00    7 526 ld      de, 9*2
7328 19          7 527 add     hl, de
7329 BE          7 528 cp      (hl)                        ; check adjacent #4 distance
732A D4 5A 71    7 529 call    nc, PathFinder_Update
732D 11 09 00    7 530 ld      de, 9
7330 19          7 531 add     hl, de
7331 BE          7 532 cp      (hl)                        ; check adjacent #5 distance
7332 D4 5A 71    7 533 call    nc, PathFinder_Update
7335 11 09 00    7 534 ld      de, 9
7338 19          7 535 add     hl, de
7339 BE          7 536 cp      (hl)                        ; check adjacent #6 distance
733A D4 5A 71    7 537 call    nc, PathFinder_Update
733D 11 CA FF    7 538 ld      de, -9*6
7340 19          7 539 add     hl, de
7341 BE          7 540 cp      (hl)                        ; check adjacent #0 distance
7342 D4 5A 71    7 541 call    nc, PathFinder_Update
7345 FD 45       7 542 ld      b, iyl                      ; restore current position
7347 C3 84 72    7 543 jp      Path_Finder_Neighbors       ; continue processing neighbors
734A             7 545 PathFinder_RED_Edge_3
734A EB          7 546 ex      de, hl                      ; restore pointer to current position address
734B 11 E5 FF    7 547 ld      de, -9*3
734E 19          7 548 add     hl, de
734F BE          7 549 cp      (hl)                        ; check adjacent #0 distance
7350 D4 5A 71    7 550 call    nc, PathFinder_Update
7353 11 09 00    7 551 ld      de, 9
7356 19          7 552 add     hl, de
7357 BE          7 553 cp      (hl)                        ; check adjacent #1 distance
7358 D4 5A 71    7 554 call    nc, PathFinder_Update
735B 11 24 00    7 555 ld      de, 9*4
735E 19          7 556 add     hl, de
735F BE          7 557 cp      (hl)                        ; check adjacent #5 distance
7360 D4 5A 71    7 558 call    nc, PathFinder_Update
7363 11 09 00    7 559 ld      de, 9
7366 19          7 560 add     hl, de
7367 BE          7 561 cp      (hl)                        ; check adjacent #6 distance
7368 D4 5A 71    7 562 call    nc, PathFinder_Update
736B FD 45       7 563 ld      b, iyl                      ; restore current position
736D C3 84 72    7 564 jp      Path_Finder_Neighbors       ; continue processing neighbors
7370             7 566 PathFinder_RED_Edge_4
7370 EB          7 567 ex      de, hl                      ; restore pointer to current position address
7371 11 12 00    7 568 ld      de, 9*2
7374 19          7 569 add     hl, de
7375 BE          7 570 cp      (hl)                        ; check adjacent #6 distance
7376 D4 5A 71    7 571 call    nc, PathFinder_Update
7379 11 CA FF    7 572 ld      de, -9*6
737C 19          7 573 add     hl, de
737D BE          7 574 cp      (hl)                        ; check adjacent #0 distance
737E D4 5A 71    7 575 call    nc, PathFinder_Update
7381 11 09 00    7 576 ld      de, 9
7384 19          7 577 add     hl, de
7385 BE          7 578 cp      (hl)                        ; check adjacent #1 distance
7386 D4 5A 71    7 579 call    nc, PathFinder_Update
7389 11 09 00    7 580 ld      de, 9
738C 19          7 581 add     hl, de
738D BE          7 582 cp      (hl)                        ; check adjacent #2 distance
738E D4 5A 71    7 583 call    nc, PathFinder_Update
7391 FD 45       7 584 ld      b, iyl                      ; restore current position
7393 C3 84 72    7 585 jp      Path_Finder_Neighbors       ; continue processing neighbors
7396             7 587 PathFinder_RED_Edge_5
7396 EB          7 588 ex      de, hl                      ; restore pointer to current position address
7397 11 D3 FF    7 589 ld      de, -9*5
739A 19          7 590 add     hl, de
739B BE          7 591 cp      (hl)                        ; check adjacent #0 distance
739C D4 5A 71    7 592 call    nc, PathFinder_Update
739F 11 09 00    7 593 ld      de, 9
73A2 19          7 594 add     hl, de
73A3 BE          7 595 cp      (hl)                        ; check adjacent #1 distance
73A4 D4 5A 71    7 596 call    nc, PathFinder_Update
73A7 11 09 00    7 597 ld      de, 9
73AA 19          7 598 add     hl, de
73AB BE          7 599 cp      (hl)                        ; check adjacent #2 distance
73AC D4 5A 71    7 600 call    nc, PathFinder_Update
73AF 11 09 00    7 601 ld      de, 9
73B2 19          7 602 add     hl, de
73B3 BE          7 603 cp      (hl)                        ; check adjacent #3 distance
73B4 D4 5A 71    7 604 call    nc, PathFinder_Update
73B7 FD 45       7 605 ld      b, iyl                      ; restore current position
73B9 C3 84 72    7 606 jp      Path_Finder_Neighbors       ; continue processing neighbors
73BC             7 608 PathFinder_RED_Edge_6
73BC EB          7 609 ex      de, hl                      ; restore pointer to current position address
73BD 11 CA FF    7 610 ld      de, -9*6
73C0 19          7 611 add     hl, de
73C1 BE          7 612 cp      (hl)                        ; check adjacent #0 distance
73C2 D4 5A 71    7 613 call    nc, PathFinder_Update
73C5 11 09 00    7 614 ld      de, 9
73C8 19          7 615 add     hl, de
73C9 BE          7 616 cp      (hl)                        ; check adjacent #1 distance
73CA D4 5A 71    7 617 call    nc, PathFinder_Update
73CD 11 09 00    7 618 ld      de, 9
73D0 19          7 619 add     hl, de
73D1 BE          7 620 cp      (hl)                        ; check adjacent #2 distance
73D2 D4 5A 71    7 621 call    nc, PathFinder_Update
73D5 11 09 00    7 622 ld      de, 9
73D8 19          7 623 add     hl, de
73D9 BE          7 624 cp      (hl)                        ; check adjacent #3 distance
73DA D4 5A 71    7 625 call    nc, PathFinder_Update
73DD 11 09 00    7 626 ld      de, 9
73E0 19          7 627 add     hl, de
73E1 BE          7 628 cp      (hl)                        ; check adjacent #4 distance
73E2 D4 5A 71    7 629 call    nc, PathFinder_Update
73E5 FD 45       7 630 ld      b, iyl                      ; restore current position
73E7 C3 84 72    7 631 jp      Path_Finder_Neighbors       ; continue processing neighbors
73EA             7 633 ; ----------------------------------------------------------------------------------------------------------------------
73EA             7 634 ;  Check two-distance of CYAN adjacents
73EA             7 635 ; ----------------------------------------------------------------------------------------------------------------------
73EA             7 636 PathFinder_CYAN_Edge_0
73EA EB          7 637 ex      de, hl                      ; restore pointer to current position address
73EB 2C          7 638 inc     l
73EC 2C          7 639 inc     l
73ED BE          7 640 cp      (hl)                        ; check adjacent #2 distance
73EE D4 5A 71    7 641 call    nc, PathFinder_Update
73F1 2C          7 642 inc     l
73F2 BE          7 643 cp      (hl)                        ; check adjacent #3 distance
73F3 D4 5A 71    7 644 call    nc, PathFinder_Update
73F6 2C          7 645 inc     l
73F7 BE          7 646 cp      (hl)                        ; check adjacent #4 distance
73F8 D4 5A 71    7 647 call    nc, PathFinder_Update
73FB 2C          7 648 inc     l
73FC BE          7 649 cp      (hl)                        ; check adjacent of edge number 5
73FD D4 5A 71    7 650 call    nc, PathFinder_Update
7400 2C          7 651 inc     l
7401 BE          7 652 cp      (hl)                        ; check adjacent of edge number 6
7402 D4 5A 71    7 653 call    nc, PathFinder_Update
7405 FD 45       7 654 ld      b, iyl                      ; restore current position
7407 C3 84 72    7 655 jp      Path_Finder_Neighbors       ; continue processing neighbors
740A             7 657 PathFinder_CYAN_Edge_1
740A EB          7 658 ex      de, hl                      ; restore pointer to current position address
740B 2C          7 659 inc     l
740C 2C          7 660 inc     l
740D BE          7 661 cp      (hl)                        ; check adjacent #3 distance
740E D4 5A 71    7 662 call    nc, PathFinder_Update
7411 2C          7 663 inc     l
7412 BE          7 664 cp      (hl)                        ; check adjacent #4 distance
7413 D4 5A 71    7 665 call    nc, PathFinder_Update
7416 2C          7 666 inc     l
7417 BE          7 667 cp      (hl)                        ; check adjacent #5 distance
7418 D4 5A 71    7 668 call    nc, PathFinder_Update
741B 2C          7 669 inc     l
741C BE          7 670 cp      (hl)                        ; check adjacent #6 distance
741D D4 5A 71    7 671 call    nc, PathFinder_Update
7420 FD 45       7 672 ld      b, iyl                      ; restore current position
7422 C3 84 72    7 673 jp      Path_Finder_Neighbors       ; continue processing neighbors
7425             7 675 PathFinder_CYAN_Edge_2
7425 EB          7 676 ex      de, hl                      ; restore pointer to current position address
7426 2D          7 677 dec     l
7427 2D          7 678 dec     l
7428 BE          7 679 cp      (hl)                        ; check adjacent #0 distance
7429 D4 5A 71    7 680 call    nc, PathFinder_Update
742C 2C          7 681 inc     l
742D 2C          7 682 inc     l
742E 2C          7 683 inc     l
742F 2C          7 684 inc     l
7430 BE          7 685 cp      (hl)                        ; check adjacent #4 distance
7431 D4 5A 71    7 686 call    nc, PathFinder_Update
7434 2C          7 687 inc     l
7435 BE          7 688 cp      (hl)                        ; check adjacent #5 distance
7436 D4 5A 71    7 689 call    nc, PathFinder_Update
7439 2C          7 690 inc     l
743A BE          7 691 cp      (hl)                        ; check adjacent #6 distance
743B D4 5A 71    7 692 call    nc, PathFinder_Update
743E FD 45       7 693 ld      b, iyl                      ; restore current position
7440 C3 84 72    7 694 jp      Path_Finder_Neighbors       ; continue processing neighbors
7443             7 696 PathFinder_CYAN_Edge_3
7443 EB          7 697 ex      de, hl                      ; restore pointer to current position address
7444 2D          7 698 dec     l
7445 2D          7 699 dec     l
7446 2D          7 700 dec     l
7447 BE          7 701 cp      (hl)                        ; check adjacent #0 distance
7448 D4 5A 71    7 702 call    nc, PathFinder_Update
744B 2C          7 703 inc     l
744C BE          7 704 cp      (hl)                        ; check adjacent #1 distance
744D D4 5A 71    7 705 call    nc, PathFinder_Update
7450 2C          7 706 inc     l
7451 2C          7 707 inc     l
7452 2C          7 708 inc     l
7453 2C          7 709 inc     l
7454 BE          7 710 cp      (hl)                        ; check adjacent #5 distance
7455 D4 5A 71    7 711 call    nc, PathFinder_Update
7458 2C          7 712 inc     l
7459 BE          7 713 cp      (hl)                        ; check adjacent #6 distance
745A D4 5A 71    7 714 call    nc, PathFinder_Update
745D FD 45       7 715 ld      b, iyl                      ; restore current position
745F C3 84 72    7 716 jp      Path_Finder_Neighbors       ; continue processing neighbors
7462             7 718 PathFinder_CYAN_Edge_4
7462 EB          7 719 ex      de, hl                      ; restore pointer to current position address
7463 2C          7 720 inc     l
7464 2C          7 721 inc     l
7465 BE          7 722 cp      (hl)                        ; check adjacent #6 distance
7466 D4 5A 71    7 723 call    nc, PathFinder_Update
7469 2D          7 724 dec     l
746A 2D          7 725 dec     l
746B 2D          7 726 dec     l
746C 2D          7 727 dec     l
746D BE          7 728 cp      (hl)                        ; check adjacent #2 distance
746E D4 5A 71    7 729 call    nc, PathFinder_Update
7471 2D          7 730 dec     l
7472 BE          7 731 cp      (hl)                        ; check adjacent #1 distance
7473 D4 5A 71    7 732 call    nc, PathFinder_Update
7476 2D          7 733 dec     l
7477 BE          7 734 cp      (hl)                        ; check adjacent #0 distance
7478 D4 5A 71    7 735 call    nc, PathFinder_Update
747B FD 45       7 736 ld      b, iyl                      ; restore current position
747D C3 84 72    7 737 jp      Path_Finder_Neighbors       ; continue processing neighbors
7480             7 739 PathFinder_CYAN_Edge_5
7480 EB          7 740 ex      de, hl                      ; restore pointer to current position address
7481 2D          7 741 dec     l
7482 2D          7 742 dec     l
7483 BE          7 743 cp      (hl)                        ; check adjacent #3 distance
7484 D4 5A 71    7 744 call    nc, PathFinder_Update
7487 2D          7 745 dec     l
7488 BE          7 746 cp      (hl)                        ; check adjacent #2 distance
7489 D4 5A 71    7 747 call    nc, PathFinder_Update
748C 2D          7 748 dec     l
748D BE          7 749 cp      (hl)                        ; check adjacent #1 distance
748E D4 5A 71    7 750 call    nc, PathFinder_Update
7491 2D          7 751 dec     l
7492 BE          7 752 cp      (hl)                        ; check adjacent #0 distance
7493 D4 5A 71    7 753 call    nc, PathFinder_Update
7496 FD 45       7 754 ld      b, iyl                      ; restore current position
7498 C3 84 72    7 755 jp      Path_Finder_Neighbors       ; continue processing neighbors
749B             7 757 PathFinder_CYAN_Edge_6
749B EB          7 758 ex      de, hl                      ; restore pointer to current position address
749C 2D          7 759 dec     l
749D 2D          7 760 dec     l
749E BE          7 761 cp      (hl)                        ; check adjacent #4 distance
749F D4 5A 71    7 762 call    nc, PathFinder_Update
74A2 2D          7 763 dec     l
74A3 BE          7 764 cp      (hl)                        ; check adjacent #3 distance
74A4 D4 5A 71    7 765 call    nc, PathFinder_Update
74A7 2D          7 766 dec     l
74A8 BE          7 767 cp      (hl)                        ; check adjacent #2 distance
74A9 D4 5A 71    7 768 call    nc, PathFinder_Update
74AC 2D          7 769 dec     l
74AD BE          7 770 cp      (hl)                        ; check adjacent #1 distance
74AE D4 5A 71    7 771 call    nc, PathFinder_Update
74B1 2D          7 772 dec     l
74B2 BE          7 773 cp      (hl)                        ; check adjacent #0 distance
74B3 D4 5A 71    7 774 call    nc, PathFinder_Update
74B6 FD 45       7 775 ld      b, iyl                      ; restore current position
74B8 C3 84 72    7 776 jp      Path_Finder_Neighbors       ; continue processing neighbors
74BB             7 778 ; ----------------------------------------------------------------------------------------------------------------------
74BB             7 779 ; PathFinder_SpeccyScore: calculate SPECCY score depending on speccy color
74BB             7 780 ;
74BB             7 781 ; Input:    -
74BB             7 782 ;
74BB             7 783 ; Output:   A = DEFEAT, if speccy can't reach his opposite edge
74BB             7 784 ;           A = WIN_CONDITION, if player can't reach his opposite edge
74BB             7 785 ;           A = speccy heuristic evaluation, otherwise
74BB             7 786 ;
74BB             7 787 ; Uses:     AI_PLAYER (speccy side)
74BB             7 788 ;
74BB             7 789 ; Destroys: A', BC, DE, HL, IY
74BB             7 790 ; ----------------------------------------------------------------------------------------------------------------------
74BB             7 791 PathFinder_SpeccyScore:
74BB 3A 99 61    7 792 ld      a, (AI_PLAYER)
74BE FE 02       7 793 cp      FRIEND                      ; if speccy is FRIEND, calculate CYAN score
74C0 28 40       7 794 jr      z, PathFinder_CyanScore
74C2             7 796 ; ----------------------------------------------------------------------------------------------------------------------
74C2             7 797 ; PathFinder_RedScore: calculate red score
74C2             7 798 ;
74C2             7 799 ; Input:    -
74C2             7 800 ;
74C2             7 801 ; Output:   A = DEFEAT, if red can't reach his opposite edge
74C2             7 802 ;           A = WIN_CONDITION, if cyan can't reach his opposite edge
74C2             7 803 ;           A = red heuristic evaluation, otherwise
74C2             7 804 ;
74C2             7 805 ; Uses:     POTENTIALS (board potential and attack mobility)
74C2             7 806 ;
74C2             7 807 ; Destroys: A', BC, DE, HL, IY
74C2             7 808 ; ----------------------------------------------------------------------------------------------------------------------
74C2             7 809 PathFinder_RedScore
74C2 CD F4 71    7 810 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
74C5 FE 43       7 811 cp      WIN_CONDITION
74C7 C8          7 812 ret     z                           ; if A = WIN_CONDITION, return A
74C8 08          7 813 ex      af, af'                     ; save first result
74C9 CD 36 72    7 814 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
74CC 47          7 815 ld      b, a                        ; save second result
74CD 08          7 816 ex      af, af'                     ; restore first result
74CE 80          7 817 add     a, b                        ; add both results
74CF FE FE       7 818 cp      -2                          ; are both DEFEAT?
74D1 78          7 819 ld      a, b
74D2 C8          7 820 ret     z                           ; yes, return A = DEFEAT
74D3 CD 80 71    7 822 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
74D6 08          7 823 ex      af, af'                     ; save result
74D7 CD BC 71    7 824 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
74DA 47          7 825 ld      b, a                        ; save second result
74DB 08          7 826 ex      af, af'                     ; restore first result
74DC 80          7 827 add     a, b                        ; add both results
74DD FE FE       7 828 cp      -2                          ; are both DEFEAT?
74DF 3E 43       7 829 ld      a, WIN_CONDITION
74E1 C8          7 830 ret     z                           ; yes, return A = WIN_CONDITION
74E2 21 09 64    7 832 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
74E5 11 51 64    7 833 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
74E8 CD 4E 75    7 834 call    PathFinder_Potentials       ; calculate RED potentials
74EB ED 43 97 61 7 835 ld      (POTENTIALS), bc            ; store RED potentials
74EF 21 09 61    7 837 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
74F2 11 51 61    7 838 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
74F5 CD 4E 75    7 839 call    PathFinder_Potentials       ; calculate cyan potentials
74F8 C3 38 75    7 840 jp      PathFinder_Evaluation       ; calculate heuristic evaluation
74FB             7 842 ; ----------------------------------------------------------------------------------------------------------------------
74FB             7 843 ; PathFinder_PlayerScore: calculate PLAYER score depending on speccy color
74FB             7 844 ;
74FB             7 845 ; Input:    -
74FB             7 846 ;
74FB             7 847 ; Output:   A = DEFEAT, if player can't reach his opposite edge
74FB             7 848 ;           A = WIN_CONDITION, if speccy can't reach his opposite edge
74FB             7 849 ;           A = player heuristic evaluation, otherwise
74FB             7 850 ;
74FB             7 851 ; Uses:     AI_PLAYER (speccy side)
74FB             7 852 ;
74FB             7 853 ; Destroys: A', BC, DE, HL
74FB             7 854 ; ----------------------------------------------------------------------------------------------------------------------
74FB             7 855 PathFinder_PlayerScore:
74FB 3A 99 61    7 856 ld      a, (AI_PLAYER)
74FE FE 02       7 857 cp      FRIEND                      ; if speccy is FRIEND, calculate RED score
7500 28 C0       7 858 jr      z, PathFinder_RedScore
7502             7 860 ; ----------------------------------------------------------------------------------------------------------------------
7502             7 861 ; PathFinder_CyanScore: calculate cyan score
7502             7 862 ;
7502             7 863 ; Input:    -
7502             7 864 ;
7502             7 865 ; Output:   A = DEFEAT, if cyan can't reach his opposite edge
7502             7 866 ;           A = WIN_CONDITION, if red can't reach his opposite edge
7502             7 867 ;           A = cyan heuristic evaluation, otherwise
7502             7 868 ;
7502             7 869 ; Uses:     POTENTIALS (board potential and attack mobility)
7502             7 870 ;
7502             7 871 ; Destroys: A', BC, DE, HL
7502             7 872 ; ----------------------------------------------------------------------------------------------------------------------
7502             7 873 PathFinder_CyanScore
7502 CD 80 71    7 874 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
7505 FE 43       7 875 cp      WIN_CONDITION
7507 C8          7 876 ret     z                           ; if A = WIN_CONDITION, return A
7508 08          7 877 ex      af, af'                     ; save result
7509 CD BC 71    7 878 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
750C 47          7 879 ld      b, a                        ; save second result
750D 08          7 880 ex      af, af'                     ; restore first result
750E 80          7 881 add     a, b                        ; add both results
750F FE FE       7 882 cp      -2                          ; are both DEFEAT?
7511 78          7 883 ld      a, b
7512 C8          7 884 ret     z                           ; if both are DEFEAT, return A = DEFEAT
7513 CD F4 71    7 886 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
7516 08          7 887 ex      af, af'                     ; save result
7517 CD 36 72    7 888 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
751A 47          7 889 ld      b, a                        ; save second result
751B 08          7 890 ex      af, af'                     ; restore first result
751C 80          7 891 add     a, b                        ; add both results
751D FE FE       7 892 cp      -2                          ; are both DEFEAT?
751F 3E 43       7 893 ld      a, WIN_CONDITION
7521 C8          7 894 ret     z                           ; if both are DEFEAT, return A = WIN_CONDITION
7522 21 09 61    7 896 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7525 11 51 61    7 897 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7528 CD 4E 75    7 898 call    PathFinder_Potentials       ; calculate cyan potentials
752B ED 43 97 61 7 899 ld      (POTENTIALS), bc            ; save cyan potentials
752F 21 09 64    7 901 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
7532 11 51 64    7 902 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
7535 CD 4E 75    7 903 call    PathFinder_Potentials       ; calculate red potentials
7538             7 904 ; ----------------------------------------------------------------------------------------------------------------------
7538             7 905 ; PathFinder_Evaluation: calculate heuristic evaluation.
7538             7 906 ; The original evaluation function (from cyan player perspective) is described in Jack van Rijswijck's thesis as:
7538             7 907 ;
7538             7 908 ;                                       e = M (pC - pR) - (aC - aR)
7538             7 909 ; where:
7538             7 910 ;   pC = cyan board potential
7538             7 911 ;   pR = red board potential
7538             7 912 ;   aC = cyan attack mobility
7538             7 913 ;   aR = red attack mobility
7538             7 914 ;    M = a large number
7538             7 915 ;
7538             7 916 ; This adaptation uses an "invert" result to better fit BRAINIAC process.
7538             7 917 ;
7538             7 918 ; Input:    B = opponent attack mobility
7538             7 919 ;           C = opponent board potential
7538             7 920 ;
7538             7 921 ; Output:   A = heuristic evaluation
7538             7 922 ;
7538             7 923 ; Destroys: E, HL
7538             7 924 ; ----------------------------------------------------------------------------------------------------------------------
7538             7 925 PathFinder_Evaluation:
7538 21 98 61    7 926 ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
753B 78          7 927 ld      a, b                        ; get opponent's attack mobility
753C 96          7 928 sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
753D 5F          7 929 ld      e, a                        ; save the result in E
753E 2D          7 930 dec     l                           ; move HL to player's board potential address
753F 79          7 931 ld      a, c                        ; get opponent's board potential
7540 96          7 932 sub     (hl)                        ; subtract potentials -> (pC - pR)
7541 87          7 933 add     a, a                        ; multiply by 8 -> M (pC - pR)
7542 87          7 934 add     a, a
7543 87          7 935 add     a, a
7544 93          7 936 sub     e                           ; subtract result of attack mobilities subtraction
7545             7 937 ; -> M (pC - pR) - (aC - aR)
7545 EE 80       7 938 xor     $80                         ; invert sign for easier further comparative
7547 C9          7 939 ret                                 ; return A = -1 (M (pC - pR) - (aC - aR))
7548             7 941 ; ----------------------------------------------------------------------------------------------------------------------
7548             7 942 ; PathFinder_TotalPotentials: set up 'PathFinder_Potentials' routine for Total potentials
7548             7 943 ;
7548             7 944 ; Input:    -
7548             7 945 ;
7548             7 946 ; Output:   B = total attack mobility
7548             7 947 ;           C = total board potential
7548             7 948 ;
7548             7 949 ; Destroys: A, DE, HL
7548             7 950 ; ----------------------------------------------------------------------------------------------------------------------
7548             7 951 PathFinder_TotalPotentials:
7548 21 09 61    7 952 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
754B 11 09 64    7 953 ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
754E             7 954 ; ----------------------------------------------------------------------------------------------------------------------
754E             7 955 ; PathFinder_Potentials: calculate board potential and attack mobility
754E             7 956 ;
754E             7 957 ; * A cells Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
754E             7 958 ;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
754E             7 959 ;   the board.
754E             7 960 ; * The attack mobility is defined for each player as the number of cells that realize that players board potential.
754E             7 961 ;
754E             7 962 ; Input:    HL = cyan board or red board address
754E             7 963 ;           DE = cyan board or red board address
754E             7 964 ;
754E             7 965 ; Output:   B = attack mobility
754E             7 966 ;           C = board potential
754E             7 967 ;
754E             7 968 ; Destroys: A, DE, HL, IYL
754E             7 969 ; ----------------------------------------------------------------------------------------------------------------------
754E             7 970 PathFinder_Potentials:
754E 01 FF 00    7 971 ld      bc, $00FF                   ; initialize attack mobility and board potential
7551 FD 2E 3D    7 972 ld      iyl, 61                     ; number of cells to be checked (loop counter)
7554             7 973 Potentials_Loop
7554 7E          7 974 ld      a, (hl)                     ; get cell's two-distance pointed by HL
7555 FE 40       7 975 cp      $40                         ; if (friendly or edge or border)
7557 30 18       7 976 jr      nc, Potentials_Next         ;       skip to next cell 
7559 FE 04       7 977 cp      $04                         ; if (cell distance was not updated)
755B 30 02       7 978 jr      nc, Opponent_TwoDistance    ; {
755D 36 30       7 979 ld      (hl), INFINITE              ;       set cell potential as "infinite"
755F             7 980 Opponent_TwoDistance                                        ; }
755F 1A          7 981 ld      a, (de)                     ; get cell's two-distance pointed by DE
7560 FE 04       7 982 cp      $04                         ; if (cell distance was not updated)
7562 30 02       7 983 jr      nc, Sum_TwoDistances        ; {
7564 3E 30       7 984 ld      a, INFINITE                 ;       set cell potential as "infinite"
7566             7 985 Sum_TwoDistances                                            ; }
7566 86          7 986 add     a, (hl)                     ; sum both two-distances (calculate cell potential)
7567 77          7 987 ld      (hl), a                     ; save potential in the cell pointed by HL
7568 B9          7 988 cp      c                           ; is the new potential >= board potential?
7569 30 03       7 989 jr      nc, Increment_Mobility      ; yes, check attack mobility
756B 4F          7 990 ld      c, a                        ; no, board potential = new potential
756C 06 01       7 991 ld      b, 1                        ; restart attack mobility
756E             7 992 Increment_Mobility
756E 20 01       7 993 jr      nz, Potentials_Next         ; if (potential <> last potential) skip to next cell
7570 04          7 994 inc     b                           ; else, increment attack mobility
7571             7 995 Potentials_Next
7571 1C          7 996 inc     e                           ; move to next cells of each board
7572 2C          7 997 inc     l
7573 FD 2D       7 998 dec     iyl                         ; decrement loop counter
7575 C2 54 75    7 999 jp      nz, Potentials_Loop         ; repeat until end of boards
7578 C9          7 1000 ret
7579             7 1002 ; ----------------------------------------------------------------------------------------------------------------------
7579             7 1003 ; PathFinder_Candidates: search candidates based on color score result and boards potentials
7579             7 1004 ;
7579             7 1005 ; Input:    A  = DEFEAT or heuristic result
7579             7 1006 ;           IX = candidates area address
7579             7 1007 ;
7579             7 1008 ; Output:   IX = first candidate address
7579             7 1009 ;
7579             7 1010 ; Uses:     AI_PLAYER (speccy side)
7579             7 1011 ;
7579             7 1012 ; Destroys: A, A', BC, DE, HL
7579             7 1013 ; ----------------------------------------------------------------------------------------------------------------------
7579             7 1014 PathFinder_Candidates:
7579 3C          7 1015 inc     a                           ; A = DEFEAT?
757A 28 09       7 1016 jr      z, Defeat_Candidates        ; yes, process candidates for defeated color
757C CD 48 75    7 1018 call    PathFinder_TotalPotentials  ; no, process candidates from total potentials
757F 21 09 61    7 1019 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7582 C3 B3 75    7 1020 jp      PathFinder_FillCandidates   ; fill candidates vector
7585             7 1022 ; process candidates for defeated color
7585             7 1023 Defeat_Candidates
7585 3A 99 61    7 1024 ld      a, (AI_PLAYER)
7588 FE 02       7 1025 cp      FRIEND                      ; friend score has been processed?
758A 28 15       7 1026 jr      z, Cyan_Defeat_Candidates   ; yes, process candidates for cyan
758C             7 1028 ; if RED is defeated, candidates are chosen from cyan board potentials
758C CD 80 71    7 1030 call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
758F CD BC 71    7 1031 call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
7592             7 1033 ; entry point for BRAINIAC_best_move
7592             7 1034 PathFinder_CyanCandidates:
7592 21 09 61    7 1035 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
7595 11 51 61    7 1036 ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
7598 CD 4E 75    7 1037 call    PathFinder_Potentials       ; calculate cyan potentials
759B 21 09 61    7 1039 ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board potentials address (1st position)
759E C3 B3 75    7 1040 jp      PathFinder_FillCandidates   ; fill candidates vector
75A1             7 1042 ; if CYAN is defeated, candidates are chosen from red board potentials
75A1             7 1043 Cyan_Defeat_Candidates
75A1 CD F4 71    7 1044 call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
75A4 CD 36 72    7 1045 call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
75A7             7 1047 ; entry point for BRAINIAC_best_move
75A7             7 1048 PathFinder_RedCandidates:
75A7 21 09 64    7 1049 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
75AA 11 51 64    7 1050 ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
75AD CD 4E 75    7 1051 call    PathFinder_Potentials       ; calculate red potentials
75B0 21 09 64    7 1053 ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board potentials address (1st position)
75B3             7 1054 ; ----------------------------------------------------------------------------------------------------------------------
75B3             7 1055 ; Fill CANDIDATES vector with second and best candidates from calculated potentials
75B3             7 1056 ;
75B3             7 1057 ; Input:    B  = attack mobility
75B3             7 1058 ;           C  = board potential
75B3             7 1059 ;           HL = cyan or red board address (with calculated potentials) 
75B3             7 1060 ;           IX = candidates area address
75B3             7 1061 ;
75B3             7 1062 ; Output:   IX = first candidate address
75B3             7 1063 ;
75B3             7 1064 ; Destroys: A, A', HL, BC, DE
75B3             7 1065 ; ----------------------------------------------------------------------------------------------------------------------
75B3             7 1066 PathFinder_FillCandidates
75B3 DD 36 00 00 7 1067 ld      (ix+0), 0                   ; set candidates endmarker
75B7 DD 5D       7 1068 ld      e, ixl                      ; store candidates position in E
75B9 50          7 1069 ld      d, b                        ; store attack mobility in D
75BA 79          7 1070 ld      a, c                        ; store board potential in A'
75BB 08          7 1071 ex      af, af'
75BC             7 1073 ; insert the second best board potentials in candidates vector
75BC             7 1075 Search_Second_Best
75BC 2E 09       7 1076 ld      l, 9                        ; HL points to board potentials address (1st position)
75BE 0C          7 1077 inc     c                           ; increment board potential
75BF 79          7 1078 ld      a, c                        ; A = second best board potential
75C0 06 3D       7 1079 ld      b, 61                       ; number of cells to be checked (loop counter)
75C2             7 1080 Second_Best_Loop
75C2 BE          7 1081 cp      (hl)                        ; is current board potential = 2nd best board potential?
75C3 C2 CB 75    7 1082 jp      nz, Second_Best_Next        ; no, skip to next potential
75C6 DD 2C       7 1083 inc     ixl                         ; yes, insert candidate
75C8 DD 75 00    7 1084 ld      (ix+0), l
75CB             7 1085 Second_Best_Next
75CB 2C          7 1086 inc     l                           ; move HL to next board potential address
75CC 10 F4       7 1087 djnz    Second_Best_Loop            ; repeat for each cell
75CE DD 7D       7 1088 ld      a, ixl                      ; A = current candidates position
75D0 BB          7 1089 cp      e                           ; new candidates inserted?
75D1 28 E9       7 1090 jr      z, Search_Second_Best       ; no, repeat until new candidates inserted
75D3             7 1092 ; insert the best board potentials in candidates vector
75D3 2E 08       7 1094 ld      l, 8                        ; HL points to board potential address (1st position -1)
75D5 42          7 1095 ld      b, d                        ; restore attack mobility (loop counter)
75D6 08          7 1096 ex      af, af'                     ; restore board potential
75D7             7 1097 Best_Candidate_Loop
75D7 2C          7 1098 inc     l                           ; move HL to next board potential address
75D8 BE          7 1099 cp      (hl)                        ; is current board potential equal to best board potential?
75D9 C2 D7 75    7 1100 jp      nz, Best_Candidate_Loop     ; no, next potential
75DC DD 2C       7 1101 inc     ixl                         ; yes, insert candidate
75DE DD 75 00    7 1102 ld      (ix+0), l
75E1 10 F4       7 1103 djnz    Best_Candidate_Loop         ; repeat for each cell
75E3 C9          7 1104 ret
75E4             7 1106 ; ----------------------------------------------------------------------------------------------------------------------
75E4             7 1107 ; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
75E4             7 1108 ;
75E4             7 1109 ; Input:    B = current position
75E4             7 1110 ;
75E4             7 1111 ; Output:   -
75E4             7 1112 ;
75E4             7 1113 ; Uses:     TOKEN_COLOR (current token color)
75E4             7 1114 ;
75E4             7 1115 ; Destroys: A, BC, DE, HL, IY
75E4             7 1116 ; ----------------------------------------------------------------------------------------------------------------------
75E4             7 1117 PathFinder_BrightPath:
75E4 C5          7 1118 push    bc                          ; store current position
75E5 3A 9E 61    7 1120 ld      a, (TOKEN_COLOR)            ; get current player color
75E8 F5          7 1121 push    af                          ; store current player color
75E9 FE 05       7 1122 cp      CYAN_COLOR                  ; check current token color
75EB 28 0B       7 1123 jr      z, BrightPath_Cyan          ; prepare board if it is cyan
75ED 21 45 64    7 1125 ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
75F0 CD 44 76    7 1126 call    PathFinder_PrepareBoard     ; prepare RED board 
75F3 CD FD 71    7 1127 call    PathFinder_Red_BrightPath   ; find RED victory path
75F6 18 09       7 1128 jr      BrightPath_Start            ; start bright path
75F8             7 1129 BrightPath_Cyan
75F8 21 45 61    7 1130 ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
75FB CD 44 76    7 1131 call    PathFinder_PrepareBoard     ; prepare CYAN board
75FE CD 89 71    7 1132 call    PathFinder_Cyan_BrightPath  ; find CYAN victory path
7601             7 1133 BrightPath_Start
7601 F1          7 1134 pop     af                          ; restore current player color
7602 C6 40       7 1135 add     a, $40                      ; apply bright attribute
7604 32 9E 61    7 1136 ld      (TOKEN_COLOR), a            ; save color
7607 C1          7 1138 pop     bc                          ; restore current position
7608 24          7 1140 inc     h
7609 68          7 1141 ld      l, b                        ; HL points to the start position of the victory path
760A 4E          7 1142 ld      c, (hl)                     ; set victory path length in C
760B 18 1E       7 1143 jr      BrightPath_Position         ; animate and highlight the hexagon position
760D             7 1144 BrightPath_Neighbor
760D 2C          7 1145 inc     l                           ; move HL to left neighbor address
760E BE          7 1146 cp      (hl)                        ; is it the same as victory path length?
760F 28 1A       7 1147 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7611 2D          7 1148 dec     l
7612 2D          7 1149 dec     l                           ; right neighbor
7613 BE          7 1150 cp      (hl)                        ; is it the same as victory path length?
7614 28 15       7 1151 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7616 7D          7 1152 ld      a, l
7617 D6 08       7 1153 sub     WIDTH
7619 6F          7 1154 ld      l, a                        ; move HL to upper-right neighbor address
761A 79          7 1155 ld      a, c                        ; restore victory path length in A
761B BE          7 1156 cp      (hl)                        ; is it the same as victory path length?
761C 28 0D       7 1157 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
761E 2C          7 1158 inc     l                           ; upper-left neighbor
761F BE          7 1159 cp      (hl)                        ; is it the same as victory path length?
7620 28 09       7 1160 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
7622 7D          7 1161 ld      a, l
7623 C6 10       7 1162 add     a, WIDTH*2
7625 6F          7 1163 ld      l, a                        ; move HL to lower-right neighbor address
7626 79          7 1164 ld      a, c                        ; restore victory path length in A
7627 BE          7 1165 cp      (hl)                        ; is it the same as victory path length?
7628 28 01       7 1166 jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
762A 2C          7 1167 inc     l                           ; move HL to lower-left neighbor address
762B             7 1168 BrightPath_Position
762B C5          7 1169 push    bc                          ; store victory path length
762C E5          7 1170 push    hl                          ; store current position pointer
762D CD 85 6D    7 1171 call    Main_Board2Indexes          ; convert a board position into a board indexes
7630 CD C0 6D    7 1172 call    Draw_Token                  ; draw token
7633 E1          7 1173 pop     hl                          ; restore current position pointer
7634 C1          7 1174 pop     bc                          ; restore victory path length
7635 0D          7 1175 dec     c                           ; decrement victory path length
7636 79          7 1176 ld      a, c                        ; set victory path length in A
7637 FE 03       7 1177 cp      VICTORY                     ; has reached victory path length?
7639 20 D2       7 1178 jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach VICTORY length
763B 3A 9E 61    7 1180 ld      a, (TOKEN_COLOR)            ; restore token color
763E D6 40       7 1181 sub     $40
7640 32 9E 61    7 1182 ld      (TOKEN_COLOR), a
7643 C9          7 1183 ret
7644             7 1185 ; ----------------------------------------------------------------------------------------------------------------------
7644             7 1186 ; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing WIN_CONDITION to 1, everything else to ENEMY.
7644             7 1187 ; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
7644             7 1188 ; [color]' again to find a victory path.
7644             7 1189 ;
7644             7 1190 ; Coded by Einar Saukas
7644             7 1191 ;
7644             7 1192 ; Input:    HL = pointer to last position of [color]_BOARD
7644             7 1193 ;
7644             7 1194 ; Output:   -
7644             7 1195 ;
7644             7 1196 ; Destroys: A, BC, HL
7644             7 1197 ; ----------------------------------------------------------------------------------------------------------------------
7644             7 1198 PathFinder_PrepareBoard:
7644 3E 43       7 1199 ld      a, WIN_CONDITION
7646 0E 07       7 1200 ld      c, 7                        ; 7 rows
7648             7 1201 PrepareBoard_Row
7648 06 07       7 1202 ld      b, 7                        ; 7 columns
764A             7 1203 PrepareBoard_Column
764A BE          7 1204 cp      (hl)                        ; is it win condition?
764B 36 01       7 1205 ld      (hl), 1                     ; save 1 by default
764D 28 02       7 1206 jr      z, PrepareBoard_Next        ; yes, next position
764F 36 7E       7 1207 ld      (hl), ENEMY                 ; no, save ENEMY
7651             7 1208 PrepareBoard_Next
7651 2D          7 1209 dec     l                           ; HL points to next board position
7652 10 F6       7 1210 djnz    PrepareBoard_Column         ; repeat for each column
7654 2D          7 1212 dec     l                           ; skip borders
7655 2D          7 1213 dec     l
7656 0D          7 1214 dec     c                           ; decrement rows
7657 20 EF       7 1215 jr      nz, PrepareBoard_Row        ; repeat for each row
7659 C9          7 1216 ret

; File #8: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Timer.z80asm

765A             8 1 ; ----------------------------------------------------------------------------------------------------------------------
765A             8 2 ; Timer.z80asm
765A             8 3 ; Coded by Antonio Luque
765A             8 4 ;
765A             8 5 ; Based on disassembly of "Chess" (c) 1982 Psion
765A             8 6 ; ----------------------------------------------------------------------------------------------------------------------
765A             8 8 ; ----------------------------------------------------------------------------------------------------------------------
765A             8 9 ; Timer_Interrupt: interrupt routine to manage players' timers
765A             8 10 ;
765A             8 11 ; Input:    -
765A             8 12 ;
765A             8 13 ; Output:   -
765A             8 14 ;
765A             8 15 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
765A             8 16 ;
765A             8 17 ; Destroys: BC', DE', HL'
765A             8 18 ; ----------------------------------------------------------------------------------------------------------------------
765A             8 19 Timer_Interrupt:
765A F5          8 20 push    af                          ; store AF register
765B D9          8 21 exx                                 ; store BC, DE and HL registers
765C 3A E9 62    8 22 ld      a, (TIMER_FLAG)             ; check timer flag
765F B7          8 23 or      a                           ; is timer stopped?
7660 CA 89 76    8 24 jp      z, Timer_Exit               ; yes, exit routine
7663 21 ED 62    8 25 ld      hl, RED_TIMER               ; HL points to red's interrupt counter address
7666 3D          8 26 dec     a                           ; is red timer on?
7667 C2 6D 76    8 27 jp      nz, Timer_Counters          ; yes, check interrupt counter 
766A 21 EA 62    8 28 ld      hl, CYAN_TIMER              ; HL points to cyan's interrupt counter address
766D             8 29 Timer_Counters
766D 35          8 30 dec     (hl)                        ; decrement interrupt counter
766E C2 89 76    8 31 jp      nz, Timer_Exit              ; if not 0, exit routine
7671 36 32       8 32 ld      (hl), 50                    ; restart interrupt counter
7673 23          8 33 inc     hl                          ; move HL to seconds counter address
7674 3E 01       8 34 ld      a, 1                        ; increment seconds counter
7676 86          8 35 add     a, (hl)
7677 27          8 36 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7678 77          8 37 ld      (hl), a                     ; store seconds
7679 FE 60       8 38 cp      $60                         ; 60 seconds reached?
767B C2 86 76    8 39 jp      nz, Timer_Show              ; no, show timer
767E 36 00       8 40 ld      (hl), 0                     ; restart seconds counter
7680 23          8 41 inc     hl                          ; move HL to minutes counter address
7681 3E 01       8 42 ld      a, 1                        ; increment minutes counter
7683 86          8 43 add     a, (hl)
7684 27          8 44 daa                                 ; convert to BCD (Binary-Coded-Decimal)
7685 77          8 45 ld      (hl), a                     ; store minutes
7686             8 46 Timer_Show
7686 CD 8D 76    8 47 call    Timer_Display               ; display timer on the screen
7689             8 48 Timer_Exit
7689 D9          8 49 exx                                 ; restore BC, DE and HL registers
768A F1          8 50 pop     af                          ; restore AF register
768B FB          8 51 ei                                  ; enable interrupts
768C C9          8 52 ret
768D             8 54 ; ----------------------------------------------------------------------------------------------------------------------
768D             8 55 ; Timer_Display: display a timer on the screen
768D             8 56 ;
768D             8 57 ; Input:    -
768D             8 58 ;
768D             8 59 ; Output:   -
768D             8 60 ;
768D             8 61 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
768D             8 62 ;
768D             8 63 ; Destroys: A, BC, DE, HL
768D             8 64 ; ----------------------------------------------------------------------------------------------------------------------
768D             8 65 Timer_Display:
768D 11 EF 62    8 66 ld      de, RED_TIMER+2             ; DE points to red's minutes counter address
7690 01 E2 48    8 67 ld      bc, $48E2                   ; BC points to red's minutes screen address
7693 3A E9 62    8 68 ld      a, (TIMER_FLAG)             ; check timer flag
7696 3D          8 69 dec     a                           ; is cyan timer on?
7697 C2 A0 76    8 70 jp      nz, Timer_Display_Min       ; no, jump to display minutes counter
769A 11 EC 62    8 71 ld      de, CYAN_TIMER+2            ; DE points to cyan's minutes counter address
769D 01 78 40    8 72 ld      bc, $4078                   ; BC points to cyan's minutes screen address
76A0             8 73 Timer_Display_Min
76A0 CD A5 76    8 74 call    Timer_Display_MinSec        ; display minutes counter on screen
76A3 1B          8 75 dec     de                          ; DE points to seconds counter address
76A4 0C          8 76 inc     c                           ; BC points to seconds screen address
76A5             8 77 Timer_Display_MinSec:
76A5 1A          8 78 ld      a, (de)                     ; set min/sec counter in A
76A6 1F          8 79 rra                                 ; move tens digit to the first 4th bits of A
76A7 1F          8 80 rra
76A8 1F          8 81 rra
76A9 1F          8 82 rra
76AA CD AE 76    8 83 call    Timer_Display_Digit         ; display tens digit on screen
76AD 1A          8 84 ld      a, (de)                     ; set min/sec counter in A 
76AE             8 85 Timer_Display_Digit:
76AE E6 0F       8 86 and     %00001111                   ; discard the last 4th bits of the digit
76B0 C5          8 87 push    bc                          ; store digit screen address
76B1 21 97 64    8 88 ld      hl, TIMER_DIGITS            ; HL points to timer digits (graphics) address
76B4 87          8 89 add     a, a                        ; a digit is 8 bytes long
76B5 87          8 90 add     a, a
76B6 87          8 91 add     a, a
76B7 85          8 92 add     a, l                        ; set digit index in HL
76B8 6F          8 93 ld      l, a
76B9 7E          8 94 ld      a, (hl)                     ; get digit tile
76BA 02          8 95 ld      (bc), a                     ; put it on screen address
76BB 04          8 96 inc     b                           ; move BC to next pixel-line address
76BC 2C          8 97 inc     l                           ; move HL to next digit tile address
76BD 7E          8 98 ld      a, (hl)                     ; (repeat 7 more times)
76BE 02          8 99 ld      (bc), a
76BF 04          8 100 inc     b
76C0 2C          8 101 inc     l
76C1 7E          8 102 ld      a, (hl)
76C2 02          8 103 ld      (bc), a
76C3 04          8 104 inc     b
76C4 2C          8 105 inc     l
76C5 7E          8 106 ld      a, (hl)
76C6 02          8 107 ld      (bc), a
76C7 04          8 108 inc     b
76C8 2C          8 109 inc     l
76C9 7E          8 110 ld      a, (hl)
76CA 02          8 111 ld      (bc), a
76CB 04          8 112 inc     b
76CC 2C          8 113 inc     l
76CD 7E          8 114 ld      a, (hl)
76CE 02          8 115 ld      (bc), a
76CF 04          8 116 inc     b
76D0 2C          8 117 inc     l
76D1 7E          8 118 ld      a, (hl)
76D2 02          8 119 ld      (bc), a
76D3 04          8 120 inc     b
76D4 2C          8 121 inc     l
76D5 7E          8 122 ld      a, (hl)
76D6 02          8 123 ld      (bc), a
76D7 C1          8 124 pop     bc                          ; restore digit screen address
76D8 0C          8 125 inc     c                           ; move screen address to next column
76D9 C9          8 126 ret
76DA             8 128 ; ----------------------------------------------------------------------------------------------------------------------
76DA             8 129 ; Timer_Display_All: display cyan and red timers
76DA             8 130 ;
76DA             8 131 ; Input:    -
76DA             8 132 ;
76DA             8 133 ; Output:   -
76DA             8 134 ;
76DA             8 135 ; Uses:     TIMER_FLAG (0 = timer stopped, 1 = cyan timer on, 2 = red timer on)
76DA             8 136 ;
76DA             8 137 ; Destroys: BC, DE, HL
76DA             8 138 ; ----------------------------------------------------------------------------------------------------------------------
76DA             8 139 Timer_Display_All:
76DA 3E 01       8 140 ld      a, 1                        ; set cyan timer on
76DC 32 E9 62    8 141 ld      (TIMER_FLAG), a
76DF CD 8D 76    8 142 call    Timer_Display               ; display cyan timer
76E2 3E 02       8 143 ld      a, 2                        ; set red timer on
76E4 32 E9 62    8 144 ld      (TIMER_FLAG), a
76E7 CD 8D 76    8 145 call    Timer_Display               ; display red timer
76EA AF          8 146 xor     a                           ; stop timers
76EB 32 E9 62    8 147 ld      (TIMER_FLAG), a
76EE C9          8 148 ret
76EF             8 150 ; ----------------------------------------------------------------------------------------------------------------------
76EF             8 151 ; Timer_Reset: initialize cyan and red timers
76EF             8 152 ;
76EF             8 153 ; Input:    -
76EF             8 154 ;
76EF             8 155 ; Output:   -
76EF             8 156 ;
76EF             8 157 ; Destroys: HL
76EF             8 158 ; ----------------------------------------------------------------------------------------------------------------------
76EF             8 159 Timer_Reset:
76EF 21 EA 62    8 160 ld      hl, CYAN_TIMER              ; HL points to cyan timer address
76F2 36 32       8 161 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76F4 23          8 162 inc     hl                          ; move HL to cyan's seconds counter address
76F5 36 00       8 163 ld      (hl), 0                     ; reset seconds counter
76F7 23          8 164 inc     hl                          ; move HL to cyan's minutes counter address
76F8 36 00       8 165 ld      (hl), 0                     ; reset minutes counter
76FA 23          8 166 inc     hl                          ; move HL to red's interrupt counter
76FB 36 32       8 167 ld      (hl), 50                    ; set interrupt counter (1/50 seconds)
76FD 23          8 168 inc     hl                          ; move HL to red's seconds counter address
76FE 36 00       8 169 ld      (hl), 0                     ; reset seconds counter
7700 23          8 170 inc     hl                          ; move HL to red's minutes counter address
7701 36 00       8 171 ld      (hl), 0                     ; reset minutes counter
7703 C9          8 172 ret

; File #9: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Sound.z80asm

7704             9 1 ; ----------------------------------------------------------------------------------------------------------------------
7704             9 2 ; Sound.z80asm
7704             9 3 ; Coded with BeepFX player tool by Shiru: https://opengameart.org/content/zx-spectrum-beeper-sound-effects
7704             9 4 ;
7704             9 5 ; Adapted for Hex game by Antonio Luque
7704             9 6 ; ----------------------------------------------------------------------------------------------------------------------
7704             9 8 ; ----------------------------------------------------------------------------------------------------------------------
7704             9 9 ; Sound_FX: play a sound effect (tone) defined by many parameters
7704             9 10 ; 
7704             9 11 ; Input:    IX = tone parameters address
7704             9 12 ;
7704             9 13 ; Output:   -
7704             9 14 ;
7704             9 15 ; Destroys: A, BC, DE, HL, IY
7704             9 16 ; ----------------------------------------------------------------------------------------------------------------------
7704             9 17 Sound_FX:
7704 F3          9 18 di                                  ; disable interrupts
7705 DD 4E 00    9 19 ld      c, (ix+0)                   ; BC = frames
7708 DD 46 01    9 20 ld      b, (ix+1)
770B DD 5E 02    9 21 ld      e, (ix+2)                   ; DE = frame length
770E DD 56 03    9 22 ld      d, (ix+3)
7711 D5          9 23 push    de                          ; (simulate 'ld iy,de')
7712 FD E1       9 24 pop     iy                          ; store frame length in IY
7714 DD 5E 04    9 25 ld      e, (ix+4)                   ; DE = pitch
7717 DD 56 05    9 26 ld      d, (ix+5)
771A 21 00 00    9 27 ld      hl, 0                       ; reset HL
771D             9 28 Sound_FX_Frames
771D C5          9 29 push    bc                          ; store frames
771E FD E5       9 30 push    iy                          ; (simulate 'ld bc,iy')
7720 C1          9 31 pop     bc                          ; restore frame length in BC
7721             9 32 Sound_FX_FrameLength
7721 19          9 33 add     hl, de                      ; HL = incremented pitch
7722 7C          9 34 ld      a, h                        ; set high-byte in A
7723 FE 80       9 35 cp      128                         ; compares with duty cycle, the timbre of the tone
7725             9 36 ; (128 for 50% square wave)
7725 9F          9 37 sbc     a, a                        ; subtract with carry
7726 E6 10       9 38 and     16                          ; mask result
7728 D3 FE       9 39 out     (254), a                    ; play sound
772A 0B          9 40 dec     bc                          ; decrement frame length
772B 78          9 41 ld      a, b
772C B1          9 42 or      c                           ; frame length = 0?
772D 20 F2       9 43 jr      nz, Sound_FX_FrameLength    ; no, repeat "frame length" times
772F DD 4E 06    9 44 ld      c, (ix+6)                   ; BC = pitch slide
7732 DD 46 07    9 45 ld      b, (ix+7)
7735 EB          9 46 ex      de, hl                      ; HL = pitch
7736 09          9 47 add     hl, bc                      ; add pitch slide
7737 EB          9 48 ex      de, hl                      ; DE = incremented pitch
7738 C1          9 49 pop     bc                          ; restore frames
7739 0B          9 50 dec     bc                          ; decrement frames
773A 78          9 51 ld      a, b
773B B1          9 52 or      c                           ; frames = 0?
773C 20 DF       9 53 jr      nz, Sound_FX_Frames         ; no, repeat "frames" times
773E FB          9 54 ei                                  ; enable interrupts
773F C9          9 55 ret

; File #10: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Screen.z80asm

7740             10 1 ; ----------------------------------------------------------------------------------------------------------------------
7740             10 2 ; Screen.z80asm
7740             10 3 ; Coded by Antonio Luque
7740             10 4 ; ----------------------------------------------------------------------------------------------------------------------
7740             10 6 BLUE_INK                equ     %00000001                   ; attributes: flash 0, bright 0, paper 0, ink 1
7740             10 7 BLUE_PAPER              equ     %00001000                   ; attributes: flash 0, bright 0, paper 1, ink 0
7740             10 8 WHITE_PAPER             equ     %00111000                   ; attributes: flash 0, bright 0, paper 7, ink 0
7740             10 9 WHITE                   equ     %00000111                   ; attributes: flash 0, bright 0, paper 0, ink 7
7740             10 10 BRIGHT                  equ     %01000000                   ; mask to apply bright to attributes
7740             10 11 FLASH                   equ     %10000000                   ; mask to apply flash to attributes
7740             10 12 WHITE_FLASH0            equ     WHITE+BRIGHT                ; attributes: flash 0, bright 1, paper 0, ink 7
7740             10 13 WHITE_FLASH1            equ     WHITE+BRIGHT+FLASH          ; attributes: flash 1, bright 1, paper 0, ink 7
7740             10 15 ; ----------------------------------------------------------------------------------------------------------------------
7740             10 16 ; Screen_Clear: fill in black the whole screen area and attributes area
7740             10 17 ;
7740             10 18 ; Input:    -
7740             10 19 ;
7740             10 20 ; Output:   -
7740             10 21 ;
7740             10 22 ; Destroys: BC, DE, HL
7740             10 23 ; ----------------------------------------------------------------------------------------------------------------------
7740             10 24 Screen_Clear:
7740 21 00 40    10 25 ld      hl, $4000                   ; HL points to start of the screen address
7743 11 01 40    10 26 ld      de, $4001                   ; DE points to next byte of the screen address
7746 36 00       10 27 ld      (hl), 0                     ; set first pixel-byte in black
7748 01 FF 1A    10 28 ld      bc, 6144-1+768              ; length of screen area (-1 already set) + attributes area 
774B ED B0       10 29 ldir                                ; fill the rest of screen area and attributes area in black
774D C9          10 30 ret
774E             10 32 ; ----------------------------------------------------------------------------------------------------------------------
774E             10 33 ; Screen_Letters: draw the two rows of letters on the screen (a..g)
774E             10 34 ;
774E             10 35 ; Input:    -
774E             10 36 ;
774E             10 37 ; Output:   -
774E             10 38 ;
774E             10 39 ; Destroys: A, BC, DE, HL, IX
774E             10 40 ; ----------------------------------------------------------------------------------------------------------------------
774E             10 41 Screen_Letters:
774E 21 66 45    10 42 ld      hl, $4566                   ; HL points to first letter screen address (top row)
7751 DD 21 66 58 10 43 ld      ix, $5866                   ; IX points to first letter attribute address (top row)
7755 CD 5F 77    10 44 call    Screen_Letters_Row          ; draw top row of letters
7758 21 6D 51    10 45 ld      hl, $516D                   ; HL points to first letter screen address (bottom row)
775B DD 21 6D 5A 10 46 ld      ix, $5A6D                   ; IX points to first letter attribute address (bottom row)
775F             10 47 Screen_Letters_Row:
775F 11 5E 66    10 48 ld      de, LETTER_SPRITES          ; DE points to letter sprites address
7762 06 07       10 49 ld      b, 7                        ; number of letters (loop counter)
7764             10 50 Screen_Letter_Loop
7764 E5          10 51 push    hl                          ; store letter screen address
7765 CD 0A 6E    10 52 call    Draw_Sprite_LetterNum       ; draw letter at screen address
7768 E1          10 53 pop     hl                          ; restore letter screen address
7769 2C          10 54 inc     l                           ; move HL to next screen address
776A 2C          10 55 inc     l
776B DD 36 00 05 10 56 ld      (ix+0), CYAN_COLOR          ; set letter color (2 bytes)
776F DD 36 20 05 10 57 ld      (ix+32), CYAN_COLOR
7773 DD 2C       10 58 inc     ixl                         ; move IX to next attribute address
7775 DD 2C       10 59 inc     ixl
7777 10 EB       10 60 djnz    Screen_Letter_Loop          ; repeat for each letter
7779 C9          10 61 ret
777A             10 63 ; ----------------------------------------------------------------------------------------------------------------------
777A             10 64 ; Screen_Numbers: draw the two columns of numbers on the screen (1-7)
777A             10 65 ;
777A             10 66 ; Input:    -
777A             10 67 ;
777A             10 68 ; Output:   -
777A             10 69 ;
777A             10 70 ; Destroys: A, BC, DE, HL, IX, IY
777A             10 71 ; ----------------------------------------------------------------------------------------------------------------------
777A             10 72 Screen_Numbers:
777A 11 A4 66    10 73 ld      de, NUMBER_SPRITES          ; DE points to numbers sprites
777D FD 21 F0 62 10 74 ld      iy, NUMBER_SCREEN           ; IY points to numbers screen addresses
7781 DD 21 A5 58 10 75 ld      ix, $58A5                   ; IX points to first number attribute address
7785 06 07       10 76 ld      b, 7                        ; number of numbers (loop counter)
7787             10 77 Screen_Number_Loop
7787 FD 6E 00    10 78 ld      l, (iy+0)                   ; HL points to number screen address
778A FD 66 01    10 79 ld      h, (iy+1)
778D E5          10 80 push    hl                          ; store pointer to number screen address
778E D5          10 81 push    de                          ; store pointer to sprite address
778F CD 0A 6E    10 82 call    Draw_Sprite_LetterNum       ; draw number at screen address
7792 D1          10 83 pop     de                          ; restore pointer to sprite address
7793 E1          10 84 pop     hl                          ; restore pointer to number screen address
7794 DD 36 00 02 10 85 ld      (ix+0), RED_COLOR           ; set number color (2 bytes)
7798 DD 36 20 02 10 86 ld      (ix+32), RED_COLOR
779C 7D          10 87 ld      a, l                        ; move HL to screen address of the 2nd column
779D C6 0F       10 88 add     a, 15
779F 6F          10 89 ld      l, a
77A0 CD 0A 6E    10 90 call    Draw_Sprite_LetterNum       ; draw number at screen address
77A3 DD 36 0F 02 10 91 ld      (ix+15), RED_COLOR          ; set number color (2 bytes)
77A7 DD 36 2F 02 10 92 ld      (ix+47), RED_COLOR
77AB 78          10 93 ld      a, b                        ; save loop counter
77AC 01 41 00    10 94 ld      bc, 65                      ; displacement of next attribute address
77AF DD 09       10 95 add     ix, bc                      ; move IX to next attribute address
77B1 FD 23       10 96 inc     iy                          ; move IY to next number screen address
77B3 FD 23       10 97 inc     iy
77B5 47          10 98 ld      b, a                        ; restore loop counter
77B6 10 CF       10 99 djnz    Screen_Number_Loop          ; repeat for each number
77B8 C9          10 100 ret
77B9             10 102 ; ----------------------------------------------------------------------------------------------------------------------
77B9             10 103 ; Screen_Frame: draw the screen frame on the screen
77B9             10 104 ;
77B9             10 105 ; Input:    -
77B9             10 106 ;
77B9             10 107 ; Output:   -
77B9             10 108 ;
77B9             10 109 ; Destroys: A, BC, DE, HL, IX
77B9             10 110 ; ----------------------------------------------------------------------------------------------------------------------
77B9             10 111 Screen_Frame:
77B9 11 29 62    10 112 ld      de, STR_LEVELTEXT           ; DE points to "Level" string address
77BC 21 09 40    10 113 ld      hl, $4009                   ; HL points to screen address of the string
77BF CD 8D 6F    10 114 call    Print_String                ; print "Level"
77C2 CD FE 77    10 115 call    Screen_Vertical_Bars        ; draw the vertical bars of frame
77C5 01 8E 62    10 117 ld      bc, FRAME_MAP               ; BC points to the frame tiles indexes
77C8 21 00 40    10 118 ld      hl, $4000                   ; HL points to the screen address of the up-border
77CB CD D1 77    10 119 call    Screen_Frame_Border         ; draw up-border
77CE 21 E0 50    10 120 ld      hl, $50E0                   ; HL points to the screen address of the bottom-border
77D1             10 121 Screen_Frame_Border:
77D1 DD 2E 20    10 122 ld      ixl, 32                     ; border width in bytes (loop counter)
77D4             10 123 Screen_Frame_Loop
77D4 0A          10 124 ld      a, (bc)                     ; get tile index
77D5 FE FF       10 125 cp      -1                          ; is it -1?
77D7 28 06       10 126 jr      z, Screen_Frame_Next        ; yes, there is no tile to print
77D9 11 0E 65    10 127 ld      de, FRAME_TILES             ; DE points to tiles array
77DC CD 9C 6F    10 128 call    Print_Tile                  ; print frame tile
77DF             10 129 Screen_Frame_Next
77DF 2C          10 130 inc     l                           ; HL points to the next screen address (next column)
77E0 03          10 131 inc     bc                          ; BC points to the next tile index
77E1 DD 2D       10 132 dec     ixl                         ; decrement loop counter
77E3 20 EF       10 133 jr      nz, Screen_Frame_Loop       ; repeat for each tile
77E5 DD 21 07 58 10 135 ld      ix, $5807                   ; IX points to the "concave left" tile screen position
77E9 DD 36 00 08 10 136 ld      (ix+0), BLUE_PAPER          ; color tile
77ED DD 36 0A 08 10 137 ld      (ix+10), BLUE_PAPER         ; color "concave right" tile
77F1 DD 21 F1 5A 10 138 ld      ix, $5AF1                   ; IX points to the "convex left" tile screen position
77F5 DD 36 00 01 10 139 ld      (ix+0), BLUE_INK            ; color tile
77F9 DD 36 04 01 10 140 ld      (ix+4), BLUE_INK            ; color "convex right" tile
77FD C9          10 141 ret
77FE             10 143 ; ----------------------------------------------------------------------------------------------------------------------
77FE             10 144 ; Screen_Vertical_Bars: draw the vertical bars of the frame on the screen
77FE             10 145 ;
77FE             10 146 ; Input:    -
77FE             10 147 ;
77FE             10 148 ; Output:   -
77FE             10 149 ;
77FE             10 150 ; Destroys: A, BC, HL
77FE             10 151 ; ----------------------------------------------------------------------------------------------------------------------
77FE             10 152 Screen_Vertical_Bars:
77FE 21 20 40    10 153 ld      hl, $4020                   ; HL points to left bar screen address
7801 CD 07 78    10 154 call    Screen_Vertical_Bar         ; draw left bar
7804 21 3F 40    10 155 ld      hl, $403F                   ; HL points to right bar screen address
7807             10 156 Screen_Vertical_Bar:
7807 06 B0       10 157 ld      b, 176                      ; number of pixel lines (loop counter)
7809             10 158 Screen_Vertical_Loop
7809 36 3C       10 159 ld      (hl), %00111100             ; draw pixel byte of bar
780B CD 16 6E    10 160 call    Draw_Down_PixelLine         ; move HL to the next pixel-line address
780E 10 F9       10 161 djnz    Screen_Vertical_Loop        ; repeat for each pixel line
7810 C9          10 162 ret
7811             10 164 ; ----------------------------------------------------------------------------------------------------------------------
7811             10 165 ; Screen_Tokens: draw the fixed tokens on the screen
7811             10 166 ;
7811             10 167 ; Input:    -
7811             10 168 ;
7811             10 169 ; Output:   -
7811             10 170 ;
7811             10 171 ; Uses:     TOKEN_COLOR (current token color)
7811             10 172 ;
7811             10 173 ; Destroys: A, BC, DE, HL, IX
7811             10 174 ; ----------------------------------------------------------------------------------------------------------------------
7811             10 175 Screen_Tokens:
7811 3E 05       10 176 ld      a, CYAN_COLOR               ; set token color
7813 21 BA 44    10 177 ld      hl, $44BA                   ; HL points to the fixed cyan token screen address
7816 CD 1E 78    10 178 call    Screen_Tokens_Draw          ; draw cyan fixed token
7819 3E 02       10 180 ld      a, RED_COLOR                ; set token color
781B 21 24 54    10 181 ld      hl, $5424                   ; HL points to the fixed red token screen address 
781E             10 182 Screen_Tokens_Draw:
781E 32 9E 61    10 183 ld      (TOKEN_COLOR), a            ; save token color
7821 CD 25 6E    10 184 call    Draw_Hexagon_Color          ; color fixed token area
7824 DD 77 40    10 185 ld      (ix+64), a                  ; the fixed tokens are 3 bytes (attributes) high, so we have
7827 DD 77 41    10 186 ld      (ix+65), a                  ; to color the remaining 2 bytes that have not been colored
782A 11 3E 66    10 187 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
782D C3 F7 6D    10 188 jp      Draw_Sprite_Hexagon         ; draw fixed token
7830             10 190 ; ----------------------------------------------------------------------------------------------------------------------
7830             10 191 ; Screen_Timer_Quotes: draw the timer quotes ('  '') on the screen
7830             10 192 ;
7830             10 193 ; Input:    -
7830             10 194 ;
7830             10 195 ; Output:   -
7830             10 196 ;
7830             10 197 ; Destroys: IX
7830             10 198 ; ----------------------------------------------------------------------------------------------------------------------
7830             10 199 Screen_Timer_Quotes:
7830 DD 21 7A 40 10 200 ld      ix, $407A                   ; IX points to the screen address of the cyan timer quotes 
7834 DD 36 00 08 10 201 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7838 DD 36 03 0A 10 202 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
783C DD 24       10 203 inc     ixh                         ; move IX to the next screen pixel-line
783E DD 36 00 08 10 204 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7842 DD 36 03 0A 10 205 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7846 DD 26 58    10 206 ld      ixh, $58                    ; move IX to the attribute address
7849 DD 36 00 07 10 207 ld      (ix+0), WHITE               ; color simple quote
784D DD 36 03 07 10 208 ld      (ix+3), WHITE               ; color double quotes
7851 DD 21 E4 48 10 210 ld      ix, $48E4                   ; IX points to the screen address of the red timer quotes
7855 DD 36 00 08 10 211 ld      (ix+0), %00001000           ; draw 1st half of simple quote (')
7859 DD 36 03 0A 10 212 ld      (ix+3), %00001010           ; draw 1st half of double quotes (")
785D DD 24       10 213 inc     ixh                         ; move IX to the next screen pixel-line
785F DD 36 00 08 10 214 ld      (ix+0), %00001000           ; draw 2nd half of simple quote (')
7863 DD 36 03 0A 10 215 ld      (ix+3), %00001010           ; draw 2nd half of double quotes (")
7867 DD 26 59    10 216 ld      ixh, $59                    ; move IX to the attribute address
786A DD 36 00 07 10 217 ld      (ix+0), WHITE               ; color simple quote
786E DD 36 03 07 10 218 ld      (ix+3), WHITE               ; color double quotes
7872 C9          10 219 ret
7873             10 221 ; ----------------------------------------------------------------------------------------------------------------------
7873             10 222 ; Screen_Color_Statics: apply color to some statics items of the screen
7873             10 223 ;
7873             10 224 ; Input:    -
7873             10 225 ;
7873             10 226 ; Output:   -
7873             10 227 ;
7873             10 228 ; Destroys: BC, IX
7873             10 229 ; ----------------------------------------------------------------------------------------------------------------------
7873             10 230 Screen_Color_Statics:
7873 DD 21 78 58 10 231 ld      ix, $5878                   ; IX points to the attr. address of the cyan player timer
7877 0E 07       10 232 ld      c, WHITE                    ; set color in C
7879 CD A3 78    10 233 call    Screen_Apply_Color          ; apply color
787C DD 2E 98    10 234 ld      ixl, $98                    ; IX points to the attr. address of the cyan player name
787F 0E 05       10 235 ld      c, CYAN_COLOR               ; set color in C
7881 CD A3 78    10 236 call    Screen_Apply_Color          ; apply color
7884 DD 21 18 59 10 237 ld      ix, $5918                   ; IX points to the attr. address of the cyan player messages
7888 0E 47       10 238 ld      c, WHITE+BRIGHT             ; set color in C
788A CD A3 78    10 239 call    Screen_Apply_Color          ; apply color
788D DD 2E E2    10 240 ld      ixl, $E2                    ; IX points to the attr. address of the red player timer
7890 0E 07       10 241 ld      c, WHITE                    ; set color in C
7892 CD A3 78    10 242 call    Screen_Apply_Color          ; apply color
7895 DD 21 02 5A 10 243 ld      ix, $5A02                   ; IX points to the attr. address of the red player name
7899 0E 02       10 244 ld      c, RED_COLOR                ; set color in C
789B CD A3 78    10 245 call    Screen_Apply_Color          ; apply color
789E DD 2E 82    10 246 ld      ixl, $82                    ; IX points to the attr. address of the red player messages
78A1 0E 47       10 247 ld      c, WHITE+BRIGHT             ; set color in C
78A3             10 248 Screen_Apply_Color:
78A3 06 06       10 249 ld      b, 6                        ; number of bytes to be colored (loop counter)
78A5             10 250 Screen_Apply_Color_Loop:
78A5 DD 71 00    10 251 ld      (ix+0), c                   ; apply color
78A8 DD 2C       10 252 inc     ixl                         ; move IX to the next attribute address
78AA 10 F9       10 253 djnz    Screen_Apply_Color_Loop     ; repeat for each byte
78AC C9          10 254 ret
78AD             10 256 ; ----------------------------------------------------------------------------------------------------------------------
78AD             10 257 ; Screen_Last_Level: show last level screen and input game level
78AD             10 258 ;
78AD             10 259 ; Input:    -
78AD             10 260 ;
78AD             10 261 ; Output:   -
78AD             10 262 ;
78AD             10 263 ; Uses:     GAME_LEVEL (current game level)
78AD             10 264 ;
78AD             10 265 ; Destroys: A, BC, DE, HL, IX, IY
78AD             10 266 ; ----------------------------------------------------------------------------------------------------------------------
78AD             10 267 Screen_Last_Level:
78AD 11 3C 68    10 268 ld      de, STR_PRESSKEY            ; DE points to "Press any key" string address
78B0 21 AD 50    10 269 ld      hl, $50AD                   ; HL points to string screen address
78B3 CD 8D 6F    10 270 call    Print_String                ; print "Press any key"
78B6 DD 21 AD 5A 10 271 ld      ix, $5AAD                   ; IX points to string attributes address
78BA 01 38 0D    10 272 ld      bc, (13*256)+WHITE_PAPER    ; B = string length (loop counter), C = color attributes
78BD CD A5 78    10 273 call    Screen_Apply_Color_Loop     ; apply color to string area
78C0 CD F9 6E    10 274 call    Input_Key_Scan              ; wait for a key pressed
78C3 CD 40 77    10 276 call    Screen_Clear                ; fill in black the whole screen area and attributes area
78C6 CD 86 7C    10 277 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
78C9 DD 21 C7 59 10 278 ld      ix, $59C7                   ; IX points to "CONGRATULATIONS" string attributes address
78CD 01 C7 11    10 279 ld      bc, (17*256)+WHITE_FLASH1   ; B = string length (loop counter), C = color attributes
78D0 CD A5 78    10 280 call    Screen_Apply_Color_Loop     ; apply color to string area
78D3 11 B4 68    10 281 ld      de, STR_CONGRATS            ; DE points to string address
78D6 21 C7 48    10 282 ld      hl, $48C7                   ; HL points to string screen address
78D9 CD 8D 6F    10 283 call    Print_String                ; print "CONGRATULATIONS"
78DC DD 21 EF 64 10 284 ld      ix, WINNER_FX               ; IX points to winner tone parameters address
78E0 CD 04 77    10 285 call    Sound_FX                    ; play sound fx
78E3 F3          10 287 di                                  ; disable interrupts
78E4 DD 21 42 5A 10 288 ld      ix, $5A42                   ; IX points to "Well done!..." string attributes address
78E8 01 07 1C    10 289 ld      bc, (28*256)+WHITE          ; B = string length (loop counter), C = color attributes
78EB CD A5 78    10 290 call    Screen_Apply_Color_Loop     ; apply color to string area
78EE 11 C6 68    10 291 ld      de, STR_LAST_LEVEL          ; DE points to string address
78F1 21 42 50    10 292 ld      hl, $5042                   ; HL points to string screen address
78F4 CD 8D 6F    10 293 call    Print_String                ; print "Well done!..."
78F7 DD 2E 82    10 294 ld      ixl, $82                    ; IX points to "Choose..." string attributes address
78FA 06 18       10 295 ld      b, 24                       ; string length-4 (loop counter)
78FC CD A5 78    10 296 call    Screen_Apply_Color_Loop     ; apply color to string area
78FF DD 36 01 78 10 297 ld      (ix+1), WHITE_PAPER+BRIGHT  ; set color for last characters ("1-4")
7903 DD 36 02 78 10 298 ld      (ix+2), WHITE_PAPER+BRIGHT
7907 DD 36 03 78 10 299 ld      (ix+3), WHITE_PAPER+BRIGHT
790B 13          10 300 inc     de                          ; move DE to next string address
790C 2E 82       10 301 ld      l, $82                      ; HL points to string screen address
790E CD 8D 6F    10 302 call    Print_String                ; print "Choose..."
7911             10 303 Screen_Choose_Level
7911 CD F9 6E    10 304 call    Input_Key_Scan              ; wait for a key pressed
7914 FE 31       10 305 cp      '1'                         ; is it < '1' ?
7916 38 F9       10 306 jr      c, Screen_Choose_Level      ; yes, wait for a key pressed
7918 FE 35       10 307 cp      '5'                         ; is it >= '5' ?
791A 30 F5       10 308 jr      nc, Screen_Choose_Level     ; yes, wait for a key pressed
791C D6 31       10 309 sub     $31                         ; convert ASCII into level number (-1)
791E 21 9D 61    10 310 ld      hl, GAME_LEVEL              ; HL points to game level address
7921 77          10 311 ld      (hl), a                     ; save chosen game level (-1)
7922 C9          10 312 ret
7923             10 314 ; ----------------------------------------------------------------------------------------------------------------------
7923             10 315 ; Screen_ThreeRow: color the three-in-a-row marks according to the current three row counter
7923             10 316 ;
7923             10 317 ; Input:    -
7923             10 318 ;
7923             10 319 ; Output:   -
7923             10 320 ;
7923             10 321 ; Uses:     LEVEL_COLOR (current level color for frame border)
7923             10 322 ;           THREE_ROW (three-in-a-row counter)
7923             10 323 ;
7923             10 324 ; Destroys: A, C, HL, IX
7923             10 325 ; ----------------------------------------------------------------------------------------------------------------------
7923             10 326 Screen_ThreeRow:
7923 21 9C 61    10 327 ld      hl, LEVEL_COLOR             ; HL points to level color address
7926 4E          10 328 ld      c, (hl)                     ; save level color in C
7927 CD 3F 79    10 329 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
792A 3A 11 62    10 330 ld      a, (THREE_ROW)              ; A = three-in-a-row counter
792D B7          10 331 or      a                           ; is it 0?
792E C8          10 332 ret     z                           ; yes, return
792F 3D          10 333 dec     a                           ; is it 1?
7930 28 09       10 334 jr      z, Screen_ThreeRow_1        ; yes, color first mark
7932 3D          10 335 dec     a                           ; is it 2?
7933 28 03       10 336 jr      z, Screen_ThreeRow_2        ; yes color 2nd and 1st marks
7935 DD 71 00    10 337 ld      (ix+0), c                   ; color 3rd mark
7938             10 338 Screen_ThreeRow_2
7938 DD 71 01    10 339 ld      (ix+1), c                   ; color 2nd mark
793B             10 340 Screen_ThreeRow_1
793B DD 71 02    10 341 ld      (ix+2), c                   ; color 1st mark
793E C9          10 342 ret
793F             10 344 ; ----------------------------------------------------------------------------------------------------------------------
793F             10 345 ; Screen_Clear_ThreeRow: clear all three-in-a-row marks
793F             10 346 ;
793F             10 347 ; Input:    -
793F             10 348 ;
793F             10 349 ; Output:   IX = three-in-a-row marks attribute address
793F             10 350 ;
793F             10 351 ; Destroys: -
793F             10 352 ; ----------------------------------------------------------------------------------------------------------------------
793F             10 353 Screen_Clear_ThreeRow:
793F DD 21 F2 5A 10 354 ld      ix, $5AF2                   ; IX points to attribute address of three-in-a-row marks
7943 DD 36 00 01 10 355 ld      (ix+0), BLUE_INK            ; clear all three-in-a-row marks
7947 DD 36 01 01 10 356 ld      (ix+1), BLUE_INK
794B DD 36 02 01 10 357 ld      (ix+2), BLUE_INK
794F C9          10 358 ret
7950             10 360 ; ----------------------------------------------------------------------------------------------------------------------
7950             10 361 ; Screen_Frame_Color: set up frame color and print level number depending on current level
7950             10 362 ;
7950             10 363 ; Input:    HL = game level address
7950             10 364 ;
7950             10 365 ; Output:   -
7950             10 366 ;
7950             10 367 ; Uses:     LEVEL_COLOR (current level color for frame border)
7950             10 368 ;
7950             10 369 ; Destroys: A, BC, DE, HL
7950             10 370 ; ----------------------------------------------------------------------------------------------------------------------
7950             10 371 Screen_Frame_Color:
7950 06 00       10 372 ld      b, 0                        ; set game level in BC
7952 4E          10 373 ld      c, (hl)
7953 3E 30       10 374 ld      a, $30                      ; convert game level number to game level character
7955 81          10 375 add     a, c
7956 21 0F 40    10 376 ld      hl, $400F                   ; HL points to screen address of game level
7959 CD 99 6F    10 377 call    Print_Char                  ; print game level
795C 21 11 62    10 378 ld      hl, ROW_COLOR_MAP-1         ; HL points to color map address (adjusted for index 0)
795F 09          10 379 add     hl, bc                      ; use BC as index for color map address
7960 7E          10 380 ld      a, (hl)                     ; A = level color
7961 CD 76 79    10 381 call    Screen_Tiles_Color          ; color the frame according to the current level
7964 E6 07       10 382 and     %00000111                   ; mask color
7966 32 9C 61    10 383 ld      (LEVEL_COLOR), a            ; save masked color
7969 17          10 384 rla                                 ; rotate to text level color
796A 17          10 385 rla
796B 17          10 386 rla
796C 21 08 58    10 387 ld      hl, $5808                   ; HL points to attribute address of level text
796F 06 09       10 388 ld      b, 9                        ; length of level text (loop counter)
7971             10 389 Screen_Level_Loop
7971 77          10 390 ld      (hl), a                     ; apply color to level text
7972 2C          10 391 inc     l                           ; HL points to attr address of next character of level text
7973 10 FC       10 392 djnz    Screen_Level_Loop           ; repeat for each character of level text
7975 C9          10 393 ret
7976             10 395 ; ----------------------------------------------------------------------------------------------------------------------
7976             10 396 ; Screen_Tiles_Color: apply color to the frame tiles
7976             10 397 ;
7976             10 398 ; Input:    A = color to apply
7976             10 399 ;
7976             10 400 ; Output:   -
7976             10 401 ;
7976             10 402 ; Destroys: BC, DE, HL
7976             10 403 ; ----------------------------------------------------------------------------------------------------------------------
7976             10 404 Screen_Tiles_Color:
7976             10 405 ; color up row
7976 21 01 58    10 407 ld      hl, $5801                   ; HL points to attribute address of the the frame tile 
7979 06 06       10 408 ld      b, 6                        ; number of tiles (loop counter)
797B             10 409 Screen_Tiles_URow1
797B 77          10 410 ld      (hl), a                     ; apply color
797C 2C          10 411 inc     l                           ; move HL to the next attribute address
797D 10 FC       10 412 djnz    Screen_Tiles_URow1          ; repeat for each tile
797F 2E 12       10 413 ld      l, $12                      ; move HL to the next attribute address
7981 06 0D       10 414 ld      b, 13                       ; number of tiles (loop counter)
7983             10 415 Screen_Tiles_URow2
7983 77          10 416 ld      (hl), a                     ; apply color
7984 2C          10 417 inc     l                           ; move HL to the next attribute address
7985 10 FC       10 418 djnz    Screen_Tiles_URow2          ; repeat for each tile
7987             10 420 ; color vertical bars
7987 2E 00       10 422 ld      l, 0                        ; move HL to the next attribute address
7989 11 1F 00    10 423 ld      de, 31                      ; attribute address displacement (for each bar)
798C 0E 03       10 424 ld      c, 3                        ; number of screen thirds (outer loop counter)
798E             10 425 Screen_Tiles_VBar1
798E 06 08       10 426 ld      b, 8                        ; number of tiles (inner loop counter)
7990             10 427 Screen_Tiles_VBar2
7990 77          10 428 ld      (hl), a                     ; apply color
7991 19          10 429 add     hl, de                      ; move HL to the right column
7992 77          10 430 ld      (hl), a                     ; apply color
7993 2C          10 431 inc     l                           ; move HL to the next attribute address
7994 10 FA       10 432 djnz    Screen_Tiles_VBar2          ; repeat for each tile
7996 24          10 433 inc     h                           ; move HL to the next screen third
7997 0D          10 434 dec     c                           ; decrement number of thirds
7998 20 F4       10 435 jr      nz, Screen_Tiles_VBar1      ; repeat for each third
799A             10 437 ; color bottom row
799A 21 E1 5A    10 439 ld      hl, $5AE1                   ; HL points to attribute address of the the frame tile
799D 06 10       10 440 ld      b, 16                       ; number of tiles (loop counter)
799F             10 441 Screen_Tiles_BRow1
799F 77          10 442 ld      (hl), a                     ; apply color
79A0 2C          10 443 inc     l                           ; move HL to the next attribute address
79A1 10 FC       10 444 djnz    Screen_Tiles_BRow1          ; repeat for each tile
79A3 2E F6       10 445 ld      l, $F6                      ; move HL to the next attribute address
79A5 06 09       10 446 ld      b, 9                        ; number of tiles (loop counter)
79A7             10 447 Screen_Tiles_BRow2
79A7 77          10 448 ld      (hl), a                     ; apply color
79A8 2C          10 449 inc     l                           ; move HL to the next attribute address
79A9 10 FC       10 450 djnz    Screen_Tiles_BRow2          ; repeat for each tile
79AB C9          10 451 ret
79AC             10 453 ; ----------------------------------------------------------------------------------------------------------------------
79AC             10 454 ; Screen_Menu: show main menu and wait for an option
79AC             10 455 ;
79AC             10 456 ; Input:    -
79AC             10 457 ;
79AC             10 458 ; Output:   -
79AC             10 459 ;
79AC             10 460 ; Uses:     GAME_LEVEL (current game level)
79AC             10 461 ;
79AC             10 462 ; Destroys: A, BC, DE, HL, IX, IY
79AC             10 463 ; ----------------------------------------------------------------------------------------------------------------------
79AC             10 464 Screen_Menu:
79AC CD 40 77    10 465 call    Screen_Clear                ; fill in black the whole screen area and attributes area
79AF CD 86 7C    10 466 call    Screen_Hexagons             ; draw menu hexagons ("HEX 2")
79B2             10 467 Screen_Menu_Strings
79B2 21 80 59    10 468 ld      hl, $5980                   ; HL points to menu text area attributes address
79B5 11 81 59    10 469 ld      de, $5981                   ; DE points to next byte of menu text area attr. address
79B8 36 00       10 470 ld      (hl), 0                     ; set first attribute text area in black
79BA 01 7F 01    10 471 ld      bc, (32*12)-1               ; length of text area attributes (-1 already set)
79BD ED B0       10 472 ldir                                ; set the rest of text area attributes in black
79BF DD 21 CA 59 10 474 ld      ix, $59CA                   ; IX points to "Start new game" string attr. address (+1)
79C3 DD 36 FF 78 10 475 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79C7 01 47 0D    10 476 ld      bc, (13*256)+WHITE_FLASH0   ; B = string length-1 (loop counter), C = color attributes
79CA CD A5 78    10 477 call    Screen_Apply_Color_Loop     ; apply color to string area
79CD 11 80 67    10 478 ld      de, STR_OPTIONS             ; DE points to string address
79D0 21 C9 48    10 479 ld      hl, $48C9                   ; HL points to string screen address
79D3 CD 8D 6F    10 480 call    Print_String                ; print "Start new game"
79D6 DD 21 2A 5A 10 481 ld      ix, $5A2A                   ; IX points to "How to play" string attributes address (+1)
79DA DD 36 FF 78 10 482 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79DE 06 0A       10 483 ld      b, 10                       ; string length-1 (loop counter)
79E0 CD A5 78    10 484 call    Screen_Apply_Color_Loop     ; apply color to string area
79E3 13          10 485 inc     de                          ; move DE to "How to play" string address
79E4 21 29 50    10 486 ld      hl, $5029                   ; HL points to string screen address
79E7 CD 8D 6F    10 487 call    Print_String                ; print "How to play"
79EA DD 2E 8A    10 488 ld      ixl, $8A                    ; IX points to "Credits" string attributes address (+1)
79ED DD 36 FF 78 10 489 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
79F1 CD A3 78    10 490 call    Screen_Apply_Color          ; apply color to string area
79F4 13          10 491 inc     de                          ; move DE to "Credits" string address
79F5 2E 89       10 492 ld      l, $89                      ; HL points to string screen address
79F7 CD 8D 6F    10 493 call    Print_String                ; print "Credits"
79FA             10 494 Screen_Menu_Options
79FA CD F9 6E    10 495 call    Input_Key_Scan              ; wait for a key pressed
79FD FE 73       10 496 cp      's'                         ; is it 's'?
79FF C8          10 497 ret     z                           ; yes, return
7A00 FE 63       10 498 cp      'c'                         ; is it 'c'?
7A02 CA 16 7C    10 499 jp      z, Screen_Menu_Credits      ; yes, show credits
7A05 FE 68       10 500 cp      'h'                         ; is it 'h'?
7A07 20 F1       10 501 jr      nz, Screen_Menu_Options     ; no, repeat until key pressed = 's' or 'c' or 'h'
7A09             10 503 ; ----------------------------------------------------------------------------------------------------------------------
7A09             10 504 ; Show "How to play" pages
7A09             10 505 ; ----------------------------------------------------------------------------------------------------------------------
7A09             10 506 Screen_Menu_How2Play
7A09 CD 40 77    10 507 call    Screen_Clear                ; fill in black the whole screen area and attributes area
7A0C CD 4E 77    10 508 call    Screen_Letters              ; draw the two rows of letters on the screen (a..g)
7A0F CD 7A 77    10 509 call    Screen_Numbers              ; draw the two columns of numbers on the screen (1..7)
7A12 CD B9 77    10 510 call    Screen_Frame                ; draw the screen frame
7A15 21 9D 61    10 512 ld      hl, GAME_LEVEL              ; HL points to game level address (needed for color frame)
7A18 34          10 513 inc     (hl)                        ; increment game level (GAME_LEVEL = 1)
7A19 CD 50 79    10 514 call    Screen_Frame_Color          ; set up frame color depending on current level
7A1C CD 3F 79    10 515 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7A1F 11 4A 68    10 517 ld      de, STR_BUTTONS             ; DE points to "Next" string address
7A22 21 DB 50    10 518 ld      hl, $50DB                   ; HL points to string screen address
7A25 CD 8D 6F    10 519 call    Print_String                ; print "Next"
7A28 13          10 520 inc     de                          ; move DE to "Back" string address
7A29 21 C1 50    10 521 ld      hl, $50C1                   ; HL points to string screen address
7A2C CD 8D 6F    10 522 call    Print_String                ; print "Back"
7A2F             10 524 Screen_How2Play_RED
7A2F 21 5E 58    10 525 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7A32 CD C0 7C    10 526 call    Screen_Clear_Text           ; clear text area attributes
7A35 CD A5 6D    10 527 call    Draw_Board                  ; draw an empty hexagons board
7A38             10 529 ; text for RED
7A38 DD 21 01 5A 10 531 ld      ix, $5A01                   ; IX points to "Connect" string attributes address
7A3C 01 07 07    10 532 ld      bc, (7*256)+WHITE           ; B = string length (loop counter), C = color attributes
7A3F CD A5 78    10 533 call    Screen_Apply_Color_Loop     ; apply color to string area
7A42 11 5D 68    10 534 ld      de, STR_HELP1               ; DE points to string address
7A45 21 01 50    10 535 ld      hl, $5001                   ; HL points to string screen address
7A48 CD 8D 6F    10 536 call    Print_String                ; print "Connect"
7A4B DD 2E 21    10 537 ld      ixl, $21                    ; IX points to "left and" string attributes address
7A4E 06 08       10 538 ld      b, 8                        ; string length (loop counter)
7A50 CD A5 78    10 539 call    Screen_Apply_Color_Loop     ; apply color to string area
7A53 13          10 540 inc     de                          ; move DE to "left and" string address
7A54 2E 21       10 541 ld      l, $21                      ; HL points to string screen address
7A56 CD 8D 6F    10 542 call    Print_String                ; print "left and"
7A59 DD 2E 41    10 543 ld      ixl, $41                    ; IX points to "right" string attributes address
7A5C 06 05       10 544 ld      b, 5                        ; set string length (loop counter)
7A5E CD A5 78    10 545 call    Screen_Apply_Color_Loop     ; apply color to string area
7A61 11 75 68    10 546 ld      de, STR_HELP3_RED           ; DE points to "right" string address
7A64 2E 41       10 547 ld      l, $41                      ; HL points to string screen address
7A66 CD 8D 6F    10 548 call    Print_String                ; print "right"
7A69 DD 2E 61    10 549 ld      ixl, $61                    ; IX points to "borders" string attributes address
7A6C 06 07       10 550 ld      b, 7                        ; set string length (loop counter)
7A6E CD A5 78    10 551 call    Screen_Apply_Color_Loop     ; apply color to string area
7A71 11 80 68    10 552 ld      de, STR_HELP4               ; DE points to "borders" string address
7A74 2E 61       10 553 ld      l, $61                      ; HL points to string screen address
7A76 CD 8D 6F    10 554 call    Print_String                ; print "borders"
7A79 DD 2E 81    10 555 ld      ixl, $81                    ; IX points to "to win" string attributes address
7A7C CD A3 78    10 556 call    Screen_Apply_Color          ; apply color to string area
7A7F 13          10 557 inc     de                          ; move DE to "to win" string address
7A80 2E 81       10 558 ld      l, $81                      ; HL points to string screen address
7A82 CD 8D 6F    10 559 call    Print_String                ; print "to win"
7A85 DD 21 E3 59 10 560 ld      ix, $59E3                   ; IX points to "RED" string attributes address
7A89 01 42 03    10 561 ld      bc, (3*256)+RED_COLOR+BRIGHT; B = string length (loop counter), C = color attributes
7A8C CD A5 78    10 562 call    Screen_Apply_Color_Loop     ; apply color to string area
7A8F 11 54 68    10 563 ld      de, STR_RED                 ; DE points to "RED" string address
7A92 21 E3 48    10 564 ld      hl, $48E3                   ; HL points to string screen address
7A95 CD 8D 6F    10 565 call    Print_String                ; print "RED"
7A98             10 567 ; draw RED sample board
7A98 FD 21 3A 67 10 569 ld      iy, SAMPLE_BOARD_RED        ; IY points to sample board (red) screen addresses
7A9C 11 3E 66    10 570 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7A9F 06 07       10 571 ld      b, 7                        ; number of red+bright tokens (loop counter)
7AA1 3E 42       10 572 ld      a, RED_COLOR+BRIGHT         ; set token color
7AA3 32 9E 61    10 573 ld      (TOKEN_COLOR), a            ; save token color
7AA6 CD AB 7C    10 574 call    Screen_Hexagons_Loop        ; draw tokens
7AA9 06 02       10 575 ld      b, 2                        ; number of red tokens (loop counter)
7AAB 3E 02       10 576 ld      a, RED_COLOR                ; set token color
7AAD 32 9E 61    10 577 ld      (TOKEN_COLOR), a            ; save token color
7AB0 CD AB 7C    10 578 call    Screen_Hexagons_Loop        ; draw tokens
7AB3 06 09       10 579 ld      b, 9                        ; number of cyan tokens (loop counter)
7AB5 3E 05       10 580 ld      a, CYAN_COLOR               ; set token color
7AB7 32 9E 61    10 581 ld      (TOKEN_COLOR), a            ; save token color
7ABA CD AB 7C    10 582 call    Screen_Hexagons_Loop        ; draw tokens
7ABD             10 584 ; wait for "Next" option pressed
7ABD DD 21 C1 5A 10 586 ld      ix, $5AC1                   ; IX points to "Back" string attribute address
7AC1 01 00 04    10 587 ld      bc, $0400                   ; B = string length (loop counter), C = attributes (black)
7AC4 CD A5 78    10 588 call    Screen_Apply_Color_Loop     ; hide "Back" string
7AC7 DD 2E DC    10 589 ld      ixl, $DC                    ; IX points to "Next" string attribute address (+1)
7ACA DD 36 FF 78 10 590 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7ACE 01 47 03    10 591 ld      bc, (3*256)+WHITE_FLASH0    ; B = string length-1 (loop counter), C = color attributes
7AD1 CD A5 78    10 592 call    Screen_Apply_Color_Loop     ; apply color to string area
7AD4             10 593 Screen_How2PlayRED_End
7AD4 CD F9 6E    10 594 call    Input_Key_Scan              ; wait for a key pressed
7AD7 FE 6E       10 595 cp      'n'                         ; is it 'n'?
7AD9 20 F9       10 596 jr      nz, Screen_How2PlayRED_End  ; no, repeat until key pressed = 'n'
7ADB             10 598 Screen_How2Play_CYAN
7ADB 21 0F 58    10 599 ld      hl, $580F                   ; HL points to level number attribute address
7ADE CB BE       10 600 res     7, (hl)                     ; reset flash attribute
7AE0 26 40       10 601 ld      h, $40                      ; HL points to level number screen address
7AE2 3E 31       10 602 ld      a, '1'                      ; set level number (char)
7AE4 CD 99 6F    10 603 call    Print_Char                  ; print '1'
7AE7 CD 3F 79    10 604 call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
7AEA 21 C9 59    10 606 ld      hl, $59E1-24                ; HL points to red text area attributes address (-24)
7AED CD C0 7C    10 607 call    Screen_Clear_Text           ; clear text area attributes
7AF0 CD A5 6D    10 608 call    Draw_Board                  ; draw an empty hexagons board
7AF3             10 610 ; text for CYAN
7AF3 DD 21 98 58 10 612 ld      ix, $5898                   ; IX points to "Connect" string attributes address
7AF7 01 07 07    10 613 ld      bc, (7*256)+WHITE           ; B = string length (loop counter), C = color attributes
7AFA CD A5 78    10 614 call    Screen_Apply_Color_Loop     ; apply color to string area
7AFD 11 5D 68    10 615 ld      de, STR_HELP1               ; DE points to "Connect" string address
7B00 21 98 40    10 616 ld      hl, $4098                   ; HL points to string screen address
7B03 CD 8D 6F    10 617 call    Print_String                ; print "Connect"
7B06 DD 2E B9    10 618 ld      ixl, $B9                    ; IX points to "up and" string attributes address
7B09 CD A3 78    10 619 call    Screen_Apply_Color          ; apply color to string area
7B0C 11 6E 68    10 620 ld      de, STR_HELP2_CYAN          ; DE points to "up and" string address
7B0F 2E B9       10 621 ld      l, $B9                      ; HL points to string screen address
7B11 CD 8D 6F    10 622 call    Print_String                ; print "up and"
7B14 DD 2E DB    10 623 ld      ixl, $DB                    ; IX points to "down" string attributes address
7B17 06 04       10 624 ld      b, 4                        ; string length (loop counter)
7B19 CD A5 78    10 625 call    Screen_Apply_Color_Loop     ; apply color to string area
7B1C 11 7B 68    10 626 ld      de, STR_HELP3_CYAN          ; DE points to "down" string address
7B1F 2E DB       10 627 ld      l, $DB                      ; HL points to string screen address
7B21 CD 8D 6F    10 628 call    Print_String                ; print "down"
7B24 DD 2E F8    10 629 ld      ixl, $F8                    ; IX points to "borders" string attributes address
7B27 06 07       10 630 ld      b, 7                        ; string length (loop counter)
7B29 CD A5 78    10 631 call    Screen_Apply_Color_Loop     ; apply color to string area
7B2C 13          10 632 inc     de                          ; move DE to "borders" string address
7B2D 2E F8       10 633 ld      l, $F8                      ; HL points to string screen address
7B2F CD 8D 6F    10 634 call    Print_String                ; print "borders"
7B32 DD 21 19 59 10 635 ld      ix, $5919                   ; IX points to "to win" string attributes address
7B36 CD A3 78    10 636 call    Screen_Apply_Color          ; apply color to string area
7B39 13          10 637 inc     de                          ; move DE to "to win" string address
7B3A 21 19 48    10 638 ld      hl, $4819                   ; HL points to string screen address
7B3D CD 8D 6F    10 639 call    Print_String                ; print "to win"
7B40 DD 21 7A 58 10 640 ld      ix, $587A                   ; IX points to "CYAN" string attributes address
7B44 01 45 04    10 641 ld      bc, $0445                   ; B = string length (loop counter)
7B47             10 642 ; C = color attributes (cyan+bright)
7B47 CD A5 78    10 643 call    Screen_Apply_Color_Loop     ; apply color to string area
7B4A 11 58 68    10 644 ld      de, STR_CYAN                ; DE points to "CYAN" string address
7B4D 21 7A 40    10 645 ld      hl, $407A                   ; HL points to string screen address
7B50 CD 8D 6F    10 646 call    Print_String                ; print "CYAN"
7B53             10 648 ; draw CYAN sample board
7B53 FD 21 5E 67 10 650 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7B57 11 3E 66    10 651 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7B5A 06 07       10 652 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7B5C 3E 45       10 653 ld      a, CYAN_COLOR+BRIGHT        ; set token color
7B5E 32 9E 61    10 654 ld      (TOKEN_COLOR), a            ; save token color
7B61 CD AB 7C    10 655 call    Screen_Hexagons_Loop        ; draw tokens
7B64 06 02       10 656 ld      b, 2                        ; number of cyan tokens (loop counter)
7B66 3E 05       10 657 ld      a, CYAN_COLOR               ; set token color
7B68 32 9E 61    10 658 ld      (TOKEN_COLOR), a            ; save token color
7B6B CD AB 7C    10 659 call    Screen_Hexagons_Loop        ; draw tokens
7B6E 06 08       10 660 ld      b, 8                        ; number of red tokens (loop counter)
7B70 3E 02       10 661 ld      a, RED_COLOR                ; set token color
7B72 32 9E 61    10 662 ld      (TOKEN_COLOR), a            ; save token color
7B75 CD AB 7C    10 663 call    Screen_Hexagons_Loop        ; draw tokens
7B78             10 665 ; wait for "Next" or "Back" options pressed
7B78 DD 21 C2 5A 10 667 ld      ix, $5AC2                   ; IX points to "Back" string attributes address (+1)
7B7C DD 36 FF 78 10 668 ld      (ix-1), WHITE_PAPER+BRIGHT  ; set color of first letter
7B80 01 47 03    10 669 ld      bc, (3*256)+WHITE_FLASH0    ; B = string length (-1), C = color attributes
7B83 CD A5 78    10 670 call    Screen_Apply_Color_Loop     ; apply color to string area
7B86             10 671 Screen_How2PlayCYAN_End
7B86 CD F9 6E    10 672 call    Input_Key_Scan              ; wait for a key pressed
7B89 FE 62       10 673 cp      'b'                         ; is it 'b'?
7B8B CA 2F 7A    10 674 jp      z, Screen_How2Play_RED      ; yes, show RED page
7B8E FE 6E       10 675 cp      'n'                         ; is it 'n'?
7B90 20 F4       10 676 jr      nz, Screen_How2PlayCYAN_End ; no, repeat until key pressed = 'n' or 'b'
7B92             10 678 Screen_How2Play_LevelUp
7B92 21 5E 58    10 679 ld      hl, $5876-24                ; HL points to cyan text area attributes address (-24)
7B95 CD C0 7C    10 680 call    Screen_Clear_Text           ; clear text area attributes
7B98             10 682 ; text for Level Up
7B98 DD 21 21 5A 10 684 ld      ix, $5A21                   ; IX points to "Win three" string attributes address
7B9C 01 07 09    10 685 ld      bc, (9*256)+WHITE           ; B = string length (loop counter), C = color attributes
7B9F CD A5 78    10 686 call    Screen_Apply_Color_Loop     ; apply color to string area
7BA2 11 8F 68    10 687 ld      de, STR_HELP                ; DE points to "Win three" string address
7BA5 21 21 50    10 688 ld      hl, $5021                   ; HL points to string screen address
7BA8 CD 8D 6F    10 689 call    Print_String                ; print "Win three"
7BAB DD 2E 41    10 690 ld      ixl, $41                    ; IX points to "times in" string attributes address
7BAE 06 08       10 691 ld      b, 8                        ; string length (loop counter)
7BB0 CD A5 78    10 692 call    Screen_Apply_Color_Loop     ; apply color to string area
7BB3 13          10 693 inc     de                          ; move DE to "times in" string address
7BB4 2E 41       10 694 ld      l, $41                      ; HL points to string screen address
7BB6 CD 8D 6F    10 695 call    Print_String                ; print "times in"
7BB9 DD 2E 61    10 696 ld      ixl, $61                    ; IX points to "a row to" string attributes address
7BBC 06 08       10 697 ld      b, 8                        ; string length (loop counter)
7BBE CD A5 78    10 698 call    Screen_Apply_Color_Loop     ; apply color to string area
7BC1 13          10 699 inc     de                          ; move DE to "a row to" string address
7BC2 2E 61       10 700 ld      l, $61                      ; HL points to string screen address
7BC4 CD 8D 6F    10 701 call    Print_String                ; print "a row to"
7BC7 DD 2E 81    10 702 ld      ixl, $81                    ; IX points to "level up" string attributes address
7BCA 06 08       10 703 ld      b, 8                        ; string length (loop counter)
7BCC CD A5 78    10 704 call    Screen_Apply_Color_Loop     ; apply color to string area
7BCF 13          10 705 inc     de                          ; move DE to "level up" string address
7BD0 2E 81       10 706 ld      l, $81                      ; HL points to string screen address
7BD2 CD 8D 6F    10 707 call    Print_String                ; print "level up"
7BD5             10 709 ; reset bright of cyan tokens
7BD5 FD 21 5E 67 10 711 ld      iy, SAMPLE_BOARD_CYAN       ; IY points to sample board (cyan) screen addresses
7BD9 11 3E 66    10 712 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7BDC 06 07       10 713 ld      b, 7                        ; number of cyan+bright tokens (loop counter)
7BDE 3E 05       10 714 ld      a, CYAN_COLOR               ; set new token color
7BE0 32 9E 61    10 715 ld      (TOKEN_COLOR), a            ; save color
7BE3 CD AB 7C    10 716 call    Screen_Hexagons_Loop        ; draw tokens
7BE6             10 718 ; set flash attribute of level number and three-in-a-row marks
7BE6 21 0F 58    10 720 ld      hl, $580F                   ; HL points to level number attribute address
7BE9 CB FE       10 721 set     7, (hl)                     ; set flash attribute
7BEB 21 0F 40    10 722 ld      hl, $400F                   ; HL points to level number screen address
7BEE 3E 32       10 723 ld      a, '2'                      ; set new level
7BF0 CD 99 6F    10 724 call    Print_Char                  ; print new level
7BF3 DD 21 F2 5A 10 725 ld      ix, $5AF2                   ; IX points to three-in-a-row attribute address
7BF7 DD 36 00 B8 10 726 ld      (ix+0), WHITE_PAPER+FLASH   ; set flash attributes
7BFB DD 36 01 B8 10 727 ld      (ix+1), WHITE_PAPER+FLASH
7BFF DD 36 02 B8 10 728 ld      (ix+2), WHITE_PAPER+FLASH
7C03             10 730 ; wait for "Next" or "Back" options pressed
7C03             10 732 Screen_How2Play_End
7C03 CD F9 6E    10 733 call    Input_Key_Scan              ; wait for a key pressed
7C06 FE 62       10 734 cp      'b'                         ; is it 'b'?
7C08 CA DB 7A    10 735 jp      z, Screen_How2Play_CYAN     ; yes, show CYAN page
7C0B FE 6E       10 736 cp      'n'                         ; is it 'n'?
7C0D 20 F4       10 737 jr      nz, Screen_How2Play_End     ; no, repeat until key pressed = 'b' or 'n'
7C0F 21 9D 61    10 739 ld      hl, GAME_LEVEL              ; HL points to game level address
7C12 35          10 740 dec     (hl)                        ; decrement game level (GAME_LEVEL = 0)
7C13 C3 AC 79    10 741 jp      Screen_Menu                 ; return to main menu
7C16             10 743 ; ----------------------------------------------------------------------------------------------------------------------
7C16             10 744 ; Show credits
7C16             10 745 ; ----------------------------------------------------------------------------------------------------------------------
7C16             10 746 Screen_Menu_Credits
7C16 DD 21 84 59 10 747 ld      ix, $5984                   ; IX points to "Design..." string attributes address
7C1A 01 47 19    10 748 ld      bc, (25*256)+WHITE_FLASH0   ; B = string length (loop counter), C = color attributes
7C1D CD A5 78    10 749 call    Screen_Apply_Color_Loop     ; apply color to string area
7C20 11 A3 67    10 750 ld      de, STR_CREDITS             ; DE points to "Design..." string address
7C23 21 84 48    10 751 ld      hl, $4884                   ; HL points to string screen address
7C26 CD 8D 6F    10 752 call    Print_String                ; print "Design..."
7C29 DD 2E C4    10 753 ld      ixl, $C4                    ; IX points to "Code..." string attributes address
7C2C 06 19       10 754 ld      b, 25                       ; string length (loop counter)
7C2E CD A5 78    10 755 call    Screen_Apply_Color_Loop     ; apply color to string area
7C31 13          10 756 inc     de                          ; move DE to to "Code..." string address
7C32 2E C4       10 757 ld      l, $C4                      ; HL points to string screen address
7C34 CD 8D 6F    10 758 call    Print_String                ; print "Code..."
7C37 DD 2E E4    10 759 ld      ixl, $E4                    ; IX points to "Einar Saukas" string attributes address
7C3A 06 18       10 760 ld      b, 24                       ; string length (loop counter)
7C3C CD A5 78    10 761 call    Screen_Apply_Color_Loop     ; apply color to string area
7C3F 13          10 762 inc     de                          ; move DE to "Einar Saukas" string address
7C40 2E E4       10 763 ld      l, $E4                      ; HL points to string screen address
7C42 CD 8D 6F    10 764 call    Print_String                ; print "Einar Saukas"
7C45 DD 21 24 5A 10 765 ld      ix, $5A24                   ; IX points to "Font..." string attributes address
7C49 06 18       10 766 ld      b, 24                       ; string length (loop counter)
7C4B CD A5 78    10 767 call    Screen_Apply_Color_Loop     ; apply color to string area
7C4E 13          10 768 inc     de                          ; move DE to "Font..." string address
7C4F 21 24 50    10 769 ld      hl, $5024                   ; HL points to string screen address
7C52 CD 8D 6F    10 770 call    Print_String                ; print "Font..."
7C55 DD 2E 64    10 771 ld      ixl, $64                    ; IX points to "Graphics..." string attributes address
7C58 06 18       10 772 ld      b, 24                       ; string length (loop counter)
7C5A CD A5 78    10 773 call    Screen_Apply_Color_Loop     ; apply color to string area
7C5D 13          10 774 inc     de                          ; move DE to "Graphics..." string address
7C5E 2E 64       10 775 ld      l, $64                      ; HL points to string screen address
7C60 CD 8D 6F    10 776 call    Print_String                ; print "Graphics..."
7C63 DD 2E 84    10 777 ld      ixl, $84                    ; IX points to "Antonio Luque" string attributes address
7C66 06 19       10 778 ld      b, 25                       ; string length (loop counter)
7C68 CD A5 78    10 779 call    Screen_Apply_Color_Loop     ; apply color to string area
7C6B 13          10 780 inc     de                          ; move DE to "Antonio Luque" string address
7C6C 2E 84       10 781 ld      l, $84                      ; HL points to string screen address
7C6E CD 8D 6F    10 782 call    Print_String                ; print "Antonio Luque"
7C71 DD 2E E9    10 783 ld      ixl, $E9                    ; IX points to "Press any key" string attributes address
7C74 01 38 0D    10 784 ld      bc, (13*256)+WHITE_PAPER    ; B = string length (loop counter), C = color attributes
7C77 CD A5 78    10 785 call    Screen_Apply_Color_Loop     ; apply color to string area
7C7A 13          10 786 inc     de                          ; move DE to "Press any key" string address
7C7B 2E E9       10 787 ld      l, $E9                      ; HL points to string screen address
7C7D CD 8D 6F    10 788 call    Print_String                ; print "Press any key"
7C80 CD F9 6E    10 789 call    Input_Key_Scan              ; wait for a key pressed
7C83 C3 B2 79    10 790 jp      Screen_Menu_Strings         ; return to main menu
7C86             10 792 ; ----------------------------------------------------------------------------------------------------------------------
7C86             10 793 ; Screen_Menu_Hexagons: draw menu hexagons on screen
7C86             10 794 ;
7C86             10 795 ; Input:    -
7C86             10 796 ;
7C86             10 797 ; Output:   -
7C86             10 798 ;
7C86             10 799 ; Uses:     TOKEN_COLOR (current token color)
7C86             10 800 ;
7C86             10 801 ; Destroys: A, BC, DE, HL, IX, IY
7C86             10 802 ; ----------------------------------------------------------------------------------------------------------------------
7C86             10 803 Screen_Hexagons:
7C86 FD 21 EA 66 10 804 ld      iy, MENU_HEXAGONS           ; IY points to menu hexagons screen addresses
7C8A 3E 07       10 805 ld      a, WHITE                    ; set hexagon color
7C8C 32 9E 61    10 806 ld      (TOKEN_COLOR), a            ; save hexagon color
7C8F 11 7E 65    10 807 ld      de, HEXAGON_EMPTY           ; DE points to empty hexagon sprite address
7C92 06 1C       10 808 ld      b, 28                       ; number of empty hexagons (loop counter)
7C94 CD AB 7C    10 809 call    Screen_Hexagons_Loop        ; draw empty hexagons
7C97 3E 05       10 810 ld      a, CYAN_COLOR               ; set token color
7C99 32 9E 61    10 811 ld      (TOKEN_COLOR), a            ; save hexagon color
7C9C 11 3E 66    10 812 ld      de, HEXAGON_TOKEN           ; DE points to token sprite address
7C9F 06 06       10 813 ld      b, 6                        ; number of cyan tokens (loop counter)
7CA1 CD AB 7C    10 814 call    Screen_Hexagons_Loop        ; draw cyan tokens
7CA4 3E 02       10 815 ld      a, RED_COLOR                ; set token color
7CA6 32 9E 61    10 816 ld      (TOKEN_COLOR), a            ; save hexagon color
7CA9 06 06       10 817 ld      b, 6                        ; number of red tokens (loop counter)
7CAB             10 818 Screen_Hexagons_Loop:
7CAB FD 6E 00    10 819 ld      l, (iy+0)                   ; HL points to hexagon/token screen address
7CAE FD 66 01    10 820 ld      h, (iy+1)
7CB1 CD 25 6E    10 821 call    Draw_Hexagon_Color          ; apply color to hexagon/token area
7CB4 D5          10 822 push    de                          ; store hexagon/token sprite address
7CB5 CD F7 6D    10 823 call    Draw_Sprite_Hexagon         ; draw hexagon sprite
7CB8 D1          10 824 pop     de                          ; restore hexagon/token sprite address
7CB9 FD 23       10 825 inc     iy                          ; move IY to next hexagon/token screen address
7CBB FD 23       10 826 inc     iy
7CBD 10 EC       10 827 djnz    Screen_Hexagons_Loop        ; repeat for each hexagon/token
7CBF C9          10 828 ret
7CC0             10 830 ; ----------------------------------------------------------------------------------------------------------------------
7CC0             10 831 ; Screen_Clear_Text: clean a text attributes area
7CC0             10 832 ;
7CC0             10 833 ; Input:    HL = text area attributes address
7CC0             10 834 ;
7CC0             10 835 ; Output:   -
7CC0             10 836 ;
7CC0             10 837 ; Destroys: BC, DE, HL
7CC0             10 838 ; ----------------------------------------------------------------------------------------------------------------------
7CC0             10 839 Screen_Clear_Text:
7CC0 01 30 00    10 840 ld      bc, 8*6                     ; length of attributes area: width x height (in bytes)
7CC3             10 841 Screen_ClearText_Loop
7CC3 11 18 00    10 842 ld      de, 24                      ; displacement for each text row
7CC6 19          10 843 add     hl, de                      ; add displacement to text area attributes address
7CC7 54          10 844 ld      d, h                        ; DE points to text area attributes address
7CC8 5D          10 845 ld      e, l
7CC9 36 00       10 846 ld      (hl), 0                     ; set attributes color (black) for 1st byte of current row
7CCB 13          10 847 inc     de                          ; move DE to next byte attribute address
7CCC ED A0       10 848 ldi                                 ; set attributes color for the rest of bytes of current row
7CCE ED A0       10 849 ldi
7CD0 ED A0       10 850 ldi
7CD2 ED A0       10 851 ldi
7CD4 ED A0       10 852 ldi
7CD6 ED A0       10 853 ldi
7CD8 ED A0       10 854 ldi
7CDA ED A0       10 855 ldi
7CDC EA C3 7C    10 856 jp      pe, Screen_ClearText_Loop   ; repeat for each row
7CDF C9          10 857 ret

; File #0: C:\Users\Antonio Luque\source\Repos\Hex2\Z80CodeFiles\Hex2.z80asm

7CE0             0 19 ; ----------------------------------------------------------------------------------------------------------------------
7CE0             0 20 ; Credits and acknowledgements:
7CE0             0 21 ;
7CE0             0 22 ; - Einar Saukas and his amazing BRAINIAC: https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC,
7CE0             0 23 ;   PATHFINDER adaptation: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER, loading screen,
7CE0             0 24 ;   "King+" font and TOKEN graphics.
7CE0             0 25 ; - Greg Surma article: https://gsurma.medium.com/hex-creating-intelligent-opponents-with-minimax-driven-ai-part-1-%CE%B
7CE0             0 26 ;   1-%CE%B2-pruning-cc1df850e5bd
7CE0             0 27 ; - Jack van Rijswijck's thesis: https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
7CE0             0 28 ; - ChibiAkumas lessons: https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
7CE0             0 29 ; - Santiago Romero assembler course: https://wiki.speccy.org/cursos/ensamblador/indice
7CE0             0 30 ;
7CE0             0 31 ; - Special thanks to my wife Sonia.
7CE0             0 32 ; ----------------------------------------------------------------------------------------------------------------------
