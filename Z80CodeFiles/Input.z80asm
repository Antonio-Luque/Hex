; ----------------------------------------------------------------------------------------------------------------------
; Input.z80asm
; Coded by Antonio Luque
; ----------------------------------------------------------------------------------------------------------------------

MAX_CHARS               equ     2                           ; maximum of input chars

; ----------------------------------------------------------------------------------------------------------------------
; Input_Move: wait for input a move from keyboard
; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
;
; Input:    -
;
; Output:   HL = player move address (PLAYER_MOVE)
;
; Uses:     CHAR_COUNT (number of current characters in input player move)
;           TOKEN_COLOR (current token color)
;
; Destroys: A, A', BC, DE, IX
; ----------------------------------------------------------------------------------------------------------------------
Input_Move:
                        ld      bc, PLAYER_MOVE             ; BC points to player move address
                        push    bc                          ; store pointer to player move address
                        xor     a                           ; A = 0
                        ld      (CHAR_COUNT), a             ; initialize char counter

                        ld      ix, $5A83                   ; IX points to attribute address of RED input text
                        ld      hl, $5083                   ; HL points to screen address of RED input text
                        ld      a, (TOKEN_COLOR)            ; check current player color
                        cp      RED_COLOR                   ; is RED the current token color?
                        jr      z, Input_Start              ; yes, start input
                        ld      ix, $5919                   ; IX points to attribute address of CYAN input text
                        ld      hl, $4819                   ; HL points to screen address of CYAN input text
Input_Start
                        ld      a, '_'                      ; text input cursor
                        ld      (ix+0), WHITE_FLASH1        ; set attributes for cursor (flash)
                        call    Print_Char                  ; print cursor
Input_Loop
                        call    Input_Key_Scan              ; scan for a key pressed
                        cp      $0D                         ; is it ENTER?
                        jr      z, Input_Exit               ; yes, go to the end of routine
                        cp      '0'                         ; is it DELETE?
                        jr      z, Input_Delete             ; yes, perform delete char
                        ex      af, af'                     ; store ASCII code in A'
                        ld      a, (CHAR_COUNT)             ; A = number of chars inserted
                        cp      MAX_CHARS                   ; chars limit reached?
                        jr      z, Input_Loop               ; yes, repeat input loop (do not insert char)
                        or      a                           ; is the first char to be inserted? (A = 0)
                        jr      z, Input_First_Letter       ; yes, perform input of 1st char (column)
                        cp      1                           ; is the secord char to be inserted? (A = 1)
                        jr      z, Input_First_Number       ; yes, perform input of 2nd char (row)

; ----------------------------------------------------------------------------------------------------------------------
; char is valid: 'a'-'g' (1st char) and '1'-'7' (2nd char)
; ----------------------------------------------------------------------------------------------------------------------
Input_Char_OK
                        ld      (bc), a                     ; set char in ASCII move
                        inc     bc                          ; increment ASCII move position
                        ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
                        call    Print_Char                  ; print key pressed
                        ld      a, (CHAR_COUNT)             ; increment char counter
                        inc     a
                        ld      (CHAR_COUNT), a
                        inc     l                           ; increment X position of current input screen location
                        inc     ixl                         ; increment X position of current input attr location
                        dec     a                           ; is the first char?
                        jr      nz, Input_Start             ; no, get next char
                        ld      a, '-'                      ; yes, print dash
                        call    Print_Char                  ; print dash
                        inc     l                           ; increment X position of current input screen location
                        inc     ixl                         ; increment X position of current input attr location
                        jr      Input_Start                 ; get next char (do until ENTER is pressed)

; ----------------------------------------------------------------------------------------------------------------------
; restrict first char to 'a'-'g'
; ----------------------------------------------------------------------------------------------------------------------
Input_First_Letter 
                        ex      af, af'                     ; restore ASCII code
                        cp      'a'                         ; is it < 'a'?
                        jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
                        cp      'h'                         ; is it >= 'h'?
                        jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
                        jr      Input_Char_OK               ; char is valid

; ----------------------------------------------------------------------------------------------------------------------
; restrict second char to '1'-'7'
; ----------------------------------------------------------------------------------------------------------------------
Input_First_Number 
                        ex      af, af'                     ; restore ASCII code
                        cp      '1'                         ; is it < '1'?
                        jr      c, Input_Loop               ; yes, repeat input loop (char is not allowed)
                        cp      '8'                         ; is it >= '8'?
                        jr      nc, Input_Loop              ; yes, repeat input loop (char is not allowed)
                        jr      Input_Char_OK               ; char is valid

; ----------------------------------------------------------------------------------------------------------------------
; erase last char, update input screen location and string pointer
; ----------------------------------------------------------------------------------------------------------------------
Input_Delete
                        ld      a, (CHAR_COUNT)             ; get char counter
                        or      a                           ; is it 0?
                        jr      z, Input_Loop               ; yes, repeat input loop (no chars to delete)
                        cp      2                           ; is it 2?
                        jr      nz, Input_Delete_Dash       ; no, delete dash
                        jr      Input_Decrement_Chars       ; continue delete
Input_Delete_Dash  
                        ld      a, ' '                      ; empty char
                        ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
                        call    Print_Char                  ; delete char
                        dec     l                           ; decrement X position of input screen location
                        dec     ixl                         ; decrement X position of input attr location
Input_Decrement_Chars 
                        ld      a, (CHAR_COUNT)             ; decrement char counter
                        dec     a
                        ld      (CHAR_COUNT), a
                        dec     bc                          ; decrement ASCII move position
                        ld      a, ' '                      ; empty char
                        ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
                        call    Print_Char                  ; delete cursor and last char
                        dec     l                           ; decrement X position of player input screen location
                        dec     ixl                         ; decrement X position of player input attr location
                        jp      Input_Start                 ; get next char

; ----------------------------------------------------------------------------------------------------------------------
; player finished move (ENTER pressed)
; ----------------------------------------------------------------------------------------------------------------------
Input_Exit
                        ld      a, (CHAR_COUNT)             ; check char counter  
                        cp      2                           ; is it < 2?
                        jp      c, Input_Loop               ; yes, repeat input loop (move is incomplete)
                        ld      a, ' '                      ; empty char
                        ld      (ix+0), WHITE_FLASH0        ; restore attributes (no flash)
                        call    Print_Char                  ; delete cursor
                        pop     hl                          ; restore pointer to player move address
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; Input_Key_Scan: wait for a key pressed and return its ASCII code
;
;                           Bit
;  Port  |   0   |   1   |   2   |   3   |   4   |
;  ------+-------+-------+-------+-------+-------+
;  $FEFE | Shift |   Z   |   X   |   C   |   V   |
;  $FDFE |   A   |   S   |   D   |   F   |   G   |
;  $FBFE |   Q   |   W   |   E   |   R   |   T   |
;  $F7FE |   1   |   2   |   3   |   4   |   5   |
;  $EFFE |   0   |   9   |   8   |   7   |   6   |
;  $DFFE |   P   |   O   |   I   |   U   |   Y   |
;  $BFFE | Enter |   L   |   K   |   J   |   H   |
;  $7FFE | Space |  Sym  |   M   |   N   |   B   |
;
;  Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed
;
; Input:    -
;
; Output:   A = ASCII code of key pressed
;
; Destroys: DE
; ----------------------------------------------------------------------------------------------------------------------
Input_Key_Scan:
                        push    bc                          ; store registers
                        push    hl
Input_Key_Released
                        ld      bc, $FEFE                   ; set keyboard port (see above)
Input_Key_Released_Line
                        in      a, (c)                      ; read port
                        cpl                                 ; invert bits
                        and     %00011111                   ; check 0 to 4 bits
                        jr      nz, Input_Key_Released      ; repeat from the beginning until no key is pressed
                        rlc     b                           ; move BC to the next port
                        jr      c, Input_Key_Released_Line  ; repeat for each port
                        ld      de, 5                       ; number of keys in each port (KEY_MAP displacement)
Input_Key_Pressed_Begin
                        ld      hl, KEY_MAP                 ; HL points to KEY_MAP array
Input_Key_Pressed_Line
                        in      a, (c)                      ; read port
                        cpl                                 ; invert bits
                        and     %00011111                   ; check 0 to 4 bits
                        jr      nz, Input_Key_Pressed       ; if any key is pressed, process it
                        add     hl, de                      ; HL points to the next KEY_MAP block
                        rlc     b                           ; move BC to the next port
                        jr      c, Input_Key_Pressed_Line   ; repeat for each port
                        jr      Input_Key_Pressed_Begin     ; repeat from the beginning until any key is pressed
Input_Key_Next
                        inc     hl                          ; move HL to the next character
Input_Key_Pressed
                        rra                                 ; rotate bits of port readed
                        jr      nc, Input_Key_Next          ; repeat until find the key pressed
                        ld      a, (hl)                     ; return key pressed (ASCII) in A
                        pop     hl                          ; restore registers
                        pop     bc
                        ret
