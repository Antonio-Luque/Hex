;
; Input.z80asm
; Coded by Antonio Luque
;
LAST_K          equ $5C08               ; RAM address of last key pressed system variable
KEY_SCAN        equ $028E               ; ROM address of keyboard scanning routine

MESSAGE_XY      equ $08B8               ; XY question message screen location
BLUETEXT_XY     equ $1910               ; XY blue player name screen location
REDTEXT_XY      equ $0188               ; XY red player name screen location
LEVEL_XY        equ $10B0               ; XY level text message screen location
LEVELNUM_XY     equ $16B0               ; XY level number screen location

MAX_CHARS       equ 2                   ; maximum of input chars

;
; Input game options: take game options from keyboard
;
; Input:    -
; Output:   NUM_PLAYERS, HUMAN_COLOR, AI_DEPTH
; Destroys: A, HL, BC, E
;
Input_Options:
                ; choice of number of players

                ld hl,STR_PLAYERS       ; HL points to question # players string
                ld bc,MESSAGE_XY        ; set string position
                call Print_String       ; prints string
           
                ld bc,$3132             ; set input limits to key '1' ($31) or key '2' ($32)
                call Read_Key           ; read key from keyboard

                push af
                call Clear_Alert        ; clear alert message (if any)

                ; clear last players moves

                ld hl,STR_EMPTY4        ; HL points to a 4 blanks string
                ld bc,BLUE_XY           ; set XY BLUE player input/output screen location
                call Print_String       ; clear BLUE player last move

                ld hl,STR_EMPTY4        ; HL points to a 4 blanks string
                ld bc,RED_XY            ; set XY RED player input/output screen location
                call Print_String       ; clear RED player last move

                ; clear level

                ld hl,STR_NOLEVEL       ; HL points to a 7 blanks string
                ld bc,LEVEL_XY          ; set string position
                call Print_String       ; prints string

                pop af                  ; restores key pressed
                ld (NUM_PLAYERS),a      ; stores # of players choice
                cp '2'                  ; is it '2'?
                jr z,TwoPlayers         ; yes, skip rest of choices

                call Draw_Board         ; draw an empty hexagons board

                ; choice of color

                ld hl,STR_COLORS        ; HL points to question color string
                ld bc,MESSAGE_XY        ; set string position
                call Print_String       ; prints string
          
                ld bc,$6272             ; set input limits to key 'b' ($62) or key 'r' ($72)
                call Read_Key           ; read key from keyboard

                cp 'b'                  ; is it 'B'?
                jr z,BlueChosen         ; yes, continue with BLUE

                ld a,RED_TOKEN          ; get RED color
                ld (HUMAN_COLOR),a      ; saves chosen color
                ld hl,STR_PLAYER        ; HL points to "Player" string
                ld bc,REDTEXT_XY        ; set string position
                call Print_String       ; prints string

                ld hl,STR_SPECCY        ; HL points to "Speccy" string
                ld bc,BLUETEXT_XY       ; set string position
                call Print_String       ; prints string
 
                jp GameLevel            ; continue to game level choice

BlueChosen 
                ld a,BLUE_TOKEN         ; get BLUE color 
                ld (HUMAN_COLOR),a      ; saves chosen color
                ld hl,STR_PLAYER        ; HL points to "Player" string
                ld bc,BLUETEXT_XY       ; set string position
                call Print_String       ; prints string

                ld hl,STR_SPECCY        ; HL points to "Speccy" string
                ld bc,REDTEXT_XY        ; set string position
                call Print_String       ; prints string

GameLevel
                ; choice of game level

                ld hl,STR_LEVEL         ; HL points to level string
                ld bc,MESSAGE_XY        ; set string position
                call Print_String       ; prints string

                call ReadKeys_1to4      ; read key from keyboard in range 1-4

                ld bc,LEVELNUM_XY       ; set char (level number) position

                push af                 ; stores level number (char)
                call Print_Char         ; prints level number

                pop af                  ; restores level number (char)
                sub $30                 ; converts to number
                ld (GAME_LEVEL),a       ; saves game level

                ld hl,STR_LEVELTEXT     ; HL points to "Level" string
                ld bc,LEVEL_XY          ; set string position
                call Print_String       ; prints string

                jp ExitOptions          ; one player options choosen

TwoPlayers
                call Draw_Board         ; draw an empty hexagons board

                ld hl,STR_PLAYER        ; HL points to "Player" string
                ld bc,BLUETEXT_XY       ; set blue string position
                call Print_String       ; prints string

                ld hl,STR_PLAYER        ; HL points to "Player" string
                ld bc,REDTEXT_XY        ; set red string position
                call Print_String       ; prints string

ExitOptions
                ld hl,STR_CLEAR         ; HL points to a blank string
                ld bc,MESSAGE_XY        ; set string position
                call Print_String       ; prints string

                ret
;
; Read_Key: read a key from keyboard
;
; Input:    BC - ASCII char codes that limit input
; Output:    A - ASCII char code of key pressed
; Destroys:  -
;
Read_Key:
                xor a                   ; A = 0
                in a,($FE)              ; read keyboard throught reading port
                cpl                     ; invert read data (0->1, 1->0)
                and %00011111           ; are keys released?
                jr nz,Read_Key          ; no, read keyboard again

                xor a                   ; reset last key pressed
                ld (LAST_K),a

LimitInput 
                ld a,(LAST_K)           ; get last key pressed
                cp b                    ; is it B key?
                ret z                   ; yes, return
                cp c                    ; is it C key?
                jr nz,LimitInput        ; no, repeat until B or C keys are chosen

                ret
;
; ReadKeys_1to4: read a key from keyboard in range 1-4
;
; Input:     -
; Output:    A - ASCII char code of chosen option
; Destroys: HL, BC, E
;
ReadKeys_1to4:
                ld bc,$F7FE             ; set input range for port (keys 1 to 5)

RangeLoop
                ld hl,KEYS_MAP          ; HL points to keys chars "1" to "4"
                ld e,4                  ; set loop counter
                xor a                   ; A = 0
                in a,(c)                ; read keyboard throught reading port
                and %00001111           ; mask the first four bits (1-4)

NextKey
                srl a                   ; shift A, bit 0 sets carry flag
                jr nc,KeyPressed        ; a key (1-4) was pressed

                inc hl                  ; HL points to the next key char
                dec e                   ; decrements loop counter
                jr nz,NextKey           ; repeat for the next key

                jp RangeLoop            ; repeat until a key (1-4) is pressed

KeyPressed
                ld a,(hl)               ; return key char

                ret
;
; InputString: input a text string from keyboard
; Based on assembler course by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
;
; Input:    HL - pointer to string where input text
;           BC - XY player input screen location
; Output:   HL - pointer to first char of input text string (ending with 0)
; Destroys: A
;
Input_String:
                push hl                 ; stores registers 
                push de
            
                ld bc,(MOVE_POSXY)      ; get current player XY input/output screen location

                xor a
                ld (CHAR_COUNT),a       ; char counter = 0

InputStart
                ld a,CYAN_FLASH1        ; set attributes for cursor (flash)
                ld (CHAR_ATTR),a
                ld a,'_'                ; text input cursor
                call Print_Char         ; prints cursor
                ld a,CYAN_FLASH0        ; restores attributes (no flash)
                ld (CHAR_ATTR),a

                xor a
                ld (LAST_K),a           ; clears last key pressed

InputLoop
                push hl                 ; stores registers
                push bc

                call KEY_SCAN           ; call KEY_SCAN ROM rutine

                pop bc                  ; restores registers
                pop hl

                ld a,(LAST_K)           ; A = ASCII of key pressed

                cp $0D                  ; is it ENTER?
                jp z,InputEnd           ; yes, go to the end of rutine

                cp $0C                  ; is it DELETE?
                jr z,InputDelete        ; yes, perform delete char

                ex af,af'               ; stores ASCII code in A'

                ld a,(CHAR_COUNT)       ; A = number of chars inserted

                cp MAX_CHARS            ; chars limit reached?
                jr z,InputLoop          ; yes, repeat input loop (do not insert char)

                or a                    ; is the first char to be inserted? (A = 0)
                jr z,FirstLetter        ; yes, perform input of 1st char (column)

                cp 1                    ; is the secord char to be inserted? (A = 1)
                jr z,FirstNumber        ; yes, perform input of 2nd char (row)
;
; char is valid: 'a'-'g' (1st char) and '1'-'7' (2nd char)
;
CharOK
                ld (hl),a               ; stores char in current string position
                inc hl                  ; increments string position
                call Print_Char         ; print char in player input screen location

                ld a,(CHAR_COUNT)       ; increments char counter
                inc a
                ld (CHAR_COUNT),a

                inc b                   ; increments X position of player input screen location

                dec a                   ; is the first char?
                jr nz,InputStart        ; no, get next char

                ld a,'-'                ; yes, print dash
                call Print_Char
                inc b                   ; increments X position of player input screen location

                jp InputStart           ; get next char (Do until ENTER is pressed)
;
; restricts first char to 'a'-'g'
;
FirstLetter 
                ex af,af'               ; restores ASCII code

                cp 'a'                  ; is it < 'a'
                jr c,InputLoop          ; yes, repeat input loop (char is not allowed)

                cp 'h'                  ; is it >= 'h'
                jr nc,InputLoop         ; yes, repeat input loop (char is not allowed)

                jp CharOK               ; char is valid
;
; restricts second char to '1'-'7'
;
FirstNumber 
                ex af,af'               ; restores ASCII code

                cp '1'                  ; is it < '1'
                jr c,InputLoop          ; yes, repeat input loop (char is not allowed)

                cp '8'                  ; is it >= '8'
                jr nc,InputLoop         ; yes, repeat input loop (char is not allowed)

                jp CharOK               ; char is valid
;
; erases last char, updates player input screen location and string pointer
;
InputDelete
                ld a,(CHAR_COUNT)       ; get char counter

                or a                    ; is it 0?
                jr z,InputLoop          ; yes, repeat input loop (no chars to delete)

                cp 2                    ; is it 2?
                jr nz,DeleteDash        ; no, delete dash

                jp DecCharCnt           ; continue delete

DeleteDash  
                ld a,' '                ; delete dash
                call Print_Char
                dec b                   ; decrement X position of player input screen location

DecCharCnt 
                ld a,(CHAR_COUNT)       ; decrements char counter
                dec a
                ld (CHAR_COUNT),a

                dec hl                  ; decrement string position

                ld a,' '                ; delete cursor and last char
                call Print_Char       
                dec b                   ; decrement X position of player input screen location

                jp InputStart           ; get next char
;
; player finished move (ENTER pressed)
;
InputEnd
                ld a,(CHAR_COUNT)       ; check char counter  

                cp 2                    ; is it < 2?
                jp c,InputLoop          ; yes, repeat input loop (move is incomplete)

                ld a,' '                ; delete cursor
                call Print_Char
                xor a                   ; put end of string (0)
                ld (hl),a

                pop de                  ; restores registers
                pop hl

                ret
;
; Strings
;
STR_PLAYERS     defm "One or two players? 1/2\0"
STR_COLORS      defm "Choose blue or red, b/r\0"
STR_LEVEL       defm "Select game level, 1-4 \0"
STR_CLEAR       defm "                       \0"

STR_SPECCY      defm "Speccy\0"
STR_PLAYER      defm "Player\0"
STR_LEVELTEXT   defm "Level\0"
STR_NOLEVEL     defm "       \0"

KEYS_MAP        defb '1', '2', '3', '4'

;
; Variables
;
NUM_PLAYERS     defb 0
HUMAN_COLOR     defb 0
GAME_LEVEL      defb 0

HUMAN_MOVE      defb 0, 0, 0, 0
CHAR_COUNT      defb 0
