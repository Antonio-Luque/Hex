; ----------------------------------------------------------------------------------------------------------------------
; PathFinder.z80asm
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
;
; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
; ----------------------------------------------------------------------------------------------------------------------

EMPTY                   equ     $00                         ; empty positions on the board
SKIPPED                 equ     $01                         ; skipped positions on the board
FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
VICTORY                 equ     $03                         ; internal value if victory
WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor

CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
;
; Input:    -
;
; Output:   A   = FRIEND if current token color is cyan, or A = ENEMY if current token color is red
;           P/V = flag unset if A is FRIEND, flag set if A is ENEMY
;
; Uses:     TOKEN_COLOR (current token color)
;
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Friend:
                        ld      a, (TOKEN_COLOR)            ; get current player color
                        xor     $07                         ; is current player color cyan?
                        ret     po                          ; yes, return FRIEND 
                        ld      a, ENEMY                    ; no, return ENEMY
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
;
; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
;           HL = CYAN_POSITIONS token address
;
; Output:   A   = inverted side (FRIEND or ENEMY)
;           P/V = flag unset if inverted side is FRIEND, flag set if inverted side is ENEMY
;
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_PutToken:
                        ld      (hl), a                     ; put token at cyan position
                        inc     h                           ; move HL to red position address
                        xor     $7C                         ; invert side
                        ld      (hl), a                     ; put token at red position
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
;
; Input:    HL = CYAN_POSITIONS token address
;
; Output:   -
;
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_EraseToken:
                        ld      (hl), EMPTY                 ; erase token at cyan position
                        inc     h                           ; move HL to red position address
                        ld      (hl), EMPTY                 ; erase token at red position
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
;
; Input:    DE = cyan or red board address (destiny)
;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
;
; Output:   -
;
; Destroys: BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_CopyPositions:
                        ld      bc, 7*7                     ; number of positions to be copied
PathFinder_CopyLoop
                        inc     l                           ; skip borders on positions
                        inc     l
                        inc     e                           ; skip borders on board
                        inc     e
                        ldi                                 ; copy a row of 7 positions
                        ldi
                        ldi
                        ldi
                        ldi
                        ldi
                        ldi
                        jp      pe, PathFinder_CopyLoop     ; repeat for each row
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Update: update current board position during heuristic function evaluation
;
; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
; second lowest distance of p's neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
; adjacent".
;
; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
; follows, depending on current content:
;
; * SKIPPED: 1 + distance of neighbor closest to goal
; * FRIEND:  distance of neighbor closest to goal
; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
;
; Input:    Z  = flag set when (HL) is FRIEND
;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
;           HL = current position address (on either cyan boards or red boards)
;
; Output:   -
;
; Destroys: B, DE
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Update:
                        jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
                        ld      b, (hl)                     ; check current position
                        djnz    PathFinder_EMPTY
; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
PathFinder_Skipped:
                        ld      (hl), c                     ; save current distance in current position
                        inc     (hl)                        ; increment distance of current position
                        res     6, (hl)                     ; reset friendly token flag
                        ex      de, hl                      ; store current position in DE
@Queue_Tail
                        ld      hl, $0000                   ; HL points to queue tail address (changed before call)
                        inc     l                           ; move queue tail down
                        ld      (hl), e                     ; store position into queue tail
                        ld      (@Queue_Tail+1), hl         ; update queue tail
                        ex      de, hl                      ; restore current position
                        ret
; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
PathFinder_Friendly
                        ld      (hl), c                     ; save current distance in current position
                        set     6, (hl)                     ; set friendly token flag
                        ld      b, l                        ; save current position in B
                        pop     de                          ; preserve RET address
                        ex      (sp), hl                    ; retrieve queue head
                        ld      (hl), b                     ; push this position into queue head
                        dec     l                           ; move queue head up
                        ex      (sp), hl                    ; update queue head
                        push    de                          ; restore RET address
                        ret
; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
PathFinder_EMPTY
                        bit     6, c                        ; is current distance friendly?
                        jr      nz, PathFinder_Skipped      ; yes, set (HL) = C+1 and insert HL in queue tail
                        inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
;
; Input:    -
;
; Output:   A = -1, if down edge couldn't be reached
;           A =  0, if there is chain of connected cyan tokens between the two edges
;           A = last edge position visited (-1), otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Cyan_UpDown:
                        ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
                        ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down

; entry point for PathFinder_VictoryPath
PathFinder_Cyan_CheckPath:
                        ld      iy, $0900                   ; IYH = distance to check edge positions
                                                            ; IYL = last edge position visited
                        ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
                        ld      (@Queue_Tail+1), hl         ; initialize cyan queue tail
                        push    hl                          ; store cyan queue head

                        ; set up cyan board (up-down) start positions distances

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      c, VICTORY+$40              ; set start positions distance + friendly flag
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        inc     l                           ; move HL to next start position address
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        inc     l
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
;
; Input:    -
;
; Output:   A = -1, if up edge couldn't be reached
;           A =  0, if there is chain of connected cyan tokens between the two edges
;           A = last edge position visited (-1), otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Cyan_DownUp:
                        ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
                        ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up

                        ld      iy, $F700                   ; IYH = distance to check edge positions
                                                            ; IYL = last edge position visited
                        ld      hl, (@Queue_Tail+1)         ; retreive cyan queue tail
                        push    hl                          ; initialize cyan queue head

                        ; set up cyan board (down-up) start positions distances

                        ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
                        dec     l                           ; move HL to cyan boad down-up address (last position)
                        ld      c, VICTORY+$40              ; set start positions distance + friendly flag
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        dec     l                           ; move HL to next start position address
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        dec     l                           
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
;
; Input:    -
;
; Output:   A = -1, if right edge couldn't be reached
;           A =  0, if there is chain of connected cyan tokens between the two edges
;           A = last edge position visited (-1), otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Red_LeftRight:
                        ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
                        ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from red positions to red board left-right

; entry point for PathFinder_VictoryPath
PathFinder_Red_CheckPath
                        ld      iy, $0100                   ; IYH = distance to check edge positions
                                                            ; IYL = last edge position visited
                        ld      hl, RED_QUEUE_AREA          ; HL points to red queue area address
                        ld      (@Queue_Tail+1), hl         ; initialize red queue tail
                        push    hl                          ; store red queue head

                        ; set up red board (left-right) start positions distances

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      c, VICTORY+$40              ; set start positions distance + friendly flag
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        ld      l, (RED_BOARD_LEFT_RIGHT+18)%256
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
                        jp      Path_Finder_First           ; calculate two-distances of red board (left-right)

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
;
; Input:    -
;
; Output:   A = -1, if left edge couldn't be reached
;           A =  0, if there is chain of connected cyan tokens between the two edges
;           A = last edge position visited (-1), otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Red_RightLeft:
                        ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
                        ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from red positions to red board right-left

                        ld      iy, $FF00                   ; IYH = distance to check edge positions
                                                            ; IYL = last edge position visited
                        ld      hl, (@Queue_Tail+1)         ; retreive red queue tail
                        push    hl                          ; initialize red queue head

                        ; set up red board (right-left) start positions distances

                        ex      de, hl                      ; take advantage of last "CopyPositions" execution
                        dec     l                           ; move HL to red board right-left address (last position)
                        ld      c, VICTORY+$40              ; set start positions distance + friendly flag
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        ld      l, (RED_BOARD_RIGHT_LEFT+52)%256
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
                        jp      Path_Finder_First           ; calculate red two-distance (right-left)

; ----------------------------------------------------------------------------------------------------------------------
; Path_Finder: calculate two-distance metric for each board position
;
; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
;
; Input:    HL  = cyan or red queue area address
;           IYH = distance to check edge positions
;           IYL = 0
;
; Output:   A = -1, if corresponding edge couldn't be reached
;           A =  0, if there is chain of connected (color) tokens between the two edges
;           A = last edge position visited (-1), otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
Path_Finder:
                        inc     l                           ; move queue head down
                        push    hl                          ; preserve queue head address
                        ld      l, (hl)                     ; retrieve next position to be checked
                        inc     h                           ; move HL to corresponding board address
                        ld      c, (hl)                     ; retrieve distance from this position to start
                        ld      e, l                        ; store current position

                        ; look for adjacent positions

                        ld      a, l                        ; get current position
                        add     a, iyh                      ; add distance to check edge positions
                        ld      l, a                        ; move HL to calculated position address
                        bit     7, (hl)                     ; is it an edge?
                        jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions

                        ld      a, FRIEND                   ; set distance to compare with
; return point from PathFinder_Adjacent
Path_Finder_Neighbors
                        ld      l, e                        ; restore current position to be checked
                        inc     l                           ; move HL to right neighbor address
                        cp      (hl)                        ; check right neighbor distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        dec     l                           ; move HL to left neighbor address
                        dec     l
                        cp      (hl)                        ; check left neighbor distance
                        call    nc, PathFinder_Update       ; (repeat for each neighbor)
                        ld      de, -WIDTH
                        add     hl, de
                        cp      (hl)                        ; check upper-left neighbor distance
                        call    nc, PathFinder_Update 
                        inc     l
                        cp      (hl)                        ; check upper-right neighbor distance
                        call    nc, PathFinder_Update
                        ld      de, WIDTH*2
                        add     hl, de
                        cp      (hl)                        ; check lower-left neighbor distance
                        call    nc, PathFinder_Update
                        inc     l
Path_Finder_First
                        cp      (hl)                        ; check lower-right neighbor distance
                        call    nc, PathFinder_Update
                        pop     hl                          ; retreive queue head address
                        ld      a, (@Queue_Tail+1)          ; get queue tail address (low-byte)
                        cp      l                           ; is queue empty?
                        jp      nz, Path_Finder             ; no, repeat until queue is empty

                        ld      a, iyl                      ; get last edge position visited
                        dec     a                           ; return A = -1, if the edge couldn't be reached
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; Check adjacent hexagons.
;
; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
; "two cells are adjacent if they share a common edge on the board."
;
; Input:    E  = current position
;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
;                edge number)
;
; Output:   A = 0, if there is a chain of connected tokens of the same color between the two edges.
;           A = FRIEND and E = current position, otherwise.
;
; Destroys: DE, HL
; ----------------------------------------------------------------------------------------------------------------------
Path_Finder_Adjacent
                        ld      a, VICTORY+$40              ; set victory distance + friendly flag
                        cp      c                           ; is current distance victory and friendly?
                        jr      z, Path_Finder_Abort        ; yes, abort path_finder

                        ld      iyl, e                      ; update last edge position visited
                        ld      d, h                        ; store pointer to current position address in DE
                        ld      l, (hl)                     ; get current edge position
                        sla     l                           ; calculate vector table routine index
                        inc     h                           ; move HL to (cyan or red) vector table routine address
                        ld      a, (hl)                     ; get low byte of vector table routine address
                        inc     l                           ; move HL to high byte of vector table routine address
                        ld      h, (hl)                     ; get high byte of vector table routine address
                        ld      l, a                        ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
                        ld      a, FRIEND                   ; set distance to compare with
                        jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
Path_Finder_Abort
                        pop     hl                          ; restore queue head address
                        xor     a                           ; return A = 0
                        ret

; ----------------------------------------------------------------------------------------------------------------------
;  Check two-distance of RED adjacents
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_RED_Edge_0
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2                     ; calculate distance to adjacent #2
                        add     hl, de                      ; move HL to adjacent #2 address
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
                        ld      de, 9                       ; calculate distance to adjacent #3
                        add     hl, de                      ; move HL to adjacent #3 address
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update       ; (repeat for each adjacent)
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_1
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2
                        add     hl, de
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_2
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update                     
                        ld      de, -9*6
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_3
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, -9*3
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9*4
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_4
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      de, -9*6
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_5
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, -9*5
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update 
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update 
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_6
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, -9*6
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update 
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update   
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

; ----------------------------------------------------------------------------------------------------------------------
;  Check two-distance of CYAN adjacents
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_CYAN_Edge_0
                        ex      de, hl                      ; restore pointer to current position address
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent of edge number 5
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent of edge number 6
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_1
                        ex      de, hl                      ; restore pointer to current position address
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_2
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        inc     l
                        inc     l
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_3
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        inc     l
                        inc     l
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_4
                        ex      de, hl                      ; restore pointer to current position address
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        dec     l
                        dec     l
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_5
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        dec     l                    
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_6
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        dec     l                    
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      e, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Score: calculate board score depending on speccy color
;
; Input:    P/V = flag unset if speccy side is FRIEND, flag set if speccy side is ENEMY
;
; Output:   A = -1, if speccy can't reach his opposite edge
;           A =  0, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
;           A = speccy heuristic evaluation, otherwise
;
; Uses:     -
;
; Destroys: A', BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Score:
                        jp      po, PathFinder_CyanScore    ; if speccy side is FRIEND, calculate CYAN score

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_RedScore: calculate red score
;
; Input:    -
;
; Output:   A = -1, if red can't reach his opposite edge
;           A =  0, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
;           A = red heuristic evaluation, otherwise
;
; Uses:     POTENTIALS (board potential and attack mobility)
;
; Destroys: A', BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_RedScore
                        call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
                        ret     z                           ; if red has a chain of connected tokens, return A = 0
                        ex      af, af'                     ; save first result
                        call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        sub     b                           ; subtract both results
                        ld      a, b                        ; restore second result
                        ret     z                           ; if red can't reach his opposite edge, return A = -1

                        call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
                        ex      af, af'                     ; save result
                        call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        sub     b                           ; subtract both results
                        ret     z                           ; if cyan can't reach his opposite edge, return A = 0

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
                        call    PathFinder_Potentials       ; calculate RED potentials
                        ld      (POTENTIALS), bc            ; store RED potentials

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials
                        jp      PathFinder_Evaluation       ; calculate heuristic evaluation

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_CyanScore: calculate cyan score
;
; Input:    -
;
; Output:   A = -1, if cyan can't reach his opposite edge
;           A =  0, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
;           A = cyan heuristic evaluation, otherwise
;
; Uses:     POTENTIALS (board potential and attack mobility)
;
; Destroys: A', BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_CyanScore
                        call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
                        ret     z                           ; if cyan has a chain of connected tokens, return A = 0
                        ex      af, af'                     ; save result
                        call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        sub     b                           ; subtract both results
                        ld      a, b                        ; restore second result
                        ret     z                           ; if cyan can't reach his opposite edge, return A = -1

                        call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
                        ex      af, af'                     ; save result
                        call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        sub     b                           ; subtract both results
                        ret     z                           ; if red can't reach his opposite edge, return A = 0

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials
                        ld      (POTENTIALS), bc            ; save cyan potentials

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
                        call    PathFinder_Potentials       ; calculate red potentials
; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Evaluation: calculate heuristic evaluation.
; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's thesis as:
;
;                                       e = M (pC - pR) - (aC - aR)
; where:
;   pC = cyan board potential
;   pR = red board potential
;   aC = cyan attack mobility
;   aR = red attack mobility
;    M = a large number
;
; This adaptation uses an "invert" result to better fit BRAINIAC process.
;
; Input:    B = opponent attack mobility
;           C = opponent board potential
;
; Output:   A = heuristic evaluation
;
; Destroys: E, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Evaluation:
                        ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
                        ld      a, b                        ; get opponent's attack mobility
                        sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
                        ld      e, a                        ; save the result in E
                        dec     l                           ; move HL to player's board potential address
                        ld      a, c                        ; get opponent's board potential
                        sub     (hl)                        ; subtract potentials -> (pC - pR)
                        add     a, a                        ; multiply by 8 -> M (pC - pR)
                        add     a, a
                        add     a, a
                        sub     e                           ; subtract result of attack mobilities subtraction
                                                            ; -> M (pC - pR) - (aC - aR)
                        xor     $80                         ; invert sign for easier further comparative
                        ret                                 ; return A = -1 * (M (pC - pR) - (aC - aR))

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Potentials: calculate board potential and attack mobility
;
; * A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
;   the board.
; * The attack mobility is defined for each player as the number of cells that realize that player's board potential.
;
; Input:    HL = cyan board or red board address
;           DE = cyan board or red board address
;
; Output:   B = attack mobility
;           C = board potential
;
; Destroys: A, DE, HL, IYL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Potentials:
                        ld      bc, $00FF                   ; initialize attack mobility and board potential
                        ld      iyl, 61                     ; number of cells to be checked (loop counter)
Potentials_Loop
                        ld      a, (hl)                     ; get cell's two-distance pointed by HL
                        cp      $40                         ; is cell occupied or border?
                        jr      nc, Potentials_Next         ; yes, skip to next cell
                        cp      $04                         ; cell distance was not updated?
                        jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
                        ld      a, (de)                     ; get cell's two-distance pointed by DE
                        cp      $04                         ; cell distance was not updated?
                        jr      c, Potentials_Infinite      ; yes, set cell potential as "infinite" and skip
                        add     a, (hl)                     ; sum both two-distances (calculate cell potential)
                        ld      (hl), a                     ; save potential in the cell pointed by HL
                        cp      c                           ; is the new potential = board potential?
                        jr      z, Potentials_Increment     ; yes, increment attack mobility
                        jr      nc, Potentials_Next         ; if (new potential > board potential) skip to next cell
                        ld      c, a                        ; board potential = new potential
                        ld      b, 0                        ; restart attack mobility
Potentials_Increment
                        inc     b                           ; increment attack mobility
Potentials_Next
                        inc     e                           ; move to next cell of each board
                        inc     l
                        dec     iyl                         ; decrement loop counter
                        jp      nz, Potentials_Loop         ; repeat until end of boards
                        ret
Potentials_Infinite
                        set     7, (hl)                     ; set cell potential as "infinite"
                        inc     e                           ; move to next cell of each board
                        inc     l
                        dec     iyl                         ; decrement loop counter
                        jp      nz, Potentials_Loop         ; repeat until end of boards
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Candidates: search candidates based on score result and boards potentials
;
; Input:    A  = -1, 0 or heuristic result
;           IX = candidates area address
;
; Output:   IX = first candidate address
;
; Uses:     AI_PLAYER (speccy side)
;
; Destroys: A, A', BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Candidates:
                        ld      (ix+0), 0                   ; set candidates endmarker

                        or      a                           ; is speccy the winner?
                        jr      z, Candidates_Winner        ; yes, fill candidates for winner color
                        inc     a                           ; is speccy defeated?
                        jr      z, Candidates_Defeat        ; yes, fill candidates for defeated color

                        ; if score is not -1 nor 0, fill candidates from total potentials

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
                        call    PathFinder_Potentials       ; process candidates from total potentials

                        ld      a, c                        ; set board potential in A
                        ex      af, af'                     ; save board potential
                        ld      d, b                        ; store attack mobility
                        ld      e, ixl                      ; store candidates position

                        ; insert the second best board potentials in candidates area
Candidates_2ndBest
                        ld      l, 9                        ; HL points to board potentials address (1st position)
                        inc     c                           ; increment board potential
                        ld      a, c                        ; A = second best potential
                        cp      $20                         ; is potential >= $20? (2nd best max potential)
                        jr      nc, Candidates_2ndBest_Exit ; yes, stop searching 2nd best potential

                        ld      b, 61                       ; number of cells to be checked (loop counter)
Candidates_2ndBest_Loop
                        cp      (hl)                        ; is current board potential = 2nd best board potential?
                        jp      nz, Candidates_2ndBest_Next ; no, skip to next potential
                        inc     ixl                         ; yes, insert candidate
                        ld      (ix+0), l
Candidates_2ndBest_Next
                        inc     l                           ; move HL to next board potential address
                        djnz    Candidates_2ndBest_Loop     ; repeat for each cell
                        ld      a, ixl                      ; A = current candidates position
                        cp      e                           ; new candidates inserted?
                        jr      z, Candidates_2ndBest       ; no, repeat until new candidates inserted

Candidates_2ndBest_Exit
                        ld      b, d                        ; restore attack mobility
                        ex      af, af'                     ; restore board potential

                        ; insert the best board potentials in candidates area
Candidates_Best
                        ld      l, 8                        ; HL points to board potential address (1st position -1)
Candidates_Best_Loop
                        inc     l                           ; move HL to next board potential address
                        cp      (hl)                        ; is current board potential equal to best board potential?
                        jp      nz, Candidates_Best_Loop    ; no, next potential
                        inc     ixl                         ; yes, insert candidate
                        ld      (ix+0), l
                        djnz    Candidates_Best_Loop        ; repeat for each cell
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; Fill candidates for winner color
; ----------------------------------------------------------------------------------------------------------------------
Candidates_Winner
                        ld      a, (AI_PLAYER)              ; check speccy side
                        or      a                           ; is it FRIEND?
                        jp      pe, Candidates_Red_Potential; no, fill candidates from red potentials

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials

                        ld      a, c                        ; set board potential in A
                        jp      Candidates_Best             ; fill only the best candidates

; ----------------------------------------------------------------------------------------------------------------------
; Fill candidates for defeated color
; ----------------------------------------------------------------------------------------------------------------------
Candidates_Defeat
                        ld      a, (AI_PLAYER)              ; check speccy side
                        or      a                           ; is it FRIEND?
                        jp      po, Candidates_Red          ; yes, fill candidates from red potentials

                        ; if RED is defeated, candidates are chosen from cyan board potentials

                        call    PathFinder_Cyan_UpDown      ; calculate cyan two-distance from UP to DOWN edge
                        call    PathFinder_Cyan_DownUp      ; calculate cyan two-distance from DOWN to UP edge
                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials

                        ld      a, c                        ; set board potential in A
                        jp      Candidates_Best             ; fill only the best candidates

                        ; if CYAN is defeated, candidates are chosen from red board potentials
Candidates_Red
                        call    PathFinder_Red_LeftRight    ; calculate red two-distance from LEFT to RIGHT edge
                        call    PathFinder_Red_RightLeft    ; calculate red two-distance from RIGHT to LEFT edge
Candidates_Red_Potential
                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st pos.)
                        ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
                        call    PathFinder_Potentials       ; calculate red potentials

                        ld      a, c                        ; set board potential in A
                        jp      Candidates_Best             ; fill only the best candidates

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_VictoryPath: calculate current player victory path
;
; Input:    -
;
; Output:   A = -1, if there isn't a victory path
;           A = start position (-1) of the victory path, otherwise
;
; Uses:     TOKEN_COLOR (current token color)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_VictoryPath:
                        ld      a, (TOKEN_COLOR)            ; get current token color
                        cp      CYAN_COLOR                  ; if it is cyan, check victory path for cyan player
                        jr      z, PathFinder_VictoryPath_Cyan

                        call    PathFinder_Red_LeftRight    ; execute Path_Finder RED two-distance from LEFT to RIGHT
                        ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
                        call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
                        jp      PathFinder_Red_CheckPath    ; calculate RED victory path

PathFinder_VictoryPath_Cyan
                        call    PathFinder_Cyan_UpDown      ; execute Path_Finder CYAN two-distance from UP to DOWN
                        ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
                        call    PathFinder_PrepareBoard     ; prepare board to calculate victory path
                        jp      PathFinder_Cyan_CheckPath   ; calculate CYAN victory path

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing VICTORY+$40 to 1, everything else to ENEMY.
; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
; [color]' again to find a victory path.
;
; Coded by Einar Saukas
;
; Input:    HL = pointer to last position of [color]_BOARD
;
; Output:   -
;
; Destroys: A, BC, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_PrepareBoard:
                        ld      a, VICTORY+$40              ; set victory distance + friendly flag
                        ld      c, 7                        ; 7 rows
PrepareBoard_Row
                        ld      b, 7                        ; 7 columns
PrepareBoard_Column
                        cp      (hl)                        ; is it win condition?
                        ld      (hl), 1                     ; save 1 by default
                        jr      z, PrepareBoard_Next        ; yes, next position
                        ld      (hl), ENEMY                 ; no, save ENEMY
PrepareBoard_Next
                        dec     l                           ; HL points to next board position
                        djnz    PrepareBoard_Column         ; repeat for each column

                        dec     l                           ; skip borders
                        dec     l
                        dec     c                           ; decrement rows
                        jr      nz, PrepareBoard_Row        ; repeat for each row
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
;
; Input:    A  = start position of the victory path
;           HL = [color]_QUEUE_AREA address
;
; Output:   -
;
; Uses:     TOKEN_COLOR (current token color)
;
; Destroys: A, BC, DE, HL, IX
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_BrightPath:
                        ld      b, h                        ; store high byte of QUEUE_AREA address

                        ld      hl, TOKEN_COLOR             ; get current token color address
                        set     6, (hl)                     ; switch on bright attribute
                        ld      hl, @Token_Delay+1          ; set delay duration for animate hexagons
                        ld      (hl), 4

                        ld      h, b                        ; restore high byte of QUEUE_AREA address
                        ld      l, a                        ; move HL to the start position of the victory path
                        inc     h
                        ld      c, (hl)                     ; set current victory path length in C
                        ld      b, VICTORY                  ; set victory length in B
                        jr      BrightPath_Position         ; animate and highlight the hexagon position

BrightPath_Neighbor
                        inc     l                           ; move HL to left neighbor address
                        cp      (hl)                        ; is it the same as current victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        dec     l                           ; move HL to right neighbor address
                        dec     l
                        cp      (hl)                        ; is it the same as current victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        ld      de, -WIDTH                  ; move HL to upper-right neighbor address
                        add     hl, de
                        cp      (hl)                        ; is it the same as current victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        inc     l                           ; move HL to upper-left neighbor address
                        cp      (hl)                        ; is it the same as current victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        ld      de, WIDTH*2                 ; move HL to lower-right neighbor address
                        add     hl, de
                        cp      (hl)                        ; is it the same as current victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        inc     l                           ; move HL to lower-left neighbor address
BrightPath_Position
                        push    bc                          ; store current victory path length
                        push    hl                          ; store current position pointer

                        call    Main_Board2Indexes          ; convert a board position into a board indexes
                        call    Draw_Token                  ; animate hexagon sprite on the screen
                        ld      ix, TOKEN_FX                ; IX points to token tone parameters address
                        call    Sound_FX                    ; play sound effect

                        pop     hl                          ; restore current position pointer
                        pop     bc                          ; restore current victory path length

                        dec     c                           ; decrement current victory path length
                        ld      a, c                        ; set current victory path length in A
                        cp      b                           ; has reached victory length?
                        jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach victory length

                        ld      hl, TOKEN_COLOR             ; get current token color address
                        res     6, (hl)                     ; switch off bright attribute
                        ret
