; ----------------------------------------------------------------------------------------------------------------------
; PathFinder.z80asm
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
;
; Adapted by Antonio Luque and Einar Saukas to be used as heuristic in Hex game.
; Based on chapter 5 of Jack van Rijswijck's thesis - https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf
; ----------------------------------------------------------------------------------------------------------------------

CYAN                    equ     $01                         ; cyan side
RED                     equ     $02                         ; red side
WIDTH                   equ     $08                         ; distance to up-left/down-right neighbor
EMPTY                   equ     $00                         ; empty positions on the board
SKIPPED                 equ     $01                         ; skipped positions on the board
FRIEND                  equ     $02                         ; positions occupied by friendly tokens on the board
ENEMY                   equ     $7E                         ; positions occupied by opponent tokens on the board
DEFEAT                  equ     $FF                         ; return value if defeat
VICTORY                 equ     $03                         ; internal value if victory
FRIENDLY                equ     %01000000                   ; mask to set friendly flag
WIN_CONDITION           equ     VICTORY+FRIENDLY            ; return value if victory
INFINITE                equ     $30                         ; cell potential value when two-distance cannot percolate
                                                            ; through two-bridges
CYAN_POSITIONS          equ     $7D00                       ; a 256-aligned memory area reserved for cyan positions
RED_POSITIONS           equ     $7E00                       ; a 256-aligned memory area reserved for red positions
CANDIDATES              equ     $7F00                       ; a 256-aligned memory area reserved to store candidates

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Friend: return if current player is FRIEND or ENEMY from the perspective of the cyan player
;
; Input:    -
;
; Output:   A = FRIEND, if current token color is cyan
;           A = ENEMY, if current token color is red
;
; Uses:     TOKEN_COLOR (current token color)
;
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Friend:
                        ld      a, (TOKEN_COLOR)            ; get current player color
                        rra                                 ; is current player color cyan?
                        ld      a, FRIEND                   ; set FRIEND in A
                        ret     c                           ; yes, return FRIEND 
                        xor     $7C                         ; no, return ENEMY
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_PutToken: put a token on both CYAN_POSITIONS and RED_POSITIONS areas
;
; Input:    A  = either FRIEND or ENEMY from the perspective of cyan player
;           HL = CYAN_POSITIONS token address
;
; Output:   -
;
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_PutToken:
                        ld      (hl), a                     ; put token at cyan position
                        inc     h                           ; move HL to red position address
                        xor     $7C                         ; invert side
                        ld      (hl), a                     ; put token at red position
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_EraseToken: erase a token from both CYAN_POSITIONS and RED_POSITIONS areas
;
; Input:    HL = CYAN_POSITIONS token address
;
; Output:   -
;
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_EraseToken:
                        ld      (hl), EMPTY                 ; erase token at cyan position
                        inc     h                           ; move HL to red position address
                        ld      (hl), EMPTY                 ; erase token at red position
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_CopyPositions: copy from CYAN_POSITIONS or RED_POSITIONS area to its corresponding board
;
; Input:    DE = cyan or red board address (destiny)
;           HL = CYAN_POSITIONS or RED_POSITIONS address (origin)
;
; Output:   -
;
; Destroys: BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_CopyPositions:
                        ld      bc, 7*7                     ; number of positions to be copied
PathFinder_CopyLoop
                        inc     l                           ; skip borders on positions
                        inc     l
                        inc     e                           ; skip borders on board
                        inc     e
                        ldi                                 ; copy a row of 7 positions
                        ldi
                        ldi
                        ldi
                        ldi
                        ldi
                        ldi
                        jp      pe, PathFinder_CopyLoop     ; repeat for each row
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Update: update current board position during heuristic function evaluation
;
; This is an approach to Jack van Rijswijck's "two-distance" metric. The two-distance is defined as "one more than the
; second lowest distance of pâ€™s neighbors to q, with the proviso that the two-distance equals 1 if p and q are directly
; adjacent".
;
; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as
; follows, depending on current content:
;
; * SKIPPED: 1 + distance of neighbor closest to goal
; * FRIEND:  distance of neighbor closest to goal
; * EMPTY:   1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise
;
; Input:    Z  = flag set when (HL) is FRIEND
;           C  = current distance (also with a flag at 6th bit that indicates a friendly position)
;           HL = current position address (on either cyan boards or red boards)
;
; Output:   -
;
; Destroys: B, DE
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Update:
                        jr      z, PathFinder_Friendly      ; if Z flag is set, update friend distance
                        ld      b, (hl)                     ; check current position
                        djnz    PathFinder_EMPTY
; if (HL) = SKIPPED, then set (HL) = C+1 and insert HL at queue tail
PathFinder_Increment:
                        ld      (hl), c                     ; save current distance in current position
                        inc     (hl)                        ; increment distance of current position
                        res     6, (hl)                     ; reset friendly token flag
                        ex      de, hl                      ; store current position in DE
@Queue_Tail
                        ld      hl, $0000                   ; HL points to queue tail address (changed before call)
                        inc     l                           ; move queue tail down
                        ld      (hl), e                     ; store position into queue tail
                        ld      (@Queue_Tail+1), hl         ; update queue tail
                        ex      de, hl                      ; restore current position
                        ret
; if (HL) = FRIEND, then set (HL) = C and insert HL at queue head
PathFinder_Friendly
                        ld      (hl), c                     ; save current distance in current position
                        set     6, (hl)                     ; set friendly token flag
                        ld      b, l                        ; save current position in B
                        pop     de                          ; preserve RET address
                        ex      (sp), hl                    ; retrieve queue head
                        ld      (hl), b                     ; push this position into queue head
                        dec     l                           ; move queue head up
                        ex      (sp), hl                    ; update queue head
                        push    de                          ; restore RET address
                        ret
; if (HL) = EMPTY, then set (HL) = C+1 if current distance is friendly, set (HL) = SKIPPED otherwise
PathFinder_EMPTY
                        bit     6, c                        ; is current distance friendly?
                        jp      nz, PathFinder_Increment    ; yes, set (HL) = C+1 and insert HL in queue tail
                        inc     (hl)                        ; set (HL) = SKIPPED to find the second lowest distance
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Cyan_UpDown: set up 'Path_Finder' routine to calculate CYAN two-distances from UP to DOWN edge
;
; Input:    -
;
; Output:   A = DEFEAT, if down edge couldn't be reached
;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
;           A = 0, otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Cyan_UpDown:
                        ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
                        ld      de, CYAN_BOARD_UP_DOWN+7    ; DE points to cyan board up-down address (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board up-down

; entry point for PathFinder_BrightPath
PathFinder_Cyan_BrightPath:
                        ld      iy, $0900                   ; IYH = distance to check edge positions
                                                            ; IYL = initialize return value of 'Path_Finder'
                        ld      hl, CYAN_QUEUE_AREA         ; HL points to cyan queue area address
                        ld      (@Queue_Tail+1), hl         ; initialize cyan queue area
                        push    hl                          ; store queue tail address

                        ; set up cyan board (up-down) start positions distances

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      c, VICTORY+FRIENDLY         ; initialize start positions distance
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        inc     l                           ; move HL to next start position address
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        inc     l
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update
                        inc     l
                        jp      Path_Finder_First           ; calculate two-distances of cyan board (up-down)

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Cyan_DownUp: set up Path_Finder routine to calculate CYAN two-distance from DOWN to UP edge
;
; Input:    -
;
; Output:   A = DEFEAT, if up edge couldn't be reached
;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
;           A = 0, otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Cyan_DownUp:
                        ld      hl, CYAN_POSITIONS+7        ; HL points to cyan positions address (up-right corner)
                        ld      de, CYAN_BOARD_DOWN_UP-1    ; DE points to cyan board down-up address (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from cyan positions to cyan board down-up

                        ld      iy, $F700                   ; IYH = distance to check edge positions
                                                            ; IYL = initialize return value of 'Path_Finder'
                        ld      hl, (@Queue_Tail+1)         ; initialize cyan queue area
                        push    hl                          ; store Queue Tail

                        ; set up cyan board (down-up) start positions distances

                        ex      de, hl                      ; (take advantage of last "CopyPositions" execution)
                        dec     l                           ; move HL to cyan boad down-up address (last position)
                        ld      c, VICTORY+FRIENDLY         ; initialize start positions distance
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        dec     l                           ; move HL to next start position address
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        dec     l                           
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update       
                        dec     l                           
                        jp      Path_Finder_First           ; calculate two-distances of cyan board (down-up)

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Red_LeftRight: set up Path_Finder routine to calculate RED two-distance from LEFT to RIGHT edge
;
; Input:    -
;
; Output:   A = DEFEAT, if right edge couldn't be reached
;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
;           A = 0, otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Red_LeftRight:
                        ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
                        ld      de, RED_BOARD_LEFT_RIGHT+7  ; DE points to red board left-right addr. (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from red positions to red board left-right

; entry point for PathFinder_BrightPath
PathFinder_Red_BrightPath
                        ld      iy, $0100                   ; IYH = distance to check edge positions
                                                            ; IYL = initialize return value of 'Path_Finder'
                        ld      hl, RED_QUEUE_AREA          ; initialize red queue area
                        ld      (@Queue_Tail+1), hl
                        push    hl                          ; store Queue Tail

                        ; set up red board (left-right) start positions distances

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      c, VICTORY+FRIENDLY         ; initialize start positions distance
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        ld      l, (RED_BOARD_LEFT_RIGHT+18)%256 ; move HL to next start position address
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        ld      l, (RED_BOARD_LEFT_RIGHT+27)%256
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+36)%256
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+45)%256
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+54)%256
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_LEFT_RIGHT+63)%256
                        jp      Path_Finder_First           ; calculate two-distances of red board (left-right)

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Red_RightLeft: set up Path_Finder routine to calculate RED two-distance from RIGHT to LEFT edge
;
; Input:    -
;
; Output:   A = DEFEAT, if left edge couldn't be reached
;           A = WIN_CONDITION, if there is chain of connected cyan tokens between the two edges
;           A = 0, otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Red_RightLeft:
                        ld      hl, RED_POSITIONS+7         ; HL points to red positions address (up-right corner)
                        ld      de, RED_BOARD_RIGHT_LEFT-1  ; DE points to red board right-left addr. (up-right corner)
                        call    PathFinder_CopyPositions    ; copy from red positions to red board right-left

                        ld      iy, $FF00                   ; IYH = distance to check edge positions
                                                            ; IYL = initialize return value of 'Path_Finder'
                        ld      hl, (@Queue_Tail+1)         ; initialize red queue area
                        push    hl                          ; store queue tail

                        ; set up red board (right-left) start positions distances

                        ex      de, hl                      ; take advantage of last "CopyPositions" execution
                        dec     l                           ; move HL to red board right-left address (last position)
                        ld      c, VICTORY+FRIENDLY         ; set start positions distance (+ friendly flag)
                        ld      a, FRIEND                   ; set distance to compare with
                        cp      (hl)                        ; check 1st start position distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        ld      l, (RED_BOARD_RIGHT_LEFT+52)%256 ; move HL to next start position address
                        cp      (hl)                        ; check 2nd start position distance
                        call    nc, PathFinder_Update       ; (repeat for each start position)
                        ld      l, (RED_BOARD_RIGHT_LEFT+43)%256
                        cp      (hl)                        ; check 3rd start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+34)%256
                        cp      (hl)                        ; check 4th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+25)%256
                        cp      (hl)                        ; check 5th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+16)%256
                        cp      (hl)                        ; check 6th start position distance
                        call    nc, PathFinder_Update
                        ld      l, (RED_BOARD_RIGHT_LEFT+7)%256
                        jp      Path_Finder_First           ; calculate red two-distance (right-left)

; ----------------------------------------------------------------------------------------------------------------------
; Path_Finder: calculate two-distance metric for each board position
;
; The algorithm is implemented running PATHFINDER, starting at the corresponding side of the input board
;
; Input:    HL  = cyan or red queue area address
;           IYH = distance to check edge positions
;           IYL = 0
;
; Output:   A = DEFEAT, if corresponding edge couldn't be reached
;           A = WIN_CONDITION, if there is chain of connected (color) tokens between the two edges
;           A = 0, otherwise
;
; Uses:     @Queue_Tail (queue pointer in 'PathFinder_Update' routine)
;
; Destroys: DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
Path_Finder:
                        inc     l                           ; move queue head down
                        push    hl                          ; preserve queue head address
                        ld      l, (hl)                     ; retrieve next position to be checked
                        inc     h                           ; move HL to corresponding board address
                        ld      c, (hl)                     ; retrieve distance from this position to start
                        ld      b, l                        ; store current position

                        ; look for adjacent positions

                        ld      a, l                        ; get current position
                        add     a, iyh                      ; add distance to check edge positions
                        ld      l, a                        ; move HL to calculated position address
                        bit     7, (hl)                     ; is it an edge?
                        jr      nz, Path_Finder_Adjacent    ; yes, process adjacent positions

                        ld      a, FRIEND                   ; set distance to compare with
; return point from PathFinder_Adjacent
Path_Finder_Neighbors
                        ld      l, b                        ; restore current position to be checked
                        inc     l                           ; move HL to right neighbor address
                        cp      (hl)                        ; check right neighbor distance
                        call    nc, PathFinder_Update       ; if FRIEND >= distance, update distance
                        dec     l                           ; move HL to left neighbor address
                        dec     l
                        cp      (hl)                        ; check left neighbor distance
                        call    nc, PathFinder_Update       ; (repeat for each neighbor)
                        ld      de, -WIDTH
                        add     hl, de
                        cp      (hl)                        ; check upper-left neighbor distance
                        call    nc, PathFinder_Update 
                        inc     l
                        cp      (hl)                        ; check upper-right neighbor distance
                        call    nc, PathFinder_Update
                        ld      de, WIDTH*2
                        add     hl, de
                        cp      (hl)                        ; check lower-left neighbor distance
                        call    nc, PathFinder_Update
                        inc     l
Path_Finder_First
                        cp      (hl)                        ; check lower-right neighbor distance
                        call    nc, PathFinder_Update
                        pop     hl                          ; restore queue tail address
                        ld      a, (@Queue_Tail+1)          ; check queue
                        cp      l                           ; is queue empty?
                        jp      nz, Path_Finder             ; no, repeat until queue is empty

                        ; check if corresponding edge was reached

                        ld      a, iyl                      ; get last position processed by 'Path_Finder_Adjacent'
                        dec     a                           ; check if the initial value (0) of IYL is unchanged
                        ret     m                           ; return A = DEFEAT, if the edge couldn't be reached
                        xor     a                           ; return A = 0, otherwise
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; Check adjacent hexagons.
;
; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's thesis:
; "two cells are adjacent if they share a common edge on the board."
;
; Input:    B  = current position
;           C  = current distance (with a flag at 6th bit that indicates a friendly position)
;           HL = current edge position address (a flag in 7th bit indicates an edge position and the lowest 3 bits the
;                edge number)
;
; Output:   A = WIN_CONDITION, if there is a chain of connected tokens of the same color between the two edges.
;           A = FRIEND, IYL = current position, otherwise.
;
; Destroys: DE, HL
; ----------------------------------------------------------------------------------------------------------------------
Path_Finder_Adjacent
                        ld      a, WIN_CONDITION            ; A = VICTORY+FRIENDLY
                        cp      c                           ; is current distance victory and friendly?
                        jr      z, Path_Finder_Abort        ; yes, abort path_finder

                        ld      a, (hl)                     ; get current edge position
                        and     %00000111                   ; convert to edge number (0..6)
                        add     a, a                        ; calculate vector table routine index
                        ld      l, a                        ; set index in L
                        inc     h                           ; move HL to (cyan or red) vector table routine address
                        ld      e, (hl)                     ; get low byte of vector table routine address
                        inc     l                           ; move HL to high byte of vector table routine address
                        ld      d, (hl)                     ; get high byte of vector table routine address
                        ex      de, hl                      ; HL points to 'PathFinder_[COLOR]_Edge_[n]' routine address
                        dec     d                           ; move DE to cyan or red board address
                        ld      e, b                        ; restore pointer to current position address
                        ld      iyl, b                      ; store current position
                        ld      a, FRIEND                   ; set distance to compare with
                        jp      (hl)                        ; jump to 'PathFinder_[COLOR]_Edge_[n]' routine
Path_Finder_Abort
                        pop     hl                          ; discard queue pointer to return to previous caller
                        ret                                 ; return A = WIN_CONDITION

; ----------------------------------------------------------------------------------------------------------------------
;  Check two-distance of RED adjacents
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_RED_Edge_0
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2                     ; calculate distance to adjacent #2
                        add     hl, de                      ; move HL to adjacent #2 address
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update       ; if FRIEND >= adjacent #2 distance, update distance
                        ld      de, 9                       ; calculate distance to adjacent #3
                        add     hl, de                      ; move HL to adjacent #3 address
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update       ; (repeat for each adjacent)
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_1
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2
                        add     hl, de
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_2
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update                     
                        ld      de, -9*6
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_3
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, -9*3
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9*4
                        add     hl, de
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_4
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, 9*2
                        add     hl, de
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      de, -9*6
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_5
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, -9*5
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update 
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update 
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_RED_Edge_6
                        ex      de, hl                      ; restore pointer to current position address
                        ld      de, -9*6
                        add     hl, de
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update 
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update   
                        ld      de, 9
                        add     hl, de
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

; ----------------------------------------------------------------------------------------------------------------------
;  Check two-distance of CYAN adjacents
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_CYAN_Edge_0
                        ex      de, hl                      ; restore pointer to current position address
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent of edge number 5
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent of edge number 6
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_1
                        ex      de, hl                      ; restore pointer to current position address
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_2
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        inc     l
                        inc     l
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_3
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        inc     l
                        inc     l
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #5 distance
                        call    nc, PathFinder_Update
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_4
                        ex      de, hl                      ; restore pointer to current position address
                        inc     l
                        inc     l
                        cp      (hl)                        ; check adjacent #6 distance
                        call    nc, PathFinder_Update
                        dec     l
                        dec     l
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_5
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        dec     l                    
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

PathFinder_CYAN_Edge_6
                        ex      de, hl                      ; restore pointer to current position address
                        dec     l
                        dec     l
                        cp      (hl)                        ; check adjacent #4 distance
                        call    nc, PathFinder_Update
                        dec     l                    
                        cp      (hl)                        ; check adjacent #3 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #2 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #1 distance
                        call    nc, PathFinder_Update
                        dec     l
                        cp      (hl)                        ; check adjacent #0 distance
                        call    nc, PathFinder_Update
                        ld      b, iyl                      ; restore current position
                        jp      Path_Finder_Neighbors       ; continue processing neighbors

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_SpeccyScore: calculate SPECCY score depending on speccy color
;
; Input:    -
;
; Output:   A = DEFEAT, if speccy can't reach his opposite edge
;           A = WIN_CONDITION, if player can't reach his opposite edge
;           A = speccy heuristic evaluation, otherwise
;
; Uses:     AI_PLAYER (speccy side)
;
; Destroys: A', BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_SpeccyScore:
                        ld      a, (AI_PLAYER)
                        cp      FRIEND                      ; if speccy is FRIEND, calculate CYAN score
                        jr      z, PathFinder_CyanScore

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_RedScore: calculate red score
;
; Input:    -
;
; Output:   A = DEFEAT, if red can't reach his opposite edge
;           A = WIN_CONDITION, if cyan can't reach his opposite edge
;           A = red heuristic evaluation, otherwise
;
; Uses:     POTENTIALS (board potential and attack mobility)
;
; Destroys: A', BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_RedScore
                        call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
                        cp      WIN_CONDITION
                        ret     z                           ; if A = WIN_CONDITION, return A
                        ex      af, af'                     ; save first result
                        call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        add     a, b                        ; add both results
                        cp      -2                          ; are both DEFEAT?
                        ld      a, b
                        ret     z                           ; yes, return A = DEFEAT

                        call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
                        ex      af, af'                     ; save result
                        call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        add     a, b                        ; add both results
                        cp      -2                          ; are both DEFEAT?
                        ld      a, WIN_CONDITION
                        ret     z                           ; yes, return A = WIN_CONDITION

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
                        call    PathFinder_Potentials       ; calculate RED potentials
                        ld      (POTENTIALS), bc            ; store RED potentials

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials
                        jp      PathFinder_Evaluation       ; calculate heuristic evaluation

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_PlayerScore: calculate PLAYER score depending on speccy color
;
; Input:    -
;
; Output:   A = DEFEAT, if player can't reach his opposite edge
;           A = WIN_CONDITION, if speccy can't reach his opposite edge
;           A = player heuristic evaluation, otherwise
;
; Uses:     AI_PLAYER (speccy side)
;
; Destroys: A', BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_PlayerScore:
                        ld      a, (AI_PLAYER)
                        cp      FRIEND                      ; if speccy is FRIEND, calculate RED score
                        jr      z, PathFinder_RedScore

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_CyanScore: calculate cyan score
;
; Input:    -
;
; Output:   A = DEFEAT, if cyan can't reach his opposite edge
;           A = WIN_CONDITION, if red can't reach his opposite edge
;           A = cyan heuristic evaluation, otherwise
;
; Uses:     POTENTIALS (board potential and attack mobility)
;
; Destroys: A', BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_CyanScore
                        call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
                        cp      WIN_CONDITION
                        ret     z                           ; if A = WIN_CONDITION, return A
                        ex      af, af'                     ; save result
                        call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        add     a, b                        ; add both results
                        cp      -2                          ; are both DEFEAT?
                        ld      a, b 
                        ret     z                           ; if both are DEFEAT, return A = DEFEAT

                        call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
                        ex      af, af'                     ; save result
                        call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge
                        ld      b, a                        ; save second result
                        ex      af, af'                     ; restore first result
                        add     a, b                        ; add both results
                        cp      -2                          ; are both DEFEAT?
                        ld      a, WIN_CONDITION
                        ret     z                           ; if both are DEFEAT, return A = WIN_CONDITION

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials
                        ld      (POTENTIALS), bc            ; save cyan potentials

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
                        call    PathFinder_Potentials       ; calculate red potentials
; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Evaluation: calculate heuristic evaluation.
; The original evaluation function (from cyan player perspective) is described in Jack van Rijswijck's thesis as:
;
;                                       e = M (pC - pR) - (aC - aR)
; where:
;   pC = cyan board potential
;   pR = red board potential
;   aC = cyan attack mobility
;   aR = red attack mobility
;    M = a large number
;
; This adaptation uses an "invert" result to better fit BRAINIAC process.
;
; Input:    B = opponent attack mobility
;           C = opponent board potential
;
; Output:   A = heuristic evaluation
;
; Destroys: E, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Evaluation:
                        ld      hl, POTENTIALS+1            ; HL points to color attack mobility address
                        ld      a, b                        ; get opponent's attack mobility
                        sub     (hl)                        ; subtract attack mobilities -> (aC - aR)
                        ld      e, a                        ; save the result in E
                        dec     l                           ; move HL to player's board potential address
                        ld      a, c                        ; get opponent's board potential
                        sub     (hl)                        ; subtract potentials -> (pC - pR)
                        add     a, a                        ; multiply by 8 -> M (pC - pR)
                        add     a, a
                        add     a, a
                        sub     e                           ; subtract result of attack mobilities subtraction
                                                            ; -> M (pC - pR) - (aC - aR)
                        xor     $80                         ; invert sign for easier further comparative
                        ret                                 ; return A = -1 (M (pC - pR) - (aC - aR))

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_TotalPotentials: set up 'PathFinder_Potentials' routine for Total potentials
;
; Input:    -
;
; Output:   B = total attack mobility
;           C = total board potential
;
; Destroys: A, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_TotalPotentials:
                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, RED_BOARD_LEFT_RIGHT+9  ; DE points to red board left-right address (1st position)
; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Potentials: calculate board potential and attack mobility
;
; * A cellâ€™s Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
;   sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
;   the board.
; * The attack mobility is defined for each player as the number of cells that realize that playerâ€™s board potential.
;
; Input:    HL = cyan board or red board address
;           DE = cyan board or red board address
;
; Output:   B = attack mobility
;           C = board potential
;
; Destroys: A, DE, HL, IYL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Potentials:
                        ld      bc, $00FF                   ; initialize attack mobility and board potential
                        ld      iyl, 61                     ; number of cells to be checked (loop counter)
Potentials_Loop
                        ld      a, (hl)                     ; get cell's two-distance pointed by HL
                        cp      $40                         ; if (friendly or edge or border)
                        jr      nc, Potentials_Next         ;       skip to next cell 
                        cp      $04                         ; if (cell distance was not updated)
                        jr      nc, Opponent_TwoDistance    ; {
                        ld      (hl), INFINITE              ;       set cell potential as "infinite"
Opponent_TwoDistance                                        ; }
                        ld      a, (de)                     ; get cell's two-distance pointed by DE
                        cp      $04                         ; if (cell distance was not updated)
                        jr      nc, Sum_TwoDistances        ; {
                        ld      a, INFINITE                 ;       set cell potential as "infinite"
Sum_TwoDistances                                            ; }
                        add     a, (hl)                     ; sum both two-distances (calculate cell potential)
                        ld      (hl), a                     ; save potential in the cell pointed by HL
                        cp      c                           ; is the new potential >= board potential?
                        jr      nc, Increment_Mobility      ; yes, check attack mobility
                        ld      c, a                        ; no, board potential = new potential
                        ld      b, 1                        ; restart attack mobility
Increment_Mobility
                        jr      nz, Potentials_Next         ; if (potential <> last potential) skip to next cell
                        inc     b                           ; else, increment attack mobility
Potentials_Next
                        inc     e                           ; move to next cells of each board
                        inc     l
                        dec     iyl                         ; decrement loop counter
                        jp      nz, Potentials_Loop         ; repeat until end of boards
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_Candidates: search candidates based on color score result and boards potentials
;
; Input:    A  = DEFEAT or heuristic result
;           IX = candidates area address
;
; Output:   IX = first candidate address
;
; Uses:     AI_PLAYER (speccy side)
;
; Destroys: A, A', BC, DE, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_Candidates:
                        inc     a                           ; A = DEFEAT?
                        jr      z, Defeat_Candidates        ; yes, process candidates for defeated color

                        call    PathFinder_TotalPotentials  ; no, process candidates from total potentials
                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        jp      PathFinder_FillCandidates   ; fill candidates vector

                        ; process candidates for defeated color
Defeat_Candidates
                        ld      a, (AI_PLAYER)
                        cp      FRIEND                      ; friend score has been processed?
                        jr      z, Cyan_Defeat_Candidates   ; yes, process candidates for cyan

                        ; if RED is defeated, candidates are chosen from cyan board potentials

                        call    PathFinder_Cyan_UpDown      ; calculate CYAN two-distance from UP to DOWN edge
                        call    PathFinder_Cyan_DownUp      ; calculate CYAN two-distance from DOWN to UP edge

; entry point for BRAINIAC_best_move
PathFinder_CyanCandidates:
                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board up-down address (1st position)
                        ld      de, CYAN_BOARD_DOWN_UP+1    ; DE points to cyan board down-up address (1st position)
                        call    PathFinder_Potentials       ; calculate cyan potentials

                        ld      hl, CYAN_BOARD_UP_DOWN+9    ; HL points to cyan board potentials address (1st position)
                        jp      PathFinder_FillCandidates   ; fill candidates vector

                        ; if CYAN is defeated, candidates are chosen from red board potentials
Cyan_Defeat_Candidates
                        call    PathFinder_Red_LeftRight    ; calculate RED two-distance from LEFT to RIGHT edge
                        call    PathFinder_Red_RightLeft    ; calculate RED two-distance from RIGHT to LEFT edge

; entry point for BRAINIAC_best_move
PathFinder_RedCandidates:
                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board left-right address (1st position)
                        ld      de, RED_BOARD_RIGHT_LEFT+1  ; DE points to red board right-left address (1st position)
                        call    PathFinder_Potentials       ; calculate red potentials

                        ld      hl, RED_BOARD_LEFT_RIGHT+9  ; HL points to red board potentials address (1st position)
; ----------------------------------------------------------------------------------------------------------------------
; Fill CANDIDATES vector with second and best candidates from calculated potentials
;
; Input:    B  = attack mobility
;           C  = board potential
;           HL = cyan or red board address (with calculated potentials) 
;           IX = candidates area address
;
; Output:   IX = first candidate address
;
; Destroys: A, A', HL, BC, DE
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_FillCandidates
                        ld      (ix+0), 0                   ; set candidates endmarker
                        ld      e, ixl                      ; store candidates position in E
                        ld      d, b                        ; store attack mobility in D
                        ld      a, c                        ; store board potential in A'
                        ex      af, af'

                        ; insert the second best board potentials in candidates vector

Search_Second_Best
                        ld      l, 9                        ; HL points to board potentials address (1st position)
                        inc     c                           ; increment board potential
                        ld      a, c                        ; A = second best board potential
                        ld      b, 61                       ; number of cells to be checked (loop counter)
Second_Best_Loop
                        cp      (hl)                        ; is current board potential = 2nd best board potential?
                        jp      nz, Second_Best_Next        ; no, skip to next potential
                        inc     ixl                         ; yes, insert candidate
                        ld      (ix+0), l
Second_Best_Next
                        inc     l                           ; move HL to next board potential address
                        djnz    Second_Best_Loop            ; repeat for each cell
                        ld      a, ixl                      ; A = current candidates position
                        cp      e                           ; new candidates inserted?
                        jr      z, Search_Second_Best       ; no, repeat until new candidates inserted

                        ; insert the best board potentials in candidates vector

                        ld      l, 8                        ; HL points to board potential address (1st position -1)
                        ld      b, d                        ; restore attack mobility (loop counter)
                        ex      af, af'                     ; restore board potential
Best_Candidate_Loop
                        inc     l                           ; move HL to next board potential address
                        cp      (hl)                        ; is current board potential equal to best board potential?
                        jp      nz, Best_Candidate_Loop     ; no, next potential
                        inc     ixl                         ; yes, insert candidate
                        ld      (ix+0), l
                        djnz    Best_Candidate_Loop         ; repeat for each cell
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_BrightPath: animate and highlight the hexagons included in shortest path when match ends
;
; Input:    B = current position
;
; Output:   -
;
; Uses:     TOKEN_COLOR (current token color)
;
; Destroys: A, BC, DE, HL, IY
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_BrightPath:
                        push    bc                          ; store current position

                        ld      a, (TOKEN_COLOR)            ; get current player color
                        push    af                          ; store current player color
                        cp      CYAN_COLOR                  ; check current token color
                        jr      z, BrightPath_Cyan          ; prepare board if it is cyan

                        ld      hl, RED_BOARD_LEFT_RIGHT+69 ; HL points to red board left-right address (last position)
                        call    PathFinder_PrepareBoard     ; prepare RED board 
                        call    PathFinder_Red_BrightPath   ; find RED victory path
                        jr      BrightPath_Start            ; start bright path
BrightPath_Cyan
                        ld      hl, CYAN_BOARD_UP_DOWN+69   ; HL points to cyan board up-down address (last position)
                        call    PathFinder_PrepareBoard     ; prepare CYAN board
                        call    PathFinder_Cyan_BrightPath  ; find CYAN victory path
BrightPath_Start
                        pop     af                          ; restore current player color
                        add     a, $40                      ; apply bright attribute
                        ld      (TOKEN_COLOR), a            ; save color

                        pop     bc                          ; restore current position

                        inc     h
                        ld      l, b                        ; HL points to the start position of the victory path
                        ld      c, (hl)                     ; set victory path length in C
                        jr      BrightPath_Position         ; animate and highlight the hexagon position
BrightPath_Neighbor
                        inc     l                           ; move HL to left neighbor address
                        cp      (hl)                        ; is it the same as victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        dec     l
                        dec     l                           ; right neighbor
                        cp      (hl)                        ; is it the same as victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        ld      a, l
                        sub     WIDTH
                        ld      l, a                        ; move HL to upper-right neighbor address
                        ld      a, c                        ; restore victory path length in A
                        cp      (hl)                        ; is it the same as victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        inc     l                           ; upper-left neighbor
                        cp      (hl)                        ; is it the same as victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        ld      a, l
                        add     a, WIDTH*2
                        ld      l, a                        ; move HL to lower-right neighbor address
                        ld      a, c                        ; restore victory path length in A
                        cp      (hl)                        ; is it the same as victory path length?
                        jr      z, BrightPath_Position      ; yes, animate and highlight the hexagon position
                        inc     l                           ; move HL to lower-left neighbor address
BrightPath_Position
                        push    bc                          ; store victory path length
                        push    hl                          ; store current position pointer
                        call    Main_Board2Indexes          ; convert a board position into a board indexes
                        call    Draw_Token                  ; draw token
                        pop     hl                          ; restore current position pointer
                        pop     bc                          ; restore victory path length
                        dec     c                           ; decrement victory path length
                        ld      a, c                        ; set victory path length in A
                        cp      VICTORY                     ; has reached victory path length?
                        jr      nz, BrightPath_Neighbor     ; repeat for each neighbor until reach VICTORY length

                        ld      a, (TOKEN_COLOR)            ; restore token color
                        sub     $40
                        ld      (TOKEN_COLOR), a
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; PathFinder_PrepareBoard: update '[color]_BOARD_XX_YY', changing WIN_CONDITION to 1, everything else to ENEMY.
; Immediately after 'Path_Finder_[color]' returned VICTORY, you can execute this routine, then execute 'Path_Finder_
; [color]' again to find a victory path.
;
; Coded by Einar Saukas
;
; Input:    HL = pointer to last position of [color]_BOARD
;
; Output:   -
;
; Destroys: A, BC, HL
; ----------------------------------------------------------------------------------------------------------------------
PathFinder_PrepareBoard:
                        ld      a, WIN_CONDITION
                        ld      c, 7                        ; 7 rows
PrepareBoard_Row
                        ld      b, 7                        ; 7 columns
PrepareBoard_Column
                        cp      (hl)                        ; is it win condition?
                        ld      (hl), 1                     ; save 1 by default
                        jr      z, PrepareBoard_Next        ; yes, next position
                        ld      (hl), ENEMY                 ; no, save ENEMY
PrepareBoard_Next
                        dec     l                           ; HL points to next board position
                        djnz    PrepareBoard_Column         ; repeat for each column

                        dec     l                           ; skip borders
                        dec     l
                        dec     c                           ; decrement rows
                        jr      nz, PrepareBoard_Row        ; repeat for each row
                        ret
