; ----------------------------------------------------------------------------------------------------------------------
; Main.z80asm
; Coded by Antonio Luque
; ----------------------------------------------------------------------------------------------------------------------

CYAN_COLOR              equ     %00000101                   ; Attributes: flash 0, bright 0, paper 0, ink 5
RED_COLOR               equ     %00000010                   ; Attributes: flash 0, bright 0, paper 0, ink 2
SW_COLOR                equ     %00000111                   ; BITs to be XORed to swap current player color

; ----------------------------------------------------------------------------------------------------------------------
; Entry point of the program - Initialization
; ----------------------------------------------------------------------------------------------------------------------
                        ent     $

                        di                                  ; disable interrupts

                        ; allocate jump to interrupt routine at address $5CA1 (pointed by IY+103)

                        ld      hl, Timer_Interrupt         ; HL points to interrupt routine address
                        ld      (iy+103), $C3               ; 'jp' opcode
                        ld      (iy+104), l                 ; LSB of interrupt routine address
                        ld      (iy+105), h                 ; MSB of interrupt routine address
                        ld      a, $2E                      ; set MSB of interrupt vector address
                        ld      i, a
                        im      2                           ; set interrupt mode 2

                        ; The ULA doesn't put any device ID in the data bus. When no value is placed on the Spectrum's
                        ; data bus, this acquires the value of 8 signals one ($FF). So, the resultant vector address is
                        ; formed as follows:
                        ;                           ( I * $100 ) + $FF = $2E00 + $FF = $2EFF
                        ; Source: 
                        ; https://wiki.speccy.org/cursos/ensamblador/interrupciones#curiosidades-y-consideraciones
                        ;
                        ; The value pointed at ROM address $2EFF is $5CA1. This address belongs to the calculator's
                        ; memory area and it is used by some ROM routines, but it is not longer used by HEX2 program.

                        ld      sp, $6000                   ; move stack

                        xor     a                           ; A = 0
                        ld      (GAME_LEVEL), a             ; initialize game level
                        out     ($FE), a                    ; set border colour

                        ; set up screen layout

                        call    Screen_Clear                ; clear the whole screen area and attributes area
                        call    Screen_Letters              ; draw the two rows of letters on screen (a-g)
                        call    Screen_Numbers              ; draw the two columns of numbers on screen (1-7)
                        call    Screen_Frame                ; draw the screen frame
                        call    Screen_Tokens               ; draw the fixed tokens on the screen
                        call    Screen_Timer_Quotes         ; draw the timer quotes (' ") on the screen
                        call    Screen_Color_Statics        ; apply color to some statics items of the screen

                        ld      a, CYAN_COLOR               ; initialize first player color
                        ld      (PLAYER_COLOR), a
                        ei                                  ; enable interrupts

; ----------------------------------------------------------------------------------------------------------------------
; New level
; ----------------------------------------------------------------------------------------------------------------------
Main_New_Level
                        ld      a, 4                        ; maximum level
                        ld      hl, GAME_LEVEL              ; HL points to game level address
                        cp      (hl)                        ; check current level
                        jr      nz, Main_Increment_Level    ; if level 4 not achieved then increment level
                        call    Screen_Last_Level           ; else show last level messages
Main_Increment_Level
                        inc     (hl)                        ; increment game level
                        call    Screen_Frame_Color          ; set up frame color depending on current level
                        call    Screen_Clear_ThreeRow       ; clear all three-in-a-row marks
                        xor     a                           ; (re)initialize three-in-a-row counter
                        ld      (THREE_ROW), a

; ----------------------------------------------------------------------------------------------------------------------
; Start new match
; ----------------------------------------------------------------------------------------------------------------------
Main_Start_Match
                        call    Print_Clear_Alert           ; clear last alert

                        ld      a, RED_COLOR                ; set red color in A
                        ld      (TOKEN_COLOR), a            ; save token color
                        call    Print_Clear_Move            ; clear red player last move

                        call    Timer_Reset                 ; reset timers
                        call    Timer_Display_All           ; display timers
                        call    Print_Players               ; swap colors and print "Player" and "Speccy" strings
                        call    Draw_Board                  ; draw an empty hexagons board

                        ; initialize boards

                        ld      hl, CYAN_BOARD              ; HL points to CYAN_BOARD address
                        ld      de, CYAN_BOARD+1            ; DE points to CYAN_BOARD+1 address
                        ld      (hl), EMPTY                 ; set first position as empty
                        ld      bc, (256*2)-1               ; length of CYAN_BOARD+RED_BOARD areas (-1 already set)
                        ldir                                ; set empty to the rest of position

                        ld      a, 10                       ; set delay duration for animate hexagons
                        ld      (Draw_Token_Delay+1), a

                        ld      a, 1
                        ld      (MOVE_NUMBER), a            ; initialize move number
                        ld      (TIMER_FLAG), a             ; set cyan timer on
                        ld      a, CYAN_COLOR               ; (re)initialize first player color

; ----------------------------------------------------------------------------------------------------------------------
; Process players moves - Match loop
; ----------------------------------------------------------------------------------------------------------------------
Main_Match_Loop
                        ; check player turn

                        ld      (TOKEN_COLOR), a            ; save current token color
                        ld      hl, PLAYER_COLOR            ; get player color
                        cp      (hl)                        ; is player color = current token color?
                        jr      z, Main_Player_Move         ; yes, input player move

                        call    Main_Speccy_Process         ; process speccy move
                        jr      Main_Update_Board           ; continue updating board position
Main_Player_Move
                        call    Main_Player_Process         ; process player move

                        ; check player move legality

                        ld      l, (hl)                     ; get board position of player move
                        ld      h, CYAN_BOARD/256           ; HL points to move position on board
                        ld      a, EMPTY
                        cp      (hl)                        ; is node empty?
                        jr      nz, Main_Hex_Filled         ; no, node is filled
Main_Update_Board
                        ; update board position with player/speccy move

                        call    PathFinder_Friend           ; get player/speccy side
                        call    PathFinder_PutToken         ; update board position
                        call    Draw_Token                  ; draw token (player or speccy) on the screen

                        ; check win condition

                        ld      a, (TOKEN_COLOR)            ; get current token color
                        cp      CYAN_COLOR                  ; is CYAN the current token color?
                        jr      z, Main_Get_CyanScore       ; yes, go for the score for cyan player
                        call    PathFinder_Red_LeftRight    ; get score for red player
                        jr      Main_Check_Winner           ; check victory condition
Main_Get_CyanScore
                        call    PathFinder_Cyan_UpDown      ; get score for cyan player
Main_Check_Winner
                        cp      WIN_CONDITION               ; player/speccy won?
                        jr      z, Main_Match_End           ; yes, there is a winner!

                        ld      hl, MOVE_NUMBER
                        inc     (hl)                        ; increment move number

                        ; swap players timers and colors

                        ld      a, (TIMER_FLAG)             ; swap current timer
                        xor     %00000011
                        ld      (TIMER_FLAG), a
                        ld      a, (TOKEN_COLOR)            ; swap current token color
                        xor     SW_COLOR
                        jr      Main_Match_Loop             ; repeat match loop

; ----------------------------------------------------------------------------------------------------------------------
; Illegal player move (node is filled)
; ----------------------------------------------------------------------------------------------------------------------
Main_Hex_Filled
                        ld      de, STR_FILLED              ; HL points to "FILLED" string
                        call    Print_Alert                 ; print string
                        ld      ix, FILLED_FX               ; HL points to filled hexagon sound fx
                        call    Sound_FX                    ; play sound fx
                        ld      a, 80                       ; set delay counter
                        call    Main_Delay
                        call    Print_Clear_Alert           ; clear alert message
                        jr      Main_Player_Move            ; repeat player input until move is legal

; ----------------------------------------------------------------------------------------------------------------------
; Current player wins the match
; ----------------------------------------------------------------------------------------------------------------------
Main_Match_End
                        ld      hl, TIMER_FLAG              ; HL points to timer flag address
                        ld      (hl), 0                     ; stop timers
                        ld      a, 4                        ; set delay duration for animate hexagons
                        ld      (Draw_Token_Delay+1), a
                        call    PathFinder_BrightPath       ; highlights the winner path

                        ld      de, STR_WINNER              ; HL points to "WINNER" string
                        call    Print_Alert                 ; print string

                        ld      a, (TOKEN_COLOR)            ; get current token color
                        ld      hl, PLAYER_COLOR            ; get player color
                        cp      (hl)                        ; is player color = current token color?
                        ld      hl, THREE_ROW
                        jr      z, Main_ThreeRow_Increment  ; yes, increment three-in-a-row counter
                        dec     (hl)                        ; decrement three-in-a-row counter
                        jp      p, Main_ThreeRow_Show       ; if not negative (-1), show marks
Main_ThreeRow_Increment
                        inc     (hl)                        ; increment three-in-a-row counter
Main_ThreeRow_Show
                        call    Screen_ThreeRow             ; show three-in-a-row marks
                        ld      a, 255                      ; set delay duration
                        call    Main_Delay                  ; delay
                        ld      a, (THREE_ROW)              ; check three row counter
                        cp      3                           ; is it 3?
                        jp      z, Main_New_Level           ; yes, start new level

                        jp      Main_Start_Match            ; start a new match

; ----------------------------------------------------------------------------------------------------------------------
; Main_Player_Proces: process for player move
;
; Input:    -
; Output:   HL - address of board position of player move
;           BC - board indexes at screen of player move (B=column, C=row)
; Destroys: DE, IX
; ----------------------------------------------------------------------------------------------------------------------
Main_Player_Process:
                        call    Print_Clear_Move            ; clear player last move
                        call    Input_Move                  ; wait for input player move
                        ld      ix, STR_MOVE                ; IX points to formatted move string to print
                        dec     bc                          ; BC points to the last char of input move
                        ld      a, (bc)                     ; get row ('1'..'7')
                        ld      (ix+3), a                   ; put it on formatted move string
                        dec     bc                          ; BC points to the first char of input move
                        ld      a, (bc)                     ; get column ('a'..'g')
                        ld      (ix+0), a                   ; put it on formatted move string
                        call    Print_Move                  ; print Speccy move

                        ; convert player move into an hexagon's indexes in board

                        inc     de                          ; DE points to the first char of input move
                        ld      a, (de)                     ; get 'a'..'g' column
                        sub     $60                         ; adjust to charset (1..7)
                        ld      b, a                        ; set column position in B
                        inc     de                          ; DE points to next char of input move
                        ld      a, (de)                     ; get '1'..'7' row
                        sub     $30                         ; adjust to charset (1..7)
                        ld      c, a                        ; set row position in C

                        ; convert a XY indexes of the hexagon in screen into a board position

                        ld      h, 0                        ; first, get the C row
                        ld      l, c
                        add     hl, hl                      ; a row is 8 bytes long
                        add     hl, hl
                        add     hl, hl
                        ld      de, BOARD_COORDINATES
                        add     hl, de
                        ex      de, hl                      ; DE and HL points to the address of C row 
                        ld      h, 0                        ; go for to the B column
                        ld      l, b
                        add     hl, de                      ; HL points to the address of B col
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; Main_Speccy_Process: process for speccy move
;
; Input:    -
; Output:   HL - address of board position of speccy move
;           BC - board indexes at screen of speccy move (B=column, C=row)
; Destroys: DE, IX
; ----------------------------------------------------------------------------------------------------------------------
Main_Speccy_Process:
                        call    Print_Wait                  ; print "WAIT" message
                        call    Play_Speccy                 ; get Speccy move
                        push    hl                          ; store board position of move
                        call    Main_Board2Indexes          ; convert board postion to indexes
                        ld      ix, STR_MOVE                ; IX points to formatted move string to print
                        ld      a, b                        ; get 1..7 column
                        add     a, $60                      ; adjust to charset ('a'..'g')
                        ld      (ix+0), a                   ; put it on formatted move string
                        ld      a, c                        ; get 1..7 row
                        add     a, $30                      ; adjust to charset ('1'..'7')
                        ld      (ix+3), a                   ; put it on formatted move string
                        push    bc                          ; store XY indexes
                        call    Print_Move                  ; print Speccy move
                        pop     bc                          ; restore XY indexes
                        pop     hl                          ; restore board position of move
                        ret

; ----------------------------------------------------------------------------------------------------------------------
; Main_Board2Indexes: convert a board position into a XY indexes of the hexagon in screen
;
; Input:    L  - board position
; Output:   BC - board indexes of the hexagon in screen (B=column, C=row)
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
Main_Board2Indexes:
                        ld      a, l
                        ld      hl, BOARD_COORDINATES+64
                        ld      c, 7                        ; 7 rows
Board2Indexes_Row
                        ld      b, 7                        ; 7 columns
Board2Indexes_Col
                        dec     hl
                        cp      (hl)                        ; is it the position?
                        ret      z                          ; yes, return XY indexes
                        djnz    Board2Indexes_Col
                        dec     hl                          ; skip borders
                        dec     c
                        jr      Board2Indexes_Row           ; loop each row

; ----------------------------------------------------------------------------------------------------------------------
; Main_Delay: wait for execution
;
; Input:    A - delay counter
; Output:   A - 0
; Destroys: -
; ----------------------------------------------------------------------------------------------------------------------
Main_Delay:
                        push    bc                          ; store register
Main_Delay_Loop
                        ld      c, 10                       ; set outher loop counter
Main_Delay_Loop1
                        ld      b, 0                        ; set inner loop counter (255)
Main_Delay_Loop2
                        djnz    Main_Delay_Loop2            ; repeat until B=0
                        dec     c                           ; decrement outher loop counter
                        jr      nz, Main_Delay_Loop1        ; repeat until C=0
                        dec     a                           ; decrement delay counter
                        jr      nz, Main_Delay_Loop         ; repeat until A=0
                        pop     bc                          ; restore register
                        ret
