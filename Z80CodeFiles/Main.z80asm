; -----------------------------------------------------------------------------
; Main.z80asm
; Coded by Antonio Luque
; -----------------------------------------------------------------------------

CL_ALL              equ     $0DAF                   ; ROM address of CL_ALL subroutine
BORDER              equ     $229B                   ; ROM address of BORDER+7 command routine
ATTR_P              equ     $5C8D                   ; RAM address of permanent attributes system variable
RED_XY              equ     $02A8                   ; XY RED input/output screen location
BLUE_XY             equ     $1A30                   ; XY BLUE input/output screen location
CYAN_FLASH0         equ     %00101000               ; Attributes: bright 0, flash 0, paper 5, ink 0
CYAN_REVERSE        equ     %00000101               ; Attributes: bright 0, flash 0, paper 0, ink 5
BLUE_TOKEN          equ     %00111001               ; Attributes: bright 0, flash 0, paper 7, ink 1
RED_TOKEN           equ     %00111010               ; Attributes: bright 0, flash 0, paper 7, ink 2
SW_COLOR            equ     %00000011               ; BITs to be XORed to swap current player color

; -----------------------------------------------------------------------------
; Entry point of the program
; -----------------------------------------------------------------------------
                    ent     $

                    ; set border/screen colors, print "HEX" header and draw empty board

                    ld      a, 5                    ; set border 5 (cyan)
                    call    BORDER
                    ld      a, CYAN_FLASH0          ; set screen color: paper 5, ink 0
                    ld      (ATTR_P), a
                    call    CL_ALL                  ; clear screen

                    ld      hl, STR_HEADER          ; HL points to header string
                    ld      bc, $0A08               ; set string position
                    ld      a, CYAN_REVERSE         ; set header attributes
                    ld      (CHAR_ATTR), a
                    call    Print_String

                    call    Draw_Frame              ; draw board frame
                    call    Draw_Board              ; draw an empty hexagons board

; -----------------------------------------------------------------------------
; Game (re)initialization - main loop
; -----------------------------------------------------------------------------
GameInit
                    ; initialize boards

                    ld      hl, BLUE_BOARD
                    ld      de, BLUE_BOARD+1
                    ld      (hl), EMPTY
                    ld      bc, 256*2-1
                    ldir

                    ; initialize screen attributes and input game options

                    ld      a, CYAN_FLASH0          ; set clear attributes
                    ld      (CHAR_ATTR), a
                    call    Input_Options
                    ld      a, 1                    ; initialize move number
                    ld      (MOVE_NUMBER), a
                    ld      a, BLUE_TOKEN           ; BLUE player starts the game

; -----------------------------------------------------------------------------
; Process players moves - game loop
; -----------------------------------------------------------------------------
GameLoop
                    ld      (TOKEN_COLOR), a        ; save current token color
                    ld      bc, RED_XY              ; set XY RED input/output screen location
                    rra                             ; is RED the current token color?
                    jr      nc, StorePosXY          ; yes, continue storing XY input/output screen location
                    ld      bc, BLUE_XY             ; set XY BLUE input/output screen location
StorePosXY
                    ld      (MOVE_POSXY), bc        ; store current XY input/output screen location

                    ; check game options

                    ld      a, (NUM_PLAYERS)        ; get number of players
                    cp      '2'                     ; is it '2'?
                    jr      z, PlayerMove           ; yes, input player move

                    ld      a, (TOKEN_COLOR)        ; get current player color
                    ld      hl, PLAYER_COLOR        ; get player color choice
                    cp      (hl)                    ; is player color choice = current token color?
                    jr      z, PlayerMove           ; yes, input player move

                    ; get speccy move

                    call    Print_Wait              ; print "WAIT" message
                    call    Speccy_Move             ; get Speccy move
                    call    Board2Indexes           ; get XY indexes of the hexagon in screen

                    push    bc                      ; store XY hexagon board indexes
                    call    Format_Move             ; format string move ("a-nn")
                    ld      a, CYAN_FLASH0          ; restore message color
                    ld      (CHAR_ATTR), a
                    call    Print_Move              ; print Speccy move
                    pop     bc                      ; restore XY hexagon board indexes

                    jr      DrawToken               ; continue drawing token
PlayerMove
                    call    Clear_Move              ; clear player last move

                    ld      hl, PLAYER_MOVE         ; HL points to the string to store player move
                    call    Input_String            ; input player move
                    call    String2_Indexes         ; get XY hexagon board indexes

                    push    bc                      ; store XY hexagon board indexes
                    call    Format_Move             ; format string move ("a-nn")
                    call    Print_Move              ; print player move
                    pop     bc                      ; restore XY hexagon board indexes

                    ; check player move legality

                    call    Indexes2Board           ; get board position
                    ld      h, BLUE_BOARD/256
                    ld      l, a                    ; HL points to move position on board
                    ld      a, EMPTY
                    cp      (hl)                    ; is node empty?
                    jr      nz, HexFilled           ; no, node is filled

                    ; update board position with player move

                    call    Friend_Or_Foe           ; get player side (FRIEND or ENEMY)
                    call    Put_Token               ; update board position
DrawToken
                    call    Draw_Token              ; draw token (player or speccy) on the screen
                    ld      hl, TOKEN_FX            ; HL points to the sound fx for move
                    call    SoundFX                 ; play sound fx
                    ld      hl, MOVE_NUMBER         ; increment move number
                    inc     (hl)

                    ; check win condition

                    ld      a, (TOKEN_COLOR)        ; get current token color
                    cp      BLUE_TOKEN              ; is BLUE the current token color?
                    jr      z, GetBlueScore         ; yes, go for the score for blue player
                    call    Red_Distance_LeftRight  ; get score for red player
                    jr      CheckWinner             ; check victory condition
GetBlueScore
                    call    Blue_Distance_UpDown    ; get score for blue player
CheckWinner
                    cp      WIN_CONDITION           ; player/speccy won?
                    jr      z, GameOver             ; yes, there is a winner!

                    ld      a, (TOKEN_COLOR)        ; swap current token color
                    xor     SW_COLOR
                    jp      GameLoop                ; repeat game loop

; -----------------------------------------------------------------------------
; Illegal player move (node is filled)
; -----------------------------------------------------------------------------
HexFilled
                    ld      hl, STR_FILLED          ; HL points to "FILLED" string
                    call    Print_Alert             ; print string
                    ld      hl, FILLED_FX           ; HL points to filled hexagon sound fx
                    call    SoundFX                 ; play sound fx

                    ; delay
                    ld      a, 80                   ; set delay counter
Delay
                    halt
                    dec     a
                    jr      nz, Delay

                    call    Clear_Alert             ; clear alert message
                    jr      PlayerMove              ; repeat player input until move is legal

; -----------------------------------------------------------------------------
; Current player wins the game
; -----------------------------------------------------------------------------
GameOver
                    call    Bright_Path             ; highlights the winner path
                    ld      hl, STR_WINNER          ; HL points to " WINS " string
                    call    Print_Alert             ; print string
                    ld      hl, WINNER_FX           ; HL points to winner sound fx
                    call    SoundFX                 ; play sound fx
                    jp      GameInit                ; initialize a new game

; -----------------------------------------------------------------------------
; Bright_Path: highlight the hexagons included in shortest path when game ends
;
; Input:    B = current position
; Output:   -
; Destroys: BC, HL, DE, AF
; -----------------------------------------------------------------------------
Bright_Path:
                    push    bc                      ; store current position

                    ld      a, (TOKEN_COLOR)
                    cp      BLUE_TOKEN              ; check current token color
                    jr      z, Prepare_Blue_Board

                    ld      hl, RED_BOARD_LEFT_RIGHT+69
                    call    Prepare_Board           ; prepare RED board 
                    call    Red_Bright_Path         ; find RED victory path
                    jp      Bright_Path_Start
Prepare_Blue_Board
                    ld      hl, BLUE_BOARD_UP_DOWN+69
                    call    Prepare_Board           ; prepare BLUE board
                    call    Blue_Bright_Path        ; find BLUE victory path

Bright_Path_Start
                    pop     bc                      ; restore current position

                    ; get the start position of the victory path
                    inc     h
                    ld      l, b
                    ld      a, (hl)
                    ld      c, a
                    jp      BrightPosition
FindNextNeighbour
                    inc     l                       ; left neighbour
                    cp      (hl)
                    jr      z, BrightPosition
                    dec     l
                    dec     l                       ; right neighbour
                    cp      (hl)
                    jr      z, BrightPosition
                    ld      a, l
                    sub     WIDTH
                    ld      l, a                    ; upper-right neighbour
                    ld      a, c
                    cp      (hl)
                    jr      z, BrightPosition
                    inc     l                       ; upper-left neighbour
                    cp      (hl)
                    jr      z, BrightPosition
                    ld      a, l
                    add     a, WIDTH*2
                    ld      l, a                    ; lower-right neighbour
                    ld      a, c
                    cp      (hl)
                    jr      z, BrightPosition
                    inc     l                       ; lower-left neighbour
BrightPosition
                    push    bc                      ; store victory path length and current position
                    push    hl
                    ld      a, l
                    call    Board2Indexes           ; convert a board position into a XY indexes of the hexagon in screen
                    pop     hl
                    call    GetHEX_Color            ; get the attributes memory address of an hexagon in screen
                    pop     bc
                    ld      a, (de)                 ; get hexagon color and brights it
                    set     6, a
                    ld      (TOKEN_COLOR), a
                    call    SetHEX_Color
                    dec     c                       ; decrement victory path length
                    ld      a, c
                    cp      VICTORY
                    jr      nz, FindNextNeighbour   ; repeat for each neighbour until reach VICTORY length
                    ret

; -----------------------------------------------------------------------------
; Update '(Color)_BOARD_XX_YY', changing WIN_CONDITION to EMPTY, everything else to ENEMY. 
; Immediately after 'Path_Finder_(color)' returned VICTORY, you can execute this routine, 
; then execute 'Path_Finder_(color)' again to find a victory path.
;
; Input:    HL = address of 'Board_(Color)' + 69
; Output:    -
; Destroys:  BC, HL, AF
; -----------------------------------------------------------------------------
Prepare_Board:
                    ld      a, WIN_CONDITION
                    ld      c, 7                    ; 7 rows
PrepareBoardNextRow
                    ld      b, 7                    ; 7 columns
PrepareBoardNextCol
                    cp      (hl)
                    ld      (hl), 1
                    jr      z, PrepareBoardSkip
                    ld      (hl), ENEMY
PrepareBoardSkip
                    dec     l
                    djnz    PrepareBoardNextCol

                    dec     l                       ; skip borders
                    dec     l
                    dec     c
                    jr      nz, PrepareBoardNextRow

                    ret

; -----------------------------------------------------------------------------
; Convert a XY indexes of the hexagon in screen into a board position
;
; Input:    BC - board indexes of the hexagon in screen (B=column, C=row)
; Output:   A  - board position
; Destroys: DE, HL
; -----------------------------------------------------------------------------
Indexes2Board:
                    push    bc
                    ld      de, BOARD_COORDINATES
                    ld      h, 0                    ; first, get the C row
                    ld      l, c
                    add     hl, hl                  ; a row is 8 bytes long
                    add     hl, hl
                    add     hl, hl
                    add     hl, de
                    ex      de, hl                  ; DE and HL points to the address of C row 
                    ld      h, 0                    ; go for to the B column
                    ld      l, b
                    add     hl, de                  ; HL points to the address of B col
                    ld      a, (hl)                 ; return board position
                    pop     bc

                    ret

; -----------------------------------------------------------------------------
; Convert a board position into a XY indexes of the hexagon in screen
;
; Input:    A  - board position
; Output:   BC - board indexes of the hexagon in screen (B=column, C=row)
; Destroys: -
; -----------------------------------------------------------------------------
Board2Indexes:
                    ld      hl, BOARD_COORDINATES+64
                    ld      c, 7                    ; 7 rows
BoardRow
                    ld      b, 7                    ; 7 columns
BoardPos
                    dec     hl
                    cp      (hl)                    ; is it the position?
                    ret     z                       ; yes, return XY indexes
                    djnz    BoardPos

                    dec     hl                      ; skip borders
                    dec     c
                    jr      BoardRow                ; loop each row

; -----------------------------------------------------------------------------
; Format_Move: applies format ("a-nn") to move string
;
; Input:    BC - XY hexagon board indexes
;           STR_MOVE - string to save formated string
; Output:   STR_MOVE - string with the formated string
; Destroys: A, DE, IX
; -----------------------------------------------------------------------------
Format_Move:
                    ld      ix, STR_MOVE            ; IX points to formatted move string to print
                    ld      a, b                    ; set column index position
                    xor     %01100000               ; add $60 (see charset 'a'-'g')
                    ld      (ix+0), a               ; put it in 1st position of formated string
                    ld      a, c                    ; set row index position
                    call    Int2_String             ; convert row index in a two bytes string (no 0 ended)
                    ld      (ix+2), d               ; put it in 2nd and 3th positions of formated string
                    ld      (ix+3), e

                    ret

; -----------------------------------------------------------------------------
; Int2_String: convert an integer byte number into an ASCII string 
; Developed by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
;
; Input:     A - number to be converted
; Output:   DE - number conversion in two bytes ASCII string
; Destroys:  A 
; -----------------------------------------------------------------------------
Int2_String:
                    ld      d, '0'                  ; initialize in char '0'
                    dec     d                       ; for later inc
                    ld      e, 10                   ; base-10
                    and     a                       ; set carry flag to 0
I2SLoop
                    inc     d                       ; tens increment
                    sub     e                       ; remove a unit of tens  
                    jr      nc, I2SLoop             ; if A is not negative, repeat
                    add     a, e                    ; adjust decrement
                    add     a, '0'                  ; convert to ASCII char
                    ld      e, a                    ; units are in E

                    ret

; -----------------------------------------------------------------------------
; String2_Indexes: converts player move into an hexagon's indexes in board
;
; Input:    HL - pointer to player move string
; Output:   BC - XY indexes of the hexagons board
; Destroys: A
; -----------------------------------------------------------------------------
String2_Indexes:
                    ld      a, (hl)                 ; get a-g column
                    xor     %01100000               ; substract $60 (see charset)
                    ld      b, a                    ; set column position
                    inc     hl                      ; HL points to next char
                    ld      a, (hl)                 ; get char of 1-7 column
                    xor     %00110000               ; subtract $30
                    ld      c, a                    ; set row position

                    ret

Timer:
                    ret
