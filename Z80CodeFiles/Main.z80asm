;
; Main.z80asm
; Coded by Antonio Luque
;
CL_ALL          equ $0DAF               ; ROM address of CL_ALL subroutine
BORDER          equ $229B               ; ROM address of BORDER+7 command routine
ATTR_P          equ $5C8D               ; RAM address of permanent attributes system variable

RED_XY          equ $02A8               ; XY RED input/output screen location
BLUE_XY         equ $1A30               ; XY BLUE input/output screen location

CYAN_FLASH0     equ %00101000           ; Attributes: bright 0, flash 0, paper 5, ink 0
CYAN_REVERSE    equ %00000101           ; Attributes: bright 0, flash 0, paper 0, ink 5
BLUE_TOKEN      equ %00111001           ; Attributes: bright 0, flash 0, paper 7, ink 1
RED_TOKEN       equ %00111010           ; Attributes: bright 0, flash 0, paper 7, ink 2
SW_COLOR        equ %00000011           ; BITs to be XORed to swap current player color

;
; Entry point of the program
;
                ; set screen colors

                ld a,5                  ; set border 5 (cyan)
                call BORDER             ; call BORDER ROM routine
                ld a,CYAN_FLASH0        ; set screen color: paper 5, ink 0
                ld (ATTR_P),a           ; stores it in ATTR_P system variable
                call CL_ALL             ; call CL_ALL ROM subroutine

                ; print " HEX " header

                ld hl,STR_HEADER        ; HL points to header string
                ld bc,$0A08             ; set string position
                ld a,CYAN_REVERSE       ; set header attributes
                ld (CHAR_ATTR),a
                call Print_String       ; print header

                ; draw board frame and empty hex board

                call Draw_Frame         ; draw board frame
                call Draw_Board         ; draw an empty hexagons board

;
; Game (re)initialization - main loop
;
GameInit
                ld hl,hex_board_blue+WIDTH
                ld c,7

EraseBoardsRow
                ld b,7

EraseBoardsHex
                call Erase_Hexagon
                dec h
                inc l
                djnz EraseBoardsHex

                inc l
                inc l

                dec c
                jr nz,EraseBoardsRow

                ld a,CYAN_FLASH0        ; set clear attributes
                ld (CHAR_ATTR),a

                call Input_Options      ; input game options

                ld a,1                  ; initialize move number
                ld (MOVE_NUMBER),a

                ld a,BLUE_TOKEN         ; set BLUE token color in A

;
; Process players moves - game loop
;
GameLoop
                ld (TOKEN_COLOR),a      ; save current token color
                ld bc,RED_XY            ; set XY RED input/output screen location
                rra                     ; is RED the current token color?
                jr nc,StorePosXY        ; yes, continue storing XY input/output screen location
                ld bc,BLUE_XY           ; no, set XY BLUE input/output screen location

StorePosXY
                ld (MOVE_POSXY),bc      ; store current XY input/output screen location

                ; check game options

                ld a,(NUM_PLAYERS)      ; get number of players
                cp '2'                  ; is it '2'?
                jr z,PlayerMove         ; yes, input player move

                ld a,(TOKEN_COLOR)      ; get current player color
                ld hl,PLAYER_COLOR      ; get player color choice
                cp (hl)                 ; is player color choice = current token color?
                jr z,PlayerMove         ; yes, input player move

                ; speccy move

                call Print_Wait         ; print "WAIT" message
                call Speccy_Move        ; get Speccy move
                ;call Node2_Indexes      ; get XY hexagon board indexes
                call Board2Indexes

                push bc                 ; store XY hexagon board indexes

                call Format_Move        ; format string move
                ld a,CYAN_FLASH0        ; restore message color
                ld (CHAR_ATTR),a
                call Print_Move         ; print Speccy move

                pop bc                  ; restore XY hexagon board indexes

                jp DrawToken            ; continue drawing token

PlayerMove
                call Clear_Move         ; clear player last move

                ld hl,PLAYER_MOVE       ; HL points to the string to store player move
                call Input_String       ; input player move

                call String2_Indexes    ; get XY hexagon board indexes

                push bc                 ; store XY hexagon board indexes

                call Format_Move        ; format string move
                call Print_Move         ; print player move

                pop bc                  ; restore XY hexagon board indexes

                ; check player move legality

                ;call Indexes2Node      ; get graph's node index (0-48)
                call Indexes2Board
                ld h,hex_board_blue/256           ; HL points to node color
                ld l,a
                ld a,EMPTY        ; set empty node color in A
                cp (hl)                 ; is node empty?
                jr nz,HexFilled         ; no, node is filled

                ld a,l                  ; save last player move
                ld (LAST_MOVE),a

                call Friend_Or_Foe
                call Put_Hexagon

DrawToken
                call Draw_Token         ; draw token (player or speccy) on the screen

                ld hl,TOKEN_FX          ; HL points to the sound fx for move
                call SoundFX            ; play sound fx

                ld hl,MOVE_NUMBER       ; increments move number
                inc (hl)

                ; check winner

                ld a,(TOKEN_COLOR)      ; get current token color
                rra
                jr c,GetBlueScore
                call RedScore
                    ld      hl, Board_Red+WIDTH
                    ld      de, Path_Finder_Red

                jr CheckWinner

GetBlueScore
                call BlueScore
                    ld      hl, Board_Blue+WIDTH
                    ld      de, Path_Finder_Blue
CheckWinner
                ld a,VICTORY
                cp c
                jr z,GameOver           ; yes, there is a winner!

                ld a,(TOKEN_COLOR)
                xor SW_COLOR

                jp GameLoop             ; repeat game loop
;
; Illegal player move (node is filled)
;
HexFilled
                ld hl,STR_FILLED        ; HL points to "FILLED" string
                call Print_Alert        ; print string

                ld hl,FILLED_FX         ; HL points to filled hexagon sound fx
                call SoundFX            ; play sound fx

                ld a,80                 ; set delay counter

Delay
                halt                    ; stops execution
                dec a                   ; decrement delay counter
                jr nz,Delay             ; repeat until A = 0

                call Clear_Alert        ; clear alert message

                jp PlayerMove           ; repeat player input until move is legal
;
; Current player wins the game
;
GameOver
                call Bright_Path        ; highlights the winner path

                ld hl,STR_WINNER        ; HL points to " WINS " string
                call Print_Alert        ; print string

                ld hl,WINNER_FX         ; HL points to winner sound fx
                call SoundFX            ; play sound fx

                jp GameInit             ; initialize a new game

; -----------------------------------------------------------------------------
; Bright_Path: highlight the hexagons included in shortest path when game ends
;
; Input:    
; Output:   
; Destroys:
; -----------------------------------------------------------------------------
Bright_Path:
                    ret

; Work in progress...
                    push    hl
                    call    GetWinner_Path
                    pop     hl

BrightLoop
                    ; TO DO
                    ret

;
;
;
GetWinner_Path:
                    ld      b, 61
                    ld      a, EMPTY
ChangeEmpty
                    cp      (hl)
                    jr      nz, NextEmpty
                    ld      (hl), ENEMY
NextEmpty
                    inc     l
                    djnz    ChangeEmpty

                    dec     l

                    ld      b, 61
                    ld      a, $84
ChangeFriend
                    cp      (hl)
                    jr      nz, NextFriend
                    ld      (hl), EMPTY
NextFriend
                    dec     l
                    djnz    ChangeFriend

                    ex      de, hl
                    jp      (hl)

;
; Format_Move: applies format ("a-nn") to move string
;
; Input:    BC - XY hexagon board indexes
;           STR_MOVE - string to save formated string
; Output:   STR_MOVE - string with the formated string
; Destroys: A, DE, IX
;
Format_Move:
                ld ix,STR_MOVE          ; IX points to formatted move string to print

                ld a,b                  ; set column index position
                xor %01100000           ; add $60 (see charset 'a'-'g')
                ld (ix+0),a             ; put it in 1st position of formated string
                ld a,c                  ; set row index position

                call Int2_String        ; convert row index in a two bytes string (no 0 ended)
                ld (ix+2),d             ; put it in 2nd and 3th positions of formated string
                ld (ix+3),e

                ret
;
; Int2_String: convert an integer byte number into an ASCII string 
; Developed by sromero: https://wiki.speccy.org/cursos/ensamblador/gfx4_fuentes
;
; Input:     A - number to be converted
; Output:   DE - number conversion in two bytes ASCII string
; Destroys:  A 
;
Int2_String:
                ld d,'0'                ; initialize in char '0'
                dec d                   ; for later inc
                ld e,10                 ; base-10
                and a                   ; set carry flag to 0
I2SLoop
                inc d                   ; tens increment
                sub e                   ; remove a unit of tens  
                jr nc,I2SLoop           ; if A is not negative, repeat

                add a,e                 ; adjust decrement
                add a,'0'               ; convert to ASCII char
                ld e,a                  ; units are in E

                ret
;
; String2_Indexes: converts player move into an hexagon's indexes in board
;
; Input:    HL - pointer to player move string
; Output:   BC - XY indexes of the hexagons board
; Destroys: A
;
String2_Indexes:
                ld a,(hl)               ; get a-g column
                xor %01100000           ; substract $60 (see charset)
                ld b,a                  ; set column position

                inc hl                  ; HL points to next char
                ld a,(hl)               ; get char of 1-7 column

                xor %00110000           ; subtract $30
                ld c,a                  ; set row position

                ret
;
; Indexes2Node: converts an hexagon's XY indexes into a node index
; Designed by Sonia Ortega
;
; Input:    BC - board indexes of the hexagon (B=column, C=row)
; Output:   A  - node index (0 to 48)
; Destroys: -
;
; [Antonio] this routine is in the project from the begining for update
; player moves. I have take advantage of it for this other use
;
;Indexes2Node:
                push bc                 ; store board indexes

                ld a,b                  ; node = column index
                dec a                   ; node = node - 1
                dec c                   ; row = row - 1
                ld b,c                  ; set loop counter through row index
                ld c,7

LoopNode
                add a,c                 ; node = node + 7
                djnz LoopNode           ; repeat (row - 1) times

                pop bc                  ; restore board indexes

                ret

;
; Node2_Indexes: converts a node index into an hexagon's XY indexes in board
; Designed by Sonia Ortega
;
; Input:     A - node index (0 to 48)
; Output:   BC - Board indexes of the hexagon (B=column, C=row)
; Destroys: -
;
;Node2_Indexes:
                ld c,1                  ; set board row = 1
                ld b,a                  ; set board column = hexagon index
                cp 7                    ; is hexagon index < 7?
                jr c,ExitConv           ; yes, continue to end of rutine

CalcXYLoop  
                inc c                   ; increment board row
                sub 7                   ; column = column - 7
                cp 7                    ; is it >= 7?
                jr nc,CalcXYLoop        ; yes, subtract again

                ld b,a                  ; set calculated column index
ExitConv
                inc b                   ; increment board column index

                ret

;
; Strings
;
STR_HEADER      defm " HEX \0"
STR_FILLED      defm "FILLED\0"
STR_WINNER      defm " WINS \0"

;
; Variables
;
;TOKEN_COLOR     defb 0                  ; current token color (BLUE_TOKEN or RED_TOKEN)
MOVE_NUMBER     defb 0                  ; current move number
LAST_MOVE       defb 0                  ; last move for the player (0-48)
PLAYER_MOVE     defb 0, 0, 0, 0         ; 4 bytes for input player move
