; -----------------------------------------------------------------------------
; Based on PATHFINDER - https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER
; Adapted by Einar Saukas to be used as heuristic in Antonio Luque's Hex game.
; -----------------------------------------------------------------------------
WIDTH           EQU     9               ; distance to up-left/down-right neighbor
ORIGIN          EQU     0               ; origin positions on the board
EMPTY           EQU     1               ; empty positions on the board
FRIEND          EQU     2               ; friendly hexagons on the board
VICTORY         EQU     4               ; return value if victory
ENEMY           EQU     253
DEFEAT          EQU     255             ; return value if defeat

                org $7c00

intersection_test:

                ; speccy plays with RED
                ld a,ENEMY
                ld (AI_PLAYER),a

                ; simulate initial moves
                ld a,FRIEND
                ld hl,hex_board_blue + $10
                call Put_Hexagon
                ld a,ENEMY
                ld hl,hex_board_blue + $18
                call Put_Hexagon
                ld a,FRIEND
                ld hl,hex_board_blue + $17
                call Put_Hexagon
                ld a,ENEMY
                ld hl,hex_board_blue + $1E
                call Put_Hexagon
                ld a,FRIEND
                ld hl,hex_board_blue + $1D
                call Put_Hexagon
                ld a,ENEMY
                ld hl,hex_board_blue + $24
                call Put_Hexagon
                ld a,FRIEND
                ld hl,hex_board_blue + $23
                call Put_Hexagon
                ld a,ENEMY
                ld hl,hex_board_blue + $2A
                call Put_Hexagon
                ld a,FRIEND
                ld hl,hex_board_blue + $19
                call Put_Hexagon
                ld a,ENEMY
                ld hl,hex_board_blue + $12
                call Put_Hexagon

                call Board_Score
                ; Blue: C = 10 = VICTORY+7 -> [Antonio] NOK??
                ; Red:  C =  6 = VICTORY+3 -> [Antonio] OK!
                ; Score: A = $84

                ld a, hex_intersect/256
                call Path_Tracker
                ; now take a look at hex_intersect: all empty positions that belong to either blue's OR red's shortest paths have value 1,
                ; and all empty positions that belong to both blue's AND red's shortest paths have value 2.
                ; [Antonio] there are NOT empty positions with value 2 :(

                jp $

; -----------------------------------------------------------------------------
; GetPlayer_Nodes: return current player vector's nodes.
;
; Input:
; Output:
; Destroys:
;
; TO BE INTEGRATED, PENDING COMMENTS (SORRY!)
; -----------------------------------------------------------------------------
GetPlayer_Nodes:
                ; clear hex_intersect
                ld hl,hex_intersect
                ld de,hex_intersect+1
                ld (hl),0
                ld bc,71
                ldir

                ; get intersections
                ld a, hex_intersect/256
                call Path_Tracker

                ; set up candidates address
                ld de,$6C00             ; set address of nodes vector in DE
                ld a,(AI_DEPTH)         ; get recursion depth level
                add a,a                 ; calculate low address of nodes vector pointer
                add a,a 
                add a,a 
                add a,a                 ; A = AI_DEPTH * 16
                ld e,a                  ; set low address of nodes vector pointer in E

                push de

                ; loop each position looking for candidates

                ld hl,hex_intersect+69

                ld c,7

loop1
                ld b,7

loop2
                ld a,(hl)
                cp 2
                jr nz,skippos

                ; candidate found!
                call Indexes2Node
                ld (de),a
                inc de              ; insert in "queue"

skippos
                dec l
                djnz loop2

                ; skip the last 2 values

                dec l
                dec l

                dec c
                jr nz,loop1

                pop hl

                ; calculate and return candidates length
                ld a,e
                sub l
                ld b,a

                ret

; -----------------------------------------------------------------------------
; Bright_Path: highlight the hexagons included in shortest path when game ends
;
; Input:    
; Output:   
; Destroys: 
; -----------------------------------------------------------------------------
Bright_Path:
                ; TO DO
                ret

; -----------------------------------------------------------------------------
                org $7E00

hex_board_blue:
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1

; -----------------------------------------------------------------------------
                org $7F00

hex_board_red:
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1
                defb 1, 1, 1, 1, 1, 1, 1

; -----------------------------------------------------------------------------
; Return if current player is FRIEND or ENEMY from the perspective of the blue player
;
; Input:    TOKEN_COLOR (BLUE_TOKEN or RED_TOKEN)
; Output:   A - FRIEND if current player color is blue, ENEMY if current player color is red
; Destroys: -
; -----------------------------------------------------------------------------
Friend_Or_Foe:
                ld a,(TOKEN_COLOR)      ; set current player color in A
                rra                     ; is current player color BLUE?
                ld a,FRIEND             ; set FRIEND in A
                ret c                   ; yes, return FRIEND 
                cpl                     ; no, return ENEMY
                ret

; -----------------------------------------------------------------------------
; Put an hexagon on 'hex_board_blue' and 'hex_board_red' boards
;
; Input:    HL - pointer to the hexagon position on blue board
;            A - FRIEND or ENEMY from the perspective of blue player
; Output:    A - ENEMY if input was FRIEND, FRIEND if input was ENEMY
; -----------------------------------------------------------------------------
Put_Hexagon:
                ld (hl),a
                inc h
                cpl
                ld (hl),a
                ret

; -----------------------------------------------------------------------------
; Erase an hexagon on 'hex_board_blue' and 'hex_board_red' boards
;
; Input:    HL - pointer to the hexagon position on blue board
; Output:    -
; Destroys  HL
; -----------------------------------------------------------------------------
Erase_Hexagon:
                ld (hl),EMPTY
                inc h
                ld (hl),EMPTY
                ret

; -----------------------------------------------------------------------------
; Calculate current board score
;
; Input:    -
; Output:   A  - ((player steps to win) minus (speccy steps to win)) * (-1)
; Destroys: BC, DE, HL
;
; TO DO: check player's VICTORY/DEFEAT condition
; -----------------------------------------------------------------------------
Board_Score:
                call Player_Score       ; get player score

                ld a, c
                ex af, af'              ; save player score

                call Speccy_Score       ; get speccy score

                ex af, af'              ; recover player score

                sub c                   ; A = (player steps to win) - (player speccy to win)
                xor $80                 ; A = A * (-1) inverts sign for easier further comparative
                ret

; -----------------------------------------------------------------------------
; Copy an 'hex_board_(color)' to its corresponding 'Board_(Color)'
;
; Input:    HL - pointer to the 'hex_board_(color)' source
;           DE - pointer to the 'Board_(Color)' destination
; Output:   -
; Destroys: BC, HL, DE
; -----------------------------------------------------------------------------
Copy_Board:
                ld bc,49                ; number of positions to be copied (7x7)

CopyLoop
                inc e                   ; skip borders
                inc e

                ldi                     ; copy a row of 7 positions
                ldi
                ldi
                ldi
                ldi
                ldi
                ldi
                jp pe,CopyLoop          ; repeat for each row

                ret

; -----------------------------------------------------------------------------
AI_PLAYER       defb 0                ; speccy side (FRIEND or ENEMY)
AI_DEPTH        defb 0                  ; recursion depth level (0-4)
TOKEN_COLOR     defb 0                  ; current token color (BLUE_TOKEN or RED_TOKEN)

; -----------------------------------------------------------------------------
; Calculate player score depending on player color
;
; Input:    -
; Output:   player heuristic result, see Path_Finder_(Color) routines below
; Destroys: B, DE, HL, AF
; -----------------------------------------------------------------------------
Player_Score:
                ld a,(AI_PLAYER)        ; set speccy side in A
                rra                     ; is speccy ENEMY?
                jr nc,RedScore          ; no, calculate red score
; -----------------------------------------------------------------------------
; Calculate score for blue
;
BlueScore:
                ld hl,hex_board_blue    ; HL points to hex_board_blue
                ld de,Board_Blue+7      ; DE points to Board_Blue+7 (skipping the firsts 7 bytes of the upper border)
                call Copy_Board         ; copy 'hex_board_blue' board to 'Board_Blue' board
; -----------------------------------------------------------------------------
; Calculate heuristic function for Blue
;
; Input:    -
; Output:   C = VICTORY if blue already won,
;           C = VICTORY+N if blue needs N steps to win
;           C = DEFEAT if blue already lost
;           DE = Queue Head
;           IX = Queue Tail
; Destroys: B, HL, AF
; -----------------------------------------------------------------------------
Path_Finder_Blue:
                ld      de, Queue_Area_Blue  ; Queue Head
                ld      ix, Queue_Area_Blue  ; Queue Tail
                ld      c, VICTORY
                ld      a, FRIEND
                ld      hl, Board_Blue+69
                cp      (hl)            ; 1st goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                dec     l
                cp      (hl)            ; 2nd goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                dec     l
                cp      (hl)            ; 3rd goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                dec     l
                cp      (hl)            ; 4th goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                dec     l
                cp      (hl)            ; 5th goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                dec     l
                jp      Path_Finder_Begin_Blue
Path_Finder_Loop:
                dec     e               ; move Queue Head
                ld      a, (de)         ; retrieve next position to be checked
                ld      l, a
                ld      c, (hl)         ; retrieve distance from this position to start
                res     7, c            ; clean highest bit that indicates occupied position
                ld      a, FRIEND
                dec     l
                cp      (hl)            ; left neighbor not visited yet?
                call    nc, Path_Finder_Update_Pos
                inc     l
                inc     l
                cp      (hl)            ; right neighbor not visited yet?
                call    nc, Path_Finder_Update_Pos
                ld      a, l
                sub     WIDTH
                ld      l, a
                ld      a, FRIEND
                cp      (hl)            ; upper-right neighbor not visited yet?
                call    nc, Path_Finder_Update_Pos
                dec     l
                cp      (hl)            ; upper-left neighbor not visited yet?
                call    nc, Path_Finder_Update_Pos
                ld      a, l
                add     a, WIDTH*2
                ld      l, a
                ld      a, FRIEND
Path_Finder_Begin_Blue:
                cp      (hl)            ; lower-right neighbor not visited yet?
                call    nc, Path_Finder_Update_Pos
                dec     l
Path_Finder_Begin_Red:
                cp      (hl)            ; lower-left neighbor not visited yet?
                call    nc, Path_Finder_Update_Pos
                ld      a, ixl
                cp      e               ; empty queue?
                jp      nz, Path_Finder_Loop
                ld      c, DEFEAT       ; no path to origin means we lost!
                ret

; -----------------------------------------------------------------------------
; Calculate speccy score depending on speccy color
;
; Input:    -
; Output:   speccy heuristic result, see Path_Finder_(Color) routines above and below
; Destroys: B, DE, HL, AF
; -----------------------------------------------------------------------------
Speccy_Score:
                ld a,(AI_PLAYER)        ; set speccy side in A
                rra                     ; is speccy ENEMY?
                jr nc,BlueScore         ; no, calculate blue score
; -----------------------------------------------------------------------------
; Calculate score for red
;
RedScore:
                ld hl,hex_board_red     ; HL points to hex_board_red
                ld de,Board_Red+7       ; DE points to Board_Red+7 (skipping the firsts 7 bytes of the upper border)
                call Copy_Board         ; copy 'hex_board_red' board to 'Board_Red' board
; -----------------------------------------------------------------------------
; Calculate heuristic function for Red
;
; Input:    -
; Output:   C = VICTORY if red won,
;           C = VICTORY+N if red needs N steps to win
;           C = DEFEAT if red lost
;           DE = Queue Head
;           IX = Queue Tail
; Destroys: B, HL, AF
; -----------------------------------------------------------------------------
Path_Finder_Red:
                ld      de, Queue_Area_Red  ; Queue Head
                ld      ix, Queue_Area_Red  ; Queue Tail
                ld      c, VICTORY
                ld      a, FRIEND
                ld      hl, Board_Red+69
                cp      (hl)            ; 1st goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                ld      l, (Board_Red+60)%256
                cp      (hl)            ; 2nd goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                ld      l, (Board_Red+51)%256
                cp      (hl)            ; 3rd goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                ld      l, (Board_Red+42)%256
                cp      (hl)            ; 4th goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                ld      l, (Board_Red+33)%256
                cp      (hl)            ; 5th goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                ld      l, (Board_Red+24)%256
                cp      (hl)            ; 6th goal position not blocked?
                call    nc, Path_Finder_Update_Pos
                ld      l, (Board_Red+15)%256
                jp      Path_Finder_Begin_Red

; -----------------------------------------------------------------------------
; Update current board position during heuristic function evaluation.
;
; This position will be updated with a number that indicates distance from
; goal, depending on current content:
;
; * EMPTY:  1 + distance of closest neighbour
; * FRIEND: 128 + distance of closest neighbour
; * ORIGIN: done!
;
; Input:    HL = points to current position (on either Board_Blue or Board_Red)
;           DE = Queue Head
;           IX = Queue Tail
;           C = current distance
;           Z = flag set when (HL) = FRIEND
; Output:   -
; Destroys: B
; -----------------------------------------------------------------------------
Path_Finder_Update_Pos:
                jr      z, Path_Finder_Friendly
                ld      b, (hl)
                djnz    Path_Finder_Victory
; if (HL) = EMPTY, then set (HL) = C+1 and insert HL at Queue Tail
                ld      (hl), c
                inc     (hl)
                ld      b, l
                dec     ixl
                ld      (ix+0), b       ; insert HL at Queue Tail
                ret
; if (HL) = FRIEND, then set (HL) = C+128 and insert HL at Queue Head
Path_Finder_Friendly:
                ld      (hl), c
                set     7, (hl)         ; set highest bit to indicate occupied position
                ex      de, hl
                ld      (hl), e         ; insert HL at Queue Head
                ex      de, hl
                inc     e
                ret
; if (HL) = ORIGIN, then abort execution and return C = VICTORY+steps
Path_Finder_Victory:
                ; dec     iyl
                ; ld      (iy+0), (Board_Blue+70)%256   ; insert end marker at Queue Tail
                ld      l, Board_Blue_Result%256
                ld      (hl), c
                ; inc     l
                ; ld      (hl), e
                pop     hl
                ret

; -----------------------------------------------------------------------------
; Identify empty positions in blue's and red's shortest paths. It must be called 
; after Path_Finder_Blue has updated Board_Blue, and Path_Finder_Red has updated 
; Board_Red.
;
; Input:    A = MSB of intersection area
; Output:   -
; Destroys: BC, DE, HL, AF
; -----------------------------------------------------------------------------
Path_Tracker:
                ld      (Path_Tracker_Intersect+1), a
                call    Path_Tracker_Red
; -----------------------------------------------------------------------------
; Identify empty positions in blue's shortest paths. It must be called after
; Path_Finder_Blue has updated Board_Blue.
;
; Input:    -
; Output:   -
; Destroys: BC, DE, HL, AF
; -----------------------------------------------------------------------------
Path_Tracker_Blue:
                ld      a, (Board_Blue_Result)
                ld      c, a
                ld      de, Queue_Area_Blue+1  ; Queue Head
                ld      b, $7f
                ld      hl, Board_Blue+9
                ld      a, (hl)
                and     b
                cp      c               ; 1st goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                inc     l
                ld      a, (hl)
                and     b
                cp      c               ; 2nd goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                inc     l
                ld      a, (hl)
                and     b
                cp      c               ; 3rd goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                inc     l
                ld      a, (hl)
                and     b
                cp      c               ; 4th goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                inc     l
                ld      a, (hl)
                and     b
                cp      c               ; 5th goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                dec     l
                jp      Path_Tracker_Begin_Blue
Path_Tracker_Loop:
                ld      a, (de)         ; retrieve next position to be checked
                ld      l, a
                ld      a, (hl)         ; retrieve distance from this position to start
                sub     $80             ; are we looking at a previously EMPTY or FRIEND position?
                sbc     a, $40          ; if it was FRIEND, we will be looking for neighbours with same distance
                                        ; if it was EMPTY, we will be looking for neighbours with shorter distance
                and     b               ; clean highest bit that indicates occupied position
                ld      c, a
                dec     l
                ld      a, (hl)
                and     b
                cp      c               ; left neighbor not visited yet?
                call    z, Path_Tracker_Update_Pos
                inc     l
                inc     l
                ld      a, (hl)
                and     b
                cp      c               ; right neighbor not visited yet?
                call    z, Path_Tracker_Update_Pos
                ld      a, l
                sub     WIDTH
                ld      l, a
                ld      a, (hl)
                and     b
                cp      c               ; upper-right neighbor not visited yet?
                call    z, Path_Tracker_Update_Pos
                dec     l
                ld      a, (hl)
                and     b
                cp      c               ; upper-left neighbor not visited yet?
                call    z, Path_Tracker_Update_Pos
                ld      a, l
                add     a, WIDTH*2
                ld      l, a
Path_Tracker_Begin_Blue:
                ld      a, (hl)
                and     b
                cp      c               ; lower-right neighbor not visited yet?
                call    z, Path_Tracker_Update_Pos
                dec     l
Path_Tracker_Begin_Red:
                ld      a, (hl)
                and     b
                cp      c               ; lower-left neighbor not visited yet?
                call    z, Path_Tracker_Update_Pos
                dec     e               ; empty queue?
                jp      nz, Path_Tracker_Loop
                ret

; -----------------------------------------------------------------------------
; Identify empty positions in red's shortest paths. It must be called after
; Path_Finder_Red has updated Board_Red.
;
; Input:    - 
; Output:   -
; Destroys: BC, DE, HL, AF
; -----------------------------------------------------------------------------
Path_Tracker_Red:
                ld      a, (Board_Red_Result)
                ld      c, a
                ld      de, Queue_Area_Red+1  ; Queue Head
                ld      b, $7f
                ld      hl, Board_Red+9
                ld      a, (hl)
                and     b
                cp      c               ; 1st goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                ld      l, (Board_Red+18)%256
                ld      a, (hl)
                and     b
                cp      c               ; 2nd goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                ld      l, (Board_Red+27)%256
                ld      a, (hl)
                and     b
                cp      c               ; 3rd goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                ld      l, (Board_Red+36)%256
                ld      a, (hl)
                and     b
                cp      c               ; 4th goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                ld      l, (Board_Red+45)%256
                ld      a, (hl)
                and     b
                cp      c               ; 5th goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                ld      l, (Board_Red+54)%256
                ld      a, (hl)
                and     b
                cp      c               ; 6th goal position in shortest path?
                call    z, Path_Tracker_Update_Pos
                ld      l, (Board_Red+63)%256
                jp      Path_Tracker_Begin_Red

; -----------------------------------------------------------------------------
; During shortest path tracking, this routine updates current board position 
; (set bit 6 to prevent visiting same position twice), adds current board 
; position to queue, and updates intersection board.
;
; Input:    HL = points to current position (on either Board_Blue or Board_Red)
;           A = current position content, except with bit 7 reset
;           DE = Queue Head
; Output:   -
; Destroys: A
; -----------------------------------------------------------------------------
Path_Tracker_Update_Pos:
                cp      (hl)
                jr      nz, Path_Tracker_Friendly
                ld      a, h
Path_Tracker_Intersect:
                ld      h, 0
                inc     (hl)            ; if empty position that's part of a shortest
                ld      h, a            ;   path, then increment intersection counter
Path_Tracker_Friendly:
                set     6, (hl)         ; set bit 6 to avoid visiting this position again
                ld      a, l
                ld      (de), a         ; add this position to queue
                inc     e
                ret

; -----------------------------------------------------------------------------
                org $F800
hex_intersect:
; We can have multiple intersect tables like this (one for each depth), but each of them
; must be 256-aligned and have the exactly this format.
; Before executing Path_Tracker, fill this table with zeros. After execution:
; * Empty positions that belong to a shortest path of a single color will have value 1.
; * Empty positions that belong to a shortest path of both colors will have value 2.

                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; (just ignore this line)

                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 1st row (ignore last 2 values)
                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 2nd row (ignore last 2 values)
                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 3rd row (ignore last 2 values)
                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 4th row (ignore last 2 values)
                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 5th row (ignore last 2 values)
                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 6th row (ignore last 2 values)
                defb    0, 0, 0, 0, 0, 0, 0,     0, 0  ; 7th row (ignore last 2 values)

; -----------------------------------------------------------------------------
                org $FA00
; 256-aligned block reserved for circular queue
Queue_Area_Blue:
                defs 256

; -----------------------------------------------------------------------------
                org $FB00
; 256-aligned block reserved for circular queue
Queue_Area_Red:
                defs 256


; -----------------------------------------------------------------------------
                org $FD00
Board_Blue:
; Before executing Path_Finder_Blue, replace the 7x7 positions (currently marked with 1) as follows:
;   1 when your corresponding board position is empty
;   2 when your corresponding board position is occupied by blue
;   >2 when your corresponding board position is occupied by red
; WARNING: do not modify the borders!
                defb       0,  0,  0,  0,  0,  0,  0,  0
                defb   255,  1,  1,  1,  1,  1,  1,  1, 255
                defb     255,  1,  1,  1,  1,  1,  1,  1, 255
                defb       255,  1,  1,  1,  1,  1,  1,  1, 255
                defb         255,  1,  1,  1,  1,  1,  1,  1, 255
                defb           255,  1,  1,  1,  1,  1,  1,  1, 255
                defb             255,  1,  1,  1,  1,  1,  1,  1, 255
                defb               255,  1,  1,  1,  1,  1,  1,  1, 255
                defb                  255,255,255,255,255,255,255,255
Board_Blue_Result:
                defb 255

; -----------------------------------------------------------------------------
                org $FE00
Board_Red:
; Before executing Path_Finder_Red, replace the 7x7 positions (currently marked with 1) as follows:
;   1 when your corresponding board position is empty
;   2 when your corresponding board position is occupied by red
;   >2 when your corresponding board position is occupied by blue
; WARNING: do not modify the borders!
                defb                  255,255,255,255,255,255,255,255
                defb                 0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                   0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                     0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                       0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                         0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                           0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                             0,  1,  1,  1,  1,  1,  1,  1, 255
                defb                               0, 255,255,255,255,255,255,255
Board_Red_Result:
                defb 255

; -----------------------------------------------------------------------------