;
; Brainiac.z80asm
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/30216/ZX-Spectrum/COMPLICA_DX
; Slightly adapted by Antonio Luque
;
MIN_VALUE       equ 0                  ; alphaBeta pruning minimum value
MAX_VALUE       equ 255                ; alphaBeta pruning maximum value

;
; Board_Score: get the heuristic score of a determined board position
; Coded by Antonio Luque
;
; Inspired on Greg Surma article:
; https://towardsdatascience.com/hex-creating-intelligent-adversaries-part-2-heuristics-dijkstras-algorithm-597e4dcacf93 
;
; Input:    AI_PLAYER (BLUE_TOKEN or RED_TOKEN)
; Output:   A  - ((player remaining nodes) minus (speccy remaining nodes)) * (-1)
;                or MAX_VALUE if speccy is the winner
;                or MIN_VALUE if player is the winner
; Destroys: A', B, HL
;
Board_Score:
                ld a,(AI_PLAYER)        ; set speccy color in A

                call Path_Finder        ; calculate speccy shortest path
                ld a,(hl)               ; set speccy remaining nodes in A
                ld b,a                  ; set speccy remaining nodes in B
                or a                    ; is speccy shortest path = 0?
                cpl                     ; inverts all bits of A
                ret z                   ; yes, return MAX_VALUE

                ex af,af'               ; get player color
                call Path_Finder        ; calculate player shortest path
                ld a,(hl)               ; set player remaining nodes in A
                or a                    ; is player shortest path = 0?
                ret z                   ; yes, return MIN_VALUE

                sub b                   ; A = (player remaining nodes) - (speccy remaining nodes)
                xor $80                 ; A = A * (-1) inverts sign for easier further comparative

                ret
;
; BRAINIAC_best_move: execute BRAINIAC algorithm to determine best choice for specified player's next move, 
; according to specified AI difficulty level. This algorithm is implemented as recursive Minimax with
; alpha-beta pruning, that alternates between tree nodes maximizing score (speccy move) and minimizing
; it (player move) depending on recursion depth.
;
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/30216/ZX-Spectrum/COMPLICA_DX
; The complete and original source code in the link above. Adaptations are marked with * in routines comments.
; 
; Parameters:
;   A: speccy color* (BLUE_TOKEN or RED_TOKEN)
;
; Returns:
;   E: selected node (0-48)*
;
; Uses:
;   AI_DEPTH:  current recursion depth
;   AI_PLAYER: speccy color* (BLUE_TOKEN or RED_TOKEN)
;
; Destroys:
;   AF, BC, D, HL, AF'
;
BRAINIAC_best_move:
                ld (AI_PLAYER),a        ; save speccy color*

                call Path_Finder        ; calculate speccy shortest path*
                call GetPlayer_Nodes    ; get speccy vector's nodes and # of nodes (loop counter)

                ld e,(hl)               ; E = best speccy move (initialization)
                ld d,MIN_VALUE          ; D = alphaMax

AIMainLoop
                push hl                 ; store pointer to speccy vector's nodes*

                ld l,(hl)               ; set node index in L*
                ld h,COLORS_H           ; HL points to node color*

                ld c,l                  ; save node index in C

                push bc                 ; store # of nodes (loop counter) and node index

                ld a,(AI_PLAYER)        ; get speccy color
                ld c,a                  ; C = speccy color

                ld (hl),c               ; update node color with speccy color* (BRAINIAC_play)

                push hl                 ; store pointer to node color
                push de                 ; store alphaMax and best speccy move
                push bc                 ; store # of nodes (loop counter) and speccy color

                ld e,MAX_VALUE          ; E = betaMin
                call Alphabeta_Min      ; A = alphabeta_min(alphaMax, betaMin)

                pop bc                  ; restore # of nodes and speccy color
                pop de                  ; restore alphaMax and best player node
                pop hl                  ; restore pointer to node color

                ld (hl),WHITE_BLACK     ; update node color with empty color (BRAINIAC_undo)

                pop bc                  ; restore # of nodes (loop counter) and node index
                pop hl                  ; restore pointer to speccy vector's nodes*

                cp d
                jr c,AIMainNext
                jr z,AIMainNext         ; if (A <= alphaMax) continue

                ld d,a                  ; alphaMax = A
                ld e,c                  ; best move = C

                inc a                   ; if (alphaMax = MAX_VALUE) return best move*
                ret z

AIMainNext
                dec hl                  ; HL points to the next speccy node*
                djnz AIMainLoop         ; repeat for each node in speccy vector's nodes

                ret
;
; Alphabeta_Min: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING
; player's score.
;
; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin
; value obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest)
; score at this tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node
; would make parent node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling
; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
; always choose the child node evaluated first, since the other child node node may not really have the same score and
; could be just; reproducing the best score from its sibling.
;
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/30216/ZX-Spectrum/COMPLICA_DX
; The complete and original source code in the link above. Adaptations are marked with * in routines comments.
;
; Parameters:
;   D: alphaMax
;   E: betaMin
;
; Returns:
;   A: "improved" betaMin
;   C: player color (BLUE_TOKEN or RED_TOKEN)
;   D: alphaMax
;   E: "improved" betaMin
;
; Uses:
;   AI_DEPTH:  current recursion depth
;   AI_PLAYER: speccy color* (BLUE_TOKEN or RED_TOKEN)
;
; Destroys:
;   F, B, HL, AF'
;
Alphabeta_Min:
                ; check if last speccy move is a winner one

                ld a,c                  ; set speccy color in A
                call Path_Finder        ; calculate speccy shortest path
                ld a,(hl)               ; set speccy remaining nodes in A
                or a                    ; is speccy shortest path = 0?
                cpl                     ; inverts all bits of A
                ret z                   ; yes, return MAX_VALUE

                ; process player moves

                ex af,af'               ; get player color
                call Path_Finder        ; calculate player shortest path

                ld hl,AI_DEPTH
                dec (hl)                ; depth--
                jr z,Heuristic_Min      ; if (depth == 0) return heuristic_min

                call GetPlayer_Nodes    ; get player vector's nodes, # of nodes (loop counter) and player color

AlphabetaMinLoop
                push hl                 ; store pointer to player vector's nodes
                
                ld l,(hl)               ; set node index in L
                ld h,COLORS_H           ; HL points to node color

                ld (hl),c               ; update node color with player color (BRAINIAC_play)

                push hl                 ; store pointer to node color
                push de                 ; store alphaMax and betaMin
                push bc                 ; store # of nodes (loop counter) and player color

                call Alphabeta_Max      ; A = alphabeta_max(alphaMax, betaMin)

                pop bc                  ; restore # of nodes (loop counter) and player color
                pop de                  ; restore alphaMax and betaMin
                pop hl                  ; restore pointer to node color

                ld (hl),WHITE_BLACK     ; update node color with empty color (BRAINIAC_undo)

                pop hl                  ; restore pointer to player vector's nodes

                cp e
                jr nc,AlphabetaMinNext  ; if (A >= betaMin) continue

                cp d
                jr c,AlphabetaMinExit
                jr z,AlphabetaMinExit   ; if (A <= alphaMax) { depth++; return A }

                ld e,a                  ; betaMin = A

AlphabetaMinNext
                dec hl                  ; HL points to the next player node*
                djnz AlphabetaMinLoop   ; repeat for each node in player vector's nodes

                ld a,e                  ; return betaMin

AlphabetaMinExit
                ld hl,AI_DEPTH
                inc (hl)                ; depth++

                ret
;
; Heuristic_Min: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with
; alpha-beta pruning, when it requires MINIMIZING player's score.
;
; Technically "Heuristic_Min" works exactly like "AlphabetaMinLoop", except it directly evaluates board for each child
; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max"
; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds faster.
;
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/30216/ZX-Spectrum/COMPLICA_DX
; The complete and original source code in the link above. Adaptations are marked with * in routines comments.
;
; Parameters:
;   A : player color (BLUE_TOKEN or RED_TOKEN)*
;   D : alphaMax
;   E : betaMin
;
; Returns:
;   A: "improved" betaMin
;   D: alphaMax
;   E: "improved" betaMin
;
; Uses:
;   AI_DEPTH:  current recursion depth
;   AI_PLAYER: speccy color* (BLUE_TOKEN or RED_TOKEN)
;
; Destroys:
;   F, B, HL, F'
;
Heuristic_Min:
                call GetPlayer_Nodes    ; get player vector's nodes, # of nodes (loop counter) and player color

HeuristicMinLoop
                push hl                 ; store pointer to player vector's nodes

                ld l,(hl)               ; set node index in L
                ld h,COLORS_H           ; HL points to node color

                ld (hl),c               ; update node color with player color (BRAINIAC_play)

                exx                     ; store pointer to node color, alphaMax and betaMin
                                        ; number of nodes (loop counter) and player color

                call Board_Score        ; A = board score

                exx                     ; restore pointer to node color, alphaMax and betaMin
                                        ; number of nodes (loop counter) and player color

                ld (hl),WHITE_BLACK     ; update node color with empty color (BRAINIAC_undo)

                pop hl                  ; restore pointer to player vector's nodes

                cp e
                jr nc,HeuristicMinNext  ; if (A >= betaMin) continue

                cp d
                jr c,HeuristicMinExit
                jr z,HeuristicMinExit   ; if (A <= alphaMax) { depth++; return A }

                ld e,a                  ; betaMin = A

HeuristicMinNext
                dec hl                  ; HL points to the next node
                djnz HeuristicMinLoop   ; repeat for each node in player vector's nodes

                ld a,e                  ; return betaMin

HeuristicMinExit
                ld hl,AI_DEPTH
                inc (hl)                ; depth++

                ret
;
; Alphabeta_Max: Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING
; speccy's score.
;
; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax
; value obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best (highest)
; score at this tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous sibling node
; would make parent node discard the node's alphaMax value and adopt the even higher alphaMax value from a previous sibling
; node anyway. This change was useful to allow a highly optimized Assembly implementation with a more efficient register
; allocation. The only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must
; always choose the child node evaluated first, since the other child node node may not really have the same score and could
; be just reproducing the best score from its sibling.
;
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/30216/ZX-Spectrum/COMPLICA_DX
; The complete and original source code in the link above. Adaptations are marked with * in routines comments.
;
; Parameters:
;   D: alphaMax
;   E: betaMin
;
; Returns:
;   A: "improved" alphaMax
;   C: speccy color* (BLUE_TOKEN or RED_TOKEN)
;   D: "improved" alphaMax
;   E: betaMin
;
; Uses:
;   AI_DEPTH:  current recursion depth
;   AI_PLAYER: speccy color* (BLUE_TOKEN or RED_TOKEN)
;
; Destroys:
;   F, B, HL, AF'
;
Alphabeta_Max:
                ; check if last player move is a winner one

                ld a,c                  ; set player color in A
                call Path_Finder        ; calculate player shortest path
                ld a,(hl)               ; set player remaining nodes in A
                or a                    ; is player shortest path = 0?
                ret z                   ; yes, return MIN_VALUE

                ; process speccy moves

                ex af,af'               ; get speccy color
                call Path_Finder        ; calculate speccy shortest path

                ld hl,AI_DEPTH
                dec (hl)                ; depth--
                jr z,Heuristic_Max      ; if (depth == 0) return heuristic_max

                call GetPlayer_Nodes    ; get speccy vector's nodes, # of nodes (loop counter) and speccy color

AlphabetaMaxLoop
                push hl                 ; store pointer to speccy vector's nodes

                ld l,(hl)               ; set index in L
                ld h,COLORS_H           ; HL points to node color

                ld (hl),c               ; update node color with speccy color (BRANIAC_play)

                push hl                 ; store pointer to node color
                push de                 ; store alphaMax and betaMin
                push bc                 ; store # of nodes (loop counter) and speccy color

                call Alphabeta_Min      ; A = alphabeta_min(alphaMax, betaMin)

                pop bc                  ; restore pointer to node color
                pop de                  ; restore alphaMax and betaMin
                pop hl                  ; restore # of nodes (loop counter) and speccy color

                ld (hl),WHITE_BLACK     ; update node color with empty color (BRAINIAC_undo)

                pop hl                  ; restore pointer to speccy vector's nodes

                cp d
                jr c,AlphabetaMaxNext
                jr z,AlphabetaMaxNext   ; if (A <= alphaMax) continue

                cp e
                jr nc,AlphabetaMaxExit  ; if (A >= betaMin) { depth++; return A }

                ld d,a                  ; alphaMax = A

AlphabetaMaxNext
                dec hl                  ; HL points to the next node
                djnz AlphabetaMaxLoop   ; repeat for each node in speccy vector's nodes

                ld a,d                  ; return alphaMax

AlphabetaMaxExit
                ld hl,AI_DEPTH
                inc (hl)                ; depth++

                ret
;
; Heuristic_Max: Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with
; alpha-beta pruning, when it requires MAXIMIZING speccy's score.
;
; Technically "Heuristic_Max" works exactly like "AlphabetaMaxLoop", except it directly evaluates board for each child node
; instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min" again to
; obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds faster.
;
; Coded by Einar Saukas: https://spectrumcomputing.co.uk/entry/30216/ZX-Spectrum/COMPLICA_DX
; The complete and original source code in the link above. Adaptations are marked with * in routines comments.
;
; Parameters:
;   D : alphaMax
;   E : betaMin
;
; Returns:
;   A: "improved" alphaMax
;   D: "improved" alphaMax
;   E: betaMin
;
; Uses:
;   AI_DEPTH:  current recursion depth
;   AI_PLAYER: speccy color* (BLUE_TOKEN or RED_TOKEN)
;
; Destroys:
;   F, B, HL, F'
;
Heuristic_Max:
                call GetPlayer_Nodes    ; get speccy vector's nodes, # of nodes (loop counter) and speccy color

HeuristicMaxLoop
                push hl                 ; store pointer to speccy vector's nodes

                ld l,(hl)               ; set node index in L
                ld h,COLORS_H           ; HL points to node color

                ld (hl),c               ; update node color with speccy color (BRANIAC_play)

                exx                     ; store pointer to node color, alphaMax and betaMin,
                                        ; number of nodes (loop counter) and speccy color

                call Board_Score        ; A = board score

                exx                     ; restore pointer to node color, alphaMax and betaMin,
                                        ; number of nodes (loop counter) and speccy color

                ld (hl),WHITE_BLACK     ; update node color with empty color (BRAINIAC_undo)

                pop hl                  ; restore pointer to speccy vector's nodes

                cp d
                jr c,HeuristicMaxNext
                jr z,HeuristicMaxNext   ; if (A <= alphaMax) continue

                cp e
                jr nc,HeuristicMaxExit  ; if (A >= betaMin) { depth++; return A }

                ld d,a                  ; alphaMax = A

HeuristicMaxNext
                dec hl                  ; HL points to the next node
                djnz HeuristicMaxLoop   ; repeat for each node in speccy vector's nodes

                ld a,d                  ; return alphaMax

HeuristicMaxExit
                ld hl,AI_DEPTH
                inc (hl)                ; depth++

                ret
;
; Variables
;
AI_PLAYER       defb 0                  ; speccy color (BLUE_TOKEN or RED_TOKEN)
AI_DEPTH        defb 0                  ; recursion depth level (0-4)
